
Praktikum_5_Template_6_2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000040a6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000005e  00802000  000040a6  0000413a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000035f  0080205e  0080205e  00004198  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00004198  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000044  00000000  00000000  000041f4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006f0  00000000  00000000  00004238  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000128b3  00000000  00000000  00004928  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003110  00000000  00000000  000171db  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000b650  00000000  00000000  0001a2eb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001740  00000000  00000000  0002593c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000356da  00000000  00000000  0002707c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00009a56  00000000  00000000  0005c756  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000958  00000000  00000000  000661b0  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000c883  00000000  00000000  00066b08  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	50 c2       	rjmp	.+1184   	; 0x4a2 <__ctors_end>
       2:	00 00       	nop
       4:	6f c2       	rjmp	.+1246   	; 0x4e4 <__bad_interrupt>
       6:	00 00       	nop
       8:	6d c2       	rjmp	.+1242   	; 0x4e4 <__bad_interrupt>
       a:	00 00       	nop
       c:	6b c2       	rjmp	.+1238   	; 0x4e4 <__bad_interrupt>
       e:	00 00       	nop
      10:	69 c2       	rjmp	.+1234   	; 0x4e4 <__bad_interrupt>
      12:	00 00       	nop
      14:	67 c2       	rjmp	.+1230   	; 0x4e4 <__bad_interrupt>
      16:	00 00       	nop
      18:	65 c2       	rjmp	.+1226   	; 0x4e4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	63 c2       	rjmp	.+1222   	; 0x4e4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	61 c2       	rjmp	.+1218   	; 0x4e4 <__bad_interrupt>
      22:	00 00       	nop
      24:	5f c2       	rjmp	.+1214   	; 0x4e4 <__bad_interrupt>
      26:	00 00       	nop
      28:	5d c2       	rjmp	.+1210   	; 0x4e4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5b c2       	rjmp	.+1206   	; 0x4e4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	59 c2       	rjmp	.+1202   	; 0x4e4 <__bad_interrupt>
      32:	00 00       	nop
      34:	57 c2       	rjmp	.+1198   	; 0x4e4 <__bad_interrupt>
      36:	00 00       	nop
      38:	0c 94 90 0f 	jmp	0x1f20	; 0x1f20 <__vector_14>
      3c:	53 c2       	rjmp	.+1190   	; 0x4e4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	51 c2       	rjmp	.+1186   	; 0x4e4 <__bad_interrupt>
      42:	00 00       	nop
      44:	4f c2       	rjmp	.+1182   	; 0x4e4 <__bad_interrupt>
      46:	00 00       	nop
      48:	4d c2       	rjmp	.+1178   	; 0x4e4 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	4b c2       	rjmp	.+1174   	; 0x4e4 <__bad_interrupt>
      4e:	00 00       	nop
      50:	49 c2       	rjmp	.+1170   	; 0x4e4 <__bad_interrupt>
      52:	00 00       	nop
      54:	47 c2       	rjmp	.+1166   	; 0x4e4 <__bad_interrupt>
      56:	00 00       	nop
      58:	45 c2       	rjmp	.+1162   	; 0x4e4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	43 c2       	rjmp	.+1158   	; 0x4e4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	41 c2       	rjmp	.+1154   	; 0x4e4 <__bad_interrupt>
      62:	00 00       	nop
      64:	3f c2       	rjmp	.+1150   	; 0x4e4 <__bad_interrupt>
      66:	00 00       	nop
      68:	3d c2       	rjmp	.+1146   	; 0x4e4 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3b c2       	rjmp	.+1142   	; 0x4e4 <__bad_interrupt>
      6e:	00 00       	nop
      70:	39 c2       	rjmp	.+1138   	; 0x4e4 <__bad_interrupt>
      72:	00 00       	nop
      74:	37 c2       	rjmp	.+1134   	; 0x4e4 <__bad_interrupt>
      76:	00 00       	nop
      78:	35 c2       	rjmp	.+1130   	; 0x4e4 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	33 c2       	rjmp	.+1126   	; 0x4e4 <__bad_interrupt>
      7e:	00 00       	nop
      80:	31 c2       	rjmp	.+1122   	; 0x4e4 <__bad_interrupt>
      82:	00 00       	nop
      84:	2f c2       	rjmp	.+1118   	; 0x4e4 <__bad_interrupt>
      86:	00 00       	nop
      88:	2d c2       	rjmp	.+1114   	; 0x4e4 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	2b c2       	rjmp	.+1110   	; 0x4e4 <__bad_interrupt>
      8e:	00 00       	nop
      90:	29 c2       	rjmp	.+1106   	; 0x4e4 <__bad_interrupt>
      92:	00 00       	nop
      94:	27 c2       	rjmp	.+1102   	; 0x4e4 <__bad_interrupt>
      96:	00 00       	nop
      98:	25 c2       	rjmp	.+1098   	; 0x4e4 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	d6 c7       	rjmp	.+4012   	; 0x104a <__vector_39>
      9e:	00 00       	nop
      a0:	0c 94 57 08 	jmp	0x10ae	; 0x10ae <__vector_40>
      a4:	0c 94 89 08 	jmp	0x1112	; 0x1112 <__vector_41>
      a8:	0c 94 bb 08 	jmp	0x1176	; 0x1176 <__vector_42>
      ac:	1b c2       	rjmp	.+1078   	; 0x4e4 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	19 c2       	rjmp	.+1074   	; 0x4e4 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	17 c2       	rjmp	.+1070   	; 0x4e4 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	15 c2       	rjmp	.+1066   	; 0x4e4 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	13 c2       	rjmp	.+1062   	; 0x4e4 <__bad_interrupt>
      be:	00 00       	nop
      c0:	11 c2       	rjmp	.+1058   	; 0x4e4 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	0f c2       	rjmp	.+1054   	; 0x4e4 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	0d c2       	rjmp	.+1050   	; 0x4e4 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0b c2       	rjmp	.+1046   	; 0x4e4 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	09 c2       	rjmp	.+1042   	; 0x4e4 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	07 c2       	rjmp	.+1038   	; 0x4e4 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	05 c2       	rjmp	.+1034   	; 0x4e4 <__bad_interrupt>
      da:	00 00       	nop
      dc:	03 c2       	rjmp	.+1030   	; 0x4e4 <__bad_interrupt>
      de:	00 00       	nop
      e0:	01 c2       	rjmp	.+1026   	; 0x4e4 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	ff c1       	rjmp	.+1022   	; 0x4e4 <__bad_interrupt>
      e6:	00 00       	nop
      e8:	fd c1       	rjmp	.+1018   	; 0x4e4 <__bad_interrupt>
      ea:	00 00       	nop
      ec:	fb c1       	rjmp	.+1014   	; 0x4e4 <__bad_interrupt>
      ee:	00 00       	nop
      f0:	f9 c1       	rjmp	.+1010   	; 0x4e4 <__bad_interrupt>
      f2:	00 00       	nop
      f4:	f7 c1       	rjmp	.+1006   	; 0x4e4 <__bad_interrupt>
      f6:	00 00       	nop
      f8:	f5 c1       	rjmp	.+1002   	; 0x4e4 <__bad_interrupt>
      fa:	00 00       	nop
      fc:	f3 c1       	rjmp	.+998    	; 0x4e4 <__bad_interrupt>
      fe:	00 00       	nop
     100:	f1 c1       	rjmp	.+994    	; 0x4e4 <__bad_interrupt>
     102:	00 00       	nop
     104:	ef c1       	rjmp	.+990    	; 0x4e4 <__bad_interrupt>
     106:	00 00       	nop
     108:	ed c1       	rjmp	.+986    	; 0x4e4 <__bad_interrupt>
     10a:	00 00       	nop
     10c:	eb c1       	rjmp	.+982    	; 0x4e4 <__bad_interrupt>
     10e:	00 00       	nop
     110:	e9 c1       	rjmp	.+978    	; 0x4e4 <__bad_interrupt>
     112:	00 00       	nop
     114:	e7 c1       	rjmp	.+974    	; 0x4e4 <__bad_interrupt>
     116:	00 00       	nop
     118:	e5 c1       	rjmp	.+970    	; 0x4e4 <__bad_interrupt>
     11a:	00 00       	nop
     11c:	ce c6       	rjmp	.+3484   	; 0xeba <__vector_71>
     11e:	00 00       	nop
     120:	fe c6       	rjmp	.+3580   	; 0xf1e <__vector_72>
     122:	00 00       	nop
     124:	2e c7       	rjmp	.+3676   	; 0xf82 <__vector_73>
     126:	00 00       	nop
     128:	5e c7       	rjmp	.+3772   	; 0xfe6 <__vector_74>
     12a:	00 00       	nop
     12c:	db c1       	rjmp	.+950    	; 0x4e4 <__bad_interrupt>
     12e:	00 00       	nop
     130:	d9 c1       	rjmp	.+946    	; 0x4e4 <__bad_interrupt>
     132:	00 00       	nop
     134:	d7 c1       	rjmp	.+942    	; 0x4e4 <__bad_interrupt>
     136:	00 00       	nop
     138:	d5 c1       	rjmp	.+938    	; 0x4e4 <__bad_interrupt>
     13a:	00 00       	nop
     13c:	d3 c1       	rjmp	.+934    	; 0x4e4 <__bad_interrupt>
     13e:	00 00       	nop
     140:	d1 c1       	rjmp	.+930    	; 0x4e4 <__bad_interrupt>
     142:	00 00       	nop
     144:	cf c1       	rjmp	.+926    	; 0x4e4 <__bad_interrupt>
     146:	00 00       	nop
     148:	cd c1       	rjmp	.+922    	; 0x4e4 <__bad_interrupt>
     14a:	00 00       	nop
     14c:	cb c1       	rjmp	.+918    	; 0x4e4 <__bad_interrupt>
     14e:	00 00       	nop
     150:	c9 c1       	rjmp	.+914    	; 0x4e4 <__bad_interrupt>
     152:	00 00       	nop
     154:	c7 c1       	rjmp	.+910    	; 0x4e4 <__bad_interrupt>
     156:	00 00       	nop
     158:	c5 c1       	rjmp	.+906    	; 0x4e4 <__bad_interrupt>
     15a:	00 00       	nop
     15c:	c3 c1       	rjmp	.+902    	; 0x4e4 <__bad_interrupt>
     15e:	00 00       	nop
     160:	c1 c1       	rjmp	.+898    	; 0x4e4 <__bad_interrupt>
     162:	00 00       	nop
     164:	bf c1       	rjmp	.+894    	; 0x4e4 <__bad_interrupt>
     166:	00 00       	nop
     168:	bd c1       	rjmp	.+890    	; 0x4e4 <__bad_interrupt>
     16a:	00 00       	nop
     16c:	bb c1       	rjmp	.+886    	; 0x4e4 <__bad_interrupt>
     16e:	00 00       	nop
     170:	b9 c1       	rjmp	.+882    	; 0x4e4 <__bad_interrupt>
     172:	00 00       	nop
     174:	b7 c1       	rjmp	.+878    	; 0x4e4 <__bad_interrupt>
     176:	00 00       	nop
     178:	b5 c1       	rjmp	.+874    	; 0x4e4 <__bad_interrupt>
     17a:	00 00       	nop
     17c:	b3 c1       	rjmp	.+870    	; 0x4e4 <__bad_interrupt>
     17e:	00 00       	nop
     180:	b1 c1       	rjmp	.+866    	; 0x4e4 <__bad_interrupt>
     182:	00 00       	nop
     184:	af c1       	rjmp	.+862    	; 0x4e4 <__bad_interrupt>
     186:	00 00       	nop
     188:	ad c1       	rjmp	.+858    	; 0x4e4 <__bad_interrupt>
     18a:	00 00       	nop
     18c:	ab c1       	rjmp	.+854    	; 0x4e4 <__bad_interrupt>
     18e:	00 00       	nop
     190:	a9 c1       	rjmp	.+850    	; 0x4e4 <__bad_interrupt>
     192:	00 00       	nop
     194:	a7 c1       	rjmp	.+846    	; 0x4e4 <__bad_interrupt>
     196:	00 00       	nop
     198:	a5 c1       	rjmp	.+842    	; 0x4e4 <__bad_interrupt>
     19a:	00 00       	nop
     19c:	a3 c1       	rjmp	.+838    	; 0x4e4 <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	a1 c1       	rjmp	.+834    	; 0x4e4 <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	9f c1       	rjmp	.+830    	; 0x4e4 <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	9d c1       	rjmp	.+826    	; 0x4e4 <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	9b c1       	rjmp	.+822    	; 0x4e4 <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	99 c1       	rjmp	.+818    	; 0x4e4 <__bad_interrupt>
     1b2:	00 00       	nop
     1b4:	97 c1       	rjmp	.+814    	; 0x4e4 <__bad_interrupt>
     1b6:	00 00       	nop
     1b8:	95 c1       	rjmp	.+810    	; 0x4e4 <__bad_interrupt>
     1ba:	00 00       	nop
     1bc:	93 c1       	rjmp	.+806    	; 0x4e4 <__bad_interrupt>
     1be:	00 00       	nop
     1c0:	91 c1       	rjmp	.+802    	; 0x4e4 <__bad_interrupt>
     1c2:	00 00       	nop
     1c4:	8f c1       	rjmp	.+798    	; 0x4e4 <__bad_interrupt>
     1c6:	00 00       	nop
     1c8:	8d c1       	rjmp	.+794    	; 0x4e4 <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	8b c1       	rjmp	.+790    	; 0x4e4 <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	89 c1       	rjmp	.+786    	; 0x4e4 <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	87 c1       	rjmp	.+782    	; 0x4e4 <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	85 c1       	rjmp	.+778    	; 0x4e4 <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	83 c1       	rjmp	.+774    	; 0x4e4 <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	81 c1       	rjmp	.+770    	; 0x4e4 <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	7f c1       	rjmp	.+766    	; 0x4e4 <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	7d c1       	rjmp	.+762    	; 0x4e4 <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	7b c1       	rjmp	.+758    	; 0x4e4 <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	79 c1       	rjmp	.+754    	; 0x4e4 <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	77 c1       	rjmp	.+750    	; 0x4e4 <__bad_interrupt>
     1f6:	00 00       	nop
     1f8:	75 c1       	rjmp	.+746    	; 0x4e4 <__bad_interrupt>
     1fa:	00 00       	nop
     1fc:	ac 18       	sub	r10, r12
     1fe:	ac 18       	sub	r10, r12
     200:	ac 18       	sub	r10, r12
     202:	e2 18       	sub	r14, r2
     204:	d2 18       	sub	r13, r2
     206:	df 18       	sub	r13, r15
     208:	ac 18       	sub	r10, r12
     20a:	ac 18       	sub	r10, r12
     20c:	e2 18       	sub	r14, r2
     20e:	d2 18       	sub	r13, r2

00000210 <__trampolines_end>:
     210:	00 00       	nop
     212:	00 00       	nop
     214:	00 00       	nop
     216:	00 20       	and	r0, r0
     218:	20 20       	and	r2, r0
     21a:	20 20       	and	r2, r0
     21c:	00 20       	and	r0, r0
     21e:	50 50       	subi	r21, 0x00	; 0
     220:	50 00       	.word	0x0050	; ????
     222:	00 00       	nop
     224:	00 50       	subi	r16, 0x00	; 0
     226:	50 f8       	bld	r5, 0
     228:	50 f8       	bld	r5, 0
     22a:	50 50       	subi	r21, 0x00	; 0
     22c:	20 78       	andi	r18, 0x80	; 128
     22e:	a0 70       	andi	r26, 0x00	; 0
     230:	28 f0       	brcs	.+10     	; 0x23c <__trampolines_end+0x2c>
     232:	20 c0       	rjmp	.+64     	; 0x274 <__trampolines_end+0x64>
     234:	c8 10       	cpse	r12, r8
     236:	20 40       	sbci	r18, 0x00	; 0
     238:	98 18       	sub	r9, r8
     23a:	60 90 a0 40 	lds	r6, 0x40A0	; 0x8040a0 <__bss_end+0x1ce3>
     23e:	a8 90       	.word	0x90a8	; ????
     240:	68 60       	ori	r22, 0x08	; 8
     242:	20 40       	sbci	r18, 0x00	; 0
     244:	00 00       	nop
     246:	00 00       	nop
     248:	10 20       	and	r1, r0
     24a:	40 40       	sbci	r20, 0x00	; 0
     24c:	40 20       	and	r4, r0
     24e:	10 40       	sbci	r17, 0x00	; 0
     250:	20 10       	cpse	r2, r0
     252:	10 10       	cpse	r1, r0
     254:	20 40       	sbci	r18, 0x00	; 0
     256:	00 50       	subi	r16, 0x00	; 0
     258:	20 f8       	bld	r2, 0
     25a:	20 50       	subi	r18, 0x00	; 0
     25c:	00 00       	nop
     25e:	20 20       	and	r2, r0
     260:	f8 20       	and	r15, r8
     262:	20 00       	.word	0x0020	; ????
     264:	00 00       	nop
     266:	00 00       	nop
     268:	60 20       	and	r6, r0
     26a:	40 00       	.word	0x0040	; ????
     26c:	00 00       	nop
     26e:	f8 00       	.word	0x00f8	; ????
     270:	00 00       	nop
     272:	00 00       	nop
     274:	00 00       	nop
     276:	00 60       	ori	r16, 0x00	; 0
     278:	60 00       	.word	0x0060	; ????
     27a:	08 10       	cpse	r0, r8
     27c:	20 40       	sbci	r18, 0x00	; 0
     27e:	80 00       	.word	0x0080	; ????
     280:	70 88       	ldd	r7, Z+16	; 0x10
     282:	98 a8       	ldd	r9, Y+48	; 0x30
     284:	c8 88       	ldd	r12, Y+16	; 0x10
     286:	70 20       	and	r7, r0
     288:	60 20       	and	r6, r0
     28a:	20 20       	and	r2, r0
     28c:	20 70       	andi	r18, 0x00	; 0
     28e:	70 88       	ldd	r7, Z+16	; 0x10
     290:	08 10       	cpse	r0, r8
     292:	20 40       	sbci	r18, 0x00	; 0
     294:	f8 f8       	.word	0xf8f8	; ????
     296:	10 20       	and	r1, r0
     298:	10 08       	sbc	r1, r0
     29a:	88 70       	andi	r24, 0x08	; 8
     29c:	10 30       	cpi	r17, 0x00	; 0
     29e:	50 90 f8 10 	lds	r5, 0x10F8	; 0x8010f8 <__TEXT_REGION_LENGTH__+0x7010f8>
     2a2:	10 f8       	bld	r1, 0
     2a4:	80 f0       	brcs	.+32     	; 0x2c6 <__trampolines_end+0xb6>
     2a6:	08 08       	sbc	r0, r8
     2a8:	88 70       	andi	r24, 0x08	; 8
     2aa:	30 40       	sbci	r19, 0x00	; 0
     2ac:	80 f0       	brcs	.+32     	; 0x2ce <__trampolines_end+0xbe>
     2ae:	88 88       	ldd	r8, Y+16	; 0x10
     2b0:	70 f8       	bld	r7, 0
     2b2:	08 10       	cpse	r0, r8
     2b4:	20 40       	sbci	r18, 0x00	; 0
     2b6:	40 40       	sbci	r20, 0x00	; 0
     2b8:	70 88       	ldd	r7, Z+16	; 0x10
     2ba:	88 70       	andi	r24, 0x08	; 8
     2bc:	88 88       	ldd	r8, Y+16	; 0x10
     2be:	70 70       	andi	r23, 0x00	; 0
     2c0:	88 88       	ldd	r8, Y+16	; 0x10
     2c2:	78 08       	sbc	r7, r8
     2c4:	10 60       	ori	r17, 0x00	; 0
     2c6:	00 60       	ori	r16, 0x00	; 0
     2c8:	60 00       	.word	0x0060	; ????
     2ca:	60 60       	ori	r22, 0x00	; 0
     2cc:	00 00       	nop
     2ce:	60 60       	ori	r22, 0x00	; 0
     2d0:	00 60       	ori	r16, 0x00	; 0
     2d2:	20 40       	sbci	r18, 0x00	; 0
     2d4:	08 10       	cpse	r0, r8
     2d6:	20 40       	sbci	r18, 0x00	; 0
     2d8:	20 10       	cpse	r2, r0
     2da:	08 00       	.word	0x0008	; ????
     2dc:	00 f8       	bld	r0, 0
     2de:	00 f8       	bld	r0, 0
     2e0:	00 00       	nop
     2e2:	80 40       	sbci	r24, 0x00	; 0
     2e4:	20 10       	cpse	r2, r0
     2e6:	20 40       	sbci	r18, 0x00	; 0
     2e8:	80 70       	andi	r24, 0x00	; 0
     2ea:	88 08       	sbc	r8, r8
     2ec:	10 20       	and	r1, r0
     2ee:	00 20       	and	r0, r0
     2f0:	70 88       	ldd	r7, Z+16	; 0x10
     2f2:	08 68       	ori	r16, 0x88	; 136
     2f4:	a8 a8       	ldd	r10, Y+48	; 0x30
     2f6:	70 70       	andi	r23, 0x00	; 0
     2f8:	88 88       	ldd	r8, Y+16	; 0x10
     2fa:	88 f8       	.word	0xf888	; ????
     2fc:	88 88       	ldd	r8, Y+16	; 0x10
     2fe:	f0 88       	ldd	r15, Z+16	; 0x10
     300:	88 f0       	brcs	.+34     	; 0x324 <__trampolines_end+0x114>
     302:	88 88       	ldd	r8, Y+16	; 0x10
     304:	f0 70       	andi	r31, 0x00	; 0
     306:	88 80       	ld	r8, Y
     308:	80 80       	ld	r8, Z
     30a:	88 70       	andi	r24, 0x08	; 8
     30c:	e0 90 88 88 	lds	r14, 0x8888	; 0x808888 <__bss_end+0x64cb>
     310:	88 90       	.word	0x9088	; ????
     312:	e0 f8       	bld	r14, 0
     314:	80 80       	ld	r8, Z
     316:	f0 80       	ld	r15, Z
     318:	80 f8       	bld	r8, 0
     31a:	f8 80       	ld	r15, Y
     31c:	80 e0       	ldi	r24, 0x00	; 0
     31e:	80 80       	ld	r8, Z
     320:	80 70       	andi	r24, 0x00	; 0
     322:	88 80       	ld	r8, Y
     324:	80 98       	cbi	0x10, 0	; 16
     326:	88 70       	andi	r24, 0x08	; 8
     328:	88 88       	ldd	r8, Y+16	; 0x10
     32a:	88 f8       	.word	0xf888	; ????
     32c:	88 88       	ldd	r8, Y+16	; 0x10
     32e:	88 70       	andi	r24, 0x08	; 8
     330:	20 20       	and	r2, r0
     332:	20 20       	and	r2, r0
     334:	20 70       	andi	r18, 0x00	; 0
     336:	38 10       	cpse	r3, r8
     338:	10 10       	cpse	r1, r0
     33a:	10 90 60 88 	lds	r1, 0x8860	; 0x808860 <__bss_end+0x64a3>
     33e:	90 a0       	ldd	r9, Z+32	; 0x20
     340:	c0 a0       	ldd	r12, Z+32	; 0x20
     342:	90 88       	ldd	r9, Z+16	; 0x10
     344:	80 80       	ld	r8, Z
     346:	80 80       	ld	r8, Z
     348:	80 80       	ld	r8, Z
     34a:	f8 88       	ldd	r15, Y+16	; 0x10
     34c:	d8 a8       	ldd	r13, Y+48	; 0x30
     34e:	88 88       	ldd	r8, Y+16	; 0x10
     350:	88 88       	ldd	r8, Y+16	; 0x10
     352:	88 88       	ldd	r8, Y+16	; 0x10
     354:	c8 a8       	ldd	r12, Y+48	; 0x30
     356:	98 88       	ldd	r9, Y+16	; 0x10
     358:	88 70       	andi	r24, 0x08	; 8
     35a:	88 88       	ldd	r8, Y+16	; 0x10
     35c:	88 88       	ldd	r8, Y+16	; 0x10
     35e:	88 70       	andi	r24, 0x08	; 8
     360:	f0 88       	ldd	r15, Z+16	; 0x10
     362:	88 f0       	brcs	.+34     	; 0x386 <__trampolines_end+0x176>
     364:	80 80       	ld	r8, Z
     366:	80 70       	andi	r24, 0x00	; 0
     368:	88 88       	ldd	r8, Y+16	; 0x10
     36a:	88 a8       	ldd	r8, Y+48	; 0x30
     36c:	90 68       	ori	r25, 0x80	; 128
     36e:	f0 88       	ldd	r15, Z+16	; 0x10
     370:	88 f0       	brcs	.+34     	; 0x394 <__trampolines_end+0x184>
     372:	a0 90 88 78 	lds	r10, 0x7888	; 0x807888 <__bss_end+0x54cb>
     376:	80 80       	ld	r8, Z
     378:	70 08       	sbc	r7, r0
     37a:	08 f0       	brcs	.+2      	; 0x37e <__trampolines_end+0x16e>
     37c:	f8 20       	and	r15, r8
     37e:	20 20       	and	r2, r0
     380:	20 20       	and	r2, r0
     382:	20 88       	ldd	r2, Z+16	; 0x10
     384:	88 88       	ldd	r8, Y+16	; 0x10
     386:	88 88       	ldd	r8, Y+16	; 0x10
     388:	88 70       	andi	r24, 0x08	; 8
     38a:	88 88       	ldd	r8, Y+16	; 0x10
     38c:	88 88       	ldd	r8, Y+16	; 0x10
     38e:	88 50       	subi	r24, 0x08	; 8
     390:	20 88       	ldd	r2, Z+16	; 0x10
     392:	88 88       	ldd	r8, Y+16	; 0x10
     394:	a8 a8       	ldd	r10, Y+48	; 0x30
     396:	d8 88       	ldd	r13, Y+16	; 0x10
     398:	88 88       	ldd	r8, Y+16	; 0x10
     39a:	50 20       	and	r5, r0
     39c:	50 88       	ldd	r5, Z+16	; 0x10
     39e:	88 88       	ldd	r8, Y+16	; 0x10
     3a0:	88 50       	subi	r24, 0x08	; 8
     3a2:	20 20       	and	r2, r0
     3a4:	20 20       	and	r2, r0
     3a6:	f8 08       	sbc	r15, r8
     3a8:	10 20       	and	r1, r0
     3aa:	40 80       	ld	r4, Z
     3ac:	f8 38       	cpi	r31, 0x88	; 136
     3ae:	20 20       	and	r2, r0
     3b0:	20 20       	and	r2, r0
     3b2:	20 38       	cpi	r18, 0x80	; 128
     3b4:	00 80       	ld	r0, Z
     3b6:	40 20       	and	r4, r0
     3b8:	10 08       	sbc	r1, r0
     3ba:	00 e0       	ldi	r16, 0x00	; 0
     3bc:	20 20       	and	r2, r0
     3be:	20 20       	and	r2, r0
     3c0:	20 e0       	ldi	r18, 0x00	; 0
     3c2:	20 50       	subi	r18, 0x00	; 0
     3c4:	88 00       	.word	0x0088	; ????
	...
     3ce:	00 f8       	bld	r0, 0
     3d0:	40 20       	and	r4, r0
     3d2:	10 00       	.word	0x0010	; ????
     3d4:	00 00       	nop
     3d6:	00 00       	nop
     3d8:	00 70       	andi	r16, 0x00	; 0
     3da:	08 78       	andi	r16, 0x88	; 136
     3dc:	88 78       	andi	r24, 0x88	; 136
     3de:	80 80       	ld	r8, Z
     3e0:	b0 c8       	rjmp	.-3744   	; 0xfffff542 <__eeprom_end+0xff7ef542>
     3e2:	88 88       	ldd	r8, Y+16	; 0x10
     3e4:	f0 00       	.word	0x00f0	; ????
     3e6:	00 70       	andi	r16, 0x00	; 0
     3e8:	80 80       	ld	r8, Z
     3ea:	88 70       	andi	r24, 0x08	; 8
     3ec:	08 08       	sbc	r0, r8
     3ee:	68 98       	cbi	0x0d, 0	; 13
     3f0:	88 88       	ldd	r8, Y+16	; 0x10
     3f2:	78 00       	.word	0x0078	; ????
     3f4:	00 70       	andi	r16, 0x00	; 0
     3f6:	88 f8       	.word	0xf888	; ????
     3f8:	80 70       	andi	r24, 0x00	; 0
     3fa:	30 48       	sbci	r19, 0x80	; 128
     3fc:	40 e0       	ldi	r20, 0x00	; 0
     3fe:	40 40       	sbci	r20, 0x00	; 0
     400:	40 00       	.word	0x0040	; ????
     402:	00 78       	andi	r16, 0x80	; 128
     404:	88 78       	andi	r24, 0x88	; 136
     406:	08 30       	cpi	r16, 0x08	; 8
     408:	80 80       	ld	r8, Z
     40a:	b0 c8       	rjmp	.-3744   	; 0xfffff56c <__eeprom_end+0xff7ef56c>
     40c:	88 88       	ldd	r8, Y+16	; 0x10
     40e:	88 20       	and	r8, r8
     410:	00 60       	ori	r16, 0x00	; 0
     412:	20 20       	and	r2, r0
     414:	20 70       	andi	r18, 0x00	; 0
     416:	10 00       	.word	0x0010	; ????
     418:	30 10       	cpse	r3, r0
     41a:	10 90 60 40 	lds	r1, 0x4060	; 0x804060 <__bss_end+0x1ca3>
     41e:	40 48       	sbci	r20, 0x80	; 128
     420:	50 60       	ori	r21, 0x00	; 0
     422:	50 48       	sbci	r21, 0x80	; 128
     424:	60 20       	and	r6, r0
     426:	20 20       	and	r2, r0
     428:	20 20       	and	r2, r0
     42a:	70 00       	.word	0x0070	; ????
     42c:	00 d0       	rcall	.+0      	; 0x42e <__FUSE_REGION_LENGTH__+0x2e>
     42e:	a8 a8       	ldd	r10, Y+48	; 0x30
     430:	88 88       	ldd	r8, Y+16	; 0x10
     432:	00 00       	nop
     434:	b0 c8       	rjmp	.-3744   	; 0xfffff596 <__eeprom_end+0xff7ef596>
     436:	88 88       	ldd	r8, Y+16	; 0x10
     438:	88 00       	.word	0x0088	; ????
     43a:	00 70       	andi	r16, 0x00	; 0
     43c:	88 88       	ldd	r8, Y+16	; 0x10
     43e:	88 70       	andi	r24, 0x08	; 8
     440:	00 00       	nop
     442:	f0 88       	ldd	r15, Z+16	; 0x10
     444:	f0 80       	ld	r15, Z
     446:	80 00       	.word	0x0080	; ????
     448:	00 68       	ori	r16, 0x80	; 128
     44a:	98 78       	andi	r25, 0x88	; 136
     44c:	08 08       	sbc	r0, r8
     44e:	00 00       	nop
     450:	b0 c8       	rjmp	.-3744   	; 0xfffff5b2 <__eeprom_end+0xff7ef5b2>
     452:	80 80       	ld	r8, Z
     454:	80 00       	.word	0x0080	; ????
     456:	00 70       	andi	r16, 0x00	; 0
     458:	80 70       	andi	r24, 0x00	; 0
     45a:	08 f0       	brcs	.+2      	; 0x45e <__FUSE_REGION_LENGTH__+0x5e>
     45c:	40 40       	sbci	r20, 0x00	; 0
     45e:	e0 40       	sbci	r30, 0x00	; 0
     460:	40 48       	sbci	r20, 0x80	; 128
     462:	30 00       	.word	0x0030	; ????
     464:	00 88       	ldd	r0, Z+16	; 0x10
     466:	88 88       	ldd	r8, Y+16	; 0x10
     468:	98 68       	ori	r25, 0x88	; 136
     46a:	00 00       	nop
     46c:	88 88       	ldd	r8, Y+16	; 0x10
     46e:	88 50       	subi	r24, 0x08	; 8
     470:	20 00       	.word	0x0020	; ????
     472:	00 88       	ldd	r0, Z+16	; 0x10
     474:	88 a8       	ldd	r8, Y+48	; 0x30
     476:	a8 50       	subi	r26, 0x08	; 8
     478:	00 00       	nop
     47a:	88 50       	subi	r24, 0x08	; 8
     47c:	20 50       	subi	r18, 0x00	; 0
     47e:	88 00       	.word	0x0088	; ????
     480:	00 88       	ldd	r0, Z+16	; 0x10
     482:	88 78       	andi	r24, 0x88	; 136
     484:	08 70       	andi	r16, 0x08	; 8
     486:	00 00       	nop
     488:	f8 10       	cpse	r15, r8
     48a:	20 40       	sbci	r18, 0x00	; 0
     48c:	f8 10       	cpse	r15, r8
     48e:	20 20       	and	r2, r0
     490:	40 20       	and	r4, r0
     492:	20 10       	cpse	r2, r0
     494:	20 20       	and	r2, r0
     496:	20 20       	and	r2, r0
     498:	20 20       	and	r2, r0
     49a:	20 40       	sbci	r18, 0x00	; 0
     49c:	20 20       	and	r2, r0
     49e:	10 20       	and	r1, r0
     4a0:	20 40       	sbci	r18, 0x00	; 0

000004a2 <__ctors_end>:
     4a2:	11 24       	eor	r1, r1
     4a4:	1f be       	out	0x3f, r1	; 63
     4a6:	cf ef       	ldi	r28, 0xFF	; 255
     4a8:	cd bf       	out	0x3d, r28	; 61
     4aa:	df e5       	ldi	r29, 0x5F	; 95
     4ac:	de bf       	out	0x3e, r29	; 62
     4ae:	00 e0       	ldi	r16, 0x00	; 0
     4b0:	0c bf       	out	0x3c, r16	; 60

000004b2 <__do_copy_data>:
     4b2:	10 e2       	ldi	r17, 0x20	; 32
     4b4:	a0 e0       	ldi	r26, 0x00	; 0
     4b6:	b0 e2       	ldi	r27, 0x20	; 32
     4b8:	e6 ea       	ldi	r30, 0xA6	; 166
     4ba:	f0 e4       	ldi	r31, 0x40	; 64
     4bc:	00 e0       	ldi	r16, 0x00	; 0
     4be:	0b bf       	out	0x3b, r16	; 59
     4c0:	02 c0       	rjmp	.+4      	; 0x4c6 <__do_copy_data+0x14>
     4c2:	07 90       	elpm	r0, Z+
     4c4:	0d 92       	st	X+, r0
     4c6:	ae 35       	cpi	r26, 0x5E	; 94
     4c8:	b1 07       	cpc	r27, r17
     4ca:	d9 f7       	brne	.-10     	; 0x4c2 <__do_copy_data+0x10>

000004cc <__do_clear_bss>:
     4cc:	23 e2       	ldi	r18, 0x23	; 35
     4ce:	ae e5       	ldi	r26, 0x5E	; 94
     4d0:	b0 e2       	ldi	r27, 0x20	; 32
     4d2:	01 c0       	rjmp	.+2      	; 0x4d6 <.do_clear_bss_start>

000004d4 <.do_clear_bss_loop>:
     4d4:	1d 92       	st	X+, r1

000004d6 <.do_clear_bss_start>:
     4d6:	ad 3b       	cpi	r26, 0xBD	; 189
     4d8:	b2 07       	cpc	r27, r18
     4da:	e1 f7       	brne	.-8      	; 0x4d4 <.do_clear_bss_loop>
     4dc:	0e 94 3e 1b 	call	0x367c	; 0x367c <main>
     4e0:	0c 94 51 20 	jmp	0x40a2	; 0x40a2 <_exit>

000004e4 <__bad_interrupt>:
     4e4:	8d cd       	rjmp	.-1254   	; 0x0 <__vectors>

000004e6 <st7565r_init>:
 * Call this function to initialize the hardware interface and the LCD
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void st7565r_init(void)
{
     4e6:	bf 92       	push	r11
     4e8:	cf 92       	push	r12
     4ea:	df 92       	push	r13
     4ec:	ef 92       	push	r14
     4ee:	ff 92       	push	r15
     4f0:	0f 93       	push	r16
     4f2:	1f 93       	push	r17
     4f4:	cf 93       	push	r28
     4f6:	df 93       	push	r29
     4f8:	1f 92       	push	r1
     4fa:	cd b7       	in	r28, 0x3d	; 61
     4fc:	de b7       	in	r29, 0x3e	; 62
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     4fe:	e0 e0       	ldi	r30, 0x00	; 0
     500:	f6 e0       	ldi	r31, 0x06	; 6
     502:	88 e0       	ldi	r24, 0x08	; 8
     504:	86 83       	std	Z+6, r24	; 0x06
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     506:	85 83       	std	Z+5, r24	; 0x05
	spi_flags_t spi_flags = SPI_MODE_3;
	board_spi_select_id_t spi_select_id = 0;
#endif

#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {
     508:	0f 2e       	mov	r0, r31
     50a:	fb e2       	ldi	r31, 0x2B	; 43
     50c:	bf 2e       	mov	r11, r31
     50e:	f0 2d       	mov	r31, r0
     510:	b9 82       	std	Y+1, r11	; 0x01
		.id = ST7565R_CS_PIN,
	};
	usart_spi_init(ST7565R_USART_SPI);
     512:	80 ea       	ldi	r24, 0xA0	; 160
     514:	99 e0       	ldi	r25, 0x09	; 9
     516:	09 d4       	rcall	.+2066   	; 0xd2a <usart_spi_init>
	usart_spi_setup_device(ST7565R_USART_SPI, &device, spi_flags,
     518:	c1 2c       	mov	r12, r1
     51a:	d1 2c       	mov	r13, r1
     51c:	76 01       	movw	r14, r12
     51e:	00 e4       	ldi	r16, 0x40	; 64
     520:	12 e4       	ldi	r17, 0x42	; 66
     522:	2f e0       	ldi	r18, 0x0F	; 15
     524:	30 e0       	ldi	r19, 0x00	; 0
     526:	43 e0       	ldi	r20, 0x03	; 3
     528:	be 01       	movw	r22, r28
     52a:	6f 5f       	subi	r22, 0xFF	; 255
     52c:	7f 4f       	sbci	r23, 0xFF	; 255
     52e:	80 ea       	ldi	r24, 0xA0	; 160
     530:	99 e0       	ldi	r25, 0x09	; 9
     532:	2a d4       	rcall	.+2132   	; 0xd88 <usart_spi_setup_device>
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     534:	00 e6       	ldi	r16, 0x60	; 96
     536:	16 e0       	ldi	r17, 0x06	; 6
     538:	ff 24       	eor	r15, r15
     53a:	f3 94       	inc	r15
     53c:	f8 01       	movw	r30, r16
     53e:	f6 82       	std	Z+6, r15	; 0x06
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     540:	b9 82       	std	Y+1, r11	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     542:	be 01       	movw	r22, r28
     544:	6f 5f       	subi	r22, 0xFF	; 255
     546:	7f 4f       	sbci	r23, 0xFF	; 255
     548:	80 ea       	ldi	r24, 0xA0	; 160
     54a:	99 e0       	ldi	r25, 0x09	; 9
     54c:	37 d4       	rcall	.+2158   	; 0xdbc <usart_spi_select_device>
     54e:	f8 01       	movw	r30, r16
     550:	f6 82       	std	Z+6, r15	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     552:	e0 ea       	ldi	r30, 0xA0	; 160
     554:	f9 e0       	ldi	r31, 0x09	; 9
     556:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     558:	85 ff       	sbrs	r24, 5
     55a:	fd cf       	rjmp	.-6      	; 0x556 <st7565r_init+0x70>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     55c:	80 ea       	ldi	r24, 0xA0	; 160
     55e:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     562:	e0 ea       	ldi	r30, 0xA0	; 160
     564:	f9 e0       	ldi	r31, 0x09	; 9
     566:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     568:	86 ff       	sbrs	r24, 6
     56a:	fd cf       	rjmp	.-6      	; 0x566 <st7565r_init+0x80>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     56c:	e0 ea       	ldi	r30, 0xA0	; 160
     56e:	f9 e0       	ldi	r31, 0x09	; 9
     570:	80 e4       	ldi	r24, 0x40	; 64
     572:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     574:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     576:	be 01       	movw	r22, r28
     578:	6f 5f       	subi	r22, 0xFF	; 255
     57a:	7f 4f       	sbci	r23, 0xFF	; 255
     57c:	80 ea       	ldi	r24, 0xA0	; 160
     57e:	99 e0       	ldi	r25, 0x09	; 9
     580:	33 d4       	rcall	.+2150   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     582:	8b e2       	ldi	r24, 0x2B	; 43
     584:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     586:	be 01       	movw	r22, r28
     588:	6f 5f       	subi	r22, 0xFF	; 255
     58a:	7f 4f       	sbci	r23, 0xFF	; 255
     58c:	80 ea       	ldi	r24, 0xA0	; 160
     58e:	99 e0       	ldi	r25, 0x09	; 9
     590:	15 d4       	rcall	.+2090   	; 0xdbc <usart_spi_select_device>
     592:	81 e0       	ldi	r24, 0x01	; 1
     594:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     598:	e0 ea       	ldi	r30, 0xA0	; 160
     59a:	f9 e0       	ldi	r31, 0x09	; 9
     59c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     59e:	85 ff       	sbrs	r24, 5
     5a0:	fd cf       	rjmp	.-6      	; 0x59c <st7565r_init+0xb6>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     5a2:	86 ea       	ldi	r24, 0xA6	; 166
     5a4:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     5a8:	e0 ea       	ldi	r30, 0xA0	; 160
     5aa:	f9 e0       	ldi	r31, 0x09	; 9
     5ac:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     5ae:	86 ff       	sbrs	r24, 6
     5b0:	fd cf       	rjmp	.-6      	; 0x5ac <st7565r_init+0xc6>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     5b2:	e0 ea       	ldi	r30, 0xA0	; 160
     5b4:	f9 e0       	ldi	r31, 0x09	; 9
     5b6:	80 e4       	ldi	r24, 0x40	; 64
     5b8:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     5ba:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     5bc:	be 01       	movw	r22, r28
     5be:	6f 5f       	subi	r22, 0xFF	; 255
     5c0:	7f 4f       	sbci	r23, 0xFF	; 255
     5c2:	80 ea       	ldi	r24, 0xA0	; 160
     5c4:	99 e0       	ldi	r25, 0x09	; 9
     5c6:	10 d4       	rcall	.+2080   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     5c8:	8b e2       	ldi	r24, 0x2B	; 43
     5ca:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     5cc:	be 01       	movw	r22, r28
     5ce:	6f 5f       	subi	r22, 0xFF	; 255
     5d0:	7f 4f       	sbci	r23, 0xFF	; 255
     5d2:	80 ea       	ldi	r24, 0xA0	; 160
     5d4:	99 e0       	ldi	r25, 0x09	; 9
     5d6:	f2 d3       	rcall	.+2020   	; 0xdbc <usart_spi_select_device>
     5d8:	81 e0       	ldi	r24, 0x01	; 1
     5da:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     5de:	e0 ea       	ldi	r30, 0xA0	; 160
     5e0:	f9 e0       	ldi	r31, 0x09	; 9
     5e2:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     5e4:	85 ff       	sbrs	r24, 5
     5e6:	fd cf       	rjmp	.-6      	; 0x5e2 <st7565r_init+0xfc>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     5e8:	88 ec       	ldi	r24, 0xC8	; 200
     5ea:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     5ee:	e0 ea       	ldi	r30, 0xA0	; 160
     5f0:	f9 e0       	ldi	r31, 0x09	; 9
     5f2:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     5f4:	86 ff       	sbrs	r24, 6
     5f6:	fd cf       	rjmp	.-6      	; 0x5f2 <st7565r_init+0x10c>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     5f8:	e0 ea       	ldi	r30, 0xA0	; 160
     5fa:	f9 e0       	ldi	r31, 0x09	; 9
     5fc:	80 e4       	ldi	r24, 0x40	; 64
     5fe:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     600:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     602:	be 01       	movw	r22, r28
     604:	6f 5f       	subi	r22, 0xFF	; 255
     606:	7f 4f       	sbci	r23, 0xFF	; 255
     608:	80 ea       	ldi	r24, 0xA0	; 160
     60a:	99 e0       	ldi	r25, 0x09	; 9
     60c:	ed d3       	rcall	.+2010   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     60e:	8b e2       	ldi	r24, 0x2B	; 43
     610:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     612:	be 01       	movw	r22, r28
     614:	6f 5f       	subi	r22, 0xFF	; 255
     616:	7f 4f       	sbci	r23, 0xFF	; 255
     618:	80 ea       	ldi	r24, 0xA0	; 160
     61a:	99 e0       	ldi	r25, 0x09	; 9
     61c:	cf d3       	rcall	.+1950   	; 0xdbc <usart_spi_select_device>
     61e:	81 e0       	ldi	r24, 0x01	; 1
     620:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     624:	e0 ea       	ldi	r30, 0xA0	; 160
     626:	f9 e0       	ldi	r31, 0x09	; 9
     628:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     62a:	85 ff       	sbrs	r24, 5
     62c:	fd cf       	rjmp	.-6      	; 0x628 <st7565r_init+0x142>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     62e:	82 ea       	ldi	r24, 0xA2	; 162
     630:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     634:	e0 ea       	ldi	r30, 0xA0	; 160
     636:	f9 e0       	ldi	r31, 0x09	; 9
     638:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     63a:	86 ff       	sbrs	r24, 6
     63c:	fd cf       	rjmp	.-6      	; 0x638 <st7565r_init+0x152>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     63e:	e0 ea       	ldi	r30, 0xA0	; 160
     640:	f9 e0       	ldi	r31, 0x09	; 9
     642:	80 e4       	ldi	r24, 0x40	; 64
     644:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     646:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     648:	be 01       	movw	r22, r28
     64a:	6f 5f       	subi	r22, 0xFF	; 255
     64c:	7f 4f       	sbci	r23, 0xFF	; 255
     64e:	80 ea       	ldi	r24, 0xA0	; 160
     650:	99 e0       	ldi	r25, 0x09	; 9
     652:	ca d3       	rcall	.+1940   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     654:	8b e2       	ldi	r24, 0x2B	; 43
     656:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     658:	be 01       	movw	r22, r28
     65a:	6f 5f       	subi	r22, 0xFF	; 255
     65c:	7f 4f       	sbci	r23, 0xFF	; 255
     65e:	80 ea       	ldi	r24, 0xA0	; 160
     660:	99 e0       	ldi	r25, 0x09	; 9
     662:	ac d3       	rcall	.+1880   	; 0xdbc <usart_spi_select_device>
     664:	81 e0       	ldi	r24, 0x01	; 1
     666:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     66a:	e0 ea       	ldi	r30, 0xA0	; 160
     66c:	f9 e0       	ldi	r31, 0x09	; 9
     66e:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     670:	85 ff       	sbrs	r24, 5
     672:	fd cf       	rjmp	.-6      	; 0x66e <st7565r_init+0x188>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     674:	8f e2       	ldi	r24, 0x2F	; 47
     676:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     67a:	e0 ea       	ldi	r30, 0xA0	; 160
     67c:	f9 e0       	ldi	r31, 0x09	; 9
     67e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     680:	86 ff       	sbrs	r24, 6
     682:	fd cf       	rjmp	.-6      	; 0x67e <st7565r_init+0x198>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     684:	e0 ea       	ldi	r30, 0xA0	; 160
     686:	f9 e0       	ldi	r31, 0x09	; 9
     688:	80 e4       	ldi	r24, 0x40	; 64
     68a:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     68c:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     68e:	be 01       	movw	r22, r28
     690:	6f 5f       	subi	r22, 0xFF	; 255
     692:	7f 4f       	sbci	r23, 0xFF	; 255
     694:	80 ea       	ldi	r24, 0xA0	; 160
     696:	99 e0       	ldi	r25, 0x09	; 9
     698:	a7 d3       	rcall	.+1870   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     69a:	8b e2       	ldi	r24, 0x2B	; 43
     69c:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     69e:	be 01       	movw	r22, r28
     6a0:	6f 5f       	subi	r22, 0xFF	; 255
     6a2:	7f 4f       	sbci	r23, 0xFF	; 255
     6a4:	80 ea       	ldi	r24, 0xA0	; 160
     6a6:	99 e0       	ldi	r25, 0x09	; 9
     6a8:	89 d3       	rcall	.+1810   	; 0xdbc <usart_spi_select_device>
     6aa:	81 e0       	ldi	r24, 0x01	; 1
     6ac:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     6b0:	e0 ea       	ldi	r30, 0xA0	; 160
     6b2:	f9 e0       	ldi	r31, 0x09	; 9
     6b4:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     6b6:	85 ff       	sbrs	r24, 5
     6b8:	fd cf       	rjmp	.-6      	; 0x6b4 <st7565r_init+0x1ce>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     6ba:	88 ef       	ldi	r24, 0xF8	; 248
     6bc:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     6c0:	e0 ea       	ldi	r30, 0xA0	; 160
     6c2:	f9 e0       	ldi	r31, 0x09	; 9
     6c4:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     6c6:	86 ff       	sbrs	r24, 6
     6c8:	fd cf       	rjmp	.-6      	; 0x6c4 <st7565r_init+0x1de>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     6ca:	e0 ea       	ldi	r30, 0xA0	; 160
     6cc:	f9 e0       	ldi	r31, 0x09	; 9
     6ce:	80 e4       	ldi	r24, 0x40	; 64
     6d0:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     6d2:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     6d4:	be 01       	movw	r22, r28
     6d6:	6f 5f       	subi	r22, 0xFF	; 255
     6d8:	7f 4f       	sbci	r23, 0xFF	; 255
     6da:	80 ea       	ldi	r24, 0xA0	; 160
     6dc:	99 e0       	ldi	r25, 0x09	; 9
     6de:	84 d3       	rcall	.+1800   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     6e0:	8b e2       	ldi	r24, 0x2B	; 43
     6e2:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     6e4:	be 01       	movw	r22, r28
     6e6:	6f 5f       	subi	r22, 0xFF	; 255
     6e8:	7f 4f       	sbci	r23, 0xFF	; 255
     6ea:	80 ea       	ldi	r24, 0xA0	; 160
     6ec:	99 e0       	ldi	r25, 0x09	; 9
     6ee:	66 d3       	rcall	.+1740   	; 0xdbc <usart_spi_select_device>
     6f0:	81 e0       	ldi	r24, 0x01	; 1
     6f2:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     6f6:	e0 ea       	ldi	r30, 0xA0	; 160
     6f8:	f9 e0       	ldi	r31, 0x09	; 9
     6fa:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     6fc:	85 ff       	sbrs	r24, 5
     6fe:	fd cf       	rjmp	.-6      	; 0x6fa <st7565r_init+0x214>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     700:	10 92 a0 09 	sts	0x09A0, r1	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     704:	e0 ea       	ldi	r30, 0xA0	; 160
     706:	f9 e0       	ldi	r31, 0x09	; 9
     708:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     70a:	86 ff       	sbrs	r24, 6
     70c:	fd cf       	rjmp	.-6      	; 0x708 <st7565r_init+0x222>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     70e:	e0 ea       	ldi	r30, 0xA0	; 160
     710:	f9 e0       	ldi	r31, 0x09	; 9
     712:	80 e4       	ldi	r24, 0x40	; 64
     714:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     716:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     718:	be 01       	movw	r22, r28
     71a:	6f 5f       	subi	r22, 0xFF	; 255
     71c:	7f 4f       	sbci	r23, 0xFF	; 255
     71e:	80 ea       	ldi	r24, 0xA0	; 160
     720:	99 e0       	ldi	r25, 0x09	; 9
     722:	62 d3       	rcall	.+1732   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     724:	8b e2       	ldi	r24, 0x2B	; 43
     726:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     728:	be 01       	movw	r22, r28
     72a:	6f 5f       	subi	r22, 0xFF	; 255
     72c:	7f 4f       	sbci	r23, 0xFF	; 255
     72e:	80 ea       	ldi	r24, 0xA0	; 160
     730:	99 e0       	ldi	r25, 0x09	; 9
     732:	44 d3       	rcall	.+1672   	; 0xdbc <usart_spi_select_device>
     734:	81 e0       	ldi	r24, 0x01	; 1
     736:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     73a:	e0 ea       	ldi	r30, 0xA0	; 160
     73c:	f9 e0       	ldi	r31, 0x09	; 9
     73e:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     740:	85 ff       	sbrs	r24, 5
     742:	fd cf       	rjmp	.-6      	; 0x73e <st7565r_init+0x258>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     744:	81 e2       	ldi	r24, 0x21	; 33
     746:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     74a:	e0 ea       	ldi	r30, 0xA0	; 160
     74c:	f9 e0       	ldi	r31, 0x09	; 9
     74e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     750:	86 ff       	sbrs	r24, 6
     752:	fd cf       	rjmp	.-6      	; 0x74e <st7565r_init+0x268>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     754:	e0 ea       	ldi	r30, 0xA0	; 160
     756:	f9 e0       	ldi	r31, 0x09	; 9
     758:	80 e4       	ldi	r24, 0x40	; 64
     75a:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     75c:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     75e:	be 01       	movw	r22, r28
     760:	6f 5f       	subi	r22, 0xFF	; 255
     762:	7f 4f       	sbci	r23, 0xFF	; 255
     764:	80 ea       	ldi	r24, 0xA0	; 160
     766:	99 e0       	ldi	r25, 0x09	; 9
     768:	3f d3       	rcall	.+1662   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     76a:	8b e2       	ldi	r24, 0x2B	; 43
     76c:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     76e:	be 01       	movw	r22, r28
     770:	6f 5f       	subi	r22, 0xFF	; 255
     772:	7f 4f       	sbci	r23, 0xFF	; 255
     774:	80 ea       	ldi	r24, 0xA0	; 160
     776:	99 e0       	ldi	r25, 0x09	; 9
     778:	21 d3       	rcall	.+1602   	; 0xdbc <usart_spi_select_device>
     77a:	81 e0       	ldi	r24, 0x01	; 1
     77c:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     780:	e0 ea       	ldi	r30, 0xA0	; 160
     782:	f9 e0       	ldi	r31, 0x09	; 9
     784:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     786:	85 ff       	sbrs	r24, 5
     788:	fd cf       	rjmp	.-6      	; 0x784 <st7565r_init+0x29e>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     78a:	81 e8       	ldi	r24, 0x81	; 129
     78c:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     790:	e0 ea       	ldi	r30, 0xA0	; 160
     792:	f9 e0       	ldi	r31, 0x09	; 9
     794:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     796:	86 ff       	sbrs	r24, 6
     798:	fd cf       	rjmp	.-6      	; 0x794 <st7565r_init+0x2ae>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     79a:	e0 ea       	ldi	r30, 0xA0	; 160
     79c:	f9 e0       	ldi	r31, 0x09	; 9
     79e:	80 e4       	ldi	r24, 0x40	; 64
     7a0:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     7a2:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     7a4:	be 01       	movw	r22, r28
     7a6:	6f 5f       	subi	r22, 0xFF	; 255
     7a8:	7f 4f       	sbci	r23, 0xFF	; 255
     7aa:	80 ea       	ldi	r24, 0xA0	; 160
     7ac:	99 e0       	ldi	r25, 0x09	; 9
     7ae:	1c d3       	rcall	.+1592   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     7b0:	8b e2       	ldi	r24, 0x2B	; 43
     7b2:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     7b4:	be 01       	movw	r22, r28
     7b6:	6f 5f       	subi	r22, 0xFF	; 255
     7b8:	7f 4f       	sbci	r23, 0xFF	; 255
     7ba:	80 ea       	ldi	r24, 0xA0	; 160
     7bc:	99 e0       	ldi	r25, 0x09	; 9
     7be:	fe d2       	rcall	.+1532   	; 0xdbc <usart_spi_select_device>
     7c0:	81 e0       	ldi	r24, 0x01	; 1
     7c2:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     7c6:	e0 ea       	ldi	r30, 0xA0	; 160
     7c8:	f9 e0       	ldi	r31, 0x09	; 9
     7ca:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     7cc:	85 ff       	sbrs	r24, 5
     7ce:	fd cf       	rjmp	.-6      	; 0x7ca <st7565r_init+0x2e4>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     7d0:	81 e2       	ldi	r24, 0x21	; 33
     7d2:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     7d6:	e0 ea       	ldi	r30, 0xA0	; 160
     7d8:	f9 e0       	ldi	r31, 0x09	; 9
     7da:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     7dc:	86 ff       	sbrs	r24, 6
     7de:	fd cf       	rjmp	.-6      	; 0x7da <st7565r_init+0x2f4>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     7e0:	e0 ea       	ldi	r30, 0xA0	; 160
     7e2:	f9 e0       	ldi	r31, 0x09	; 9
     7e4:	80 e4       	ldi	r24, 0x40	; 64
     7e6:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     7e8:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     7ea:	be 01       	movw	r22, r28
     7ec:	6f 5f       	subi	r22, 0xFF	; 255
     7ee:	7f 4f       	sbci	r23, 0xFF	; 255
     7f0:	80 ea       	ldi	r24, 0xA0	; 160
     7f2:	99 e0       	ldi	r25, 0x09	; 9
     7f4:	f9 d2       	rcall	.+1522   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     7f6:	8b e2       	ldi	r24, 0x2B	; 43
     7f8:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     7fa:	be 01       	movw	r22, r28
     7fc:	6f 5f       	subi	r22, 0xFF	; 255
     7fe:	7f 4f       	sbci	r23, 0xFF	; 255
     800:	80 ea       	ldi	r24, 0xA0	; 160
     802:	99 e0       	ldi	r25, 0x09	; 9
     804:	db d2       	rcall	.+1462   	; 0xdbc <usart_spi_select_device>
     806:	81 e0       	ldi	r24, 0x01	; 1
     808:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     80c:	e0 ea       	ldi	r30, 0xA0	; 160
     80e:	f9 e0       	ldi	r31, 0x09	; 9
     810:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     812:	85 ff       	sbrs	r24, 5
     814:	fd cf       	rjmp	.-6      	; 0x810 <st7565r_init+0x32a>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     816:	8f ea       	ldi	r24, 0xAF	; 175
     818:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     81c:	e0 ea       	ldi	r30, 0xA0	; 160
     81e:	f9 e0       	ldi	r31, 0x09	; 9
     820:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     822:	86 ff       	sbrs	r24, 6
     824:	fd cf       	rjmp	.-6      	; 0x820 <st7565r_init+0x33a>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     826:	e0 ea       	ldi	r30, 0xA0	; 160
     828:	f9 e0       	ldi	r31, 0x09	; 9
     82a:	80 e4       	ldi	r24, 0x40	; 64
     82c:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     82e:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     830:	be 01       	movw	r22, r28
     832:	6f 5f       	subi	r22, 0xFF	; 255
     834:	7f 4f       	sbci	r23, 0xFF	; 255
     836:	80 ea       	ldi	r24, 0xA0	; 160
     838:	99 e0       	ldi	r25, 0x09	; 9
     83a:	d6 d2       	rcall	.+1452   	; 0xde8 <usart_spi_deselect_device>
	is set to the defined min*/
	st7565r_set_contrast(ST7565R_DISPLAY_CONTRAST_MIN);

	// Turn on the display
	st7565r_display_on();
}
     83c:	0f 90       	pop	r0
     83e:	df 91       	pop	r29
     840:	cf 91       	pop	r28
     842:	1f 91       	pop	r17
     844:	0f 91       	pop	r16
     846:	ff 90       	pop	r15
     848:	ef 90       	pop	r14
     84a:	df 90       	pop	r13
     84c:	cf 90       	pop	r12
     84e:	bf 90       	pop	r11
     850:	08 95       	ret

00000852 <sysclk_enable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     852:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
     854:	f8 94       	cli

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
     856:	e8 2f       	mov	r30, r24
     858:	f0 e0       	ldi	r31, 0x00	; 0
     85a:	e0 59       	subi	r30, 0x90	; 144
     85c:	ff 4f       	sbci	r31, 0xFF	; 255
     85e:	60 95       	com	r22
     860:	80 81       	ld	r24, Z
     862:	68 23       	and	r22, r24
     864:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     866:	9f bf       	out	0x3f, r25	; 63
     868:	08 95       	ret

0000086a <sysclk_disable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     86a:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
     86c:	f8 94       	cli

void sysclk_disable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) |= id;
     86e:	e8 2f       	mov	r30, r24
     870:	f0 e0       	ldi	r31, 0x00	; 0
     872:	e0 59       	subi	r30, 0x90	; 144
     874:	ff 4f       	sbci	r31, 0xFF	; 255
     876:	80 81       	ld	r24, Z
     878:	68 2b       	or	r22, r24
     87a:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     87c:	9f bf       	out	0x3f, r25	; 63
     87e:	08 95       	ret

00000880 <gfx_mono_st7565r_put_byte>:
	gfx_mono_st7565r_put_byte(0, 0, 0xFF);
\endcode
 */
void gfx_mono_st7565r_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
     880:	ff 92       	push	r15
     882:	0f 93       	push	r16
     884:	1f 93       	push	r17
     886:	cf 93       	push	r28
     888:	df 93       	push	r29
     88a:	1f 92       	push	r1
     88c:	cd b7       	in	r28, 0x3d	; 61
     88e:	de b7       	in	r29, 0x3e	; 62
     890:	08 2f       	mov	r16, r24
     892:	f6 2e       	mov	r15, r22
     894:	14 2f       	mov	r17, r20
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_framebuffer_put_byte(page, column, data);
     896:	22 d1       	rcall	.+580    	; 0xadc <gfx_mono_framebuffer_put_byte>
 * \param address the page address
 */
static inline void st7565r_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
     898:	0f 70       	andi	r16, 0x0F	; 15
	st7565r_write_command(ST7565R_CMD_PAGE_ADDRESS_SET(address));
     89a:	00 6b       	ori	r16, 0xB0	; 176
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     89c:	8b e2       	ldi	r24, 0x2B	; 43
     89e:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     8a0:	be 01       	movw	r22, r28
     8a2:	6f 5f       	subi	r22, 0xFF	; 255
     8a4:	7f 4f       	sbci	r23, 0xFF	; 255
     8a6:	80 ea       	ldi	r24, 0xA0	; 160
     8a8:	99 e0       	ldi	r25, 0x09	; 9
     8aa:	88 d2       	rcall	.+1296   	; 0xdbc <usart_spi_select_device>
     8ac:	81 e0       	ldi	r24, 0x01	; 1
     8ae:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     8b2:	e0 ea       	ldi	r30, 0xA0	; 160
     8b4:	f9 e0       	ldi	r31, 0x09	; 9
     8b6:	91 81       	ldd	r25, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     8b8:	95 ff       	sbrs	r25, 5
     8ba:	fd cf       	rjmp	.-6      	; 0x8b6 <gfx_mono_st7565r_put_byte+0x36>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     8bc:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     8c0:	e0 ea       	ldi	r30, 0xA0	; 160
     8c2:	f9 e0       	ldi	r31, 0x09	; 9
     8c4:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     8c6:	86 ff       	sbrs	r24, 6
     8c8:	fd cf       	rjmp	.-6      	; 0x8c4 <gfx_mono_st7565r_put_byte+0x44>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     8ca:	e0 ea       	ldi	r30, 0xA0	; 160
     8cc:	f9 e0       	ldi	r31, 0x09	; 9
     8ce:	80 e4       	ldi	r24, 0x40	; 64
     8d0:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     8d2:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     8d4:	be 01       	movw	r22, r28
     8d6:	6f 5f       	subi	r22, 0xFF	; 255
     8d8:	7f 4f       	sbci	r23, 0xFF	; 255
     8da:	80 ea       	ldi	r24, 0xA0	; 160
     8dc:	99 e0       	ldi	r25, 0x09	; 9
     8de:	84 d2       	rcall	.+1288   	; 0xde8 <usart_spi_deselect_device>
 * \param address the column address
 */
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
     8e0:	0f 2d       	mov	r16, r15
     8e2:	0f 77       	andi	r16, 0x7F	; 127
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
     8e4:	02 95       	swap	r16
     8e6:	0f 70       	andi	r16, 0x0F	; 15
     8e8:	00 61       	ori	r16, 0x10	; 16
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     8ea:	8b e2       	ldi	r24, 0x2B	; 43
     8ec:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     8ee:	be 01       	movw	r22, r28
     8f0:	6f 5f       	subi	r22, 0xFF	; 255
     8f2:	7f 4f       	sbci	r23, 0xFF	; 255
     8f4:	80 ea       	ldi	r24, 0xA0	; 160
     8f6:	99 e0       	ldi	r25, 0x09	; 9
     8f8:	61 d2       	rcall	.+1218   	; 0xdbc <usart_spi_select_device>
     8fa:	81 e0       	ldi	r24, 0x01	; 1
     8fc:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     900:	e0 ea       	ldi	r30, 0xA0	; 160
     902:	f9 e0       	ldi	r31, 0x09	; 9
     904:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     906:	85 ff       	sbrs	r24, 5
     908:	fd cf       	rjmp	.-6      	; 0x904 <gfx_mono_st7565r_put_byte+0x84>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     90a:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     90e:	e0 ea       	ldi	r30, 0xA0	; 160
     910:	f9 e0       	ldi	r31, 0x09	; 9
     912:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     914:	86 ff       	sbrs	r24, 6
     916:	fd cf       	rjmp	.-6      	; 0x912 <gfx_mono_st7565r_put_byte+0x92>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     918:	e0 ea       	ldi	r30, 0xA0	; 160
     91a:	f9 e0       	ldi	r31, 0x09	; 9
     91c:	80 e4       	ldi	r24, 0x40	; 64
     91e:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     920:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     922:	be 01       	movw	r22, r28
     924:	6f 5f       	subi	r22, 0xFF	; 255
     926:	7f 4f       	sbci	r23, 0xFF	; 255
     928:	80 ea       	ldi	r24, 0xA0	; 160
     92a:	99 e0       	ldi	r25, 0x09	; 9
     92c:	5d d2       	rcall	.+1210   	; 0xde8 <usart_spi_deselect_device>
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_LSB(address & 0x0F));
     92e:	0f 2d       	mov	r16, r15
     930:	0f 70       	andi	r16, 0x0F	; 15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     932:	8b e2       	ldi	r24, 0x2B	; 43
     934:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     936:	be 01       	movw	r22, r28
     938:	6f 5f       	subi	r22, 0xFF	; 255
     93a:	7f 4f       	sbci	r23, 0xFF	; 255
     93c:	80 ea       	ldi	r24, 0xA0	; 160
     93e:	99 e0       	ldi	r25, 0x09	; 9
     940:	3d d2       	rcall	.+1146   	; 0xdbc <usart_spi_select_device>
     942:	81 e0       	ldi	r24, 0x01	; 1
     944:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     948:	e0 ea       	ldi	r30, 0xA0	; 160
     94a:	f9 e0       	ldi	r31, 0x09	; 9
     94c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     94e:	85 ff       	sbrs	r24, 5
     950:	fd cf       	rjmp	.-6      	; 0x94c <gfx_mono_st7565r_put_byte+0xcc>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     952:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     956:	e0 ea       	ldi	r30, 0xA0	; 160
     958:	f9 e0       	ldi	r31, 0x09	; 9
     95a:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     95c:	86 ff       	sbrs	r24, 6
     95e:	fd cf       	rjmp	.-6      	; 0x95a <gfx_mono_st7565r_put_byte+0xda>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     960:	e0 ea       	ldi	r30, 0xA0	; 160
     962:	f9 e0       	ldi	r31, 0x09	; 9
     964:	80 e4       	ldi	r24, 0x40	; 64
     966:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     968:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     96a:	be 01       	movw	r22, r28
     96c:	6f 5f       	subi	r22, 0xFF	; 255
     96e:	7f 4f       	sbci	r23, 0xFF	; 255
     970:	80 ea       	ldi	r24, 0xA0	; 160
     972:	99 e0       	ldi	r25, 0x09	; 9
     974:	39 d2       	rcall	.+1138   	; 0xde8 <usart_spi_deselect_device>
 * \param data the data to write
 */
static inline void st7565r_write_data(uint8_t data)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     976:	8b e2       	ldi	r24, 0x2B	; 43
     978:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     97a:	be 01       	movw	r22, r28
     97c:	6f 5f       	subi	r22, 0xFF	; 255
     97e:	7f 4f       	sbci	r23, 0xFF	; 255
     980:	80 ea       	ldi	r24, 0xA0	; 160
     982:	99 e0       	ldi	r25, 0x09	; 9
     984:	1b d2       	rcall	.+1078   	; 0xdbc <usart_spi_select_device>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     986:	81 e0       	ldi	r24, 0x01	; 1
     988:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x700665>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     98c:	e0 ea       	ldi	r30, 0xA0	; 160
     98e:	f9 e0       	ldi	r31, 0x09	; 9
     990:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     992:	85 ff       	sbrs	r24, 5
     994:	fd cf       	rjmp	.-6      	; 0x990 <gfx_mono_st7565r_put_byte+0x110>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     996:	10 93 a0 09 	sts	0x09A0, r17	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     99a:	e0 ea       	ldi	r30, 0xA0	; 160
     99c:	f9 e0       	ldi	r31, 0x09	; 9
     99e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     9a0:	86 ff       	sbrs	r24, 6
     9a2:	fd cf       	rjmp	.-6      	; 0x99e <gfx_mono_st7565r_put_byte+0x11e>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     9a4:	e0 ea       	ldi	r30, 0xA0	; 160
     9a6:	f9 e0       	ldi	r31, 0x09	; 9
     9a8:	80 e4       	ldi	r24, 0x40	; 64
     9aa:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     9ac:	80 81       	ld	r24, Z
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     9ae:	81 e0       	ldi	r24, 0x01	; 1
     9b0:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
	ioport_set_pin_high(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, data);
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     9b4:	be 01       	movw	r22, r28
     9b6:	6f 5f       	subi	r22, 0xFF	; 255
     9b8:	7f 4f       	sbci	r23, 0xFF	; 255
     9ba:	80 ea       	ldi	r24, 0xA0	; 160
     9bc:	99 e0       	ldi	r25, 0x09	; 9
     9be:	14 d2       	rcall	.+1064   	; 0xde8 <usart_spi_deselect_device>

	st7565r_set_page_address(page);
	st7565r_set_column_address(column);

	st7565r_write_data(data);
}
     9c0:	0f 90       	pop	r0
     9c2:	df 91       	pop	r29
     9c4:	cf 91       	pop	r28
     9c6:	1f 91       	pop	r17
     9c8:	0f 91       	pop	r16
     9ca:	ff 90       	pop	r15
     9cc:	08 95       	ret

000009ce <gfx_mono_st7565r_init>:
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     9ce:	0f 93       	push	r16
     9d0:	1f 93       	push	r17
     9d2:	cf 93       	push	r28
     9d4:	df 93       	push	r29
     9d6:	1f 92       	push	r1
     9d8:	cd b7       	in	r28, 0x3d	; 61
     9da:	de b7       	in	r29, 0x3e	; 62
	uint8_t page;
	uint8_t column;

#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_set_framebuffer(framebuffer);
     9dc:	8e e5       	ldi	r24, 0x5E	; 94
     9de:	90 e2       	ldi	r25, 0x20	; 32
     9e0:	78 d0       	rcall	.+240    	; 0xad2 <gfx_mono_set_framebuffer>
#endif

	/* Initialize the low-level display controller. */
	st7565r_init();
     9e2:	81 dd       	rcall	.-1278   	; 0x4e6 <st7565r_init>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     9e4:	8b e2       	ldi	r24, 0x2B	; 43
     9e6:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     9e8:	be 01       	movw	r22, r28
     9ea:	6f 5f       	subi	r22, 0xFF	; 255
     9ec:	7f 4f       	sbci	r23, 0xFF	; 255
     9ee:	80 ea       	ldi	r24, 0xA0	; 160
     9f0:	99 e0       	ldi	r25, 0x09	; 9
     9f2:	e4 d1       	rcall	.+968    	; 0xdbc <usart_spi_select_device>
     9f4:	81 e0       	ldi	r24, 0x01	; 1
     9f6:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     9fa:	e0 ea       	ldi	r30, 0xA0	; 160
     9fc:	f9 e0       	ldi	r31, 0x09	; 9
     9fe:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     a00:	85 ff       	sbrs	r24, 5
     a02:	fd cf       	rjmp	.-6      	; 0x9fe <gfx_mono_st7565r_init+0x30>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     a04:	80 e4       	ldi	r24, 0x40	; 64
     a06:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     a0a:	e0 ea       	ldi	r30, 0xA0	; 160
     a0c:	f9 e0       	ldi	r31, 0x09	; 9
     a0e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     a10:	86 ff       	sbrs	r24, 6
     a12:	fd cf       	rjmp	.-6      	; 0xa0e <gfx_mono_st7565r_init+0x40>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     a14:	e0 ea       	ldi	r30, 0xA0	; 160
     a16:	f9 e0       	ldi	r31, 0x09	; 9
     a18:	80 e4       	ldi	r24, 0x40	; 64
     a1a:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     a1c:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     a1e:	be 01       	movw	r22, r28
     a20:	6f 5f       	subi	r22, 0xFF	; 255
     a22:	7f 4f       	sbci	r23, 0xFF	; 255
     a24:	80 ea       	ldi	r24, 0xA0	; 160
     a26:	99 e0       	ldi	r25, 0x09	; 9
     a28:	df d1       	rcall	.+958    	; 0xde8 <usart_spi_deselect_device>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     a2a:	00 e0       	ldi	r16, 0x00	; 0
     a2c:	0a c0       	rjmp	.+20     	; 0xa42 <gfx_mono_st7565r_init+0x74>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
     a2e:	40 e0       	ldi	r20, 0x00	; 0
     a30:	61 2f       	mov	r22, r17
     a32:	80 2f       	mov	r24, r16
     a34:	25 df       	rcall	.-438    	; 0x880 <gfx_mono_st7565r_put_byte>
	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
     a36:	1f 5f       	subi	r17, 0xFF	; 255
     a38:	10 38       	cpi	r17, 0x80	; 128
     a3a:	c9 f7       	brne	.-14     	; 0xa2e <gfx_mono_st7565r_init+0x60>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     a3c:	0f 5f       	subi	r16, 0xFF	; 255
     a3e:	04 30       	cpi	r16, 0x04	; 4
     a40:	11 f0       	breq	.+4      	; 0xa46 <gfx_mono_st7565r_init+0x78>
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     a42:	10 e0       	ldi	r17, 0x00	; 0
     a44:	f4 cf       	rjmp	.-24     	; 0xa2e <gfx_mono_st7565r_init+0x60>
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
		}
	}
}
     a46:	0f 90       	pop	r0
     a48:	df 91       	pop	r29
     a4a:	cf 91       	pop	r28
     a4c:	1f 91       	pop	r17
     a4e:	0f 91       	pop	r16
     a50:	08 95       	ret

00000a52 <gfx_mono_st7565r_draw_pixel>:
	gfx_mono_st7565r_draw_pixel(10, 10, GFX_PIXEL_XOR);
\endcode
 */
void gfx_mono_st7565r_draw_pixel(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t color)
{
     a52:	ff 92       	push	r15
     a54:	0f 93       	push	r16
     a56:	1f 93       	push	r17
     a58:	cf 93       	push	r28
     a5a:	df 93       	push	r29
	uint8_t page;
	uint8_t pixel_mask;
	uint8_t pixel_value;

	/* Discard pixels drawn outside the screen */
	if ((x > GFX_MONO_LCD_WIDTH - 1) || (y > GFX_MONO_LCD_HEIGHT - 1)) {
     a5c:	88 23       	and	r24, r24
     a5e:	8c f1       	brlt	.+98     	; 0xac2 <gfx_mono_st7565r_draw_pixel+0x70>
     a60:	60 32       	cpi	r22, 0x20	; 32
     a62:	78 f5       	brcc	.+94     	; 0xac2 <gfx_mono_st7565r_draw_pixel+0x70>
     a64:	d4 2f       	mov	r29, r20
     a66:	c8 2f       	mov	r28, r24
		return;
	}

	page = y / GFX_MONO_LCD_PIXELS_PER_BYTE;
     a68:	f6 2e       	mov	r15, r22
     a6a:	f6 94       	lsr	r15
     a6c:	f6 94       	lsr	r15
     a6e:	f6 94       	lsr	r15
	pixel_mask = (1 << (y - (page * 8)));
     a70:	2f 2d       	mov	r18, r15
     a72:	30 e0       	ldi	r19, 0x00	; 0
     a74:	31 95       	neg	r19
     a76:	21 95       	neg	r18
     a78:	31 09       	sbc	r19, r1
     a7a:	22 0f       	add	r18, r18
     a7c:	33 1f       	adc	r19, r19
     a7e:	22 0f       	add	r18, r18
     a80:	33 1f       	adc	r19, r19
     a82:	22 0f       	add	r18, r18
     a84:	33 1f       	adc	r19, r19
     a86:	26 0f       	add	r18, r22
     a88:	31 1d       	adc	r19, r1
     a8a:	61 e0       	ldi	r22, 0x01	; 1
     a8c:	70 e0       	ldi	r23, 0x00	; 0
     a8e:	8b 01       	movw	r16, r22
     a90:	02 c0       	rjmp	.+4      	; 0xa96 <gfx_mono_st7565r_draw_pixel+0x44>
     a92:	00 0f       	add	r16, r16
     a94:	11 1f       	adc	r17, r17
     a96:	2a 95       	dec	r18
     a98:	e2 f7       	brpl	.-8      	; 0xa92 <gfx_mono_st7565r_draw_pixel+0x40>
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     a9a:	68 2f       	mov	r22, r24
     a9c:	8f 2d       	mov	r24, r15
     a9e:	2c d0       	rcall	.+88     	; 0xaf8 <gfx_mono_framebuffer_get_byte>
	 * requested action on this pixel before writing the page back to the
	 * display.
	 */
	pixel_value = gfx_mono_get_byte(page, x);

	switch (color) {
     aa0:	d1 30       	cpi	r29, 0x01	; 1
     aa2:	21 f0       	breq	.+8      	; 0xaac <gfx_mono_st7565r_draw_pixel+0x5a>
     aa4:	28 f0       	brcs	.+10     	; 0xab0 <gfx_mono_st7565r_draw_pixel+0x5e>
     aa6:	d2 30       	cpi	r29, 0x02	; 2
     aa8:	39 f0       	breq	.+14     	; 0xab8 <gfx_mono_st7565r_draw_pixel+0x66>
     aaa:	07 c0       	rjmp	.+14     	; 0xaba <gfx_mono_st7565r_draw_pixel+0x68>
	case GFX_PIXEL_SET:
		pixel_value |= pixel_mask;
     aac:	80 2b       	or	r24, r16
		break;
     aae:	05 c0       	rjmp	.+10     	; 0xaba <gfx_mono_st7565r_draw_pixel+0x68>

	case GFX_PIXEL_CLR:
		pixel_value &= ~pixel_mask;
     ab0:	60 2f       	mov	r22, r16
     ab2:	60 95       	com	r22
     ab4:	86 23       	and	r24, r22
		break;
     ab6:	01 c0       	rjmp	.+2      	; 0xaba <gfx_mono_st7565r_draw_pixel+0x68>

	case GFX_PIXEL_XOR:
		pixel_value ^= pixel_mask;
     ab8:	80 27       	eor	r24, r16

	default:
		break;
	}

	gfx_mono_put_byte(page, x, pixel_value);
     aba:	48 2f       	mov	r20, r24
     abc:	6c 2f       	mov	r22, r28
     abe:	8f 2d       	mov	r24, r15
     ac0:	df de       	rcall	.-578    	; 0x880 <gfx_mono_st7565r_put_byte>
}
     ac2:	df 91       	pop	r29
     ac4:	cf 91       	pop	r28
     ac6:	1f 91       	pop	r17
     ac8:	0f 91       	pop	r16
     aca:	ff 90       	pop	r15
     acc:	08 95       	ret

00000ace <gfx_mono_st7565r_get_byte>:
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     ace:	14 c0       	rjmp	.+40     	; 0xaf8 <gfx_mono_framebuffer_get_byte>
	st7565r_set_column_address(column);

	return st7565r_read_data();

#endif
}
     ad0:	08 95       	ret

00000ad2 <gfx_mono_set_framebuffer>:
	gfx_coord_t *framebuffer_pt = fbpointer +
			((page * GFX_MONO_LCD_WIDTH) + column);
	do {
		*data++ = *framebuffer_pt++;
	} while (--width > 0);
}
     ad2:	80 93 5e 22 	sts	0x225E, r24	; 0x80225e <fbpointer>
     ad6:	90 93 5f 22 	sts	0x225F, r25	; 0x80225f <fbpointer+0x1>
     ada:	08 95       	ret

00000adc <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
     adc:	20 e8       	ldi	r18, 0x80	; 128
     ade:	82 9f       	mul	r24, r18
     ae0:	c0 01       	movw	r24, r0
     ae2:	11 24       	eor	r1, r1
     ae4:	86 0f       	add	r24, r22
     ae6:	91 1d       	adc	r25, r1
     ae8:	e0 91 5e 22 	lds	r30, 0x225E	; 0x80225e <fbpointer>
     aec:	f0 91 5f 22 	lds	r31, 0x225F	; 0x80225f <fbpointer+0x1>
     af0:	e8 0f       	add	r30, r24
     af2:	f9 1f       	adc	r31, r25
     af4:	40 83       	st	Z, r20
     af6:	08 95       	ret

00000af8 <gfx_mono_framebuffer_get_byte>:
	data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(gfx_coord_t page, gfx_coord_t column)
{
	return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
     af8:	20 e8       	ldi	r18, 0x80	; 128
     afa:	82 9f       	mul	r24, r18
     afc:	c0 01       	movw	r24, r0
     afe:	11 24       	eor	r1, r1
     b00:	86 0f       	add	r24, r22
     b02:	91 1d       	adc	r25, r1
     b04:	e0 91 5e 22 	lds	r30, 0x225E	; 0x80225e <fbpointer>
     b08:	f0 91 5f 22 	lds	r31, 0x225F	; 0x80225f <fbpointer+0x1>
     b0c:	e8 0f       	add	r30, r24
     b0e:	f9 1f       	adc	r31, r25
}
     b10:	80 81       	ld	r24, Z
     b12:	08 95       	ret

00000b14 <gfx_mono_generic_draw_horizontal_line>:
	gfx_mono_draw_horizontal_line(x, y, width, color);
	gfx_mono_draw_horizontal_line(x, y + height - 1, width, color);

	gfx_mono_draw_vertical_line(x, y, height, color);
	gfx_mono_draw_vertical_line(x + width - 1, y, height, color);
}
     b14:	ff 92       	push	r15
     b16:	0f 93       	push	r16
     b18:	1f 93       	push	r17
     b1a:	cf 93       	push	r28
     b1c:	df 93       	push	r29
     b1e:	e4 2f       	mov	r30, r20
     b20:	f0 e0       	ldi	r31, 0x00	; 0
     b22:	e8 0f       	add	r30, r24
     b24:	f1 1d       	adc	r31, r1
     b26:	e1 38       	cpi	r30, 0x81	; 129
     b28:	f1 05       	cpc	r31, r1
     b2a:	1c f0       	brlt	.+6      	; 0xb32 <gfx_mono_generic_draw_horizontal_line+0x1e>
     b2c:	c0 e8       	ldi	r28, 0x80	; 128
     b2e:	4c 2f       	mov	r20, r28
     b30:	48 1b       	sub	r20, r24
     b32:	44 23       	and	r20, r20
     b34:	09 f4       	brne	.+2      	; 0xb38 <gfx_mono_generic_draw_horizontal_line+0x24>
     b36:	53 c0       	rjmp	.+166    	; 0xbde <gfx_mono_generic_draw_horizontal_line+0xca>
     b38:	d6 2f       	mov	r29, r22
     b3a:	d6 95       	lsr	r29
     b3c:	d6 95       	lsr	r29
     b3e:	d6 95       	lsr	r29
     b40:	ed 2f       	mov	r30, r29
     b42:	f0 e0       	ldi	r31, 0x00	; 0
     b44:	f1 95       	neg	r31
     b46:	e1 95       	neg	r30
     b48:	f1 09       	sbc	r31, r1
     b4a:	ee 0f       	add	r30, r30
     b4c:	ff 1f       	adc	r31, r31
     b4e:	ee 0f       	add	r30, r30
     b50:	ff 1f       	adc	r31, r31
     b52:	ee 0f       	add	r30, r30
     b54:	ff 1f       	adc	r31, r31
     b56:	df 01       	movw	r26, r30
     b58:	a6 0f       	add	r26, r22
     b5a:	b1 1d       	adc	r27, r1
     b5c:	bd 01       	movw	r22, r26
     b5e:	e1 e0       	ldi	r30, 0x01	; 1
     b60:	f0 e0       	ldi	r31, 0x00	; 0
     b62:	df 01       	movw	r26, r30
     b64:	02 c0       	rjmp	.+4      	; 0xb6a <gfx_mono_generic_draw_horizontal_line+0x56>
     b66:	aa 0f       	add	r26, r26
     b68:	bb 1f       	adc	r27, r27
     b6a:	6a 95       	dec	r22
     b6c:	e2 f7       	brpl	.-8      	; 0xb66 <gfx_mono_generic_draw_horizontal_line+0x52>
     b6e:	fa 2e       	mov	r15, r26
     b70:	21 30       	cpi	r18, 0x01	; 1
     b72:	21 f0       	breq	.+8      	; 0xb7c <gfx_mono_generic_draw_horizontal_line+0x68>
     b74:	98 f0       	brcs	.+38     	; 0xb9c <gfx_mono_generic_draw_horizontal_line+0x88>
     b76:	22 30       	cpi	r18, 0x02	; 2
     b78:	19 f1       	breq	.+70     	; 0xbc0 <gfx_mono_generic_draw_horizontal_line+0xac>
     b7a:	31 c0       	rjmp	.+98     	; 0xbde <gfx_mono_generic_draw_horizontal_line+0xca>
     b7c:	c4 2f       	mov	r28, r20
     b7e:	1f ef       	ldi	r17, 0xFF	; 255
     b80:	18 0f       	add	r17, r24
     b82:	01 2f       	mov	r16, r17
     b84:	0c 0f       	add	r16, r28
     b86:	60 2f       	mov	r22, r16
     b88:	8d 2f       	mov	r24, r29
     b8a:	a1 df       	rcall	.-190    	; 0xace <gfx_mono_st7565r_get_byte>
     b8c:	48 2f       	mov	r20, r24
     b8e:	4f 29       	or	r20, r15
     b90:	60 2f       	mov	r22, r16
     b92:	8d 2f       	mov	r24, r29
     b94:	75 de       	rcall	.-790    	; 0x880 <gfx_mono_st7565r_put_byte>
     b96:	c1 50       	subi	r28, 0x01	; 1
     b98:	a1 f7       	brne	.-24     	; 0xb82 <gfx_mono_generic_draw_horizontal_line+0x6e>
     b9a:	21 c0       	rjmp	.+66     	; 0xbde <gfx_mono_generic_draw_horizontal_line+0xca>
     b9c:	c4 2f       	mov	r28, r20
     b9e:	1f ef       	ldi	r17, 0xFF	; 255
     ba0:	18 0f       	add	r17, r24
     ba2:	fa 2e       	mov	r15, r26
     ba4:	f0 94       	com	r15
     ba6:	01 2f       	mov	r16, r17
     ba8:	0c 0f       	add	r16, r28
     baa:	60 2f       	mov	r22, r16
     bac:	8d 2f       	mov	r24, r29
     bae:	8f df       	rcall	.-226    	; 0xace <gfx_mono_st7565r_get_byte>
     bb0:	48 2f       	mov	r20, r24
     bb2:	4f 21       	and	r20, r15
     bb4:	60 2f       	mov	r22, r16
     bb6:	8d 2f       	mov	r24, r29
     bb8:	63 de       	rcall	.-826    	; 0x880 <gfx_mono_st7565r_put_byte>
     bba:	c1 50       	subi	r28, 0x01	; 1
     bbc:	a1 f7       	brne	.-24     	; 0xba6 <gfx_mono_generic_draw_horizontal_line+0x92>
     bbe:	0f c0       	rjmp	.+30     	; 0xbde <gfx_mono_generic_draw_horizontal_line+0xca>
     bc0:	c4 2f       	mov	r28, r20
     bc2:	1f ef       	ldi	r17, 0xFF	; 255
     bc4:	18 0f       	add	r17, r24
     bc6:	01 2f       	mov	r16, r17
     bc8:	0c 0f       	add	r16, r28
     bca:	60 2f       	mov	r22, r16
     bcc:	8d 2f       	mov	r24, r29
     bce:	7f df       	rcall	.-258    	; 0xace <gfx_mono_st7565r_get_byte>
     bd0:	48 2f       	mov	r20, r24
     bd2:	4f 25       	eor	r20, r15
     bd4:	60 2f       	mov	r22, r16
     bd6:	8d 2f       	mov	r24, r29
     bd8:	53 de       	rcall	.-858    	; 0x880 <gfx_mono_st7565r_put_byte>
     bda:	c1 50       	subi	r28, 0x01	; 1
     bdc:	a1 f7       	brne	.-24     	; 0xbc6 <gfx_mono_generic_draw_horizontal_line+0xb2>
     bde:	df 91       	pop	r29
     be0:	cf 91       	pop	r28
     be2:	1f 91       	pop	r17
     be4:	0f 91       	pop	r16
     be6:	ff 90       	pop	r15
     be8:	08 95       	ret

00000bea <gfx_mono_generic_draw_filled_rect>:
 * \param  color       Pixel operation of the line
 */
void gfx_mono_generic_draw_filled_rect(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t width, gfx_coord_t height,
		enum gfx_mono_color color)
{
     bea:	ff 92       	push	r15
     bec:	0f 93       	push	r16
     bee:	1f 93       	push	r17
     bf0:	cf 93       	push	r28
     bf2:	df 93       	push	r29
	if (height == 0) {
     bf4:	22 23       	and	r18, r18
     bf6:	69 f0       	breq	.+26     	; 0xc12 <gfx_mono_generic_draw_filled_rect+0x28>
     bf8:	c2 2f       	mov	r28, r18
     bfa:	f4 2e       	mov	r15, r20
     bfc:	18 2f       	mov	r17, r24
     bfe:	df ef       	ldi	r29, 0xFF	; 255
     c00:	d6 0f       	add	r29, r22
     c02:	6d 2f       	mov	r22, r29
     c04:	6c 0f       	add	r22, r28
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
     c06:	20 2f       	mov	r18, r16
     c08:	4f 2d       	mov	r20, r15
     c0a:	81 2f       	mov	r24, r17
     c0c:	83 df       	rcall	.-250    	; 0xb14 <gfx_mono_generic_draw_horizontal_line>
     c0e:	c1 50       	subi	r28, 0x01	; 1
	if (height == 0) {
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
     c10:	c1 f7       	brne	.-16     	; 0xc02 <gfx_mono_generic_draw_filled_rect+0x18>
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
	}
}
     c12:	df 91       	pop	r29
     c14:	cf 91       	pop	r28
     c16:	1f 91       	pop	r17
     c18:	0f 91       	pop	r16
     c1a:	ff 90       	pop	r15
     c1c:	08 95       	ret

00000c1e <gfx_mono_draw_char>:
 * \param y        Y coordinate on screen.
 * \param font     Font to draw character in
 */
void gfx_mono_draw_char(const char c, const gfx_coord_t x, const gfx_coord_t y,
		const struct font *font)
{
     c1e:	af 92       	push	r10
     c20:	bf 92       	push	r11
     c22:	cf 92       	push	r12
     c24:	df 92       	push	r13
     c26:	ef 92       	push	r14
     c28:	ff 92       	push	r15
     c2a:	0f 93       	push	r16
     c2c:	1f 93       	push	r17
     c2e:	cf 93       	push	r28
     c30:	df 93       	push	r29
     c32:	c8 2f       	mov	r28, r24
     c34:	e6 2e       	mov	r14, r22
     c36:	b4 2e       	mov	r11, r20
     c38:	69 01       	movw	r12, r18
	gfx_mono_draw_filled_rect(x, y, font->width, font->height,
     c3a:	00 e0       	ldi	r16, 0x00	; 0
     c3c:	f9 01       	movw	r30, r18
     c3e:	24 81       	ldd	r18, Z+4	; 0x04
     c40:	43 81       	ldd	r20, Z+3	; 0x03
     c42:	6b 2d       	mov	r22, r11
     c44:	8e 2d       	mov	r24, r14
     c46:	d1 df       	rcall	.-94     	; 0xbea <gfx_mono_generic_draw_filled_rect>
			GFX_PIXEL_CLR);

	switch (font->type) {
     c48:	f6 01       	movw	r30, r12
     c4a:	80 81       	ld	r24, Z
     c4c:	81 11       	cpse	r24, r1
     c4e:	39 c0       	rjmp	.+114    	; 0xcc2 <gfx_mono_draw_char+0xa4>
	Assert(font != NULL);

	gfx_coord_t inc_x = x;
	gfx_coord_t inc_y = y;

	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
     c50:	83 81       	ldd	r24, Z+3	; 0x03
     c52:	28 2f       	mov	r18, r24
     c54:	26 95       	lsr	r18
     c56:	26 95       	lsr	r18
     c58:	26 95       	lsr	r18
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
     c5a:	87 70       	andi	r24, 0x07	; 7
     c5c:	09 f0       	breq	.+2      	; 0xc60 <gfx_mono_draw_char+0x42>
		char_row_size++;
     c5e:	2f 5f       	subi	r18, 0xFF	; 255
	}

	glyph_data_offset = char_row_size * font->height *
     c60:	f6 01       	movw	r30, r12
     c62:	a4 80       	ldd	r10, Z+4	; 0x04
     c64:	2a 9d       	mul	r18, r10
     c66:	90 01       	movw	r18, r0
     c68:	11 24       	eor	r1, r1
			((uint8_t)ch - font->first_char);
     c6a:	8c 2f       	mov	r24, r28
     c6c:	90 e0       	ldi	r25, 0x00	; 0
     c6e:	45 81       	ldd	r20, Z+5	; 0x05
     c70:	84 1b       	sub	r24, r20
     c72:	91 09       	sbc	r25, r1
	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
		char_row_size++;
	}

	glyph_data_offset = char_row_size * font->height *
     c74:	28 9f       	mul	r18, r24
     c76:	a0 01       	movw	r20, r0
     c78:	29 9f       	mul	r18, r25
     c7a:	50 0d       	add	r21, r0
     c7c:	38 9f       	mul	r19, r24
     c7e:	50 0d       	add	r21, r0
     c80:	11 24       	eor	r1, r1
			((uint8_t)ch - font->first_char);
	glyph_data = font->data.progmem + glyph_data_offset;
     c82:	01 81       	ldd	r16, Z+1	; 0x01
     c84:	12 81       	ldd	r17, Z+2	; 0x02
     c86:	04 0f       	add	r16, r20
     c88:	15 1f       	adc	r17, r21
	rows_left = font->height;

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;
     c8a:	f6 01       	movw	r30, r12
     c8c:	f3 80       	ldd	r15, Z+3	; 0x03

		for (i = 0; i < pixelsToDraw; i++) {
     c8e:	ff 20       	and	r15, r15
     c90:	a1 f0       	breq	.+40     	; 0xcba <gfx_mono_draw_char+0x9c>
     c92:	d0 e0       	ldi	r29, 0x00	; 0
     c94:	c0 e0       	ldi	r28, 0x00	; 0
     c96:	8c 2f       	mov	r24, r28
     c98:	8e 0d       	add	r24, r14
			if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
     c9a:	9c 2f       	mov	r25, r28
     c9c:	97 70       	andi	r25, 0x07	; 7
     c9e:	21 f4       	brne	.+8      	; 0xca8 <gfx_mono_draw_char+0x8a>
				glyph_byte = PROGMEM_READ_BYTE(glyph_data);
     ca0:	f8 01       	movw	r30, r16
     ca2:	d4 91       	lpm	r29, Z
				glyph_data++;
     ca4:	0f 5f       	subi	r16, 0xFF	; 255
     ca6:	1f 4f       	sbci	r17, 0xFF	; 255
			}

			if ((glyph_byte & 0x80)) {
     ca8:	dd 23       	and	r29, r29
     caa:	1c f4       	brge	.+6      	; 0xcb2 <gfx_mono_draw_char+0x94>
				gfx_mono_draw_pixel(inc_x, inc_y,
     cac:	41 e0       	ldi	r20, 0x01	; 1
     cae:	6b 2d       	mov	r22, r11
     cb0:	d0 de       	rcall	.-608    	; 0xa52 <gfx_mono_st7565r_draw_pixel>
						GFX_PIXEL_SET);
			}

			inc_x += 1;
			glyph_byte <<= 1;
     cb2:	dd 0f       	add	r29, r29

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
     cb4:	cf 5f       	subi	r28, 0xFF	; 255
     cb6:	cf 11       	cpse	r28, r15
     cb8:	ee cf       	rjmp	.-36     	; 0xc96 <gfx_mono_draw_char+0x78>

			inc_x += 1;
			glyph_byte <<= 1;
		}

		inc_y += 1;
     cba:	b3 94       	inc	r11
		inc_x = x;
		rows_left--;
     cbc:	aa 94       	dec	r10
	} while (rows_left > 0);
     cbe:	a1 10       	cpse	r10, r1
     cc0:	e4 cf       	rjmp	.-56     	; 0xc8a <gfx_mono_draw_char+0x6c>
	default:
		/* Unsupported mode, call assert */
		Assert(false);
		break;
	}
}
     cc2:	df 91       	pop	r29
     cc4:	cf 91       	pop	r28
     cc6:	1f 91       	pop	r17
     cc8:	0f 91       	pop	r16
     cca:	ff 90       	pop	r15
     ccc:	ef 90       	pop	r14
     cce:	df 90       	pop	r13
     cd0:	cf 90       	pop	r12
     cd2:	bf 90       	pop	r11
     cd4:	af 90       	pop	r10
     cd6:	08 95       	ret

00000cd8 <gfx_mono_draw_string>:
 * \param y         Y coordinate on screen.
 * \param font      Font to draw string in
 */
void gfx_mono_draw_string(const char *str, gfx_coord_t x, gfx_coord_t y,
		const struct font *font)
{
     cd8:	df 92       	push	r13
     cda:	ef 92       	push	r14
     cdc:	ff 92       	push	r15
     cde:	0f 93       	push	r16
     ce0:	1f 93       	push	r17
     ce2:	cf 93       	push	r28
     ce4:	df 93       	push	r29
     ce6:	04 2f       	mov	r16, r20
     ce8:	79 01       	movw	r14, r18
     cea:	ec 01       	movw	r28, r24
     cec:	16 2f       	mov	r17, r22

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
     cee:	d6 2e       	mov	r13, r22
	Assert(font != NULL);

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
     cf0:	89 91       	ld	r24, Y+
     cf2:	8a 30       	cpi	r24, 0x0A	; 10
     cf4:	31 f4       	brne	.+12     	; 0xd02 <gfx_mono_draw_string+0x2a>
     cf6:	f7 01       	movw	r30, r14
     cf8:	84 81       	ldd	r24, Z+4	; 0x04
     cfa:	8f 5f       	subi	r24, 0xFF	; 255
			x = start_of_string_position_x;
			y += font->height + 1;
     cfc:	08 0f       	add	r16, r24

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
     cfe:	1d 2d       	mov	r17, r13
     d00:	09 c0       	rjmp	.+18     	; 0xd14 <gfx_mono_draw_string+0x3c>
			y += font->height + 1;
		} else if (*str == '\r') {
     d02:	8d 30       	cpi	r24, 0x0D	; 13
     d04:	39 f0       	breq	.+14     	; 0xd14 <gfx_mono_draw_string+0x3c>
			/* Skip '\r' characters. */
		} else {
			gfx_mono_draw_char(*str, x, y, font);
     d06:	97 01       	movw	r18, r14
     d08:	40 2f       	mov	r20, r16
     d0a:	61 2f       	mov	r22, r17
     d0c:	88 df       	rcall	.-240    	; 0xc1e <gfx_mono_draw_char>
			x += font->width;
     d0e:	f7 01       	movw	r30, r14
     d10:	83 81       	ldd	r24, Z+3	; 0x03
     d12:	18 0f       	add	r17, r24
		}
	} while (*(++str));
     d14:	88 81       	ld	r24, Y
     d16:	81 11       	cpse	r24, r1
     d18:	eb cf       	rjmp	.-42     	; 0xcf0 <gfx_mono_draw_string+0x18>
}
     d1a:	df 91       	pop	r29
     d1c:	cf 91       	pop	r28
     d1e:	1f 91       	pop	r17
     d20:	0f 91       	pop	r16
     d22:	ff 90       	pop	r15
     d24:	ef 90       	pop	r14
     d26:	df 90       	pop	r13
     d28:	08 95       	ret

00000d2a <usart_spi_init>:
		*data = usart_spi_transmit(usart, CONFIG_USART_SPI_DUMMY);
		len--;
		data++;
 	}
	return STATUS_OK;
}
     d2a:	80 3a       	cpi	r24, 0xA0	; 160
     d2c:	28 e0       	ldi	r18, 0x08	; 8
     d2e:	92 07       	cpc	r25, r18
     d30:	21 f4       	brne	.+8      	; 0xd3a <usart_spi_init+0x10>
     d32:	60 e1       	ldi	r22, 0x10	; 16
     d34:	83 e0       	ldi	r24, 0x03	; 3
     d36:	8d cd       	rjmp	.-1254   	; 0x852 <sysclk_enable_module>
     d38:	08 95       	ret
     d3a:	80 3b       	cpi	r24, 0xB0	; 176
     d3c:	28 e0       	ldi	r18, 0x08	; 8
     d3e:	92 07       	cpc	r25, r18
     d40:	21 f4       	brne	.+8      	; 0xd4a <usart_spi_init+0x20>
     d42:	60 e2       	ldi	r22, 0x20	; 32
     d44:	83 e0       	ldi	r24, 0x03	; 3
     d46:	85 cd       	rjmp	.-1270   	; 0x852 <sysclk_enable_module>
     d48:	08 95       	ret
     d4a:	80 3a       	cpi	r24, 0xA0	; 160
     d4c:	29 e0       	ldi	r18, 0x09	; 9
     d4e:	92 07       	cpc	r25, r18
     d50:	21 f4       	brne	.+8      	; 0xd5a <usart_spi_init+0x30>
     d52:	60 e1       	ldi	r22, 0x10	; 16
     d54:	84 e0       	ldi	r24, 0x04	; 4
     d56:	7d cd       	rjmp	.-1286   	; 0x852 <sysclk_enable_module>
     d58:	08 95       	ret
     d5a:	80 3b       	cpi	r24, 0xB0	; 176
     d5c:	29 e0       	ldi	r18, 0x09	; 9
     d5e:	92 07       	cpc	r25, r18
     d60:	21 f4       	brne	.+8      	; 0xd6a <usart_spi_init+0x40>
     d62:	60 e2       	ldi	r22, 0x20	; 32
     d64:	84 e0       	ldi	r24, 0x04	; 4
     d66:	75 cd       	rjmp	.-1302   	; 0x852 <sysclk_enable_module>
     d68:	08 95       	ret
     d6a:	80 3a       	cpi	r24, 0xA0	; 160
     d6c:	2a e0       	ldi	r18, 0x0A	; 10
     d6e:	92 07       	cpc	r25, r18
     d70:	21 f4       	brne	.+8      	; 0xd7a <usart_spi_init+0x50>
     d72:	60 e1       	ldi	r22, 0x10	; 16
     d74:	85 e0       	ldi	r24, 0x05	; 5
     d76:	6d cd       	rjmp	.-1318   	; 0x852 <sysclk_enable_module>
     d78:	08 95       	ret
     d7a:	80 3a       	cpi	r24, 0xA0	; 160
     d7c:	9b 40       	sbci	r25, 0x0B	; 11
     d7e:	19 f4       	brne	.+6      	; 0xd86 <usart_spi_init+0x5c>
     d80:	60 e1       	ldi	r22, 0x10	; 16
     d82:	86 e0       	ldi	r24, 0x06	; 6
     d84:	66 cd       	rjmp	.-1332   	; 0x852 <sysclk_enable_module>
     d86:	08 95       	ret

00000d88 <usart_spi_setup_device>:
     d88:	0f 93       	push	r16
     d8a:	1f 93       	push	r17
     d8c:	cf 93       	push	r28
     d8e:	df 93       	push	r29
     d90:	00 d0       	rcall	.+0      	; 0xd92 <usart_spi_setup_device+0xa>
     d92:	00 d0       	rcall	.+0      	; 0xd94 <usart_spi_setup_device+0xc>
     d94:	cd b7       	in	r28, 0x3d	; 61
     d96:	de b7       	in	r29, 0x3e	; 62
     d98:	09 83       	std	Y+1, r16	; 0x01
     d9a:	1a 83       	std	Y+2, r17	; 0x02
     d9c:	2b 83       	std	Y+3, r18	; 0x03
     d9e:	3c 83       	std	Y+4, r19	; 0x04
     da0:	4d 83       	std	Y+5, r20	; 0x05
     da2:	1e 82       	std	Y+6, r1	; 0x06
     da4:	be 01       	movw	r22, r28
     da6:	6f 5f       	subi	r22, 0xFF	; 255
     da8:	7f 4f       	sbci	r23, 0xFF	; 255
     daa:	62 d5       	rcall	.+2756   	; 0x1870 <usart_init_spi>
     dac:	26 96       	adiw	r28, 0x06	; 6
     dae:	cd bf       	out	0x3d, r28	; 61
     db0:	de bf       	out	0x3e, r29	; 62
     db2:	df 91       	pop	r29
     db4:	cf 91       	pop	r28
     db6:	1f 91       	pop	r17
     db8:	0f 91       	pop	r16
     dba:	08 95       	ret

00000dbc <usart_spi_select_device>:

void usart_spi_select_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_low(device->id);
     dbc:	fb 01       	movw	r30, r22
     dbe:	80 81       	ld	r24, Z
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
     dc0:	e8 2f       	mov	r30, r24
     dc2:	e6 95       	lsr	r30
     dc4:	e6 95       	lsr	r30
     dc6:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
     dc8:	40 e2       	ldi	r20, 0x20	; 32
     dca:	e4 9f       	mul	r30, r20
     dcc:	f0 01       	movw	r30, r0
     dce:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
     dd0:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
     dd2:	87 70       	andi	r24, 0x07	; 7
     dd4:	21 e0       	ldi	r18, 0x01	; 1
     dd6:	30 e0       	ldi	r19, 0x00	; 0
     dd8:	a9 01       	movw	r20, r18
     dda:	02 c0       	rjmp	.+4      	; 0xde0 <usart_spi_select_device+0x24>
     ddc:	44 0f       	add	r20, r20
     dde:	55 1f       	adc	r21, r21
     de0:	8a 95       	dec	r24
     de2:	e2 f7       	brpl	.-8      	; 0xddc <usart_spi_select_device+0x20>
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     de4:	46 83       	std	Z+6, r20	; 0x06
     de6:	08 95       	ret

00000de8 <usart_spi_deselect_device>:
}

void usart_spi_deselect_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_high(device->id);
     de8:	fb 01       	movw	r30, r22
     dea:	80 81       	ld	r24, Z
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
     dec:	e8 2f       	mov	r30, r24
     dee:	e6 95       	lsr	r30
     df0:	e6 95       	lsr	r30
     df2:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
     df4:	40 e2       	ldi	r20, 0x20	; 32
     df6:	e4 9f       	mul	r30, r20
     df8:	f0 01       	movw	r30, r0
     dfa:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
     dfc:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
     dfe:	87 70       	andi	r24, 0x07	; 7
     e00:	21 e0       	ldi	r18, 0x01	; 1
     e02:	30 e0       	ldi	r19, 0x00	; 0
     e04:	a9 01       	movw	r20, r18
     e06:	02 c0       	rjmp	.+4      	; 0xe0c <usart_spi_deselect_device+0x24>
     e08:	44 0f       	add	r20, r20
     e0a:	55 1f       	adc	r21, r21
     e0c:	8a 95       	dec	r24
     e0e:	e2 f7       	brpl	.-8      	; 0xe08 <usart_spi_deselect_device+0x20>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     e10:	45 83       	std	Z+5, r20	; 0x05
     e12:	08 95       	ret

00000e14 <adc_enable_clock>:
void adc_enable_clock(ADC_t *adc);

void adc_enable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
     e14:	81 15       	cp	r24, r1
     e16:	22 e0       	ldi	r18, 0x02	; 2
     e18:	92 07       	cpc	r25, r18
     e1a:	61 f4       	brne	.+24     	; 0xe34 <adc_enable_clock+0x20>
		Assert(adca_enable_count < 0xff);
		if (!adca_enable_count++) {
     e1c:	80 91 61 22 	lds	r24, 0x2261	; 0x802261 <adca_enable_count>
     e20:	91 e0       	ldi	r25, 0x01	; 1
     e22:	98 0f       	add	r25, r24
     e24:	90 93 61 22 	sts	0x2261, r25	; 0x802261 <adca_enable_count>
     e28:	81 11       	cpse	r24, r1
     e2a:	12 c0       	rjmp	.+36     	; 0xe50 <adc_enable_clock+0x3c>
			sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
     e2c:	62 e0       	ldi	r22, 0x02	; 2
     e2e:	81 e0       	ldi	r24, 0x01	; 1
     e30:	10 cd       	rjmp	.-1504   	; 0x852 <sysclk_enable_module>
     e32:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
     e34:	80 34       	cpi	r24, 0x40	; 64
     e36:	92 40       	sbci	r25, 0x02	; 2
     e38:	59 f4       	brne	.+22     	; 0xe50 <adc_enable_clock+0x3c>
		Assert(adcb_enable_count < 0xff);
		if (!adcb_enable_count++) {
     e3a:	80 91 60 22 	lds	r24, 0x2260	; 0x802260 <adcb_enable_count>
     e3e:	91 e0       	ldi	r25, 0x01	; 1
     e40:	98 0f       	add	r25, r24
     e42:	90 93 60 22 	sts	0x2260, r25	; 0x802260 <adcb_enable_count>
     e46:	81 11       	cpse	r24, r1
     e48:	03 c0       	rjmp	.+6      	; 0xe50 <adc_enable_clock+0x3c>
			sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
     e4a:	62 e0       	ldi	r22, 0x02	; 2
     e4c:	82 e0       	ldi	r24, 0x02	; 2
     e4e:	01 cd       	rjmp	.-1534   	; 0x852 <sysclk_enable_module>
     e50:	08 95       	ret

00000e52 <adc_disable_clock>:
void adc_disable_clock(ADC_t *adc);

void adc_disable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
     e52:	81 15       	cp	r24, r1
     e54:	22 e0       	ldi	r18, 0x02	; 2
     e56:	92 07       	cpc	r25, r18
     e58:	59 f4       	brne	.+22     	; 0xe70 <adc_disable_clock+0x1e>
		Assert(adca_enable_count);
		if (!--adca_enable_count) {
     e5a:	80 91 61 22 	lds	r24, 0x2261	; 0x802261 <adca_enable_count>
     e5e:	81 50       	subi	r24, 0x01	; 1
     e60:	80 93 61 22 	sts	0x2261, r24	; 0x802261 <adca_enable_count>
     e64:	81 11       	cpse	r24, r1
     e66:	11 c0       	rjmp	.+34     	; 0xe8a <adc_disable_clock+0x38>
			sysclk_disable_module(SYSCLK_PORT_A, SYSCLK_ADC);
     e68:	62 e0       	ldi	r22, 0x02	; 2
     e6a:	81 e0       	ldi	r24, 0x01	; 1
     e6c:	fe cc       	rjmp	.-1540   	; 0x86a <sysclk_disable_module>
     e6e:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
     e70:	80 34       	cpi	r24, 0x40	; 64
     e72:	92 40       	sbci	r25, 0x02	; 2
     e74:	51 f4       	brne	.+20     	; 0xe8a <adc_disable_clock+0x38>
		Assert(adcb_enable_count);
		if (!--adcb_enable_count) {
     e76:	80 91 60 22 	lds	r24, 0x2260	; 0x802260 <adcb_enable_count>
     e7a:	81 50       	subi	r24, 0x01	; 1
     e7c:	80 93 60 22 	sts	0x2260, r24	; 0x802260 <adcb_enable_count>
     e80:	81 11       	cpse	r24, r1
     e82:	03 c0       	rjmp	.+6      	; 0xe8a <adc_disable_clock+0x38>
			sysclk_disable_module(SYSCLK_PORT_B, SYSCLK_ADC);
     e84:	62 e0       	ldi	r22, 0x02	; 2
     e86:	82 e0       	ldi	r24, 0x02	; 2
     e88:	f0 cc       	rjmp	.-1568   	; 0x86a <sysclk_disable_module>
     e8a:	08 95       	ret

00000e8c <adc_enable>:
 * a conversion. For most XMEGA devices the start-up time is specified
 * to be a maximum of 24 ADC clock cycles. Please verify the start-up time for
 * the device in use.
 */
void adc_enable(ADC_t *adc)
{
     e8c:	1f 93       	push	r17
     e8e:	cf 93       	push	r28
     e90:	df 93       	push	r29
     e92:	ec 01       	movw	r28, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     e94:	1f b7       	in	r17, 0x3f	; 63
	cpu_irq_disable();
     e96:	f8 94       	cli
	irqflags_t flags = cpu_irq_save();
	adc_enable_clock(adc);
     e98:	bd df       	rcall	.-134    	; 0xe14 <adc_enable_clock>
	adc->CTRLA |= ADC_ENABLE_bm;
     e9a:	88 81       	ld	r24, Y
     e9c:	81 60       	ori	r24, 0x01	; 1
     e9e:	88 83       	st	Y, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     ea0:	1f bf       	out	0x3f, r17	; 63

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     ea2:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
     ea4:	f8 94       	cli
	Assert(sleepmgr_locks[mode] < 0xff);

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
     ea6:	ef ea       	ldi	r30, 0xAF	; 175
     ea8:	f3 e2       	ldi	r31, 0x23	; 35
     eaa:	81 81       	ldd	r24, Z+1	; 0x01
     eac:	8f 5f       	subi	r24, 0xFF	; 255
     eae:	81 83       	std	Z+1, r24	; 0x01
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     eb0:	9f bf       	out	0x3f, r25	; 63
	cpu_irq_restore(flags);

	sleepmgr_lock_mode(SLEEPMGR_IDLE);
}
     eb2:	df 91       	pop	r29
     eb4:	cf 91       	pop	r28
     eb6:	1f 91       	pop	r17
     eb8:	08 95       	ret

00000eba <__vector_71>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH0_vect)
{
     eba:	1f 92       	push	r1
     ebc:	0f 92       	push	r0
     ebe:	0f b6       	in	r0, 0x3f	; 63
     ec0:	0f 92       	push	r0
     ec2:	11 24       	eor	r1, r1
     ec4:	0b b6       	in	r0, 0x3b	; 59
     ec6:	0f 92       	push	r0
     ec8:	2f 93       	push	r18
     eca:	3f 93       	push	r19
     ecc:	4f 93       	push	r20
     ece:	5f 93       	push	r21
     ed0:	6f 93       	push	r22
     ed2:	7f 93       	push	r23
     ed4:	8f 93       	push	r24
     ed6:	9f 93       	push	r25
     ed8:	af 93       	push	r26
     eda:	bf 93       	push	r27
     edc:	ef 93       	push	r30
     ede:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH0, adc_get_result(&ADCA, ADC_CH0));
     ee0:	40 91 24 02 	lds	r20, 0x0224	; 0x800224 <__TEXT_REGION_LENGTH__+0x700224>
     ee4:	50 91 25 02 	lds	r21, 0x0225	; 0x800225 <__TEXT_REGION_LENGTH__+0x700225>
     ee8:	e0 91 b7 23 	lds	r30, 0x23B7	; 0x8023b7 <adca_callback>
     eec:	f0 91 b8 23 	lds	r31, 0x23B8	; 0x8023b8 <adca_callback+0x1>
     ef0:	61 e0       	ldi	r22, 0x01	; 1
     ef2:	80 e0       	ldi	r24, 0x00	; 0
     ef4:	92 e0       	ldi	r25, 0x02	; 2
     ef6:	19 95       	eicall
}
     ef8:	ff 91       	pop	r31
     efa:	ef 91       	pop	r30
     efc:	bf 91       	pop	r27
     efe:	af 91       	pop	r26
     f00:	9f 91       	pop	r25
     f02:	8f 91       	pop	r24
     f04:	7f 91       	pop	r23
     f06:	6f 91       	pop	r22
     f08:	5f 91       	pop	r21
     f0a:	4f 91       	pop	r20
     f0c:	3f 91       	pop	r19
     f0e:	2f 91       	pop	r18
     f10:	0f 90       	pop	r0
     f12:	0b be       	out	0x3b, r0	; 59
     f14:	0f 90       	pop	r0
     f16:	0f be       	out	0x3f, r0	; 63
     f18:	0f 90       	pop	r0
     f1a:	1f 90       	pop	r1
     f1c:	18 95       	reti

00000f1e <__vector_72>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH1_vect)
{
     f1e:	1f 92       	push	r1
     f20:	0f 92       	push	r0
     f22:	0f b6       	in	r0, 0x3f	; 63
     f24:	0f 92       	push	r0
     f26:	11 24       	eor	r1, r1
     f28:	0b b6       	in	r0, 0x3b	; 59
     f2a:	0f 92       	push	r0
     f2c:	2f 93       	push	r18
     f2e:	3f 93       	push	r19
     f30:	4f 93       	push	r20
     f32:	5f 93       	push	r21
     f34:	6f 93       	push	r22
     f36:	7f 93       	push	r23
     f38:	8f 93       	push	r24
     f3a:	9f 93       	push	r25
     f3c:	af 93       	push	r26
     f3e:	bf 93       	push	r27
     f40:	ef 93       	push	r30
     f42:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH1, adc_get_result(&ADCA, ADC_CH1));
     f44:	40 91 2c 02 	lds	r20, 0x022C	; 0x80022c <__TEXT_REGION_LENGTH__+0x70022c>
     f48:	50 91 2d 02 	lds	r21, 0x022D	; 0x80022d <__TEXT_REGION_LENGTH__+0x70022d>
     f4c:	e0 91 b7 23 	lds	r30, 0x23B7	; 0x8023b7 <adca_callback>
     f50:	f0 91 b8 23 	lds	r31, 0x23B8	; 0x8023b8 <adca_callback+0x1>
     f54:	62 e0       	ldi	r22, 0x02	; 2
     f56:	80 e0       	ldi	r24, 0x00	; 0
     f58:	92 e0       	ldi	r25, 0x02	; 2
     f5a:	19 95       	eicall
}
     f5c:	ff 91       	pop	r31
     f5e:	ef 91       	pop	r30
     f60:	bf 91       	pop	r27
     f62:	af 91       	pop	r26
     f64:	9f 91       	pop	r25
     f66:	8f 91       	pop	r24
     f68:	7f 91       	pop	r23
     f6a:	6f 91       	pop	r22
     f6c:	5f 91       	pop	r21
     f6e:	4f 91       	pop	r20
     f70:	3f 91       	pop	r19
     f72:	2f 91       	pop	r18
     f74:	0f 90       	pop	r0
     f76:	0b be       	out	0x3b, r0	; 59
     f78:	0f 90       	pop	r0
     f7a:	0f be       	out	0x3f, r0	; 63
     f7c:	0f 90       	pop	r0
     f7e:	1f 90       	pop	r1
     f80:	18 95       	reti

00000f82 <__vector_73>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH2_vect)
{
     f82:	1f 92       	push	r1
     f84:	0f 92       	push	r0
     f86:	0f b6       	in	r0, 0x3f	; 63
     f88:	0f 92       	push	r0
     f8a:	11 24       	eor	r1, r1
     f8c:	0b b6       	in	r0, 0x3b	; 59
     f8e:	0f 92       	push	r0
     f90:	2f 93       	push	r18
     f92:	3f 93       	push	r19
     f94:	4f 93       	push	r20
     f96:	5f 93       	push	r21
     f98:	6f 93       	push	r22
     f9a:	7f 93       	push	r23
     f9c:	8f 93       	push	r24
     f9e:	9f 93       	push	r25
     fa0:	af 93       	push	r26
     fa2:	bf 93       	push	r27
     fa4:	ef 93       	push	r30
     fa6:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH2, adc_get_result(&ADCA, ADC_CH2));
     fa8:	40 91 34 02 	lds	r20, 0x0234	; 0x800234 <__TEXT_REGION_LENGTH__+0x700234>
     fac:	50 91 35 02 	lds	r21, 0x0235	; 0x800235 <__TEXT_REGION_LENGTH__+0x700235>
     fb0:	e0 91 b7 23 	lds	r30, 0x23B7	; 0x8023b7 <adca_callback>
     fb4:	f0 91 b8 23 	lds	r31, 0x23B8	; 0x8023b8 <adca_callback+0x1>
     fb8:	64 e0       	ldi	r22, 0x04	; 4
     fba:	80 e0       	ldi	r24, 0x00	; 0
     fbc:	92 e0       	ldi	r25, 0x02	; 2
     fbe:	19 95       	eicall
}
     fc0:	ff 91       	pop	r31
     fc2:	ef 91       	pop	r30
     fc4:	bf 91       	pop	r27
     fc6:	af 91       	pop	r26
     fc8:	9f 91       	pop	r25
     fca:	8f 91       	pop	r24
     fcc:	7f 91       	pop	r23
     fce:	6f 91       	pop	r22
     fd0:	5f 91       	pop	r21
     fd2:	4f 91       	pop	r20
     fd4:	3f 91       	pop	r19
     fd6:	2f 91       	pop	r18
     fd8:	0f 90       	pop	r0
     fda:	0b be       	out	0x3b, r0	; 59
     fdc:	0f 90       	pop	r0
     fde:	0f be       	out	0x3f, r0	; 63
     fe0:	0f 90       	pop	r0
     fe2:	1f 90       	pop	r1
     fe4:	18 95       	reti

00000fe6 <__vector_74>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH3_vect)
{
     fe6:	1f 92       	push	r1
     fe8:	0f 92       	push	r0
     fea:	0f b6       	in	r0, 0x3f	; 63
     fec:	0f 92       	push	r0
     fee:	11 24       	eor	r1, r1
     ff0:	0b b6       	in	r0, 0x3b	; 59
     ff2:	0f 92       	push	r0
     ff4:	2f 93       	push	r18
     ff6:	3f 93       	push	r19
     ff8:	4f 93       	push	r20
     ffa:	5f 93       	push	r21
     ffc:	6f 93       	push	r22
     ffe:	7f 93       	push	r23
    1000:	8f 93       	push	r24
    1002:	9f 93       	push	r25
    1004:	af 93       	push	r26
    1006:	bf 93       	push	r27
    1008:	ef 93       	push	r30
    100a:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH3, adc_get_result(&ADCA, ADC_CH3));
    100c:	40 91 3c 02 	lds	r20, 0x023C	; 0x80023c <__TEXT_REGION_LENGTH__+0x70023c>
    1010:	50 91 3d 02 	lds	r21, 0x023D	; 0x80023d <__TEXT_REGION_LENGTH__+0x70023d>
    1014:	e0 91 b7 23 	lds	r30, 0x23B7	; 0x8023b7 <adca_callback>
    1018:	f0 91 b8 23 	lds	r31, 0x23B8	; 0x8023b8 <adca_callback+0x1>
    101c:	68 e0       	ldi	r22, 0x08	; 8
    101e:	80 e0       	ldi	r24, 0x00	; 0
    1020:	92 e0       	ldi	r25, 0x02	; 2
    1022:	19 95       	eicall
}
    1024:	ff 91       	pop	r31
    1026:	ef 91       	pop	r30
    1028:	bf 91       	pop	r27
    102a:	af 91       	pop	r26
    102c:	9f 91       	pop	r25
    102e:	8f 91       	pop	r24
    1030:	7f 91       	pop	r23
    1032:	6f 91       	pop	r22
    1034:	5f 91       	pop	r21
    1036:	4f 91       	pop	r20
    1038:	3f 91       	pop	r19
    103a:	2f 91       	pop	r18
    103c:	0f 90       	pop	r0
    103e:	0b be       	out	0x3b, r0	; 59
    1040:	0f 90       	pop	r0
    1042:	0f be       	out	0x3f, r0	; 63
    1044:	0f 90       	pop	r0
    1046:	1f 90       	pop	r1
    1048:	18 95       	reti

0000104a <__vector_39>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH0_vect)
{
    104a:	1f 92       	push	r1
    104c:	0f 92       	push	r0
    104e:	0f b6       	in	r0, 0x3f	; 63
    1050:	0f 92       	push	r0
    1052:	11 24       	eor	r1, r1
    1054:	0b b6       	in	r0, 0x3b	; 59
    1056:	0f 92       	push	r0
    1058:	2f 93       	push	r18
    105a:	3f 93       	push	r19
    105c:	4f 93       	push	r20
    105e:	5f 93       	push	r21
    1060:	6f 93       	push	r22
    1062:	7f 93       	push	r23
    1064:	8f 93       	push	r24
    1066:	9f 93       	push	r25
    1068:	af 93       	push	r26
    106a:	bf 93       	push	r27
    106c:	ef 93       	push	r30
    106e:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH0, adc_get_result(&ADCB, ADC_CH0));
    1070:	40 91 64 02 	lds	r20, 0x0264	; 0x800264 <__TEXT_REGION_LENGTH__+0x700264>
    1074:	50 91 65 02 	lds	r21, 0x0265	; 0x800265 <__TEXT_REGION_LENGTH__+0x700265>
    1078:	e0 91 b5 23 	lds	r30, 0x23B5	; 0x8023b5 <adcb_callback>
    107c:	f0 91 b6 23 	lds	r31, 0x23B6	; 0x8023b6 <adcb_callback+0x1>
    1080:	61 e0       	ldi	r22, 0x01	; 1
    1082:	80 e4       	ldi	r24, 0x40	; 64
    1084:	92 e0       	ldi	r25, 0x02	; 2
    1086:	19 95       	eicall
}
    1088:	ff 91       	pop	r31
    108a:	ef 91       	pop	r30
    108c:	bf 91       	pop	r27
    108e:	af 91       	pop	r26
    1090:	9f 91       	pop	r25
    1092:	8f 91       	pop	r24
    1094:	7f 91       	pop	r23
    1096:	6f 91       	pop	r22
    1098:	5f 91       	pop	r21
    109a:	4f 91       	pop	r20
    109c:	3f 91       	pop	r19
    109e:	2f 91       	pop	r18
    10a0:	0f 90       	pop	r0
    10a2:	0b be       	out	0x3b, r0	; 59
    10a4:	0f 90       	pop	r0
    10a6:	0f be       	out	0x3f, r0	; 63
    10a8:	0f 90       	pop	r0
    10aa:	1f 90       	pop	r1
    10ac:	18 95       	reti

000010ae <__vector_40>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH1_vect)
{
    10ae:	1f 92       	push	r1
    10b0:	0f 92       	push	r0
    10b2:	0f b6       	in	r0, 0x3f	; 63
    10b4:	0f 92       	push	r0
    10b6:	11 24       	eor	r1, r1
    10b8:	0b b6       	in	r0, 0x3b	; 59
    10ba:	0f 92       	push	r0
    10bc:	2f 93       	push	r18
    10be:	3f 93       	push	r19
    10c0:	4f 93       	push	r20
    10c2:	5f 93       	push	r21
    10c4:	6f 93       	push	r22
    10c6:	7f 93       	push	r23
    10c8:	8f 93       	push	r24
    10ca:	9f 93       	push	r25
    10cc:	af 93       	push	r26
    10ce:	bf 93       	push	r27
    10d0:	ef 93       	push	r30
    10d2:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH1, adc_get_result(&ADCB, ADC_CH1));
    10d4:	40 91 6c 02 	lds	r20, 0x026C	; 0x80026c <__TEXT_REGION_LENGTH__+0x70026c>
    10d8:	50 91 6d 02 	lds	r21, 0x026D	; 0x80026d <__TEXT_REGION_LENGTH__+0x70026d>
    10dc:	e0 91 b5 23 	lds	r30, 0x23B5	; 0x8023b5 <adcb_callback>
    10e0:	f0 91 b6 23 	lds	r31, 0x23B6	; 0x8023b6 <adcb_callback+0x1>
    10e4:	62 e0       	ldi	r22, 0x02	; 2
    10e6:	80 e4       	ldi	r24, 0x40	; 64
    10e8:	92 e0       	ldi	r25, 0x02	; 2
    10ea:	19 95       	eicall
}
    10ec:	ff 91       	pop	r31
    10ee:	ef 91       	pop	r30
    10f0:	bf 91       	pop	r27
    10f2:	af 91       	pop	r26
    10f4:	9f 91       	pop	r25
    10f6:	8f 91       	pop	r24
    10f8:	7f 91       	pop	r23
    10fa:	6f 91       	pop	r22
    10fc:	5f 91       	pop	r21
    10fe:	4f 91       	pop	r20
    1100:	3f 91       	pop	r19
    1102:	2f 91       	pop	r18
    1104:	0f 90       	pop	r0
    1106:	0b be       	out	0x3b, r0	; 59
    1108:	0f 90       	pop	r0
    110a:	0f be       	out	0x3f, r0	; 63
    110c:	0f 90       	pop	r0
    110e:	1f 90       	pop	r1
    1110:	18 95       	reti

00001112 <__vector_41>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH2_vect)
{
    1112:	1f 92       	push	r1
    1114:	0f 92       	push	r0
    1116:	0f b6       	in	r0, 0x3f	; 63
    1118:	0f 92       	push	r0
    111a:	11 24       	eor	r1, r1
    111c:	0b b6       	in	r0, 0x3b	; 59
    111e:	0f 92       	push	r0
    1120:	2f 93       	push	r18
    1122:	3f 93       	push	r19
    1124:	4f 93       	push	r20
    1126:	5f 93       	push	r21
    1128:	6f 93       	push	r22
    112a:	7f 93       	push	r23
    112c:	8f 93       	push	r24
    112e:	9f 93       	push	r25
    1130:	af 93       	push	r26
    1132:	bf 93       	push	r27
    1134:	ef 93       	push	r30
    1136:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH2, adc_get_result(&ADCB, ADC_CH2));
    1138:	40 91 74 02 	lds	r20, 0x0274	; 0x800274 <__TEXT_REGION_LENGTH__+0x700274>
    113c:	50 91 75 02 	lds	r21, 0x0275	; 0x800275 <__TEXT_REGION_LENGTH__+0x700275>
    1140:	e0 91 b5 23 	lds	r30, 0x23B5	; 0x8023b5 <adcb_callback>
    1144:	f0 91 b6 23 	lds	r31, 0x23B6	; 0x8023b6 <adcb_callback+0x1>
    1148:	64 e0       	ldi	r22, 0x04	; 4
    114a:	80 e4       	ldi	r24, 0x40	; 64
    114c:	92 e0       	ldi	r25, 0x02	; 2
    114e:	19 95       	eicall
}
    1150:	ff 91       	pop	r31
    1152:	ef 91       	pop	r30
    1154:	bf 91       	pop	r27
    1156:	af 91       	pop	r26
    1158:	9f 91       	pop	r25
    115a:	8f 91       	pop	r24
    115c:	7f 91       	pop	r23
    115e:	6f 91       	pop	r22
    1160:	5f 91       	pop	r21
    1162:	4f 91       	pop	r20
    1164:	3f 91       	pop	r19
    1166:	2f 91       	pop	r18
    1168:	0f 90       	pop	r0
    116a:	0b be       	out	0x3b, r0	; 59
    116c:	0f 90       	pop	r0
    116e:	0f be       	out	0x3f, r0	; 63
    1170:	0f 90       	pop	r0
    1172:	1f 90       	pop	r1
    1174:	18 95       	reti

00001176 <__vector_42>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH3_vect)
{
    1176:	1f 92       	push	r1
    1178:	0f 92       	push	r0
    117a:	0f b6       	in	r0, 0x3f	; 63
    117c:	0f 92       	push	r0
    117e:	11 24       	eor	r1, r1
    1180:	0b b6       	in	r0, 0x3b	; 59
    1182:	0f 92       	push	r0
    1184:	2f 93       	push	r18
    1186:	3f 93       	push	r19
    1188:	4f 93       	push	r20
    118a:	5f 93       	push	r21
    118c:	6f 93       	push	r22
    118e:	7f 93       	push	r23
    1190:	8f 93       	push	r24
    1192:	9f 93       	push	r25
    1194:	af 93       	push	r26
    1196:	bf 93       	push	r27
    1198:	ef 93       	push	r30
    119a:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH3, adc_get_result(&ADCB, ADC_CH3));
    119c:	40 91 7c 02 	lds	r20, 0x027C	; 0x80027c <__TEXT_REGION_LENGTH__+0x70027c>
    11a0:	50 91 7d 02 	lds	r21, 0x027D	; 0x80027d <__TEXT_REGION_LENGTH__+0x70027d>
    11a4:	e0 91 b5 23 	lds	r30, 0x23B5	; 0x8023b5 <adcb_callback>
    11a8:	f0 91 b6 23 	lds	r31, 0x23B6	; 0x8023b6 <adcb_callback+0x1>
    11ac:	68 e0       	ldi	r22, 0x08	; 8
    11ae:	80 e4       	ldi	r24, 0x40	; 64
    11b0:	92 e0       	ldi	r25, 0x02	; 2
    11b2:	19 95       	eicall
}
    11b4:	ff 91       	pop	r31
    11b6:	ef 91       	pop	r30
    11b8:	bf 91       	pop	r27
    11ba:	af 91       	pop	r26
    11bc:	9f 91       	pop	r25
    11be:	8f 91       	pop	r24
    11c0:	7f 91       	pop	r23
    11c2:	6f 91       	pop	r22
    11c4:	5f 91       	pop	r21
    11c6:	4f 91       	pop	r20
    11c8:	3f 91       	pop	r19
    11ca:	2f 91       	pop	r18
    11cc:	0f 90       	pop	r0
    11ce:	0b be       	out	0x3b, r0	; 59
    11d0:	0f 90       	pop	r0
    11d2:	0f be       	out	0x3f, r0	; 63
    11d4:	0f 90       	pop	r0
    11d6:	1f 90       	pop	r1
    11d8:	18 95       	reti

000011da <adc_write_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_write_configuration(ADC_t *adc, const struct adc_config *conf)
{
    11da:	df 92       	push	r13
    11dc:	ef 92       	push	r14
    11de:	ff 92       	push	r15
    11e0:	0f 93       	push	r16
    11e2:	1f 93       	push	r17
    11e4:	cf 93       	push	r28
    11e6:	df 93       	push	r29
    11e8:	ec 01       	movw	r28, r24
    11ea:	8b 01       	movw	r16, r22
	uint16_t cal;
	uint8_t enable;
	irqflags_t flags;

#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)&ADCA) {
    11ec:	c1 15       	cp	r28, r1
    11ee:	22 e0       	ldi	r18, 0x02	; 2
    11f0:	d2 07       	cpc	r29, r18
    11f2:	71 f4       	brne	.+28     	; 0x1210 <adc_write_configuration+0x36>
 *
 * \param address Byte offset into the signature row
 */
static inline uint8_t nvm_read_production_signature_row(uint8_t address)
{
	return nvm_read_byte(NVM_CMD_READ_CALIB_ROW_gc, address);
    11f4:	61 e2       	ldi	r22, 0x21	; 33
    11f6:	70 e0       	ldi	r23, 0x00	; 0
    11f8:	82 e0       	ldi	r24, 0x02	; 2
    11fa:	d4 d0       	rcall	.+424    	; 0x13a4 <nvm_read_byte>
	uint16_t data;

	switch (cal) {
#ifdef ADCA
	case ADC_CAL_ADCA:
		data = nvm_read_production_signature_row(ADCACAL1);
    11fc:	e8 2e       	mov	r14, r24
    11fe:	f1 2c       	mov	r15, r1
    1200:	60 e2       	ldi	r22, 0x20	; 32
    1202:	70 e0       	ldi	r23, 0x00	; 0
    1204:	82 e0       	ldi	r24, 0x02	; 2
    1206:	ce d0       	rcall	.+412    	; 0x13a4 <nvm_read_byte>
		data <<= 8;
    1208:	fe 2c       	mov	r15, r14
    120a:	ee 24       	eor	r14, r14
		data |= nvm_read_production_signature_row(ADCACAL0);
    120c:	e8 2a       	or	r14, r24
    120e:	10 c0       	rjmp	.+32     	; 0x1230 <adc_write_configuration+0x56>
		cal = adc_get_calibration_data(ADC_CAL_ADCA);
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)&ADCB) {
    1210:	80 34       	cpi	r24, 0x40	; 64
    1212:	92 40       	sbci	r25, 0x02	; 2
    1214:	51 f5       	brne	.+84     	; 0x126a <adc_write_configuration+0x90>
    1216:	65 e2       	ldi	r22, 0x25	; 37
    1218:	70 e0       	ldi	r23, 0x00	; 0
    121a:	82 e0       	ldi	r24, 0x02	; 2
    121c:	c3 d0       	rcall	.+390    	; 0x13a4 <nvm_read_byte>
		break;
#endif

#ifdef ADCB
	case ADC_CAL_ADCB:
		data = nvm_read_production_signature_row(ADCBCAL1);
    121e:	e8 2e       	mov	r14, r24
    1220:	f1 2c       	mov	r15, r1
    1222:	64 e2       	ldi	r22, 0x24	; 36
    1224:	70 e0       	ldi	r23, 0x00	; 0
    1226:	82 e0       	ldi	r24, 0x02	; 2
    1228:	bd d0       	rcall	.+378    	; 0x13a4 <nvm_read_byte>
		data <<= 8;
    122a:	fe 2c       	mov	r15, r14
    122c:	ee 24       	eor	r14, r14
		data |= nvm_read_production_signature_row(ADCBCAL0);
    122e:	e8 2a       	or	r14, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1230:	df b6       	in	r13, 0x3f	; 63
	cpu_irq_disable();
    1232:	f8 94       	cli
		Assert(0);
		return;
	}

	flags = cpu_irq_save();
	adc_enable_clock(adc);
    1234:	ce 01       	movw	r24, r28
    1236:	ee dd       	rcall	.-1060   	; 0xe14 <adc_enable_clock>
	enable = adc->CTRLA & ADC_ENABLE_bm;
    1238:	88 81       	ld	r24, Y

	adc->CTRLA = ADC_FLUSH_bm;
    123a:	92 e0       	ldi	r25, 0x02	; 2
    123c:	98 83       	st	Y, r25
	adc->CAL = cal;
    123e:	ec 86       	std	Y+12, r14	; 0x0c
    1240:	fd 86       	std	Y+13, r15	; 0x0d
	adc->CMP = conf->cmp;
    1242:	f8 01       	movw	r30, r16
    1244:	25 81       	ldd	r18, Z+5	; 0x05
    1246:	36 81       	ldd	r19, Z+6	; 0x06
    1248:	28 8f       	std	Y+24, r18	; 0x18
    124a:	39 8f       	std	Y+25, r19	; 0x19
	adc->REFCTRL = conf->refctrl;
    124c:	92 81       	ldd	r25, Z+2	; 0x02
    124e:	9a 83       	std	Y+2, r25	; 0x02
	adc->PRESCALER = conf->prescaler;
    1250:	94 81       	ldd	r25, Z+4	; 0x04
    1252:	9c 83       	std	Y+4, r25	; 0x04
	adc->EVCTRL = conf->evctrl;
    1254:	93 81       	ldd	r25, Z+3	; 0x03
    1256:	9b 83       	std	Y+3, r25	; 0x03
	adc->CTRLB = conf->ctrlb;
    1258:	91 81       	ldd	r25, Z+1	; 0x01
    125a:	99 83       	std	Y+1, r25	; 0x01
		return;
	}

	flags = cpu_irq_save();
	adc_enable_clock(adc);
	enable = adc->CTRLA & ADC_ENABLE_bm;
    125c:	81 70       	andi	r24, 0x01	; 1
	adc->REFCTRL = conf->refctrl;
	adc->PRESCALER = conf->prescaler;
	adc->EVCTRL = conf->evctrl;
	adc->CTRLB = conf->ctrlb;

	adc->CTRLA = enable | conf->ctrla;
    125e:	90 81       	ld	r25, Z
    1260:	89 2b       	or	r24, r25
    1262:	88 83       	st	Y, r24

	adc_disable_clock(adc);
    1264:	ce 01       	movw	r24, r28
    1266:	f5 dd       	rcall	.-1046   	; 0xe52 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1268:	df be       	out	0x3f, r13	; 63

	cpu_irq_restore(flags);
}
    126a:	df 91       	pop	r29
    126c:	cf 91       	pop	r28
    126e:	1f 91       	pop	r17
    1270:	0f 91       	pop	r16
    1272:	ff 90       	pop	r15
    1274:	ef 90       	pop	r14
    1276:	df 90       	pop	r13
    1278:	08 95       	ret

0000127a <adc_read_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_read_configuration(ADC_t *adc, struct adc_config *conf)
{
    127a:	ff 92       	push	r15
    127c:	0f 93       	push	r16
    127e:	1f 93       	push	r17
    1280:	cf 93       	push	r28
    1282:	df 93       	push	r29
    1284:	ec 01       	movw	r28, r24
    1286:	8b 01       	movw	r16, r22

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1288:	ff b6       	in	r15, 0x3f	; 63
	cpu_irq_disable();
    128a:	f8 94       	cli
	irqflags_t flags = cpu_irq_save();

	adc_enable_clock(adc);
    128c:	c3 dd       	rcall	.-1146   	; 0xe14 <adc_enable_clock>

	conf->ctrla = adc->CTRLA & ADC_DMASEL_gm;
    128e:	88 81       	ld	r24, Y
    1290:	80 7c       	andi	r24, 0xC0	; 192
    1292:	f8 01       	movw	r30, r16
    1294:	80 83       	st	Z, r24

	conf->cmp = adc->CMP;
    1296:	88 8d       	ldd	r24, Y+24	; 0x18
    1298:	99 8d       	ldd	r25, Y+25	; 0x19
    129a:	85 83       	std	Z+5, r24	; 0x05
    129c:	96 83       	std	Z+6, r25	; 0x06
	conf->refctrl = adc->REFCTRL;
    129e:	8a 81       	ldd	r24, Y+2	; 0x02
    12a0:	82 83       	std	Z+2, r24	; 0x02
	conf->prescaler = adc->PRESCALER;
    12a2:	8c 81       	ldd	r24, Y+4	; 0x04
    12a4:	84 83       	std	Z+4, r24	; 0x04
	conf->evctrl = adc->EVCTRL;
    12a6:	8b 81       	ldd	r24, Y+3	; 0x03
    12a8:	83 83       	std	Z+3, r24	; 0x03
	conf->ctrlb = adc->CTRLB;
    12aa:	89 81       	ldd	r24, Y+1	; 0x01
    12ac:	81 83       	std	Z+1, r24	; 0x01

	adc_disable_clock(adc);
    12ae:	ce 01       	movw	r24, r28
    12b0:	d0 dd       	rcall	.-1120   	; 0xe52 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    12b2:	ff be       	out	0x3f, r15	; 63

	cpu_irq_restore(flags);
}
    12b4:	df 91       	pop	r29
    12b6:	cf 91       	pop	r28
    12b8:	1f 91       	pop	r17
    12ba:	0f 91       	pop	r16
    12bc:	ff 90       	pop	r15
    12be:	08 95       	ret

000012c0 <adcch_write_configuration>:
 * is called if callbacks are enabled and interrupts are enabled in the
 * channel configuration.
 */
void adcch_write_configuration(ADC_t *adc, uint8_t ch_mask,
		const struct adc_channel_config *ch_conf)
{
    12c0:	cf 92       	push	r12
    12c2:	df 92       	push	r13
    12c4:	ef 92       	push	r14
    12c6:	ff 92       	push	r15
    12c8:	0f 93       	push	r16
    12ca:	1f 93       	push	r17
    12cc:	cf 93       	push	r28
    12ce:	df 93       	push	r29
    12d0:	7c 01       	movw	r14, r24
    12d2:	d6 2e       	mov	r13, r22
    12d4:	8a 01       	movw	r16, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    12d6:	86 2f       	mov	r24, r22
    12d8:	83 70       	andi	r24, 0x03	; 3
    12da:	29 f4       	brne	.+10     	; 0x12e6 <adcch_write_configuration+0x26>
		index += 2;
		ch_mask >>= 2;
    12dc:	96 2f       	mov	r25, r22
    12de:	96 95       	lsr	r25
    12e0:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    12e2:	82 e0       	ldi	r24, 0x02	; 2
    12e4:	02 c0       	rjmp	.+4      	; 0x12ea <adcch_write_configuration+0x2a>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    12e6:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
static __always_inline ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    12e8:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    12ea:	90 ff       	sbrs	r25, 0
		index++;
    12ec:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    12ee:	e7 01       	movw	r28, r14
    12f0:	a0 96       	adiw	r28, 0x20	; 32
    12f2:	98 e0       	ldi	r25, 0x08	; 8
    12f4:	89 9f       	mul	r24, r25
    12f6:	c0 0d       	add	r28, r0
    12f8:	d1 1d       	adc	r29, r1
    12fa:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    12fc:	cf b6       	in	r12, 0x3f	; 63
	cpu_irq_disable();
    12fe:	f8 94       	cli
			return;
		}
	}
#endif

	adc_enable_clock(adc);
    1300:	c7 01       	movw	r24, r14
    1302:	88 dd       	rcall	.-1264   	; 0xe14 <adc_enable_clock>
	adc_ch->CTRL = ch_conf->ctrl;
    1304:	f8 01       	movw	r30, r16
    1306:	80 81       	ld	r24, Z
    1308:	88 83       	st	Y, r24
	adc_ch->INTCTRL = ch_conf->intctrl;
    130a:	82 81       	ldd	r24, Z+2	; 0x02
    130c:	8a 83       	std	Y+2, r24	; 0x02
	adc_ch->MUXCTRL = ch_conf->muxctrl;
    130e:	81 81       	ldd	r24, Z+1	; 0x01
    1310:	89 83       	std	Y+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    1312:	d0 fe       	sbrs	r13, 0
    1314:	02 c0       	rjmp	.+4      	; 0x131a <adcch_write_configuration+0x5a>
		/* USB devices has channel scan available on ADC channel 0 */
		adc_ch->SCAN = ch_conf->scan;
    1316:	83 81       	ldd	r24, Z+3	; 0x03
    1318:	8e 83       	std	Y+6, r24	; 0x06
	}
	adc_disable_clock(adc);
    131a:	c7 01       	movw	r24, r14
    131c:	9a dd       	rcall	.-1228   	; 0xe52 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    131e:	cf be       	out	0x3f, r12	; 63

	cpu_irq_restore(flags);
}
    1320:	df 91       	pop	r29
    1322:	cf 91       	pop	r28
    1324:	1f 91       	pop	r17
    1326:	0f 91       	pop	r16
    1328:	ff 90       	pop	r15
    132a:	ef 90       	pop	r14
    132c:	df 90       	pop	r13
    132e:	cf 90       	pop	r12
    1330:	08 95       	ret

00001332 <adcch_read_configuration>:
 * can be given in mask)
 * \param ch_conf Pointer to ADC channel configuration.
 */
void adcch_read_configuration(ADC_t *adc, uint8_t ch_mask,
		struct adc_channel_config *ch_conf)
{
    1332:	cf 92       	push	r12
    1334:	df 92       	push	r13
    1336:	ef 92       	push	r14
    1338:	ff 92       	push	r15
    133a:	0f 93       	push	r16
    133c:	1f 93       	push	r17
    133e:	cf 93       	push	r28
    1340:	df 93       	push	r29
    1342:	7c 01       	movw	r14, r24
    1344:	d6 2e       	mov	r13, r22
    1346:	8a 01       	movw	r16, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1348:	86 2f       	mov	r24, r22
    134a:	83 70       	andi	r24, 0x03	; 3
    134c:	29 f4       	brne	.+10     	; 0x1358 <adcch_read_configuration+0x26>
		index += 2;
		ch_mask >>= 2;
    134e:	96 2f       	mov	r25, r22
    1350:	96 95       	lsr	r25
    1352:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    1354:	82 e0       	ldi	r24, 0x02	; 2
    1356:	02 c0       	rjmp	.+4      	; 0x135c <adcch_read_configuration+0x2a>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1358:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
static __always_inline ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    135a:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    135c:	90 ff       	sbrs	r25, 0
		index++;
    135e:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    1360:	e7 01       	movw	r28, r14
    1362:	a0 96       	adiw	r28, 0x20	; 32
    1364:	98 e0       	ldi	r25, 0x08	; 8
    1366:	89 9f       	mul	r24, r25
    1368:	c0 0d       	add	r28, r0
    136a:	d1 1d       	adc	r29, r1
    136c:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    136e:	cf b6       	in	r12, 0x3f	; 63
	cpu_irq_disable();
    1370:	f8 94       	cli

	adc_ch = adc_get_channel(adc, ch_mask);

	flags = cpu_irq_save();

	adc_enable_clock(adc);
    1372:	c7 01       	movw	r24, r14
    1374:	4f dd       	rcall	.-1378   	; 0xe14 <adc_enable_clock>
	ch_conf->ctrl = adc_ch->CTRL;
    1376:	88 81       	ld	r24, Y
    1378:	f8 01       	movw	r30, r16
    137a:	80 83       	st	Z, r24
	ch_conf->intctrl = adc_ch->INTCTRL;
    137c:	8a 81       	ldd	r24, Y+2	; 0x02
    137e:	82 83       	std	Z+2, r24	; 0x02
	ch_conf->muxctrl = adc_ch->MUXCTRL;
    1380:	89 81       	ldd	r24, Y+1	; 0x01
    1382:	81 83       	std	Z+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    1384:	d0 fe       	sbrs	r13, 0
    1386:	02 c0       	rjmp	.+4      	; 0x138c <adcch_read_configuration+0x5a>
		/* USB devices has channel scan available on ADC channel 0 */
		ch_conf->scan = adc_ch->SCAN;
    1388:	8e 81       	ldd	r24, Y+6	; 0x06
    138a:	83 83       	std	Z+3, r24	; 0x03
	}
	adc_disable_clock(adc);
    138c:	c7 01       	movw	r24, r14
    138e:	61 dd       	rcall	.-1342   	; 0xe52 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1390:	cf be       	out	0x3f, r12	; 63

	cpu_irq_restore(flags);
}
    1392:	df 91       	pop	r29
    1394:	cf 91       	pop	r28
    1396:	1f 91       	pop	r17
    1398:	0f 91       	pop	r16
    139a:	ff 90       	pop	r15
    139c:	ef 90       	pop	r14
    139e:	df 90       	pop	r13
    13a0:	cf 90       	pop	r12
    13a2:	08 95       	ret

000013a4 <nvm_read_byte>:
#endif

#ifndef __DOXYGEN__
	PUBLIC_FUNCTION(nvm_read_byte)
#if defined(__GNUC__)
	lds r20, NVM_CMD          ; Store NVM command register
    13a4:	40 91 ca 01 	lds	r20, 0x01CA	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	mov ZL, r22               ; Load byte index into low byte of Z.
    13a8:	e6 2f       	mov	r30, r22
	mov ZH, r23               ; Load high byte into Z.
    13aa:	f7 2f       	mov	r31, r23
	sts NVM_CMD, r24          ; Load prepared command into NVM Command register.
    13ac:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	lpm r24, Z                ; Perform an LPM to read out byte
    13b0:	84 91       	lpm	r24, Z
	sts NVM_CMD, r20          ; Restore NVM command register
    13b2:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	sts NVM_CMD, r16          ; Load prepared command into NVM Command register.
	lpm r16, Z                ; Perform an LPM to read out byte
	sts NVM_CMD, r20          ; Restore NVM command register
#endif

	ret
    13b6:	08 95       	ret

000013b8 <usart_set_baudrate>:
 * \retval true if the hardware supports the baud rate
 * \retval false if the hardware does not support the baud rate (i.e. it's
 *               either too high or too low.)
 */
bool usart_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    13b8:	2f 92       	push	r2
    13ba:	3f 92       	push	r3
    13bc:	4f 92       	push	r4
    13be:	5f 92       	push	r5
    13c0:	6f 92       	push	r6
    13c2:	7f 92       	push	r7
    13c4:	8f 92       	push	r8
    13c6:	9f 92       	push	r9
    13c8:	af 92       	push	r10
    13ca:	bf 92       	push	r11
    13cc:	cf 92       	push	r12
    13ce:	df 92       	push	r13
    13d0:	ef 92       	push	r14
    13d2:	ff 92       	push	r15
    13d4:	0f 93       	push	r16
    13d6:	1f 93       	push	r17
    13d8:	cf 93       	push	r28
    13da:	1c 01       	movw	r2, r24
    13dc:	2a 01       	movw	r4, r20
    13de:	3b 01       	movw	r6, r22
    13e0:	48 01       	movw	r8, r16
    13e2:	59 01       	movw	r10, r18

	/*
	 * Check if the hardware supports the given baud rate
	 */
	/* 8 = (2^0) * 8 * (2^0) = (2^BSCALE_MIN) * 8 * (BSEL_MIN) */
	max_rate = cpu_hz / 8;
    13e4:	d9 01       	movw	r26, r18
    13e6:	c8 01       	movw	r24, r16
    13e8:	68 94       	set
    13ea:	12 f8       	bld	r1, 2
    13ec:	b6 95       	lsr	r27
    13ee:	a7 95       	ror	r26
    13f0:	97 95       	ror	r25
    13f2:	87 95       	ror	r24
    13f4:	16 94       	lsr	r1
    13f6:	d1 f7       	brne	.-12     	; 0x13ec <usart_set_baudrate+0x34>
	/* 4194304 = (2^7) * 8 * (2^12) = (2^BSCALE_MAX) * 8 * (BSEL_MAX+1) */
	min_rate = cpu_hz / 4194304;
    13f8:	b9 01       	movw	r22, r18
    13fa:	a8 01       	movw	r20, r16
    13fc:	03 2e       	mov	r0, r19
    13fe:	36 e1       	ldi	r19, 0x16	; 22
    1400:	76 95       	lsr	r23
    1402:	67 95       	ror	r22
    1404:	57 95       	ror	r21
    1406:	47 95       	ror	r20
    1408:	3a 95       	dec	r19
    140a:	d1 f7       	brne	.-12     	; 0x1400 <usart_set_baudrate+0x48>
    140c:	30 2d       	mov	r19, r0

	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
    140e:	f1 01       	movw	r30, r2
    1410:	24 81       	ldd	r18, Z+4	; 0x04
    1412:	22 fd       	sbrc	r18, 2
    1414:	08 c0       	rjmp	.+16     	; 0x1426 <usart_set_baudrate+0x6e>
		max_rate /= 2;
    1416:	b6 95       	lsr	r27
    1418:	a7 95       	ror	r26
    141a:	97 95       	ror	r25
    141c:	87 95       	ror	r24
		min_rate /= 2;
    141e:	76 95       	lsr	r23
    1420:	67 95       	ror	r22
    1422:	57 95       	ror	r21
    1424:	47 95       	ror	r20
	}

	if ((baud > max_rate) || (baud < min_rate)) {
    1426:	84 15       	cp	r24, r4
    1428:	95 05       	cpc	r25, r5
    142a:	a6 05       	cpc	r26, r6
    142c:	b7 05       	cpc	r27, r7
    142e:	08 f4       	brcc	.+2      	; 0x1432 <usart_set_baudrate+0x7a>
    1430:	ae c0       	rjmp	.+348    	; 0x158e <usart_set_baudrate+0x1d6>
    1432:	44 16       	cp	r4, r20
    1434:	55 06       	cpc	r5, r21
    1436:	66 06       	cpc	r6, r22
    1438:	77 06       	cpc	r7, r23
    143a:	08 f4       	brcc	.+2      	; 0x143e <usart_set_baudrate+0x86>
    143c:	aa c0       	rjmp	.+340    	; 0x1592 <usart_set_baudrate+0x1da>
		return false;
	}

	/* Check if double speed is enabled. */
	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
    143e:	f1 01       	movw	r30, r2
    1440:	84 81       	ldd	r24, Z+4	; 0x04
    1442:	82 fd       	sbrc	r24, 2
    1444:	04 c0       	rjmp	.+8      	; 0x144e <usart_set_baudrate+0x96>
		baud *= 2;
    1446:	44 0c       	add	r4, r4
    1448:	55 1c       	adc	r5, r5
    144a:	66 1c       	adc	r6, r6
    144c:	77 1c       	adc	r7, r7
	}

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;
    144e:	c5 01       	movw	r24, r10
    1450:	b4 01       	movw	r22, r8
    1452:	a3 01       	movw	r20, r6
    1454:	92 01       	movw	r18, r4
    1456:	0e 94 27 1c 	call	0x384e	; 0x384e <__udivmodsi4>

	for (exp = -7; exp < 7; exp++) {
		if (ratio < limit) {
    145a:	2f 3f       	cpi	r18, 0xFF	; 255
    145c:	31 05       	cpc	r19, r1
    145e:	41 05       	cpc	r20, r1
    1460:	51 05       	cpc	r21, r1
    1462:	08 f4       	brcc	.+2      	; 0x1466 <usart_set_baudrate+0xae>
    1464:	98 c0       	rjmp	.+304    	; 0x1596 <usart_set_baudrate+0x1de>
    1466:	c1 2c       	mov	r12, r1
    1468:	d1 2c       	mov	r13, r1
    146a:	76 01       	movw	r14, r12
    146c:	ca 94       	dec	r12
    146e:	c9 ef       	ldi	r28, 0xF9	; 249
    1470:	05 c0       	rjmp	.+10     	; 0x147c <usart_set_baudrate+0xc4>
    1472:	2c 15       	cp	r18, r12
    1474:	3d 05       	cpc	r19, r13
    1476:	4e 05       	cpc	r20, r14
    1478:	5f 05       	cpc	r21, r15
    147a:	68 f0       	brcs	.+26     	; 0x1496 <usart_set_baudrate+0xde>
			break;
		}

		limit <<= 1;
    147c:	cc 0c       	add	r12, r12
    147e:	dd 1c       	adc	r13, r13
    1480:	ee 1c       	adc	r14, r14
    1482:	ff 1c       	adc	r15, r15

		if (exp < -3) {
    1484:	cd 3f       	cpi	r28, 0xFD	; 253
    1486:	14 f4       	brge	.+4      	; 0x148c <usart_set_baudrate+0xd4>
			limit |= 1;
    1488:	68 94       	set
    148a:	c0 f8       	bld	r12, 0
    148c:	cf 5f       	subi	r28, 0xFF	; 255

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;

	for (exp = -7; exp < 7; exp++) {
    148e:	c7 30       	cpi	r28, 0x07	; 7
    1490:	81 f7       	brne	.-32     	; 0x1472 <usart_set_baudrate+0xba>
    1492:	8c 2f       	mov	r24, r28
    1494:	56 c0       	rjmp	.+172    	; 0x1542 <usart_set_baudrate+0x18a>
    1496:	8c 2f       	mov	r24, r28
	 * point.
	 *
	 * The formula for calculating BSEL is slightly different when exp is
	 * negative than it is when exp is positive.
	 */
	if (exp < 0) {
    1498:	cc 23       	and	r28, r28
    149a:	0c f0       	brlt	.+2      	; 0x149e <usart_set_baudrate+0xe6>
    149c:	52 c0       	rjmp	.+164    	; 0x1542 <usart_set_baudrate+0x18a>
		/* We are supposed to subtract 1, then apply BSCALE. We want to
		 * apply BSCALE first, so we need to turn everything inside the
		 * parenthesis into a single fractional expression.
		 */
		cpu_hz -= 8 * baud;
    149e:	d3 01       	movw	r26, r6
    14a0:	c2 01       	movw	r24, r4
    14a2:	88 0f       	add	r24, r24
    14a4:	99 1f       	adc	r25, r25
    14a6:	aa 1f       	adc	r26, r26
    14a8:	bb 1f       	adc	r27, r27
    14aa:	88 0f       	add	r24, r24
    14ac:	99 1f       	adc	r25, r25
    14ae:	aa 1f       	adc	r26, r26
    14b0:	bb 1f       	adc	r27, r27
    14b2:	88 0f       	add	r24, r24
    14b4:	99 1f       	adc	r25, r25
    14b6:	aa 1f       	adc	r26, r26
    14b8:	bb 1f       	adc	r27, r27
    14ba:	85 01       	movw	r16, r10
    14bc:	74 01       	movw	r14, r8
    14be:	e8 1a       	sub	r14, r24
    14c0:	f9 0a       	sbc	r15, r25
    14c2:	0a 0b       	sbc	r16, r26
    14c4:	1b 0b       	sbc	r17, r27
    14c6:	d8 01       	movw	r26, r16
    14c8:	c7 01       	movw	r24, r14
		/* If we end up with a left-shift after taking the final
		 * divide-by-8 into account, do the shift before the divide.
		 * Otherwise, left-shift the denominator instead (effectively
		 * resulting in an overall right shift.)
		 */
		if (exp <= -3) {
    14ca:	ce 3f       	cpi	r28, 0xFE	; 254
    14cc:	f4 f4       	brge	.+60     	; 0x150a <usart_set_baudrate+0x152>
			div = ((cpu_hz << (-exp - 3)) + baud / 2) / baud;
    14ce:	2d ef       	ldi	r18, 0xFD	; 253
    14d0:	3f ef       	ldi	r19, 0xFF	; 255
    14d2:	2c 1b       	sub	r18, r28
    14d4:	31 09       	sbc	r19, r1
    14d6:	c7 fd       	sbrc	r28, 7
    14d8:	33 95       	inc	r19
    14da:	04 c0       	rjmp	.+8      	; 0x14e4 <usart_set_baudrate+0x12c>
    14dc:	88 0f       	add	r24, r24
    14de:	99 1f       	adc	r25, r25
    14e0:	aa 1f       	adc	r26, r26
    14e2:	bb 1f       	adc	r27, r27
    14e4:	2a 95       	dec	r18
    14e6:	d2 f7       	brpl	.-12     	; 0x14dc <usart_set_baudrate+0x124>
    14e8:	73 01       	movw	r14, r6
    14ea:	62 01       	movw	r12, r4
    14ec:	f6 94       	lsr	r15
    14ee:	e7 94       	ror	r14
    14f0:	d7 94       	ror	r13
    14f2:	c7 94       	ror	r12
    14f4:	bc 01       	movw	r22, r24
    14f6:	cd 01       	movw	r24, r26
    14f8:	6c 0d       	add	r22, r12
    14fa:	7d 1d       	adc	r23, r13
    14fc:	8e 1d       	adc	r24, r14
    14fe:	9f 1d       	adc	r25, r15
    1500:	a3 01       	movw	r20, r6
    1502:	92 01       	movw	r18, r4
    1504:	0e 94 27 1c 	call	0x384e	; 0x384e <__udivmodsi4>
    1508:	38 c0       	rjmp	.+112    	; 0x157a <usart_set_baudrate+0x1c2>
		} else {
			baud <<= exp + 3;
    150a:	23 e0       	ldi	r18, 0x03	; 3
    150c:	2c 0f       	add	r18, r28
    150e:	83 01       	movw	r16, r6
    1510:	72 01       	movw	r14, r4
    1512:	04 c0       	rjmp	.+8      	; 0x151c <usart_set_baudrate+0x164>
    1514:	ee 0c       	add	r14, r14
    1516:	ff 1c       	adc	r15, r15
    1518:	00 1f       	adc	r16, r16
    151a:	11 1f       	adc	r17, r17
    151c:	2a 95       	dec	r18
    151e:	d2 f7       	brpl	.-12     	; 0x1514 <usart_set_baudrate+0x15c>
    1520:	a8 01       	movw	r20, r16
    1522:	97 01       	movw	r18, r14
			div = (cpu_hz + baud / 2) / baud;
    1524:	67 01       	movw	r12, r14
    1526:	78 01       	movw	r14, r16
    1528:	f6 94       	lsr	r15
    152a:	e7 94       	ror	r14
    152c:	d7 94       	ror	r13
    152e:	c7 94       	ror	r12
    1530:	bc 01       	movw	r22, r24
    1532:	cd 01       	movw	r24, r26
    1534:	6c 0d       	add	r22, r12
    1536:	7d 1d       	adc	r23, r13
    1538:	8e 1d       	adc	r24, r14
    153a:	9f 1d       	adc	r25, r15
    153c:	0e 94 27 1c 	call	0x384e	; 0x384e <__udivmodsi4>
    1540:	1c c0       	rjmp	.+56     	; 0x157a <usart_set_baudrate+0x1c2>
		}
	} else {
		/* We will always do a right shift in this case, but we need to
		 * shift three extra positions because of the divide-by-8.
		 */
		baud <<= exp + 3;
    1542:	8d 5f       	subi	r24, 0xFD	; 253
    1544:	a3 01       	movw	r20, r6
    1546:	92 01       	movw	r18, r4
    1548:	04 c0       	rjmp	.+8      	; 0x1552 <usart_set_baudrate+0x19a>
    154a:	22 0f       	add	r18, r18
    154c:	33 1f       	adc	r19, r19
    154e:	44 1f       	adc	r20, r20
    1550:	55 1f       	adc	r21, r21
    1552:	8a 95       	dec	r24
    1554:	d2 f7       	brpl	.-12     	; 0x154a <usart_set_baudrate+0x192>
		div = (cpu_hz + baud / 2) / baud - 1;
    1556:	da 01       	movw	r26, r20
    1558:	c9 01       	movw	r24, r18
    155a:	b6 95       	lsr	r27
    155c:	a7 95       	ror	r26
    155e:	97 95       	ror	r25
    1560:	87 95       	ror	r24
    1562:	bc 01       	movw	r22, r24
    1564:	cd 01       	movw	r24, r26
    1566:	68 0d       	add	r22, r8
    1568:	79 1d       	adc	r23, r9
    156a:	8a 1d       	adc	r24, r10
    156c:	9b 1d       	adc	r25, r11
    156e:	0e 94 27 1c 	call	0x384e	; 0x384e <__udivmodsi4>
    1572:	21 50       	subi	r18, 0x01	; 1
    1574:	31 09       	sbc	r19, r1
    1576:	41 09       	sbc	r20, r1
    1578:	51 09       	sbc	r21, r1
	}

	(usart)->BAUDCTRLB = (uint8_t)(((div >> 8) & 0X0F) | (exp << 4));
    157a:	83 2f       	mov	r24, r19
    157c:	8f 70       	andi	r24, 0x0F	; 15
    157e:	c2 95       	swap	r28
    1580:	c0 7f       	andi	r28, 0xF0	; 240
    1582:	c8 2b       	or	r28, r24
    1584:	f1 01       	movw	r30, r2
    1586:	c7 83       	std	Z+7, r28	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)div;
    1588:	26 83       	std	Z+6, r18	; 0x06

	return true;
    158a:	81 e0       	ldi	r24, 0x01	; 1
    158c:	1c c0       	rjmp	.+56     	; 0x15c6 <usart_set_baudrate+0x20e>
		max_rate /= 2;
		min_rate /= 2;
	}

	if ((baud > max_rate) || (baud < min_rate)) {
		return false;
    158e:	80 e0       	ldi	r24, 0x00	; 0
    1590:	1a c0       	rjmp	.+52     	; 0x15c6 <usart_set_baudrate+0x20e>
    1592:	80 e0       	ldi	r24, 0x00	; 0
    1594:	18 c0       	rjmp	.+48     	; 0x15c6 <usart_set_baudrate+0x20e>
	if (exp < 0) {
		/* We are supposed to subtract 1, then apply BSCALE. We want to
		 * apply BSCALE first, so we need to turn everything inside the
		 * parenthesis into a single fractional expression.
		 */
		cpu_hz -= 8 * baud;
    1596:	d3 01       	movw	r26, r6
    1598:	c2 01       	movw	r24, r4
    159a:	88 0f       	add	r24, r24
    159c:	99 1f       	adc	r25, r25
    159e:	aa 1f       	adc	r26, r26
    15a0:	bb 1f       	adc	r27, r27
    15a2:	88 0f       	add	r24, r24
    15a4:	99 1f       	adc	r25, r25
    15a6:	aa 1f       	adc	r26, r26
    15a8:	bb 1f       	adc	r27, r27
    15aa:	88 0f       	add	r24, r24
    15ac:	99 1f       	adc	r25, r25
    15ae:	aa 1f       	adc	r26, r26
    15b0:	bb 1f       	adc	r27, r27
    15b2:	85 01       	movw	r16, r10
    15b4:	74 01       	movw	r14, r8
    15b6:	e8 1a       	sub	r14, r24
    15b8:	f9 0a       	sbc	r15, r25
    15ba:	0a 0b       	sbc	r16, r26
    15bc:	1b 0b       	sbc	r17, r27
    15be:	d8 01       	movw	r26, r16
    15c0:	c7 01       	movw	r24, r14

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;

	for (exp = -7; exp < 7; exp++) {
    15c2:	c9 ef       	ldi	r28, 0xF9	; 249
    15c4:	84 cf       	rjmp	.-248    	; 0x14ce <usart_set_baudrate+0x116>

	(usart)->BAUDCTRLB = (uint8_t)(((div >> 8) & 0X0F) | (exp << 4));
	(usart)->BAUDCTRLA = (uint8_t)div;

	return true;
}
    15c6:	cf 91       	pop	r28
    15c8:	1f 91       	pop	r17
    15ca:	0f 91       	pop	r16
    15cc:	ff 90       	pop	r15
    15ce:	ef 90       	pop	r14
    15d0:	df 90       	pop	r13
    15d2:	cf 90       	pop	r12
    15d4:	bf 90       	pop	r11
    15d6:	af 90       	pop	r10
    15d8:	9f 90       	pop	r9
    15da:	8f 90       	pop	r8
    15dc:	7f 90       	pop	r7
    15de:	6f 90       	pop	r6
    15e0:	5f 90       	pop	r5
    15e2:	4f 90       	pop	r4
    15e4:	3f 90       	pop	r3
    15e6:	2f 90       	pop	r2
    15e8:	08 95       	ret

000015ea <usart_init_rs232>:
 *
 * \retval true if the initialization was successfull
 * \retval false if the initialization failed (error in baud rate calculation)
 */
bool usart_init_rs232(USART_t *usart, const usart_rs232_options_t *opt)
{
    15ea:	0f 93       	push	r16
    15ec:	1f 93       	push	r17
    15ee:	cf 93       	push	r28
    15f0:	df 93       	push	r29
    15f2:	ec 01       	movw	r28, r24
    15f4:	8b 01       	movw	r16, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    15f6:	00 97       	sbiw	r24, 0x00	; 0
    15f8:	09 f4       	brne	.+2      	; 0x15fc <usart_init_rs232+0x12>
    15fa:	e6 c0       	rjmp	.+460    	; 0x17c8 <usart_init_rs232+0x1de>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    15fc:	80 3c       	cpi	r24, 0xC0	; 192
    15fe:	91 05       	cpc	r25, r1
    1600:	21 f4       	brne	.+8      	; 0x160a <usart_init_rs232+0x20>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    1602:	60 e1       	ldi	r22, 0x10	; 16
    1604:	80 e0       	ldi	r24, 0x00	; 0
    1606:	25 d9       	rcall	.-3510   	; 0x852 <sysclk_enable_module>
    1608:	df c0       	rjmp	.+446    	; 0x17c8 <usart_init_rs232+0x1de>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    160a:	c0 38       	cpi	r28, 0x80	; 128
    160c:	81 e0       	ldi	r24, 0x01	; 1
    160e:	d8 07       	cpc	r29, r24
    1610:	21 f4       	brne	.+8      	; 0x161a <usart_init_rs232+0x30>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    1612:	62 e0       	ldi	r22, 0x02	; 2
    1614:	80 e0       	ldi	r24, 0x00	; 0
    1616:	1d d9       	rcall	.-3526   	; 0x852 <sysclk_enable_module>
    1618:	d7 c0       	rjmp	.+430    	; 0x17c8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    161a:	c1 15       	cp	r28, r1
    161c:	e1 e0       	ldi	r30, 0x01	; 1
    161e:	de 07       	cpc	r29, r30
    1620:	21 f4       	brne	.+8      	; 0x162a <usart_init_rs232+0x40>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    1622:	61 e0       	ldi	r22, 0x01	; 1
    1624:	80 e0       	ldi	r24, 0x00	; 0
    1626:	15 d9       	rcall	.-3542   	; 0x852 <sysclk_enable_module>
    1628:	cf c0       	rjmp	.+414    	; 0x17c8 <usart_init_rs232+0x1de>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    162a:	c0 38       	cpi	r28, 0x80	; 128
    162c:	f3 e0       	ldi	r31, 0x03	; 3
    162e:	df 07       	cpc	r29, r31
    1630:	21 f4       	brne	.+8      	; 0x163a <usart_init_rs232+0x50>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    1632:	61 e0       	ldi	r22, 0x01	; 1
    1634:	81 e0       	ldi	r24, 0x01	; 1
    1636:	0d d9       	rcall	.-3558   	; 0x852 <sysclk_enable_module>
    1638:	c7 c0       	rjmp	.+398    	; 0x17c8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    163a:	c0 39       	cpi	r28, 0x90	; 144
    163c:	83 e0       	ldi	r24, 0x03	; 3
    163e:	d8 07       	cpc	r29, r24
    1640:	21 f4       	brne	.+8      	; 0x164a <usart_init_rs232+0x60>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    1642:	61 e0       	ldi	r22, 0x01	; 1
    1644:	82 e0       	ldi	r24, 0x02	; 2
    1646:	05 d9       	rcall	.-3574   	; 0x852 <sysclk_enable_module>
    1648:	bf c0       	rjmp	.+382    	; 0x17c8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    164a:	c1 15       	cp	r28, r1
    164c:	e2 e0       	ldi	r30, 0x02	; 2
    164e:	de 07       	cpc	r29, r30
    1650:	21 f4       	brne	.+8      	; 0x165a <usart_init_rs232+0x70>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    1652:	62 e0       	ldi	r22, 0x02	; 2
    1654:	81 e0       	ldi	r24, 0x01	; 1
    1656:	fd d8       	rcall	.-3590   	; 0x852 <sysclk_enable_module>
    1658:	b7 c0       	rjmp	.+366    	; 0x17c8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    165a:	c0 34       	cpi	r28, 0x40	; 64
    165c:	f2 e0       	ldi	r31, 0x02	; 2
    165e:	df 07       	cpc	r29, r31
    1660:	21 f4       	brne	.+8      	; 0x166a <usart_init_rs232+0x80>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    1662:	62 e0       	ldi	r22, 0x02	; 2
    1664:	82 e0       	ldi	r24, 0x02	; 2
    1666:	f5 d8       	rcall	.-3606   	; 0x852 <sysclk_enable_module>
    1668:	af c0       	rjmp	.+350    	; 0x17c8 <usart_init_rs232+0x1de>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    166a:	c0 32       	cpi	r28, 0x20	; 32
    166c:	83 e0       	ldi	r24, 0x03	; 3
    166e:	d8 07       	cpc	r29, r24
    1670:	21 f4       	brne	.+8      	; 0x167a <usart_init_rs232+0x90>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    1672:	64 e0       	ldi	r22, 0x04	; 4
    1674:	82 e0       	ldi	r24, 0x02	; 2
    1676:	ed d8       	rcall	.-3622   	; 0x852 <sysclk_enable_module>
    1678:	a7 c0       	rjmp	.+334    	; 0x17c8 <usart_init_rs232+0x1de>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    167a:	c1 15       	cp	r28, r1
    167c:	e8 e0       	ldi	r30, 0x08	; 8
    167e:	de 07       	cpc	r29, r30
    1680:	21 f4       	brne	.+8      	; 0x168a <usart_init_rs232+0xa0>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    1682:	61 e0       	ldi	r22, 0x01	; 1
    1684:	83 e0       	ldi	r24, 0x03	; 3
    1686:	e5 d8       	rcall	.-3638   	; 0x852 <sysclk_enable_module>
    1688:	9f c0       	rjmp	.+318    	; 0x17c8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    168a:	c1 15       	cp	r28, r1
    168c:	f9 e0       	ldi	r31, 0x09	; 9
    168e:	df 07       	cpc	r29, r31
    1690:	21 f4       	brne	.+8      	; 0x169a <usart_init_rs232+0xb0>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    1692:	61 e0       	ldi	r22, 0x01	; 1
    1694:	84 e0       	ldi	r24, 0x04	; 4
    1696:	dd d8       	rcall	.-3654   	; 0x852 <sysclk_enable_module>
    1698:	97 c0       	rjmp	.+302    	; 0x17c8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    169a:	c1 15       	cp	r28, r1
    169c:	8a e0       	ldi	r24, 0x0A	; 10
    169e:	d8 07       	cpc	r29, r24
    16a0:	21 f4       	brne	.+8      	; 0x16aa <usart_init_rs232+0xc0>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    16a2:	61 e0       	ldi	r22, 0x01	; 1
    16a4:	85 e0       	ldi	r24, 0x05	; 5
    16a6:	d5 d8       	rcall	.-3670   	; 0x852 <sysclk_enable_module>
    16a8:	8f c0       	rjmp	.+286    	; 0x17c8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    16aa:	c1 15       	cp	r28, r1
    16ac:	eb e0       	ldi	r30, 0x0B	; 11
    16ae:	de 07       	cpc	r29, r30
    16b0:	21 f4       	brne	.+8      	; 0x16ba <usart_init_rs232+0xd0>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    16b2:	61 e0       	ldi	r22, 0x01	; 1
    16b4:	86 e0       	ldi	r24, 0x06	; 6
    16b6:	cd d8       	rcall	.-3686   	; 0x852 <sysclk_enable_module>
    16b8:	87 c0       	rjmp	.+270    	; 0x17c8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    16ba:	c0 34       	cpi	r28, 0x40	; 64
    16bc:	f8 e0       	ldi	r31, 0x08	; 8
    16be:	df 07       	cpc	r29, r31
    16c0:	21 f4       	brne	.+8      	; 0x16ca <usart_init_rs232+0xe0>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    16c2:	62 e0       	ldi	r22, 0x02	; 2
    16c4:	83 e0       	ldi	r24, 0x03	; 3
    16c6:	c5 d8       	rcall	.-3702   	; 0x852 <sysclk_enable_module>
    16c8:	7f c0       	rjmp	.+254    	; 0x17c8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    16ca:	c0 34       	cpi	r28, 0x40	; 64
    16cc:	89 e0       	ldi	r24, 0x09	; 9
    16ce:	d8 07       	cpc	r29, r24
    16d0:	21 f4       	brne	.+8      	; 0x16da <usart_init_rs232+0xf0>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    16d2:	62 e0       	ldi	r22, 0x02	; 2
    16d4:	84 e0       	ldi	r24, 0x04	; 4
    16d6:	bd d8       	rcall	.-3718   	; 0x852 <sysclk_enable_module>
    16d8:	77 c0       	rjmp	.+238    	; 0x17c8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    16da:	c0 34       	cpi	r28, 0x40	; 64
    16dc:	ea e0       	ldi	r30, 0x0A	; 10
    16de:	de 07       	cpc	r29, r30
    16e0:	21 f4       	brne	.+8      	; 0x16ea <usart_init_rs232+0x100>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    16e2:	62 e0       	ldi	r22, 0x02	; 2
    16e4:	85 e0       	ldi	r24, 0x05	; 5
    16e6:	b5 d8       	rcall	.-3734   	; 0x852 <sysclk_enable_module>
    16e8:	6f c0       	rjmp	.+222    	; 0x17c8 <usart_init_rs232+0x1de>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    16ea:	c0 39       	cpi	r28, 0x90	; 144
    16ec:	f8 e0       	ldi	r31, 0x08	; 8
    16ee:	df 07       	cpc	r29, r31
    16f0:	21 f4       	brne	.+8      	; 0x16fa <usart_init_rs232+0x110>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    16f2:	64 e0       	ldi	r22, 0x04	; 4
    16f4:	83 e0       	ldi	r24, 0x03	; 3
    16f6:	ad d8       	rcall	.-3750   	; 0x852 <sysclk_enable_module>
    16f8:	67 c0       	rjmp	.+206    	; 0x17c8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    16fa:	c0 39       	cpi	r28, 0x90	; 144
    16fc:	89 e0       	ldi	r24, 0x09	; 9
    16fe:	d8 07       	cpc	r29, r24
    1700:	21 f4       	brne	.+8      	; 0x170a <usart_init_rs232+0x120>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    1702:	64 e0       	ldi	r22, 0x04	; 4
    1704:	84 e0       	ldi	r24, 0x04	; 4
    1706:	a5 d8       	rcall	.-3766   	; 0x852 <sysclk_enable_module>
    1708:	5f c0       	rjmp	.+190    	; 0x17c8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    170a:	c0 39       	cpi	r28, 0x90	; 144
    170c:	ea e0       	ldi	r30, 0x0A	; 10
    170e:	de 07       	cpc	r29, r30
    1710:	21 f4       	brne	.+8      	; 0x171a <usart_init_rs232+0x130>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    1712:	64 e0       	ldi	r22, 0x04	; 4
    1714:	85 e0       	ldi	r24, 0x05	; 5
    1716:	9d d8       	rcall	.-3782   	; 0x852 <sysclk_enable_module>
    1718:	57 c0       	rjmp	.+174    	; 0x17c8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    171a:	c0 39       	cpi	r28, 0x90	; 144
    171c:	fb e0       	ldi	r31, 0x0B	; 11
    171e:	df 07       	cpc	r29, r31
    1720:	21 f4       	brne	.+8      	; 0x172a <usart_init_rs232+0x140>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    1722:	64 e0       	ldi	r22, 0x04	; 4
    1724:	86 e0       	ldi	r24, 0x06	; 6
    1726:	95 d8       	rcall	.-3798   	; 0x852 <sysclk_enable_module>
    1728:	4f c0       	rjmp	.+158    	; 0x17c8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    172a:	c0 3c       	cpi	r28, 0xC0	; 192
    172c:	88 e0       	ldi	r24, 0x08	; 8
    172e:	d8 07       	cpc	r29, r24
    1730:	21 f4       	brne	.+8      	; 0x173a <usart_init_rs232+0x150>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    1732:	68 e0       	ldi	r22, 0x08	; 8
    1734:	83 e0       	ldi	r24, 0x03	; 3
    1736:	8d d8       	rcall	.-3814   	; 0x852 <sysclk_enable_module>
    1738:	47 c0       	rjmp	.+142    	; 0x17c8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    173a:	c0 3c       	cpi	r28, 0xC0	; 192
    173c:	e9 e0       	ldi	r30, 0x09	; 9
    173e:	de 07       	cpc	r29, r30
    1740:	21 f4       	brne	.+8      	; 0x174a <usart_init_rs232+0x160>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    1742:	68 e0       	ldi	r22, 0x08	; 8
    1744:	84 e0       	ldi	r24, 0x04	; 4
    1746:	85 d8       	rcall	.-3830   	; 0x852 <sysclk_enable_module>
    1748:	3f c0       	rjmp	.+126    	; 0x17c8 <usart_init_rs232+0x1de>
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    174a:	c0 3a       	cpi	r28, 0xA0	; 160
    174c:	f8 e0       	ldi	r31, 0x08	; 8
    174e:	df 07       	cpc	r29, r31
    1750:	21 f4       	brne	.+8      	; 0x175a <usart_init_rs232+0x170>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    1752:	60 e1       	ldi	r22, 0x10	; 16
    1754:	83 e0       	ldi	r24, 0x03	; 3
    1756:	7d d8       	rcall	.-3846   	; 0x852 <sysclk_enable_module>
    1758:	37 c0       	rjmp	.+110    	; 0x17c8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    175a:	c0 3a       	cpi	r28, 0xA0	; 160
    175c:	89 e0       	ldi	r24, 0x09	; 9
    175e:	d8 07       	cpc	r29, r24
    1760:	21 f4       	brne	.+8      	; 0x176a <usart_init_rs232+0x180>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    1762:	60 e1       	ldi	r22, 0x10	; 16
    1764:	84 e0       	ldi	r24, 0x04	; 4
    1766:	75 d8       	rcall	.-3862   	; 0x852 <sysclk_enable_module>
    1768:	2f c0       	rjmp	.+94     	; 0x17c8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    176a:	c0 3a       	cpi	r28, 0xA0	; 160
    176c:	ea e0       	ldi	r30, 0x0A	; 10
    176e:	de 07       	cpc	r29, r30
    1770:	21 f4       	brne	.+8      	; 0x177a <usart_init_rs232+0x190>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    1772:	60 e1       	ldi	r22, 0x10	; 16
    1774:	85 e0       	ldi	r24, 0x05	; 5
    1776:	6d d8       	rcall	.-3878   	; 0x852 <sysclk_enable_module>
    1778:	27 c0       	rjmp	.+78     	; 0x17c8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    177a:	c0 3a       	cpi	r28, 0xA0	; 160
    177c:	fb e0       	ldi	r31, 0x0B	; 11
    177e:	df 07       	cpc	r29, r31
    1780:	21 f4       	brne	.+8      	; 0x178a <usart_init_rs232+0x1a0>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    1782:	60 e1       	ldi	r22, 0x10	; 16
    1784:	86 e0       	ldi	r24, 0x06	; 6
    1786:	65 d8       	rcall	.-3894   	; 0x852 <sysclk_enable_module>
    1788:	1f c0       	rjmp	.+62     	; 0x17c8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    178a:	c0 3b       	cpi	r28, 0xB0	; 176
    178c:	88 e0       	ldi	r24, 0x08	; 8
    178e:	d8 07       	cpc	r29, r24
    1790:	21 f4       	brne	.+8      	; 0x179a <usart_init_rs232+0x1b0>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    1792:	60 e2       	ldi	r22, 0x20	; 32
    1794:	83 e0       	ldi	r24, 0x03	; 3
    1796:	5d d8       	rcall	.-3910   	; 0x852 <sysclk_enable_module>
    1798:	17 c0       	rjmp	.+46     	; 0x17c8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    179a:	c0 3b       	cpi	r28, 0xB0	; 176
    179c:	e9 e0       	ldi	r30, 0x09	; 9
    179e:	de 07       	cpc	r29, r30
    17a0:	21 f4       	brne	.+8      	; 0x17aa <usart_init_rs232+0x1c0>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    17a2:	60 e2       	ldi	r22, 0x20	; 32
    17a4:	84 e0       	ldi	r24, 0x04	; 4
    17a6:	55 d8       	rcall	.-3926   	; 0x852 <sysclk_enable_module>
    17a8:	0f c0       	rjmp	.+30     	; 0x17c8 <usart_init_rs232+0x1de>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    17aa:	c0 38       	cpi	r28, 0x80	; 128
    17ac:	f4 e0       	ldi	r31, 0x04	; 4
    17ae:	df 07       	cpc	r29, r31
    17b0:	21 f4       	brne	.+8      	; 0x17ba <usart_init_rs232+0x1d0>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    17b2:	60 e4       	ldi	r22, 0x40	; 64
    17b4:	83 e0       	ldi	r24, 0x03	; 3
    17b6:	4d d8       	rcall	.-3942   	; 0x852 <sysclk_enable_module>
    17b8:	07 c0       	rjmp	.+14     	; 0x17c8 <usart_init_rs232+0x1de>
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    17ba:	c0 3a       	cpi	r28, 0xA0	; 160
    17bc:	84 e0       	ldi	r24, 0x04	; 4
    17be:	d8 07       	cpc	r29, r24
    17c0:	19 f4       	brne	.+6      	; 0x17c8 <usart_init_rs232+0x1de>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    17c2:	60 e4       	ldi	r22, 0x40	; 64
    17c4:	85 e0       	ldi	r24, 0x05	; 5
    17c6:	45 d8       	rcall	.-3958   	; 0x852 <sysclk_enable_module>
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    17c8:	8d 81       	ldd	r24, Y+5	; 0x05
    17ca:	8f 73       	andi	r24, 0x3F	; 63
    17cc:	8d 83       	std	Y+5, r24	; 0x05
 *  \param twoStopBits Enable two stop bit mode. Use bool type.
 */
static inline void usart_format_set(USART_t *usart, USART_CHSIZE_t charSize,
		USART_PMODE_t parityMode, bool twoStopBits)
{
	(usart)->CTRLC = (uint8_t)charSize | parityMode
    17ce:	f8 01       	movw	r30, r16
    17d0:	94 81       	ldd	r25, Z+4	; 0x04
    17d2:	85 81       	ldd	r24, Z+5	; 0x05
    17d4:	89 2b       	or	r24, r25
    17d6:	96 81       	ldd	r25, Z+6	; 0x06
    17d8:	91 11       	cpse	r25, r1
    17da:	98 e0       	ldi	r25, 0x08	; 8
    17dc:	89 2b       	or	r24, r25
    17de:	8d 83       	std	Y+5, r24	; 0x05
	bool result;
	sysclk_enable_peripheral_clock(usart);
	usart_set_mode(usart, USART_CMODE_ASYNCHRONOUS_gc);
	usart_format_set(usart, opt->charlength, opt->paritytype,
			opt->stopbits);
	result = usart_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    17e0:	f8 01       	movw	r30, r16
    17e2:	40 81       	ld	r20, Z
    17e4:	51 81       	ldd	r21, Z+1	; 0x01
    17e6:	62 81       	ldd	r22, Z+2	; 0x02
    17e8:	73 81       	ldd	r23, Z+3	; 0x03
    17ea:	00 e8       	ldi	r16, 0x80	; 128
    17ec:	14 e8       	ldi	r17, 0x84	; 132
    17ee:	2e e1       	ldi	r18, 0x1E	; 30
    17f0:	30 e0       	ldi	r19, 0x00	; 0
    17f2:	ce 01       	movw	r24, r28
    17f4:	e1 dd       	rcall	.-1086   	; 0x13b8 <usart_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    17f6:	9c 81       	ldd	r25, Y+4	; 0x04
    17f8:	98 60       	ori	r25, 0x08	; 8
    17fa:	9c 83       	std	Y+4, r25	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    17fc:	9c 81       	ldd	r25, Y+4	; 0x04
    17fe:	90 61       	ori	r25, 0x10	; 16
    1800:	9c 83       	std	Y+4, r25	; 0x04
	usart_tx_enable(usart);
	usart_rx_enable(usart);
	
	return result;
}
    1802:	df 91       	pop	r29
    1804:	cf 91       	pop	r28
    1806:	1f 91       	pop	r17
    1808:	0f 91       	pop	r16
    180a:	08 95       	ret

0000180c <usart_spi_set_baudrate>:
 * \param usart The USART(SPI) module.
 * \param baud The baudrate.
 * \param cpu_hz The CPU frequency.
 */
void usart_spi_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    180c:	cf 92       	push	r12
    180e:	df 92       	push	r13
    1810:	ef 92       	push	r14
    1812:	ff 92       	push	r15
    1814:	0f 93       	push	r16
    1816:	1f 93       	push	r17
    1818:	cf 93       	push	r28
    181a:	df 93       	push	r29
    181c:	ec 01       	movw	r28, r24
	uint16_t bsel_value;

	/* Check if baudrate is less than the maximim limit specified in
	 * datasheet */
	if (baud < (cpu_hz / 2)) {
    181e:	d9 01       	movw	r26, r18
    1820:	c8 01       	movw	r24, r16
    1822:	b6 95       	lsr	r27
    1824:	a7 95       	ror	r26
    1826:	97 95       	ror	r25
    1828:	87 95       	ror	r24
    182a:	48 17       	cp	r20, r24
    182c:	59 07       	cpc	r21, r25
    182e:	6a 07       	cpc	r22, r26
    1830:	7b 07       	cpc	r23, r27
    1832:	78 f4       	brcc	.+30     	; 0x1852 <usart_spi_set_baudrate+0x46>
		bsel_value = (cpu_hz / (baud * 2)) - 1;
    1834:	6a 01       	movw	r12, r20
    1836:	7b 01       	movw	r14, r22
    1838:	cc 0c       	add	r12, r12
    183a:	dd 1c       	adc	r13, r13
    183c:	ee 1c       	adc	r14, r14
    183e:	ff 1c       	adc	r15, r15
    1840:	c9 01       	movw	r24, r18
    1842:	b8 01       	movw	r22, r16
    1844:	a7 01       	movw	r20, r14
    1846:	96 01       	movw	r18, r12
    1848:	0e 94 27 1c 	call	0x384e	; 0x384e <__udivmodsi4>
    184c:	21 50       	subi	r18, 0x01	; 1
    184e:	31 09       	sbc	r19, r1
    1850:	02 c0       	rjmp	.+4      	; 0x1856 <usart_spi_set_baudrate+0x4a>
	} else {
		/* If baudrate is not within the specfication in datasheet,
		 * assign maximum baudrate possible for the current CPU frequency */
		bsel_value = 0;
    1852:	20 e0       	ldi	r18, 0x00	; 0
    1854:	30 e0       	ldi	r19, 0x00	; 0
	}

	(usart)->BAUDCTRLB = (uint8_t)((~USART_BSCALE_gm) & (bsel_value >> 8));
    1856:	83 2f       	mov	r24, r19
    1858:	8f 70       	andi	r24, 0x0F	; 15
    185a:	8f 83       	std	Y+7, r24	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)(bsel_value);
    185c:	2e 83       	std	Y+6, r18	; 0x06
}
    185e:	df 91       	pop	r29
    1860:	cf 91       	pop	r28
    1862:	1f 91       	pop	r17
    1864:	0f 91       	pop	r16
    1866:	ff 90       	pop	r15
    1868:	ef 90       	pop	r14
    186a:	df 90       	pop	r13
    186c:	cf 90       	pop	r12
    186e:	08 95       	ret

00001870 <usart_init_spi>:
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    1870:	ef 92       	push	r14
    1872:	ff 92       	push	r15
    1874:	0f 93       	push	r16
    1876:	1f 93       	push	r17
    1878:	cf 93       	push	r28
    187a:	df 93       	push	r29
    187c:	ec 01       	movw	r28, r24
    187e:	7b 01       	movw	r14, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    1880:	00 97       	sbiw	r24, 0x00	; 0
    1882:	09 f4       	brne	.+2      	; 0x1886 <usart_init_spi+0x16>
    1884:	98 c1       	rjmp	.+816    	; 0x1bb6 <usart_init_spi+0x346>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    1886:	80 3c       	cpi	r24, 0xC0	; 192
    1888:	91 05       	cpc	r25, r1
    188a:	29 f4       	brne	.+10     	; 0x1896 <usart_init_spi+0x26>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    188c:	60 e1       	ldi	r22, 0x10	; 16
    188e:	80 e0       	ldi	r24, 0x00	; 0
    1890:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1894:	90 c1       	rjmp	.+800    	; 0x1bb6 <usart_init_spi+0x346>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    1896:	80 38       	cpi	r24, 0x80	; 128
    1898:	91 40       	sbci	r25, 0x01	; 1
    189a:	29 f4       	brne	.+10     	; 0x18a6 <usart_init_spi+0x36>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    189c:	62 e0       	ldi	r22, 0x02	; 2
    189e:	80 e0       	ldi	r24, 0x00	; 0
    18a0:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    18a4:	88 c1       	rjmp	.+784    	; 0x1bb6 <usart_init_spi+0x346>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    18a6:	c1 15       	cp	r28, r1
    18a8:	81 e0       	ldi	r24, 0x01	; 1
    18aa:	d8 07       	cpc	r29, r24
    18ac:	29 f4       	brne	.+10     	; 0x18b8 <usart_init_spi+0x48>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    18ae:	61 e0       	ldi	r22, 0x01	; 1
    18b0:	80 e0       	ldi	r24, 0x00	; 0
    18b2:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    18b6:	7f c1       	rjmp	.+766    	; 0x1bb6 <usart_init_spi+0x346>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    18b8:	c0 38       	cpi	r28, 0x80	; 128
    18ba:	e3 e0       	ldi	r30, 0x03	; 3
    18bc:	de 07       	cpc	r29, r30
    18be:	29 f4       	brne	.+10     	; 0x18ca <usart_init_spi+0x5a>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    18c0:	61 e0       	ldi	r22, 0x01	; 1
    18c2:	81 e0       	ldi	r24, 0x01	; 1
    18c4:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    18c8:	76 c1       	rjmp	.+748    	; 0x1bb6 <usart_init_spi+0x346>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    18ca:	c0 39       	cpi	r28, 0x90	; 144
    18cc:	f3 e0       	ldi	r31, 0x03	; 3
    18ce:	df 07       	cpc	r29, r31
    18d0:	29 f4       	brne	.+10     	; 0x18dc <usart_init_spi+0x6c>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    18d2:	61 e0       	ldi	r22, 0x01	; 1
    18d4:	82 e0       	ldi	r24, 0x02	; 2
    18d6:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    18da:	6d c1       	rjmp	.+730    	; 0x1bb6 <usart_init_spi+0x346>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    18dc:	c1 15       	cp	r28, r1
    18de:	32 e0       	ldi	r19, 0x02	; 2
    18e0:	d3 07       	cpc	r29, r19
    18e2:	29 f4       	brne	.+10     	; 0x18ee <usart_init_spi+0x7e>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    18e4:	62 e0       	ldi	r22, 0x02	; 2
    18e6:	81 e0       	ldi	r24, 0x01	; 1
    18e8:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    18ec:	64 c1       	rjmp	.+712    	; 0x1bb6 <usart_init_spi+0x346>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    18ee:	c0 34       	cpi	r28, 0x40	; 64
    18f0:	82 e0       	ldi	r24, 0x02	; 2
    18f2:	d8 07       	cpc	r29, r24
    18f4:	29 f4       	brne	.+10     	; 0x1900 <usart_init_spi+0x90>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    18f6:	62 e0       	ldi	r22, 0x02	; 2
    18f8:	82 e0       	ldi	r24, 0x02	; 2
    18fa:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    18fe:	5b c1       	rjmp	.+694    	; 0x1bb6 <usart_init_spi+0x346>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    1900:	c0 32       	cpi	r28, 0x20	; 32
    1902:	e3 e0       	ldi	r30, 0x03	; 3
    1904:	de 07       	cpc	r29, r30
    1906:	29 f4       	brne	.+10     	; 0x1912 <usart_init_spi+0xa2>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    1908:	64 e0       	ldi	r22, 0x04	; 4
    190a:	82 e0       	ldi	r24, 0x02	; 2
    190c:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1910:	52 c1       	rjmp	.+676    	; 0x1bb6 <usart_init_spi+0x346>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    1912:	c1 15       	cp	r28, r1
    1914:	f8 e0       	ldi	r31, 0x08	; 8
    1916:	df 07       	cpc	r29, r31
    1918:	29 f4       	brne	.+10     	; 0x1924 <usart_init_spi+0xb4>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    191a:	61 e0       	ldi	r22, 0x01	; 1
    191c:	83 e0       	ldi	r24, 0x03	; 3
    191e:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1922:	49 c1       	rjmp	.+658    	; 0x1bb6 <usart_init_spi+0x346>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    1924:	c1 15       	cp	r28, r1
    1926:	39 e0       	ldi	r19, 0x09	; 9
    1928:	d3 07       	cpc	r29, r19
    192a:	29 f4       	brne	.+10     	; 0x1936 <usart_init_spi+0xc6>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    192c:	61 e0       	ldi	r22, 0x01	; 1
    192e:	84 e0       	ldi	r24, 0x04	; 4
    1930:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1934:	40 c1       	rjmp	.+640    	; 0x1bb6 <usart_init_spi+0x346>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    1936:	c1 15       	cp	r28, r1
    1938:	8a e0       	ldi	r24, 0x0A	; 10
    193a:	d8 07       	cpc	r29, r24
    193c:	29 f4       	brne	.+10     	; 0x1948 <usart_init_spi+0xd8>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    193e:	61 e0       	ldi	r22, 0x01	; 1
    1940:	85 e0       	ldi	r24, 0x05	; 5
    1942:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1946:	37 c1       	rjmp	.+622    	; 0x1bb6 <usart_init_spi+0x346>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    1948:	c1 15       	cp	r28, r1
    194a:	eb e0       	ldi	r30, 0x0B	; 11
    194c:	de 07       	cpc	r29, r30
    194e:	29 f4       	brne	.+10     	; 0x195a <usart_init_spi+0xea>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    1950:	61 e0       	ldi	r22, 0x01	; 1
    1952:	86 e0       	ldi	r24, 0x06	; 6
    1954:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1958:	2e c1       	rjmp	.+604    	; 0x1bb6 <usart_init_spi+0x346>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    195a:	c0 34       	cpi	r28, 0x40	; 64
    195c:	f8 e0       	ldi	r31, 0x08	; 8
    195e:	df 07       	cpc	r29, r31
    1960:	29 f4       	brne	.+10     	; 0x196c <usart_init_spi+0xfc>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    1962:	62 e0       	ldi	r22, 0x02	; 2
    1964:	83 e0       	ldi	r24, 0x03	; 3
    1966:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    196a:	25 c1       	rjmp	.+586    	; 0x1bb6 <usart_init_spi+0x346>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    196c:	c0 34       	cpi	r28, 0x40	; 64
    196e:	39 e0       	ldi	r19, 0x09	; 9
    1970:	d3 07       	cpc	r29, r19
    1972:	29 f4       	brne	.+10     	; 0x197e <usart_init_spi+0x10e>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    1974:	62 e0       	ldi	r22, 0x02	; 2
    1976:	84 e0       	ldi	r24, 0x04	; 4
    1978:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    197c:	1c c1       	rjmp	.+568    	; 0x1bb6 <usart_init_spi+0x346>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    197e:	c0 34       	cpi	r28, 0x40	; 64
    1980:	8a e0       	ldi	r24, 0x0A	; 10
    1982:	d8 07       	cpc	r29, r24
    1984:	29 f4       	brne	.+10     	; 0x1990 <usart_init_spi+0x120>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    1986:	62 e0       	ldi	r22, 0x02	; 2
    1988:	85 e0       	ldi	r24, 0x05	; 5
    198a:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    198e:	13 c1       	rjmp	.+550    	; 0x1bb6 <usart_init_spi+0x346>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    1990:	c0 39       	cpi	r28, 0x90	; 144
    1992:	e8 e0       	ldi	r30, 0x08	; 8
    1994:	de 07       	cpc	r29, r30
    1996:	29 f4       	brne	.+10     	; 0x19a2 <usart_init_spi+0x132>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    1998:	64 e0       	ldi	r22, 0x04	; 4
    199a:	83 e0       	ldi	r24, 0x03	; 3
    199c:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    19a0:	0a c1       	rjmp	.+532    	; 0x1bb6 <usart_init_spi+0x346>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    19a2:	c0 39       	cpi	r28, 0x90	; 144
    19a4:	f9 e0       	ldi	r31, 0x09	; 9
    19a6:	df 07       	cpc	r29, r31
    19a8:	29 f4       	brne	.+10     	; 0x19b4 <usart_init_spi+0x144>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    19aa:	64 e0       	ldi	r22, 0x04	; 4
    19ac:	84 e0       	ldi	r24, 0x04	; 4
    19ae:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    19b2:	01 c1       	rjmp	.+514    	; 0x1bb6 <usart_init_spi+0x346>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    19b4:	c0 39       	cpi	r28, 0x90	; 144
    19b6:	3a e0       	ldi	r19, 0x0A	; 10
    19b8:	d3 07       	cpc	r29, r19
    19ba:	29 f4       	brne	.+10     	; 0x19c6 <usart_init_spi+0x156>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    19bc:	64 e0       	ldi	r22, 0x04	; 4
    19be:	85 e0       	ldi	r24, 0x05	; 5
    19c0:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    19c4:	f8 c0       	rjmp	.+496    	; 0x1bb6 <usart_init_spi+0x346>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    19c6:	c0 39       	cpi	r28, 0x90	; 144
    19c8:	8b e0       	ldi	r24, 0x0B	; 11
    19ca:	d8 07       	cpc	r29, r24
    19cc:	29 f4       	brne	.+10     	; 0x19d8 <usart_init_spi+0x168>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    19ce:	64 e0       	ldi	r22, 0x04	; 4
    19d0:	86 e0       	ldi	r24, 0x06	; 6
    19d2:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    19d6:	ef c0       	rjmp	.+478    	; 0x1bb6 <usart_init_spi+0x346>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    19d8:	c0 3c       	cpi	r28, 0xC0	; 192
    19da:	e8 e0       	ldi	r30, 0x08	; 8
    19dc:	de 07       	cpc	r29, r30
    19de:	29 f4       	brne	.+10     	; 0x19ea <usart_init_spi+0x17a>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    19e0:	68 e0       	ldi	r22, 0x08	; 8
    19e2:	83 e0       	ldi	r24, 0x03	; 3
    19e4:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    19e8:	e6 c0       	rjmp	.+460    	; 0x1bb6 <usart_init_spi+0x346>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    19ea:	c0 3c       	cpi	r28, 0xC0	; 192
    19ec:	f9 e0       	ldi	r31, 0x09	; 9
    19ee:	df 07       	cpc	r29, r31
    19f0:	29 f4       	brne	.+10     	; 0x19fc <usart_init_spi+0x18c>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    19f2:	68 e0       	ldi	r22, 0x08	; 8
    19f4:	84 e0       	ldi	r24, 0x04	; 4
    19f6:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    19fa:	dd c0       	rjmp	.+442    	; 0x1bb6 <usart_init_spi+0x346>
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    19fc:	c0 3a       	cpi	r28, 0xA0	; 160
    19fe:	38 e0       	ldi	r19, 0x08	; 8
    1a00:	d3 07       	cpc	r29, r19
    1a02:	69 f4       	brne	.+26     	; 0x1a1e <usart_init_spi+0x1ae>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    1a04:	60 e1       	ldi	r22, 0x10	; 16
    1a06:	83 e0       	ldi	r24, 0x03	; 3
    1a08:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    1a0c:	e0 ea       	ldi	r30, 0xA0	; 160
    1a0e:	f8 e0       	ldi	r31, 0x08	; 8
    1a10:	84 81       	ldd	r24, Z+4	; 0x04
    1a12:	8f 7e       	andi	r24, 0xEF	; 239
    1a14:	84 83       	std	Z+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    1a16:	f7 01       	movw	r30, r14
    1a18:	24 81       	ldd	r18, Z+4	; 0x04
    1a1a:	22 50       	subi	r18, 0x02	; 2
    1a1c:	4a c0       	rjmp	.+148    	; 0x1ab2 <usart_init_spi+0x242>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    1a1e:	c0 3a       	cpi	r28, 0xA0	; 160
    1a20:	f9 e0       	ldi	r31, 0x09	; 9
    1a22:	df 07       	cpc	r29, r31
    1a24:	29 f4       	brne	.+10     	; 0x1a30 <usart_init_spi+0x1c0>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    1a26:	60 e1       	ldi	r22, 0x10	; 16
    1a28:	84 e0       	ldi	r24, 0x04	; 4
    1a2a:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1a2e:	c3 c0       	rjmp	.+390    	; 0x1bb6 <usart_init_spi+0x346>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    1a30:	c0 3a       	cpi	r28, 0xA0	; 160
    1a32:	3a e0       	ldi	r19, 0x0A	; 10
    1a34:	d3 07       	cpc	r29, r19
    1a36:	29 f4       	brne	.+10     	; 0x1a42 <usart_init_spi+0x1d2>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    1a38:	60 e1       	ldi	r22, 0x10	; 16
    1a3a:	85 e0       	ldi	r24, 0x05	; 5
    1a3c:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1a40:	ba c0       	rjmp	.+372    	; 0x1bb6 <usart_init_spi+0x346>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    1a42:	c0 3a       	cpi	r28, 0xA0	; 160
    1a44:	8b e0       	ldi	r24, 0x0B	; 11
    1a46:	d8 07       	cpc	r29, r24
    1a48:	29 f4       	brne	.+10     	; 0x1a54 <usart_init_spi+0x1e4>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    1a4a:	60 e1       	ldi	r22, 0x10	; 16
    1a4c:	86 e0       	ldi	r24, 0x06	; 6
    1a4e:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1a52:	b1 c0       	rjmp	.+354    	; 0x1bb6 <usart_init_spi+0x346>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    1a54:	c0 3b       	cpi	r28, 0xB0	; 176
    1a56:	e8 e0       	ldi	r30, 0x08	; 8
    1a58:	de 07       	cpc	r29, r30
    1a5a:	29 f4       	brne	.+10     	; 0x1a66 <usart_init_spi+0x1f6>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    1a5c:	60 e2       	ldi	r22, 0x20	; 32
    1a5e:	83 e0       	ldi	r24, 0x03	; 3
    1a60:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1a64:	a8 c0       	rjmp	.+336    	; 0x1bb6 <usart_init_spi+0x346>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    1a66:	c0 3b       	cpi	r28, 0xB0	; 176
    1a68:	f9 e0       	ldi	r31, 0x09	; 9
    1a6a:	df 07       	cpc	r29, r31
    1a6c:	29 f4       	brne	.+10     	; 0x1a78 <usart_init_spi+0x208>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    1a6e:	60 e2       	ldi	r22, 0x20	; 32
    1a70:	84 e0       	ldi	r24, 0x04	; 4
    1a72:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1a76:	9f c0       	rjmp	.+318    	; 0x1bb6 <usart_init_spi+0x346>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    1a78:	c0 38       	cpi	r28, 0x80	; 128
    1a7a:	34 e0       	ldi	r19, 0x04	; 4
    1a7c:	d3 07       	cpc	r29, r19
    1a7e:	29 f4       	brne	.+10     	; 0x1a8a <usart_init_spi+0x21a>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    1a80:	60 e4       	ldi	r22, 0x40	; 64
    1a82:	83 e0       	ldi	r24, 0x03	; 3
    1a84:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1a88:	96 c0       	rjmp	.+300    	; 0x1bb6 <usart_init_spi+0x346>
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    1a8a:	c0 3a       	cpi	r28, 0xA0	; 160
    1a8c:	84 e0       	ldi	r24, 0x04	; 4
    1a8e:	d8 07       	cpc	r29, r24
    1a90:	29 f4       	brne	.+10     	; 0x1a9c <usart_init_spi+0x22c>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    1a92:	60 e4       	ldi	r22, 0x40	; 64
    1a94:	85 e0       	ldi	r24, 0x05	; 5
    1a96:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1a9a:	8d c0       	rjmp	.+282    	; 0x1bb6 <usart_init_spi+0x346>
    1a9c:	8c 81       	ldd	r24, Y+4	; 0x04
    1a9e:	8f 7e       	andi	r24, 0xEF	; 239
    1aa0:	8c 83       	std	Y+4, r24	; 0x04
    1aa2:	fb 01       	movw	r30, r22
    1aa4:	24 81       	ldd	r18, Z+4	; 0x04
    1aa6:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    1aa8:	ce 01       	movw	r24, r28
    1aaa:	c0 3a       	cpi	r28, 0xA0	; 160
    1aac:	f8 e0       	ldi	r31, 0x08	; 8
    1aae:	df 07       	cpc	r29, r31
    1ab0:	31 f4       	brne	.+12     	; 0x1abe <usart_init_spi+0x24e>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
    1ab2:	80 91 4e 06 	lds	r24, 0x064E	; 0x80064e <__TEXT_REGION_LENGTH__+0x70064e>
    1ab6:	84 fd       	sbrc	r24, 4
    1ab8:	86 c0       	rjmp	.+268    	; 0x1bc6 <usart_init_spi+0x356>
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
    1aba:	11 e1       	ldi	r17, 0x11	; 17
    1abc:	85 c0       	rjmp	.+266    	; 0x1bc8 <usart_init_spi+0x358>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
    1abe:	80 3b       	cpi	r24, 0xB0	; 176
    1ac0:	38 e0       	ldi	r19, 0x08	; 8
    1ac2:	93 07       	cpc	r25, r19
    1ac4:	79 f0       	breq	.+30     	; 0x1ae4 <usart_init_spi+0x274>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
	}
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
    1ac6:	80 3a       	cpi	r24, 0xA0	; 160
    1ac8:	e9 e0       	ldi	r30, 0x09	; 9
    1aca:	9e 07       	cpc	r25, r30
    1acc:	31 f4       	brne	.+12     	; 0x1ada <usart_init_spi+0x26a>
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
    1ace:	30 91 6e 06 	lds	r19, 0x066E	; 0x80066e <__TEXT_REGION_LENGTH__+0x70066e>
    1ad2:	34 fd       	sbrc	r19, 4
    1ad4:	7c c0       	rjmp	.+248    	; 0x1bce <usart_init_spi+0x35e>
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
    1ad6:	19 e1       	ldi	r17, 0x19	; 25
    1ad8:	10 c0       	rjmp	.+32     	; 0x1afa <usart_init_spi+0x28a>
		sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
    1ada:	80 3b       	cpi	r24, 0xB0	; 176
    1adc:	f9 e0       	ldi	r31, 0x09	; 9
    1ade:	9f 07       	cpc	r25, r31
    1ae0:	a9 f0       	breq	.+42     	; 0x1b0c <usart_init_spi+0x29c>
    1ae2:	01 c0       	rjmp	.+2      	; 0x1ae6 <usart_init_spi+0x276>
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    1ae4:	15 e1       	ldi	r17, 0x15	; 21
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
	}
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
    1ae6:	80 3a       	cpi	r24, 0xA0	; 160
    1ae8:	3a e0       	ldi	r19, 0x0A	; 10
    1aea:	93 07       	cpc	r25, r19
    1aec:	31 f4       	brne	.+12     	; 0x1afa <usart_init_spi+0x28a>
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
    1aee:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <__TEXT_REGION_LENGTH__+0x70068e>
    1af2:	84 fd       	sbrc	r24, 4
    1af4:	6e c0       	rjmp	.+220    	; 0x1bd2 <usart_init_spi+0x362>
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 1);
    1af6:	11 e2       	ldi	r17, 0x21	; 33
    1af8:	0c c0       	rjmp	.+24     	; 0x1b12 <usart_init_spi+0x2a2>
	if ((uint16_t)usart == (uint16_t)&USARTE1) {
		sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
	}
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
    1afa:	80 3a       	cpi	r24, 0xA0	; 160
    1afc:	9b 40       	sbci	r25, 0x0B	; 11
    1afe:	49 f4       	brne	.+18     	; 0x1b12 <usart_init_spi+0x2a2>
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
    1b00:	80 91 ae 06 	lds	r24, 0x06AE	; 0x8006ae <__TEXT_REGION_LENGTH__+0x7006ae>
    1b04:	84 fd       	sbrc	r24, 4
    1b06:	04 c0       	rjmp	.+8      	; 0x1b10 <usart_init_spi+0x2a0>
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 1);
    1b08:	19 e2       	ldi	r17, 0x29	; 41
    1b0a:	03 c0       	rjmp	.+6      	; 0x1b12 <usart_init_spi+0x2a2>
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    1b0c:	1d e1       	ldi	r17, 0x1D	; 29
    1b0e:	01 c0       	rjmp	.+2      	; 0x1b12 <usart_init_spi+0x2a2>
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
    1b10:	1d e2       	ldi	r17, 0x2D	; 45
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
    1b12:	e1 2f       	mov	r30, r17
    1b14:	e6 95       	lsr	r30
    1b16:	e6 95       	lsr	r30
    1b18:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
    1b1a:	30 e2       	ldi	r19, 0x20	; 32
    1b1c:	e3 9f       	mul	r30, r19
    1b1e:	f0 01       	movw	r30, r0
    1b20:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    1b22:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    1b24:	17 70       	andi	r17, 0x07	; 7
    1b26:	81 e0       	ldi	r24, 0x01	; 1
    1b28:	90 e0       	ldi	r25, 0x00	; 0
    1b2a:	01 2e       	mov	r0, r17
    1b2c:	02 c0       	rjmp	.+4      	; 0x1b32 <usart_init_spi+0x2c2>
    1b2e:	88 0f       	add	r24, r24
    1b30:	99 1f       	adc	r25, r25
    1b32:	0a 94       	dec	r0
    1b34:	e2 f7       	brpl	.-8      	; 0x1b2e <usart_init_spi+0x2be>
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    1b36:	81 83       	std	Z+1, r24	; 0x01
	}
#endif

	/* Configure the USART output pin */
	ioport_set_pin_dir(sck_pin, IOPORT_DIR_OUTPUT);
	ioport_set_pin_mode(sck_pin,
    1b38:	22 30       	cpi	r18, 0x02	; 2
    1b3a:	10 f0       	brcs	.+4      	; 0x1b40 <usart_init_spi+0x2d0>
    1b3c:	40 e0       	ldi	r20, 0x00	; 0
    1b3e:	01 c0       	rjmp	.+2      	; 0x1b42 <usart_init_spi+0x2d2>
    1b40:	40 e4       	ldi	r20, 0x40	; 64
__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));
    1b42:	df 01       	movw	r26, r30
    1b44:	50 96       	adiw	r26, 0x10	; 16

__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
    1b46:	a1 0f       	add	r26, r17
    1b48:	b1 1d       	adc	r27, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1b4a:	3f b7       	in	r19, 0x3f	; 63
	cpu_irq_disable();
    1b4c:	f8 94       	cli
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));

	uint8_t flags = cpu_irq_save();

	*pin_ctrl &= PORT_ISC_gm;
    1b4e:	2c 91       	ld	r18, X
    1b50:	27 70       	andi	r18, 0x07	; 7
    1b52:	2c 93       	st	X, r18
	*pin_ctrl |= mode;
    1b54:	9c 91       	ld	r25, X
    1b56:	94 2b       	or	r25, r20
    1b58:	9c 93       	st	X, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1b5a:	3f bf       	out	0x3f, r19	; 63
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    1b5c:	85 83       	std	Z+5, r24	; 0x05
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    1b5e:	8d 81       	ldd	r24, Y+5	; 0x05
    1b60:	80 6c       	ori	r24, 0xC0	; 192
    1b62:	8d 83       	std	Y+5, r24	; 0x05
			IOPORT_MODE_TOTEM | (invert_sck? IOPORT_MODE_INVERT_PIN : 0));
	ioport_set_pin_level(sck_pin, IOPORT_PIN_LEVEL_HIGH);

	usart_set_mode(usart, USART_CMODE_MSPI_gc);

	if (opt->spimode == 1 || opt->spimode == 3) {
    1b64:	f7 01       	movw	r30, r14
    1b66:	84 81       	ldd	r24, Z+4	; 0x04
    1b68:	8d 7f       	andi	r24, 0xFD	; 253
    1b6a:	81 30       	cpi	r24, 0x01	; 1
    1b6c:	21 f4       	brne	.+8      	; 0x1b76 <usart_init_spi+0x306>
		usart->CTRLC |= USART_UCPHA_bm;
    1b6e:	8d 81       	ldd	r24, Y+5	; 0x05
    1b70:	82 60       	ori	r24, 0x02	; 2
    1b72:	8d 83       	std	Y+5, r24	; 0x05
    1b74:	03 c0       	rjmp	.+6      	; 0x1b7c <usart_init_spi+0x30c>
	} else {
		usart->CTRLC &= ~USART_UCPHA_bm;
    1b76:	8d 81       	ldd	r24, Y+5	; 0x05
    1b78:	8d 7f       	andi	r24, 0xFD	; 253
    1b7a:	8d 83       	std	Y+5, r24	; 0x05
	}
	if (opt->data_order) {
    1b7c:	f7 01       	movw	r30, r14
    1b7e:	85 81       	ldd	r24, Z+5	; 0x05
    1b80:	88 23       	and	r24, r24
    1b82:	21 f0       	breq	.+8      	; 0x1b8c <usart_init_spi+0x31c>
		(usart)->CTRLC |= USART_DORD_bm;
    1b84:	8d 81       	ldd	r24, Y+5	; 0x05
    1b86:	84 60       	ori	r24, 0x04	; 4
    1b88:	8d 83       	std	Y+5, r24	; 0x05
    1b8a:	03 c0       	rjmp	.+6      	; 0x1b92 <usart_init_spi+0x322>
	} else {
		(usart)->CTRLC &= ~USART_DORD_bm;
    1b8c:	8d 81       	ldd	r24, Y+5	; 0x05
    1b8e:	8b 7f       	andi	r24, 0xFB	; 251
    1b90:	8d 83       	std	Y+5, r24	; 0x05
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    1b92:	f7 01       	movw	r30, r14
    1b94:	40 81       	ld	r20, Z
    1b96:	51 81       	ldd	r21, Z+1	; 0x01
    1b98:	62 81       	ldd	r22, Z+2	; 0x02
    1b9a:	73 81       	ldd	r23, Z+3	; 0x03
    1b9c:	00 e8       	ldi	r16, 0x80	; 128
    1b9e:	14 e8       	ldi	r17, 0x84	; 132
    1ba0:	2e e1       	ldi	r18, 0x1E	; 30
    1ba2:	30 e0       	ldi	r19, 0x00	; 0
    1ba4:	ce 01       	movw	r24, r28
    1ba6:	32 de       	rcall	.-924    	; 0x180c <usart_spi_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    1ba8:	8c 81       	ldd	r24, Y+4	; 0x04
    1baa:	88 60       	ori	r24, 0x08	; 8
    1bac:	8c 83       	std	Y+4, r24	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    1bae:	8c 81       	ldd	r24, Y+4	; 0x04
    1bb0:	80 61       	ori	r24, 0x10	; 16
    1bb2:	8c 83       	std	Y+4, r24	; 0x04
    1bb4:	10 c0       	rjmp	.+32     	; 0x1bd6 <usart_init_spi+0x366>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    1bb6:	8c 81       	ldd	r24, Y+4	; 0x04
    1bb8:	8f 7e       	andi	r24, 0xEF	; 239
    1bba:	8c 83       	std	Y+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    1bbc:	f7 01       	movw	r30, r14
    1bbe:	24 81       	ldd	r18, Z+4	; 0x04
    1bc0:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    1bc2:	ce 01       	movw	r24, r28
    1bc4:	7c cf       	rjmp	.-264    	; 0x1abe <usart_init_spi+0x24e>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    1bc6:	15 e1       	ldi	r17, 0x15	; 21
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    1bc8:	80 ea       	ldi	r24, 0xA0	; 160
    1bca:	98 e0       	ldi	r25, 0x08	; 8
    1bcc:	86 cf       	rjmp	.-244    	; 0x1ada <usart_init_spi+0x26a>
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    1bce:	1d e1       	ldi	r17, 0x1D	; 29
    1bd0:	94 cf       	rjmp	.-216    	; 0x1afa <usart_init_spi+0x28a>
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
    1bd2:	15 e2       	ldi	r17, 0x25	; 37
    1bd4:	9e cf       	rjmp	.-196    	; 0x1b12 <usart_init_spi+0x2a2>
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    1bd6:	df 91       	pop	r29
    1bd8:	cf 91       	pop	r28
    1bda:	1f 91       	pop	r17
    1bdc:	0f 91       	pop	r16
    1bde:	ff 90       	pop	r15
    1be0:	ef 90       	pop	r14
    1be2:	08 95       	ret

00001be4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1be4:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1be6:	03 96       	adiw	r24, 0x03	; 3
    1be8:	81 83       	std	Z+1, r24	; 0x01
    1bea:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1bec:	2f ef       	ldi	r18, 0xFF	; 255
    1bee:	3f ef       	ldi	r19, 0xFF	; 255
    1bf0:	23 83       	std	Z+3, r18	; 0x03
    1bf2:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bf4:	85 83       	std	Z+5, r24	; 0x05
    1bf6:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bf8:	87 83       	std	Z+7, r24	; 0x07
    1bfa:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1bfc:	10 82       	st	Z, r1
    1bfe:	08 95       	ret

00001c00 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1c00:	fc 01       	movw	r30, r24
    1c02:	10 86       	std	Z+8, r1	; 0x08
    1c04:	11 86       	std	Z+9, r1	; 0x09
    1c06:	08 95       	ret

00001c08 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1c08:	cf 93       	push	r28
    1c0a:	df 93       	push	r29
    1c0c:	9c 01       	movw	r18, r24
    1c0e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1c10:	dc 01       	movw	r26, r24
    1c12:	11 96       	adiw	r26, 0x01	; 1
    1c14:	cd 91       	ld	r28, X+
    1c16:	dc 91       	ld	r29, X
    1c18:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1c1a:	c2 83       	std	Z+2, r28	; 0x02
    1c1c:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1c1e:	8c 81       	ldd	r24, Y+4	; 0x04
    1c20:	9d 81       	ldd	r25, Y+5	; 0x05
    1c22:	84 83       	std	Z+4, r24	; 0x04
    1c24:	95 83       	std	Z+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1c26:	8c 81       	ldd	r24, Y+4	; 0x04
    1c28:	9d 81       	ldd	r25, Y+5	; 0x05
    1c2a:	dc 01       	movw	r26, r24
    1c2c:	12 96       	adiw	r26, 0x02	; 2
    1c2e:	6d 93       	st	X+, r22
    1c30:	7c 93       	st	X, r23
    1c32:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    1c34:	6c 83       	std	Y+4, r22	; 0x04
    1c36:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1c38:	20 87       	std	Z+8, r18	; 0x08
    1c3a:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    1c3c:	f9 01       	movw	r30, r18
    1c3e:	80 81       	ld	r24, Z
    1c40:	8f 5f       	subi	r24, 0xFF	; 255
    1c42:	80 83       	st	Z, r24
}
    1c44:	df 91       	pop	r29
    1c46:	cf 91       	pop	r28
    1c48:	08 95       	ret

00001c4a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1c4a:	cf 93       	push	r28
    1c4c:	df 93       	push	r29
    1c4e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1c50:	48 81       	ld	r20, Y
    1c52:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1c54:	4f 3f       	cpi	r20, 0xFF	; 255
    1c56:	2f ef       	ldi	r18, 0xFF	; 255
    1c58:	52 07       	cpc	r21, r18
    1c5a:	21 f4       	brne	.+8      	; 0x1c64 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1c5c:	fc 01       	movw	r30, r24
    1c5e:	a7 81       	ldd	r26, Z+7	; 0x07
    1c60:	b0 85       	ldd	r27, Z+8	; 0x08
    1c62:	0d c0       	rjmp	.+26     	; 0x1c7e <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c64:	dc 01       	movw	r26, r24
    1c66:	13 96       	adiw	r26, 0x03	; 3
    1c68:	01 c0       	rjmp	.+2      	; 0x1c6c <vListInsert+0x22>
    1c6a:	df 01       	movw	r26, r30
    1c6c:	12 96       	adiw	r26, 0x02	; 2
    1c6e:	ed 91       	ld	r30, X+
    1c70:	fc 91       	ld	r31, X
    1c72:	13 97       	sbiw	r26, 0x03	; 3
    1c74:	20 81       	ld	r18, Z
    1c76:	31 81       	ldd	r19, Z+1	; 0x01
    1c78:	42 17       	cp	r20, r18
    1c7a:	53 07       	cpc	r21, r19
    1c7c:	b0 f7       	brcc	.-20     	; 0x1c6a <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1c7e:	12 96       	adiw	r26, 0x02	; 2
    1c80:	ed 91       	ld	r30, X+
    1c82:	fc 91       	ld	r31, X
    1c84:	13 97       	sbiw	r26, 0x03	; 3
    1c86:	ea 83       	std	Y+2, r30	; 0x02
    1c88:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1c8a:	c4 83       	std	Z+4, r28	; 0x04
    1c8c:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    1c8e:	ac 83       	std	Y+4, r26	; 0x04
    1c90:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    1c92:	12 96       	adiw	r26, 0x02	; 2
    1c94:	cd 93       	st	X+, r28
    1c96:	dc 93       	st	X, r29
    1c98:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1c9a:	88 87       	std	Y+8, r24	; 0x08
    1c9c:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    1c9e:	fc 01       	movw	r30, r24
    1ca0:	20 81       	ld	r18, Z
    1ca2:	2f 5f       	subi	r18, 0xFF	; 255
    1ca4:	20 83       	st	Z, r18
}
    1ca6:	df 91       	pop	r29
    1ca8:	cf 91       	pop	r28
    1caa:	08 95       	ret

00001cac <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1cac:	cf 93       	push	r28
    1cae:	df 93       	push	r29
    1cb0:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1cb2:	a0 85       	ldd	r26, Z+8	; 0x08
    1cb4:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1cb6:	c2 81       	ldd	r28, Z+2	; 0x02
    1cb8:	d3 81       	ldd	r29, Z+3	; 0x03
    1cba:	84 81       	ldd	r24, Z+4	; 0x04
    1cbc:	95 81       	ldd	r25, Z+5	; 0x05
    1cbe:	8c 83       	std	Y+4, r24	; 0x04
    1cc0:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1cc2:	c4 81       	ldd	r28, Z+4	; 0x04
    1cc4:	d5 81       	ldd	r29, Z+5	; 0x05
    1cc6:	82 81       	ldd	r24, Z+2	; 0x02
    1cc8:	93 81       	ldd	r25, Z+3	; 0x03
    1cca:	8a 83       	std	Y+2, r24	; 0x02
    1ccc:	9b 83       	std	Y+3, r25	; 0x03

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1cce:	11 96       	adiw	r26, 0x01	; 1
    1cd0:	cd 91       	ld	r28, X+
    1cd2:	dc 91       	ld	r29, X
    1cd4:	12 97       	sbiw	r26, 0x02	; 2
    1cd6:	ce 17       	cp	r28, r30
    1cd8:	df 07       	cpc	r29, r31
    1cda:	31 f4       	brne	.+12     	; 0x1ce8 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1cdc:	8c 81       	ldd	r24, Y+4	; 0x04
    1cde:	9d 81       	ldd	r25, Y+5	; 0x05
    1ce0:	11 96       	adiw	r26, 0x01	; 1
    1ce2:	8d 93       	st	X+, r24
    1ce4:	9c 93       	st	X, r25
    1ce6:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1ce8:	10 86       	std	Z+8, r1	; 0x08
    1cea:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    1cec:	8c 91       	ld	r24, X
    1cee:	81 50       	subi	r24, 0x01	; 1
    1cf0:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    1cf2:	df 91       	pop	r29
    1cf4:	cf 91       	pop	r28
    1cf6:	08 95       	ret

00001cf8 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1cf8:	0f 93       	push	r16
    1cfa:	1f 93       	push	r17
    1cfc:	8b 01       	movw	r16, r22
uint16_t usAddress;

    /* Place a few bytes of known values on the bottom of the stack.
    This is just useful for debugging. */

    *pxTopOfStack = 0x11;
    1cfe:	71 e1       	ldi	r23, 0x11	; 17
    1d00:	fc 01       	movw	r30, r24
    1d02:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = 0x22;
    1d04:	31 97       	sbiw	r30, 0x01	; 1
    1d06:	62 e2       	ldi	r22, 0x22	; 34
    1d08:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = 0x33;
    1d0a:	31 97       	sbiw	r30, 0x01	; 1
    1d0c:	23 e3       	ldi	r18, 0x33	; 51
    1d0e:	20 83       	st	Z, r18

    /*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

    /* The start of the task code will be popped off the stack last, so place
    it on first. */
    ulAddress = ( uint32_t ) pxCode;
    1d10:	01 2e       	mov	r0, r17
    1d12:	00 0c       	add	r0, r0
    1d14:	22 0b       	sbc	r18, r18
    1d16:	33 0b       	sbc	r19, r19
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    1d18:	31 97       	sbiw	r30, 0x01	; 1
    1d1a:	00 83       	st	Z, r16
    pxTopOfStack--;

    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    1d1c:	31 97       	sbiw	r30, 0x01	; 1
    1d1e:	10 83       	st	Z, r17
    pxTopOfStack--;

#ifdef __AVR_3_BYTE_PC__
    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    1d20:	31 97       	sbiw	r30, 0x01	; 1
    1d22:	20 83       	st	Z, r18

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
    portSAVE_CONTEXT places the flags on the stack immediately after r0
    to ensure the interrupts get disabled as soon as possible, and so ensuring
    the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R0 */
    1d24:	31 97       	sbiw	r30, 0x01	; 1
    1d26:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = portFLAGS_INT_ENABLED;
    1d28:	31 97       	sbiw	r30, 0x01	; 1
    1d2a:	20 e8       	ldi	r18, 0x80	; 128
    1d2c:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Now the remaining registers.   The compiler expects R1 to be 0. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R1 */
    1d2e:	31 97       	sbiw	r30, 0x01	; 1
    1d30:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x02;   /* R2 */
    1d32:	31 97       	sbiw	r30, 0x01	; 1
    1d34:	22 e0       	ldi	r18, 0x02	; 2
    1d36:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x03;   /* R3 */
    1d38:	31 97       	sbiw	r30, 0x01	; 1
    1d3a:	23 e0       	ldi	r18, 0x03	; 3
    1d3c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x04;   /* R4 */
    1d3e:	31 97       	sbiw	r30, 0x01	; 1
    1d40:	24 e0       	ldi	r18, 0x04	; 4
    1d42:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x05;   /* R5 */
    1d44:	31 97       	sbiw	r30, 0x01	; 1
    1d46:	25 e0       	ldi	r18, 0x05	; 5
    1d48:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x06;   /* R6 */
    1d4a:	31 97       	sbiw	r30, 0x01	; 1
    1d4c:	26 e0       	ldi	r18, 0x06	; 6
    1d4e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x07;   /* R7 */
    1d50:	31 97       	sbiw	r30, 0x01	; 1
    1d52:	27 e0       	ldi	r18, 0x07	; 7
    1d54:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x08;   /* R8 */
    1d56:	31 97       	sbiw	r30, 0x01	; 1
    1d58:	28 e0       	ldi	r18, 0x08	; 8
    1d5a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x09;   /* R9 */
    1d5c:	31 97       	sbiw	r30, 0x01	; 1
    1d5e:	29 e0       	ldi	r18, 0x09	; 9
    1d60:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x10;   /* R10 */
    1d62:	31 97       	sbiw	r30, 0x01	; 1
    1d64:	20 e1       	ldi	r18, 0x10	; 16
    1d66:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x11;   /* R11 */
    1d68:	31 97       	sbiw	r30, 0x01	; 1
    1d6a:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x12;   /* R12 */
    1d6c:	31 97       	sbiw	r30, 0x01	; 1
    1d6e:	22 e1       	ldi	r18, 0x12	; 18
    1d70:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x13;   /* R13 */
    1d72:	31 97       	sbiw	r30, 0x01	; 1
    1d74:	23 e1       	ldi	r18, 0x13	; 19
    1d76:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x14;   /* R14 */
    1d78:	31 97       	sbiw	r30, 0x01	; 1
    1d7a:	24 e1       	ldi	r18, 0x14	; 20
    1d7c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x15;   /* R15 */
    1d7e:	31 97       	sbiw	r30, 0x01	; 1
    1d80:	25 e1       	ldi	r18, 0x15	; 21
    1d82:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x16;   /* R16 */
    1d84:	31 97       	sbiw	r30, 0x01	; 1
    1d86:	26 e1       	ldi	r18, 0x16	; 22
    1d88:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x17;   /* R17 */
    1d8a:	31 97       	sbiw	r30, 0x01	; 1
    1d8c:	27 e1       	ldi	r18, 0x17	; 23
    1d8e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x18;   /* R18 */
    1d90:	31 97       	sbiw	r30, 0x01	; 1
    1d92:	28 e1       	ldi	r18, 0x18	; 24
    1d94:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x19;   /* R19 */
    1d96:	31 97       	sbiw	r30, 0x01	; 1
    1d98:	29 e1       	ldi	r18, 0x19	; 25
    1d9a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x20;   /* R20 */
    1d9c:	31 97       	sbiw	r30, 0x01	; 1
    1d9e:	20 e2       	ldi	r18, 0x20	; 32
    1da0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x21;   /* R21 */
    1da2:	31 97       	sbiw	r30, 0x01	; 1
    1da4:	21 e2       	ldi	r18, 0x21	; 33
    1da6:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x22;   /* R22 */
    1da8:	31 97       	sbiw	r30, 0x01	; 1
    1daa:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x23;   /* R23 */
    1dac:	31 97       	sbiw	r30, 0x01	; 1
    1dae:	23 e2       	ldi	r18, 0x23	; 35
    1db0:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    1db2:	31 97       	sbiw	r30, 0x01	; 1
    1db4:	40 83       	st	Z, r20
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    1db6:	31 97       	sbiw	r30, 0x01	; 1
    1db8:	50 83       	st	Z, r21
    pxTopOfStack--;

    *pxTopOfStack = ( StackType_t ) 0x26;   /* R26 X */
    1dba:	31 97       	sbiw	r30, 0x01	; 1
    1dbc:	26 e2       	ldi	r18, 0x26	; 38
    1dbe:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x27;   /* R27 */
    1dc0:	31 97       	sbiw	r30, 0x01	; 1
    1dc2:	27 e2       	ldi	r18, 0x27	; 39
    1dc4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x28;   /* R28 Y */
    1dc6:	31 97       	sbiw	r30, 0x01	; 1
    1dc8:	28 e2       	ldi	r18, 0x28	; 40
    1dca:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x29;   /* R29 */
    1dcc:	31 97       	sbiw	r30, 0x01	; 1
    1dce:	29 e2       	ldi	r18, 0x29	; 41
    1dd0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x30;   /* R30 Z */
    1dd2:	31 97       	sbiw	r30, 0x01	; 1
    1dd4:	20 e3       	ldi	r18, 0x30	; 48
    1dd6:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x31;   /* R31 */
    1dd8:	31 97       	sbiw	r30, 0x01	; 1
    1dda:	21 e3       	ldi	r18, 0x31	; 49
    1ddc:	20 83       	st	Z, r18
    pxTopOfStack--;

    /*lint +e950 +e611 +e923 */

    return pxTopOfStack;
}
    1dde:	87 97       	sbiw	r24, 0x27	; 39
    1de0:	1f 91       	pop	r17
    1de2:	0f 91       	pop	r16
    1de4:	08 95       	ret

00001de6 <xPortStartScheduler>:
 * Setup timer generate a tick interrupt.
 */
static void prvSetupTimerInterrupt(void)
{
    // disable global interrupt for a moment
    cli();
    1de6:	f8 94       	cli

    {
        //enable TC0 clock source, high resolution
        PR.PRPC &= ~(PR_TC0_bm | PR_HIRES_bm);
    1de8:	e0 e7       	ldi	r30, 0x70	; 112
    1dea:	f0 e0       	ldi	r31, 0x00	; 0
    1dec:	83 81       	ldd	r24, Z+3	; 0x03
    1dee:	8a 7f       	andi	r24, 0xFA	; 250
    1df0:	83 83       	std	Z+3, r24	; 0x03

        //set period of counter
        TCC0.PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ / 1;
    1df2:	e0 e0       	ldi	r30, 0x00	; 0
    1df4:	f8 e0       	ldi	r31, 0x08	; 8
    1df6:	80 e0       	ldi	r24, 0x00	; 0
    1df8:	9a ef       	ldi	r25, 0xFA	; 250
    1dfa:	86 a3       	std	Z+38, r24	; 0x26
    1dfc:	97 a3       	std	Z+39, r25	; 0x27

        //enable interrupt and set low level
        TCC0.INTCTRLA = TC_OVFINTLVL_LO_gc;
    1dfe:	91 e0       	ldi	r25, 0x01	; 1
    1e00:	96 83       	std	Z+6, r25	; 0x06

        //enable low-level interrupt
        PMIC.CTRL |= PMIC_LOLVLEN_bm;
    1e02:	a0 ea       	ldi	r26, 0xA0	; 160
    1e04:	b0 e0       	ldi	r27, 0x00	; 0
    1e06:	12 96       	adiw	r26, 0x02	; 2
    1e08:	8c 91       	ld	r24, X
    1e0a:	12 97       	sbiw	r26, 0x02	; 2
    1e0c:	81 60       	ori	r24, 0x01	; 1
    1e0e:	12 96       	adiw	r26, 0x02	; 2
    1e10:	8c 93       	st	X, r24

        //select (start) the clock source
        TCC0.CTRLA = TC_CLKSEL_DIV1_gc;
    1e12:	90 83       	st	Z, r25

    }

    // enable global interrupt
    sei();
    1e14:	78 94       	sei
{
    /* Setup the hardware to generate the tick. */
    prvSetupTimerInterrupt();

    /* Restore the context of the first task that is going to run. */
    portRESTORE_CONTEXT();
    1e16:	a0 91 ba 22 	lds	r26, 0x22BA	; 0x8022ba <pxCurrentTCB>
    1e1a:	b0 91 bb 22 	lds	r27, 0x22BB	; 0x8022bb <pxCurrentTCB+0x1>
    1e1e:	0d 90       	ld	r0, X+
    1e20:	0d be       	out	0x3d, r0	; 61
    1e22:	0d 90       	ld	r0, X+
    1e24:	0e be       	out	0x3e, r0	; 62
    1e26:	ff 91       	pop	r31
    1e28:	ef 91       	pop	r30
    1e2a:	df 91       	pop	r29
    1e2c:	cf 91       	pop	r28
    1e2e:	bf 91       	pop	r27
    1e30:	af 91       	pop	r26
    1e32:	9f 91       	pop	r25
    1e34:	8f 91       	pop	r24
    1e36:	7f 91       	pop	r23
    1e38:	6f 91       	pop	r22
    1e3a:	5f 91       	pop	r21
    1e3c:	4f 91       	pop	r20
    1e3e:	3f 91       	pop	r19
    1e40:	2f 91       	pop	r18
    1e42:	1f 91       	pop	r17
    1e44:	0f 91       	pop	r16
    1e46:	ff 90       	pop	r15
    1e48:	ef 90       	pop	r14
    1e4a:	df 90       	pop	r13
    1e4c:	cf 90       	pop	r12
    1e4e:	bf 90       	pop	r11
    1e50:	af 90       	pop	r10
    1e52:	9f 90       	pop	r9
    1e54:	8f 90       	pop	r8
    1e56:	7f 90       	pop	r7
    1e58:	6f 90       	pop	r6
    1e5a:	5f 90       	pop	r5
    1e5c:	4f 90       	pop	r4
    1e5e:	3f 90       	pop	r3
    1e60:	2f 90       	pop	r2
    1e62:	1f 90       	pop	r1
    1e64:	0f 90       	pop	r0
    1e66:	0f be       	out	0x3f, r0	; 63
    1e68:	0f 90       	pop	r0

    /* Simulate a function call end as generated by the compiler.  We will now
    jump to the start of the task the context of which we have just restored. */
    asm volatile ( "ret" );
    1e6a:	08 95       	ret

    /* Should not get here. */
    return pdTRUE;
}
    1e6c:	81 e0       	ldi	r24, 0x01	; 1
    1e6e:	08 95       	ret

00001e70 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    1e70:	0f 92       	push	r0
    1e72:	0f b6       	in	r0, 0x3f	; 63
    1e74:	f8 94       	cli
    1e76:	0f 92       	push	r0
    1e78:	1f 92       	push	r1
    1e7a:	11 24       	eor	r1, r1
    1e7c:	2f 92       	push	r2
    1e7e:	3f 92       	push	r3
    1e80:	4f 92       	push	r4
    1e82:	5f 92       	push	r5
    1e84:	6f 92       	push	r6
    1e86:	7f 92       	push	r7
    1e88:	8f 92       	push	r8
    1e8a:	9f 92       	push	r9
    1e8c:	af 92       	push	r10
    1e8e:	bf 92       	push	r11
    1e90:	cf 92       	push	r12
    1e92:	df 92       	push	r13
    1e94:	ef 92       	push	r14
    1e96:	ff 92       	push	r15
    1e98:	0f 93       	push	r16
    1e9a:	1f 93       	push	r17
    1e9c:	2f 93       	push	r18
    1e9e:	3f 93       	push	r19
    1ea0:	4f 93       	push	r20
    1ea2:	5f 93       	push	r21
    1ea4:	6f 93       	push	r22
    1ea6:	7f 93       	push	r23
    1ea8:	8f 93       	push	r24
    1eaa:	9f 93       	push	r25
    1eac:	af 93       	push	r26
    1eae:	bf 93       	push	r27
    1eb0:	cf 93       	push	r28
    1eb2:	df 93       	push	r29
    1eb4:	ef 93       	push	r30
    1eb6:	ff 93       	push	r31
    1eb8:	a0 91 ba 22 	lds	r26, 0x22BA	; 0x8022ba <pxCurrentTCB>
    1ebc:	b0 91 bb 22 	lds	r27, 0x22BB	; 0x8022bb <pxCurrentTCB+0x1>
    1ec0:	0d b6       	in	r0, 0x3d	; 61
    1ec2:	0d 92       	st	X+, r0
    1ec4:	0e b6       	in	r0, 0x3e	; 62
    1ec6:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    1ec8:	10 d6       	rcall	.+3104   	; 0x2aea <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    1eca:	a0 91 ba 22 	lds	r26, 0x22BA	; 0x8022ba <pxCurrentTCB>
    1ece:	b0 91 bb 22 	lds	r27, 0x22BB	; 0x8022bb <pxCurrentTCB+0x1>
    1ed2:	0d 90       	ld	r0, X+
    1ed4:	0d be       	out	0x3d, r0	; 61
    1ed6:	0d 90       	ld	r0, X+
    1ed8:	0e be       	out	0x3e, r0	; 62
    1eda:	ff 91       	pop	r31
    1edc:	ef 91       	pop	r30
    1ede:	df 91       	pop	r29
    1ee0:	cf 91       	pop	r28
    1ee2:	bf 91       	pop	r27
    1ee4:	af 91       	pop	r26
    1ee6:	9f 91       	pop	r25
    1ee8:	8f 91       	pop	r24
    1eea:	7f 91       	pop	r23
    1eec:	6f 91       	pop	r22
    1eee:	5f 91       	pop	r21
    1ef0:	4f 91       	pop	r20
    1ef2:	3f 91       	pop	r19
    1ef4:	2f 91       	pop	r18
    1ef6:	1f 91       	pop	r17
    1ef8:	0f 91       	pop	r16
    1efa:	ff 90       	pop	r15
    1efc:	ef 90       	pop	r14
    1efe:	df 90       	pop	r13
    1f00:	cf 90       	pop	r12
    1f02:	bf 90       	pop	r11
    1f04:	af 90       	pop	r10
    1f06:	9f 90       	pop	r9
    1f08:	8f 90       	pop	r8
    1f0a:	7f 90       	pop	r7
    1f0c:	6f 90       	pop	r6
    1f0e:	5f 90       	pop	r5
    1f10:	4f 90       	pop	r4
    1f12:	3f 90       	pop	r3
    1f14:	2f 90       	pop	r2
    1f16:	1f 90       	pop	r1
    1f18:	0f 90       	pop	r0
    1f1a:	0f be       	out	0x3f, r0	; 63
    1f1c:	0f 90       	pop	r0

    asm volatile ( "ret" );
    1f1e:	08 95       	ret

00001f20 <__vector_14>:
         * Context switch function used by the tick.  This must be identical to
         * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
         * difference from vPortYield() is the tick count is incremented as the
         * call comes from the tick ISR.
         */
        portSAVE_CONTEXT();
    1f20:	0f 92       	push	r0
    1f22:	0f b6       	in	r0, 0x3f	; 63
    1f24:	f8 94       	cli
    1f26:	0f 92       	push	r0
    1f28:	1f 92       	push	r1
    1f2a:	11 24       	eor	r1, r1
    1f2c:	2f 92       	push	r2
    1f2e:	3f 92       	push	r3
    1f30:	4f 92       	push	r4
    1f32:	5f 92       	push	r5
    1f34:	6f 92       	push	r6
    1f36:	7f 92       	push	r7
    1f38:	8f 92       	push	r8
    1f3a:	9f 92       	push	r9
    1f3c:	af 92       	push	r10
    1f3e:	bf 92       	push	r11
    1f40:	cf 92       	push	r12
    1f42:	df 92       	push	r13
    1f44:	ef 92       	push	r14
    1f46:	ff 92       	push	r15
    1f48:	0f 93       	push	r16
    1f4a:	1f 93       	push	r17
    1f4c:	2f 93       	push	r18
    1f4e:	3f 93       	push	r19
    1f50:	4f 93       	push	r20
    1f52:	5f 93       	push	r21
    1f54:	6f 93       	push	r22
    1f56:	7f 93       	push	r23
    1f58:	8f 93       	push	r24
    1f5a:	9f 93       	push	r25
    1f5c:	af 93       	push	r26
    1f5e:	bf 93       	push	r27
    1f60:	cf 93       	push	r28
    1f62:	df 93       	push	r29
    1f64:	ef 93       	push	r30
    1f66:	ff 93       	push	r31
    1f68:	a0 91 ba 22 	lds	r26, 0x22BA	; 0x8022ba <pxCurrentTCB>
    1f6c:	b0 91 bb 22 	lds	r27, 0x22BB	; 0x8022bb <pxCurrentTCB+0x1>
    1f70:	0d b6       	in	r0, 0x3d	; 61
    1f72:	0d 92       	st	X+, r0
    1f74:	0e b6       	in	r0, 0x3e	; 62
    1f76:	0d 92       	st	X+, r0
        if( xTaskIncrementTick() != pdFALSE )
    1f78:	4d d4       	rcall	.+2202   	; 0x2814 <xTaskIncrementTick>
    1f7a:	81 11       	cpse	r24, r1
        {
            vTaskSwitchContext();
    1f7c:	b6 d5       	rcall	.+2924   	; 0x2aea <vTaskSwitchContext>
        }
        portRESTORE_CONTEXT();
    1f7e:	a0 91 ba 22 	lds	r26, 0x22BA	; 0x8022ba <pxCurrentTCB>
    1f82:	b0 91 bb 22 	lds	r27, 0x22BB	; 0x8022bb <pxCurrentTCB+0x1>
    1f86:	0d 90       	ld	r0, X+
    1f88:	0d be       	out	0x3d, r0	; 61
    1f8a:	0d 90       	ld	r0, X+
    1f8c:	0e be       	out	0x3e, r0	; 62
    1f8e:	ff 91       	pop	r31
    1f90:	ef 91       	pop	r30
    1f92:	df 91       	pop	r29
    1f94:	cf 91       	pop	r28
    1f96:	bf 91       	pop	r27
    1f98:	af 91       	pop	r26
    1f9a:	9f 91       	pop	r25
    1f9c:	8f 91       	pop	r24
    1f9e:	7f 91       	pop	r23
    1fa0:	6f 91       	pop	r22
    1fa2:	5f 91       	pop	r21
    1fa4:	4f 91       	pop	r20
    1fa6:	3f 91       	pop	r19
    1fa8:	2f 91       	pop	r18
    1faa:	1f 91       	pop	r17
    1fac:	0f 91       	pop	r16
    1fae:	ff 90       	pop	r15
    1fb0:	ef 90       	pop	r14
    1fb2:	df 90       	pop	r13
    1fb4:	cf 90       	pop	r12
    1fb6:	bf 90       	pop	r11
    1fb8:	af 90       	pop	r10
    1fba:	9f 90       	pop	r9
    1fbc:	8f 90       	pop	r8
    1fbe:	7f 90       	pop	r7
    1fc0:	6f 90       	pop	r6
    1fc2:	5f 90       	pop	r5
    1fc4:	4f 90       	pop	r4
    1fc6:	3f 90       	pop	r3
    1fc8:	2f 90       	pop	r2
    1fca:	1f 90       	pop	r1
    1fcc:	0f 90       	pop	r0
    1fce:	0f be       	out	0x3f, r0	; 63
    1fd0:	0f 90       	pop	r0

        asm volatile ( "reti" );
    1fd2:	18 95       	reti

00001fd4 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1fd4:	cf 93       	push	r28
    1fd6:	df 93       	push	r29
    1fd8:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
    1fda:	0c d4       	rcall	.+2072   	; 0x27f4 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
    1fdc:	ce 01       	movw	r24, r28
    1fde:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <malloc>
    1fe2:	ec 01       	movw	r28, r24
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1fe4:	ea d4       	rcall	.+2516   	; 0x29ba <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1fe6:	ce 01       	movw	r24, r28
    1fe8:	df 91       	pop	r29
    1fea:	cf 91       	pop	r28
    1fec:	08 95       	ret

00001fee <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1fee:	cf 93       	push	r28
    1ff0:	df 93       	push	r29
	if( pv )
    1ff2:	00 97       	sbiw	r24, 0x00	; 0
    1ff4:	31 f0       	breq	.+12     	; 0x2002 <vPortFree+0x14>
    1ff6:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
    1ff8:	fd d3       	rcall	.+2042   	; 0x27f4 <vTaskSuspendAll>
		{
			free( pv );
    1ffa:	ce 01       	movw	r24, r28
    1ffc:	0e 94 e6 1c 	call	0x39cc	; 0x39cc <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
    2000:	dc d4       	rcall	.+2488   	; 0x29ba <xTaskResumeAll>
	}
}
    2002:	df 91       	pop	r29
    2004:	cf 91       	pop	r28
    2006:	08 95       	ret

00002008 <prvCopyDataToQueue>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2008:	1f 93       	push	r17
    200a:	cf 93       	push	r28
    200c:	df 93       	push	r29
    200e:	ec 01       	movw	r28, r24
    2010:	14 2f       	mov	r17, r20
    2012:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2014:	88 23       	and	r24, r24
    2016:	e9 f1       	breq	.+122    	; 0x2092 <prvCopyDataToQueue+0x8a>
    2018:	41 11       	cpse	r20, r1
    201a:	17 c0       	rjmp	.+46     	; 0x204a <prvCopyDataToQueue+0x42>
    201c:	48 2f       	mov	r20, r24
    201e:	50 e0       	ldi	r21, 0x00	; 0
    2020:	8c 81       	ldd	r24, Y+4	; 0x04
    2022:	9d 81       	ldd	r25, Y+5	; 0x05
    2024:	0e 94 7e 1d 	call	0x3afc	; 0x3afc <memcpy>
    2028:	2c 8d       	ldd	r18, Y+28	; 0x1c
    202a:	8c 81       	ldd	r24, Y+4	; 0x04
    202c:	9d 81       	ldd	r25, Y+5	; 0x05
    202e:	82 0f       	add	r24, r18
    2030:	91 1d       	adc	r25, r1
    2032:	8c 83       	std	Y+4, r24	; 0x04
    2034:	9d 83       	std	Y+5, r25	; 0x05
    2036:	2a 81       	ldd	r18, Y+2	; 0x02
    2038:	3b 81       	ldd	r19, Y+3	; 0x03
    203a:	82 17       	cp	r24, r18
    203c:	93 07       	cpc	r25, r19
    203e:	48 f1       	brcs	.+82     	; 0x2092 <prvCopyDataToQueue+0x8a>
    2040:	88 81       	ld	r24, Y
    2042:	99 81       	ldd	r25, Y+1	; 0x01
    2044:	8c 83       	std	Y+4, r24	; 0x04
    2046:	9d 83       	std	Y+5, r25	; 0x05
    2048:	24 c0       	rjmp	.+72     	; 0x2092 <prvCopyDataToQueue+0x8a>
    204a:	48 2f       	mov	r20, r24
    204c:	50 e0       	ldi	r21, 0x00	; 0
    204e:	8e 81       	ldd	r24, Y+6	; 0x06
    2050:	9f 81       	ldd	r25, Y+7	; 0x07
    2052:	0e 94 7e 1d 	call	0x3afc	; 0x3afc <memcpy>
    2056:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2058:	90 e0       	ldi	r25, 0x00	; 0
    205a:	91 95       	neg	r25
    205c:	81 95       	neg	r24
    205e:	91 09       	sbc	r25, r1
    2060:	2e 81       	ldd	r18, Y+6	; 0x06
    2062:	3f 81       	ldd	r19, Y+7	; 0x07
    2064:	28 0f       	add	r18, r24
    2066:	39 1f       	adc	r19, r25
    2068:	2e 83       	std	Y+6, r18	; 0x06
    206a:	3f 83       	std	Y+7, r19	; 0x07
    206c:	48 81       	ld	r20, Y
    206e:	59 81       	ldd	r21, Y+1	; 0x01
    2070:	24 17       	cp	r18, r20
    2072:	35 07       	cpc	r19, r21
    2074:	30 f4       	brcc	.+12     	; 0x2082 <prvCopyDataToQueue+0x7a>
    2076:	2a 81       	ldd	r18, Y+2	; 0x02
    2078:	3b 81       	ldd	r19, Y+3	; 0x03
    207a:	82 0f       	add	r24, r18
    207c:	93 1f       	adc	r25, r19
    207e:	8e 83       	std	Y+6, r24	; 0x06
    2080:	9f 83       	std	Y+7, r25	; 0x07
    2082:	12 30       	cpi	r17, 0x02	; 2
    2084:	31 f4       	brne	.+12     	; 0x2092 <prvCopyDataToQueue+0x8a>
    2086:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2088:	88 23       	and	r24, r24
    208a:	19 f0       	breq	.+6      	; 0x2092 <prvCopyDataToQueue+0x8a>
    208c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    208e:	81 50       	subi	r24, 0x01	; 1
    2090:	8a 8f       	std	Y+26, r24	; 0x1a
    2092:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2094:	8f 5f       	subi	r24, 0xFF	; 255
    2096:	8a 8f       	std	Y+26, r24	; 0x1a
    2098:	80 e0       	ldi	r24, 0x00	; 0
    209a:	df 91       	pop	r29
    209c:	cf 91       	pop	r28
    209e:	1f 91       	pop	r17
    20a0:	08 95       	ret

000020a2 <prvCopyDataFromQueue>:
    20a2:	fc 01       	movw	r30, r24
    20a4:	44 8d       	ldd	r20, Z+28	; 0x1c
    20a6:	44 23       	and	r20, r20
    20a8:	a9 f0       	breq	.+42     	; 0x20d4 <prvCopyDataFromQueue+0x32>
    20aa:	50 e0       	ldi	r21, 0x00	; 0
    20ac:	26 81       	ldd	r18, Z+6	; 0x06
    20ae:	37 81       	ldd	r19, Z+7	; 0x07
    20b0:	24 0f       	add	r18, r20
    20b2:	35 1f       	adc	r19, r21
    20b4:	26 83       	std	Z+6, r18	; 0x06
    20b6:	37 83       	std	Z+7, r19	; 0x07
    20b8:	82 81       	ldd	r24, Z+2	; 0x02
    20ba:	93 81       	ldd	r25, Z+3	; 0x03
    20bc:	28 17       	cp	r18, r24
    20be:	39 07       	cpc	r19, r25
    20c0:	20 f0       	brcs	.+8      	; 0x20ca <prvCopyDataFromQueue+0x28>
    20c2:	80 81       	ld	r24, Z
    20c4:	91 81       	ldd	r25, Z+1	; 0x01
    20c6:	86 83       	std	Z+6, r24	; 0x06
    20c8:	97 83       	std	Z+7, r25	; 0x07
    20ca:	cb 01       	movw	r24, r22
    20cc:	66 81       	ldd	r22, Z+6	; 0x06
    20ce:	77 81       	ldd	r23, Z+7	; 0x07
    20d0:	0c 94 7e 1d 	jmp	0x3afc	; 0x3afc <memcpy>
    20d4:	08 95       	ret

000020d6 <prvUnlockQueue>:
    20d6:	0f 93       	push	r16
    20d8:	1f 93       	push	r17
    20da:	cf 93       	push	r28
    20dc:	df 93       	push	r29
    20de:	ec 01       	movw	r28, r24
    20e0:	0f b6       	in	r0, 0x3f	; 63
    20e2:	f8 94       	cli
    20e4:	0f 92       	push	r0
    20e6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    20e8:	18 16       	cp	r1, r24
    20ea:	ac f4       	brge	.+42     	; 0x2116 <prvUnlockQueue+0x40>
    20ec:	89 89       	ldd	r24, Y+17	; 0x11
    20ee:	81 11       	cpse	r24, r1
    20f0:	05 c0       	rjmp	.+10     	; 0x20fc <prvUnlockQueue+0x26>
    20f2:	11 c0       	rjmp	.+34     	; 0x2116 <prvUnlockQueue+0x40>
    20f4:	99 89       	ldd	r25, Y+17	; 0x11
    20f6:	91 11       	cpse	r25, r1
    20f8:	04 c0       	rjmp	.+8      	; 0x2102 <prvUnlockQueue+0x2c>
    20fa:	0d c0       	rjmp	.+26     	; 0x2116 <prvUnlockQueue+0x40>
    20fc:	8e 01       	movw	r16, r28
    20fe:	0f 5e       	subi	r16, 0xEF	; 239
    2100:	1f 4f       	sbci	r17, 0xFF	; 255
    2102:	c8 01       	movw	r24, r16
    2104:	96 d5       	rcall	.+2860   	; 0x2c32 <xTaskRemoveFromEventList>
    2106:	81 11       	cpse	r24, r1
    2108:	16 d6       	rcall	.+3116   	; 0x2d36 <vTaskMissedYield>
    210a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    210c:	91 50       	subi	r25, 0x01	; 1
    210e:	9e 8f       	std	Y+30, r25	; 0x1e
    2110:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2112:	19 16       	cp	r1, r25
    2114:	7c f3       	brlt	.-34     	; 0x20f4 <prvUnlockQueue+0x1e>
    2116:	8f ef       	ldi	r24, 0xFF	; 255
    2118:	8e 8f       	std	Y+30, r24	; 0x1e
    211a:	0f 90       	pop	r0
    211c:	0f be       	out	0x3f, r0	; 63
    211e:	0f b6       	in	r0, 0x3f	; 63
    2120:	f8 94       	cli
    2122:	0f 92       	push	r0
    2124:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2126:	18 16       	cp	r1, r24
    2128:	ac f4       	brge	.+42     	; 0x2154 <prvUnlockQueue+0x7e>
    212a:	88 85       	ldd	r24, Y+8	; 0x08
    212c:	81 11       	cpse	r24, r1
    212e:	05 c0       	rjmp	.+10     	; 0x213a <prvUnlockQueue+0x64>
    2130:	11 c0       	rjmp	.+34     	; 0x2154 <prvUnlockQueue+0x7e>
    2132:	98 85       	ldd	r25, Y+8	; 0x08
    2134:	91 11       	cpse	r25, r1
    2136:	04 c0       	rjmp	.+8      	; 0x2140 <prvUnlockQueue+0x6a>
    2138:	0d c0       	rjmp	.+26     	; 0x2154 <prvUnlockQueue+0x7e>
    213a:	8e 01       	movw	r16, r28
    213c:	08 5f       	subi	r16, 0xF8	; 248
    213e:	1f 4f       	sbci	r17, 0xFF	; 255
    2140:	c8 01       	movw	r24, r16
    2142:	77 d5       	rcall	.+2798   	; 0x2c32 <xTaskRemoveFromEventList>
    2144:	81 11       	cpse	r24, r1
    2146:	f7 d5       	rcall	.+3054   	; 0x2d36 <vTaskMissedYield>
    2148:	9d 8d       	ldd	r25, Y+29	; 0x1d
    214a:	91 50       	subi	r25, 0x01	; 1
    214c:	9d 8f       	std	Y+29, r25	; 0x1d
    214e:	9d 8d       	ldd	r25, Y+29	; 0x1d
    2150:	19 16       	cp	r1, r25
    2152:	7c f3       	brlt	.-34     	; 0x2132 <prvUnlockQueue+0x5c>
    2154:	8f ef       	ldi	r24, 0xFF	; 255
    2156:	8d 8f       	std	Y+29, r24	; 0x1d
    2158:	0f 90       	pop	r0
    215a:	0f be       	out	0x3f, r0	; 63
    215c:	df 91       	pop	r29
    215e:	cf 91       	pop	r28
    2160:	1f 91       	pop	r17
    2162:	0f 91       	pop	r16
    2164:	08 95       	ret

00002166 <xQueueGenericReset>:
    2166:	cf 93       	push	r28
    2168:	df 93       	push	r29
    216a:	ec 01       	movw	r28, r24
    216c:	0f b6       	in	r0, 0x3f	; 63
    216e:	f8 94       	cli
    2170:	0f 92       	push	r0
    2172:	48 81       	ld	r20, Y
    2174:	59 81       	ldd	r21, Y+1	; 0x01
    2176:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2178:	30 e0       	ldi	r19, 0x00	; 0
    217a:	7b 8d       	ldd	r23, Y+27	; 0x1b
    217c:	72 9f       	mul	r23, r18
    217e:	c0 01       	movw	r24, r0
    2180:	73 9f       	mul	r23, r19
    2182:	90 0d       	add	r25, r0
    2184:	11 24       	eor	r1, r1
    2186:	fa 01       	movw	r30, r20
    2188:	e8 0f       	add	r30, r24
    218a:	f9 1f       	adc	r31, r25
    218c:	ea 83       	std	Y+2, r30	; 0x02
    218e:	fb 83       	std	Y+3, r31	; 0x03
    2190:	1a 8e       	std	Y+26, r1	; 0x1a
    2192:	4c 83       	std	Y+4, r20	; 0x04
    2194:	5d 83       	std	Y+5, r21	; 0x05
    2196:	82 1b       	sub	r24, r18
    2198:	93 0b       	sbc	r25, r19
    219a:	84 0f       	add	r24, r20
    219c:	95 1f       	adc	r25, r21
    219e:	8e 83       	std	Y+6, r24	; 0x06
    21a0:	9f 83       	std	Y+7, r25	; 0x07
    21a2:	8f ef       	ldi	r24, 0xFF	; 255
    21a4:	8d 8f       	std	Y+29, r24	; 0x1d
    21a6:	8e 8f       	std	Y+30, r24	; 0x1e
    21a8:	61 11       	cpse	r22, r1
    21aa:	0a c0       	rjmp	.+20     	; 0x21c0 <xQueueGenericReset+0x5a>
    21ac:	88 85       	ldd	r24, Y+8	; 0x08
    21ae:	88 23       	and	r24, r24
    21b0:	69 f0       	breq	.+26     	; 0x21cc <xQueueGenericReset+0x66>
    21b2:	ce 01       	movw	r24, r28
    21b4:	08 96       	adiw	r24, 0x08	; 8
    21b6:	3d d5       	rcall	.+2682   	; 0x2c32 <xTaskRemoveFromEventList>
    21b8:	81 30       	cpi	r24, 0x01	; 1
    21ba:	41 f4       	brne	.+16     	; 0x21cc <xQueueGenericReset+0x66>
    21bc:	59 de       	rcall	.-846    	; 0x1e70 <vPortYield>
    21be:	06 c0       	rjmp	.+12     	; 0x21cc <xQueueGenericReset+0x66>
    21c0:	ce 01       	movw	r24, r28
    21c2:	08 96       	adiw	r24, 0x08	; 8
    21c4:	0f dd       	rcall	.-1506   	; 0x1be4 <vListInitialise>
    21c6:	ce 01       	movw	r24, r28
    21c8:	41 96       	adiw	r24, 0x11	; 17
    21ca:	0c dd       	rcall	.-1512   	; 0x1be4 <vListInitialise>
    21cc:	0f 90       	pop	r0
    21ce:	0f be       	out	0x3f, r0	; 63
    21d0:	81 e0       	ldi	r24, 0x01	; 1
    21d2:	df 91       	pop	r29
    21d4:	cf 91       	pop	r28
    21d6:	08 95       	ret

000021d8 <xQueueGenericCreate>:
    21d8:	0f 93       	push	r16
    21da:	1f 93       	push	r17
    21dc:	cf 93       	push	r28
    21de:	df 93       	push	r29
    21e0:	08 2f       	mov	r16, r24
    21e2:	16 2f       	mov	r17, r22
    21e4:	66 23       	and	r22, r22
    21e6:	a9 f0       	breq	.+42     	; 0x2212 <xQueueGenericCreate+0x3a>
    21e8:	86 9f       	mul	r24, r22
    21ea:	c0 01       	movw	r24, r0
    21ec:	11 24       	eor	r1, r1
    21ee:	80 96       	adiw	r24, 0x20	; 32
    21f0:	f1 de       	rcall	.-542    	; 0x1fd4 <pvPortMalloc>
    21f2:	ec 01       	movw	r28, r24
    21f4:	00 97       	sbiw	r24, 0x00	; 0
    21f6:	21 f4       	brne	.+8      	; 0x2200 <xQueueGenericCreate+0x28>
    21f8:	12 c0       	rjmp	.+36     	; 0x221e <xQueueGenericCreate+0x46>
    21fa:	c8 83       	st	Y, r28
    21fc:	d9 83       	std	Y+1, r29	; 0x01
    21fe:	03 c0       	rjmp	.+6      	; 0x2206 <xQueueGenericCreate+0x2e>
    2200:	4f 96       	adiw	r24, 0x1f	; 31
    2202:	88 83       	st	Y, r24
    2204:	99 83       	std	Y+1, r25	; 0x01
    2206:	0b 8f       	std	Y+27, r16	; 0x1b
    2208:	1c 8f       	std	Y+28, r17	; 0x1c
    220a:	61 e0       	ldi	r22, 0x01	; 1
    220c:	ce 01       	movw	r24, r28
    220e:	ab df       	rcall	.-170    	; 0x2166 <xQueueGenericReset>
    2210:	06 c0       	rjmp	.+12     	; 0x221e <xQueueGenericCreate+0x46>
    2212:	8f e1       	ldi	r24, 0x1F	; 31
    2214:	90 e0       	ldi	r25, 0x00	; 0
    2216:	de de       	rcall	.-580    	; 0x1fd4 <pvPortMalloc>
    2218:	ec 01       	movw	r28, r24
    221a:	89 2b       	or	r24, r25
    221c:	71 f7       	brne	.-36     	; 0x21fa <xQueueGenericCreate+0x22>
    221e:	ce 01       	movw	r24, r28
    2220:	df 91       	pop	r29
    2222:	cf 91       	pop	r28
    2224:	1f 91       	pop	r17
    2226:	0f 91       	pop	r16
    2228:	08 95       	ret

0000222a <xQueueGenericSend>:
    222a:	af 92       	push	r10
    222c:	bf 92       	push	r11
    222e:	cf 92       	push	r12
    2230:	df 92       	push	r13
    2232:	ef 92       	push	r14
    2234:	ff 92       	push	r15
    2236:	0f 93       	push	r16
    2238:	1f 93       	push	r17
    223a:	cf 93       	push	r28
    223c:	df 93       	push	r29
    223e:	cd b7       	in	r28, 0x3d	; 61
    2240:	de b7       	in	r29, 0x3e	; 62
    2242:	25 97       	sbiw	r28, 0x05	; 5
    2244:	cd bf       	out	0x3d, r28	; 61
    2246:	de bf       	out	0x3e, r29	; 62
    2248:	8c 01       	movw	r16, r24
    224a:	6b 01       	movw	r12, r22
    224c:	4c 83       	std	Y+4, r20	; 0x04
    224e:	5d 83       	std	Y+5, r21	; 0x05
    2250:	a2 2e       	mov	r10, r18
    2252:	b1 2c       	mov	r11, r1
    2254:	7c 01       	movw	r14, r24
    2256:	88 e0       	ldi	r24, 0x08	; 8
    2258:	e8 0e       	add	r14, r24
    225a:	f1 1c       	adc	r15, r1
    225c:	0f b6       	in	r0, 0x3f	; 63
    225e:	f8 94       	cli
    2260:	0f 92       	push	r0
    2262:	f8 01       	movw	r30, r16
    2264:	32 8d       	ldd	r19, Z+26	; 0x1a
    2266:	93 8d       	ldd	r25, Z+27	; 0x1b
    2268:	39 17       	cp	r19, r25
    226a:	18 f0       	brcs	.+6      	; 0x2272 <xQueueGenericSend+0x48>
    226c:	f2 e0       	ldi	r31, 0x02	; 2
    226e:	af 12       	cpse	r10, r31
    2270:	15 c0       	rjmp	.+42     	; 0x229c <xQueueGenericSend+0x72>
    2272:	4a 2d       	mov	r20, r10
    2274:	b6 01       	movw	r22, r12
    2276:	c8 01       	movw	r24, r16
    2278:	c7 de       	rcall	.-626    	; 0x2008 <prvCopyDataToQueue>
    227a:	f8 01       	movw	r30, r16
    227c:	91 89       	ldd	r25, Z+17	; 0x11
    227e:	99 23       	and	r25, r25
    2280:	39 f0       	breq	.+14     	; 0x2290 <xQueueGenericSend+0x66>
    2282:	c8 01       	movw	r24, r16
    2284:	41 96       	adiw	r24, 0x11	; 17
    2286:	d5 d4       	rcall	.+2474   	; 0x2c32 <xTaskRemoveFromEventList>
    2288:	81 30       	cpi	r24, 0x01	; 1
    228a:	21 f4       	brne	.+8      	; 0x2294 <xQueueGenericSend+0x6a>
    228c:	f1 dd       	rcall	.-1054   	; 0x1e70 <vPortYield>
    228e:	02 c0       	rjmp	.+4      	; 0x2294 <xQueueGenericSend+0x6a>
    2290:	81 11       	cpse	r24, r1
    2292:	ee dd       	rcall	.-1060   	; 0x1e70 <vPortYield>
    2294:	0f 90       	pop	r0
    2296:	0f be       	out	0x3f, r0	; 63
    2298:	81 e0       	ldi	r24, 0x01	; 1
    229a:	46 c0       	rjmp	.+140    	; 0x2328 <xQueueGenericSend+0xfe>
    229c:	ec 81       	ldd	r30, Y+4	; 0x04
    229e:	fd 81       	ldd	r31, Y+5	; 0x05
    22a0:	ef 2b       	or	r30, r31
    22a2:	21 f4       	brne	.+8      	; 0x22ac <xQueueGenericSend+0x82>
    22a4:	0f 90       	pop	r0
    22a6:	0f be       	out	0x3f, r0	; 63
    22a8:	80 e0       	ldi	r24, 0x00	; 0
    22aa:	3e c0       	rjmp	.+124    	; 0x2328 <xQueueGenericSend+0xfe>
    22ac:	b1 10       	cpse	r11, r1
    22ae:	05 c0       	rjmp	.+10     	; 0x22ba <xQueueGenericSend+0x90>
    22b0:	ce 01       	movw	r24, r28
    22b2:	01 96       	adiw	r24, 0x01	; 1
    22b4:	04 d5       	rcall	.+2568   	; 0x2cbe <vTaskSetTimeOutState>
    22b6:	bb 24       	eor	r11, r11
    22b8:	b3 94       	inc	r11
    22ba:	0f 90       	pop	r0
    22bc:	0f be       	out	0x3f, r0	; 63
    22be:	9a d2       	rcall	.+1332   	; 0x27f4 <vTaskSuspendAll>
    22c0:	0f b6       	in	r0, 0x3f	; 63
    22c2:	f8 94       	cli
    22c4:	0f 92       	push	r0
    22c6:	f8 01       	movw	r30, r16
    22c8:	85 8d       	ldd	r24, Z+29	; 0x1d
    22ca:	8f 3f       	cpi	r24, 0xFF	; 255
    22cc:	09 f4       	brne	.+2      	; 0x22d0 <xQueueGenericSend+0xa6>
    22ce:	15 8e       	std	Z+29, r1	; 0x1d
    22d0:	f8 01       	movw	r30, r16
    22d2:	86 8d       	ldd	r24, Z+30	; 0x1e
    22d4:	8f 3f       	cpi	r24, 0xFF	; 255
    22d6:	09 f4       	brne	.+2      	; 0x22da <xQueueGenericSend+0xb0>
    22d8:	16 8e       	std	Z+30, r1	; 0x1e
    22da:	0f 90       	pop	r0
    22dc:	0f be       	out	0x3f, r0	; 63
    22de:	be 01       	movw	r22, r28
    22e0:	6c 5f       	subi	r22, 0xFC	; 252
    22e2:	7f 4f       	sbci	r23, 0xFF	; 255
    22e4:	ce 01       	movw	r24, r28
    22e6:	01 96       	adiw	r24, 0x01	; 1
    22e8:	f5 d4       	rcall	.+2538   	; 0x2cd4 <xTaskCheckForTimeOut>
    22ea:	81 11       	cpse	r24, r1
    22ec:	19 c0       	rjmp	.+50     	; 0x2320 <xQueueGenericSend+0xf6>
    22ee:	0f b6       	in	r0, 0x3f	; 63
    22f0:	f8 94       	cli
    22f2:	0f 92       	push	r0
    22f4:	f8 01       	movw	r30, r16
    22f6:	92 8d       	ldd	r25, Z+26	; 0x1a
    22f8:	0f 90       	pop	r0
    22fa:	0f be       	out	0x3f, r0	; 63
    22fc:	83 8d       	ldd	r24, Z+27	; 0x1b
    22fe:	98 13       	cpse	r25, r24
    2300:	0b c0       	rjmp	.+22     	; 0x2318 <xQueueGenericSend+0xee>
    2302:	6c 81       	ldd	r22, Y+4	; 0x04
    2304:	7d 81       	ldd	r23, Y+5	; 0x05
    2306:	c7 01       	movw	r24, r14
    2308:	5d d4       	rcall	.+2234   	; 0x2bc4 <vTaskPlaceOnEventList>
    230a:	c8 01       	movw	r24, r16
    230c:	e4 de       	rcall	.-568    	; 0x20d6 <prvUnlockQueue>
    230e:	55 d3       	rcall	.+1706   	; 0x29ba <xTaskResumeAll>
    2310:	81 11       	cpse	r24, r1
    2312:	a4 cf       	rjmp	.-184    	; 0x225c <xQueueGenericSend+0x32>
    2314:	ad dd       	rcall	.-1190   	; 0x1e70 <vPortYield>
    2316:	a2 cf       	rjmp	.-188    	; 0x225c <xQueueGenericSend+0x32>
    2318:	c8 01       	movw	r24, r16
    231a:	dd de       	rcall	.-582    	; 0x20d6 <prvUnlockQueue>
    231c:	4e d3       	rcall	.+1692   	; 0x29ba <xTaskResumeAll>
    231e:	9e cf       	rjmp	.-196    	; 0x225c <xQueueGenericSend+0x32>
    2320:	c8 01       	movw	r24, r16
    2322:	d9 de       	rcall	.-590    	; 0x20d6 <prvUnlockQueue>
    2324:	4a d3       	rcall	.+1684   	; 0x29ba <xTaskResumeAll>
    2326:	80 e0       	ldi	r24, 0x00	; 0
    2328:	25 96       	adiw	r28, 0x05	; 5
    232a:	cd bf       	out	0x3d, r28	; 61
    232c:	de bf       	out	0x3e, r29	; 62
    232e:	df 91       	pop	r29
    2330:	cf 91       	pop	r28
    2332:	1f 91       	pop	r17
    2334:	0f 91       	pop	r16
    2336:	ff 90       	pop	r15
    2338:	ef 90       	pop	r14
    233a:	df 90       	pop	r13
    233c:	cf 90       	pop	r12
    233e:	bf 90       	pop	r11
    2340:	af 90       	pop	r10
    2342:	08 95       	ret

00002344 <xQueueGenericSendFromISR>:
    2344:	0f 93       	push	r16
    2346:	1f 93       	push	r17
    2348:	cf 93       	push	r28
    234a:	df 93       	push	r29
    234c:	fa 01       	movw	r30, r20
    234e:	dc 01       	movw	r26, r24
    2350:	5a 96       	adiw	r26, 0x1a	; 26
    2352:	5c 91       	ld	r21, X
    2354:	5a 97       	sbiw	r26, 0x1a	; 26
    2356:	5b 96       	adiw	r26, 0x1b	; 27
    2358:	3c 91       	ld	r19, X
    235a:	53 17       	cp	r21, r19
    235c:	10 f0       	brcs	.+4      	; 0x2362 <xQueueGenericSendFromISR+0x1e>
    235e:	22 30       	cpi	r18, 0x02	; 2
    2360:	d9 f4       	brne	.+54     	; 0x2398 <xQueueGenericSendFromISR+0x54>
    2362:	42 2f       	mov	r20, r18
    2364:	8f 01       	movw	r16, r30
    2366:	ec 01       	movw	r28, r24
    2368:	4f de       	rcall	.-866    	; 0x2008 <prvCopyDataToQueue>
    236a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    236c:	8f 3f       	cpi	r24, 0xFF	; 255
    236e:	79 f4       	brne	.+30     	; 0x238e <xQueueGenericSendFromISR+0x4a>
    2370:	89 89       	ldd	r24, Y+17	; 0x11
    2372:	88 23       	and	r24, r24
    2374:	99 f0       	breq	.+38     	; 0x239c <xQueueGenericSendFromISR+0x58>
    2376:	ce 01       	movw	r24, r28
    2378:	41 96       	adiw	r24, 0x11	; 17
    237a:	5b d4       	rcall	.+2230   	; 0x2c32 <xTaskRemoveFromEventList>
    237c:	88 23       	and	r24, r24
    237e:	81 f0       	breq	.+32     	; 0x23a0 <xQueueGenericSendFromISR+0x5c>
    2380:	01 15       	cp	r16, r1
    2382:	11 05       	cpc	r17, r1
    2384:	79 f0       	breq	.+30     	; 0x23a4 <xQueueGenericSendFromISR+0x60>
    2386:	81 e0       	ldi	r24, 0x01	; 1
    2388:	f8 01       	movw	r30, r16
    238a:	80 83       	st	Z, r24
    238c:	0c c0       	rjmp	.+24     	; 0x23a6 <xQueueGenericSendFromISR+0x62>
    238e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2390:	8f 5f       	subi	r24, 0xFF	; 255
    2392:	8e 8f       	std	Y+30, r24	; 0x1e
    2394:	81 e0       	ldi	r24, 0x01	; 1
    2396:	07 c0       	rjmp	.+14     	; 0x23a6 <xQueueGenericSendFromISR+0x62>
    2398:	80 e0       	ldi	r24, 0x00	; 0
    239a:	05 c0       	rjmp	.+10     	; 0x23a6 <xQueueGenericSendFromISR+0x62>
    239c:	81 e0       	ldi	r24, 0x01	; 1
    239e:	03 c0       	rjmp	.+6      	; 0x23a6 <xQueueGenericSendFromISR+0x62>
    23a0:	81 e0       	ldi	r24, 0x01	; 1
    23a2:	01 c0       	rjmp	.+2      	; 0x23a6 <xQueueGenericSendFromISR+0x62>
    23a4:	81 e0       	ldi	r24, 0x01	; 1
    23a6:	df 91       	pop	r29
    23a8:	cf 91       	pop	r28
    23aa:	1f 91       	pop	r17
    23ac:	0f 91       	pop	r16
    23ae:	08 95       	ret

000023b0 <xQueueGenericReceive>:
    23b0:	af 92       	push	r10
    23b2:	bf 92       	push	r11
    23b4:	cf 92       	push	r12
    23b6:	df 92       	push	r13
    23b8:	ef 92       	push	r14
    23ba:	ff 92       	push	r15
    23bc:	0f 93       	push	r16
    23be:	1f 93       	push	r17
    23c0:	cf 93       	push	r28
    23c2:	df 93       	push	r29
    23c4:	cd b7       	in	r28, 0x3d	; 61
    23c6:	de b7       	in	r29, 0x3e	; 62
    23c8:	25 97       	sbiw	r28, 0x05	; 5
    23ca:	cd bf       	out	0x3d, r28	; 61
    23cc:	de bf       	out	0x3e, r29	; 62
    23ce:	8c 01       	movw	r16, r24
    23d0:	6b 01       	movw	r12, r22
    23d2:	4c 83       	std	Y+4, r20	; 0x04
    23d4:	5d 83       	std	Y+5, r21	; 0x05
    23d6:	a2 2e       	mov	r10, r18
    23d8:	b1 2c       	mov	r11, r1
    23da:	7c 01       	movw	r14, r24
    23dc:	81 e1       	ldi	r24, 0x11	; 17
    23de:	e8 0e       	add	r14, r24
    23e0:	f1 1c       	adc	r15, r1
    23e2:	0f b6       	in	r0, 0x3f	; 63
    23e4:	f8 94       	cli
    23e6:	0f 92       	push	r0
    23e8:	f8 01       	movw	r30, r16
    23ea:	92 8d       	ldd	r25, Z+26	; 0x1a
    23ec:	99 23       	and	r25, r25
    23ee:	21 f1       	breq	.+72     	; 0x2438 <xQueueGenericReceive+0x88>
    23f0:	e6 80       	ldd	r14, Z+6	; 0x06
    23f2:	f7 80       	ldd	r15, Z+7	; 0x07
    23f4:	b6 01       	movw	r22, r12
    23f6:	c8 01       	movw	r24, r16
    23f8:	54 de       	rcall	.-856    	; 0x20a2 <prvCopyDataFromQueue>
    23fa:	a1 10       	cpse	r10, r1
    23fc:	0e c0       	rjmp	.+28     	; 0x241a <xQueueGenericReceive+0x6a>
    23fe:	f8 01       	movw	r30, r16
    2400:	82 8d       	ldd	r24, Z+26	; 0x1a
    2402:	81 50       	subi	r24, 0x01	; 1
    2404:	82 8f       	std	Z+26, r24	; 0x1a
    2406:	80 85       	ldd	r24, Z+8	; 0x08
    2408:	88 23       	and	r24, r24
    240a:	91 f0       	breq	.+36     	; 0x2430 <xQueueGenericReceive+0x80>
    240c:	c8 01       	movw	r24, r16
    240e:	08 96       	adiw	r24, 0x08	; 8
    2410:	10 d4       	rcall	.+2080   	; 0x2c32 <xTaskRemoveFromEventList>
    2412:	81 30       	cpi	r24, 0x01	; 1
    2414:	69 f4       	brne	.+26     	; 0x2430 <xQueueGenericReceive+0x80>
    2416:	2c dd       	rcall	.-1448   	; 0x1e70 <vPortYield>
    2418:	0b c0       	rjmp	.+22     	; 0x2430 <xQueueGenericReceive+0x80>
    241a:	f8 01       	movw	r30, r16
    241c:	e6 82       	std	Z+6, r14	; 0x06
    241e:	f7 82       	std	Z+7, r15	; 0x07
    2420:	81 89       	ldd	r24, Z+17	; 0x11
    2422:	88 23       	and	r24, r24
    2424:	29 f0       	breq	.+10     	; 0x2430 <xQueueGenericReceive+0x80>
    2426:	c8 01       	movw	r24, r16
    2428:	41 96       	adiw	r24, 0x11	; 17
    242a:	03 d4       	rcall	.+2054   	; 0x2c32 <xTaskRemoveFromEventList>
    242c:	81 11       	cpse	r24, r1
    242e:	20 dd       	rcall	.-1472   	; 0x1e70 <vPortYield>
    2430:	0f 90       	pop	r0
    2432:	0f be       	out	0x3f, r0	; 63
    2434:	81 e0       	ldi	r24, 0x01	; 1
    2436:	45 c0       	rjmp	.+138    	; 0x24c2 <xQueueGenericReceive+0x112>
    2438:	4c 81       	ldd	r20, Y+4	; 0x04
    243a:	5d 81       	ldd	r21, Y+5	; 0x05
    243c:	45 2b       	or	r20, r21
    243e:	21 f4       	brne	.+8      	; 0x2448 <xQueueGenericReceive+0x98>
    2440:	0f 90       	pop	r0
    2442:	0f be       	out	0x3f, r0	; 63
    2444:	80 e0       	ldi	r24, 0x00	; 0
    2446:	3d c0       	rjmp	.+122    	; 0x24c2 <xQueueGenericReceive+0x112>
    2448:	b1 10       	cpse	r11, r1
    244a:	05 c0       	rjmp	.+10     	; 0x2456 <xQueueGenericReceive+0xa6>
    244c:	ce 01       	movw	r24, r28
    244e:	01 96       	adiw	r24, 0x01	; 1
    2450:	36 d4       	rcall	.+2156   	; 0x2cbe <vTaskSetTimeOutState>
    2452:	bb 24       	eor	r11, r11
    2454:	b3 94       	inc	r11
    2456:	0f 90       	pop	r0
    2458:	0f be       	out	0x3f, r0	; 63
    245a:	cc d1       	rcall	.+920    	; 0x27f4 <vTaskSuspendAll>
    245c:	0f b6       	in	r0, 0x3f	; 63
    245e:	f8 94       	cli
    2460:	0f 92       	push	r0
    2462:	f8 01       	movw	r30, r16
    2464:	85 8d       	ldd	r24, Z+29	; 0x1d
    2466:	8f 3f       	cpi	r24, 0xFF	; 255
    2468:	09 f4       	brne	.+2      	; 0x246c <xQueueGenericReceive+0xbc>
    246a:	15 8e       	std	Z+29, r1	; 0x1d
    246c:	f8 01       	movw	r30, r16
    246e:	96 8d       	ldd	r25, Z+30	; 0x1e
    2470:	9f 3f       	cpi	r25, 0xFF	; 255
    2472:	09 f4       	brne	.+2      	; 0x2476 <xQueueGenericReceive+0xc6>
    2474:	16 8e       	std	Z+30, r1	; 0x1e
    2476:	0f 90       	pop	r0
    2478:	0f be       	out	0x3f, r0	; 63
    247a:	be 01       	movw	r22, r28
    247c:	6c 5f       	subi	r22, 0xFC	; 252
    247e:	7f 4f       	sbci	r23, 0xFF	; 255
    2480:	ce 01       	movw	r24, r28
    2482:	01 96       	adiw	r24, 0x01	; 1
    2484:	27 d4       	rcall	.+2126   	; 0x2cd4 <xTaskCheckForTimeOut>
    2486:	81 11       	cpse	r24, r1
    2488:	18 c0       	rjmp	.+48     	; 0x24ba <xQueueGenericReceive+0x10a>
    248a:	0f b6       	in	r0, 0x3f	; 63
    248c:	f8 94       	cli
    248e:	0f 92       	push	r0
    2490:	f8 01       	movw	r30, r16
    2492:	82 8d       	ldd	r24, Z+26	; 0x1a
    2494:	0f 90       	pop	r0
    2496:	0f be       	out	0x3f, r0	; 63
    2498:	81 11       	cpse	r24, r1
    249a:	0b c0       	rjmp	.+22     	; 0x24b2 <xQueueGenericReceive+0x102>
    249c:	6c 81       	ldd	r22, Y+4	; 0x04
    249e:	7d 81       	ldd	r23, Y+5	; 0x05
    24a0:	c7 01       	movw	r24, r14
    24a2:	90 d3       	rcall	.+1824   	; 0x2bc4 <vTaskPlaceOnEventList>
    24a4:	c8 01       	movw	r24, r16
    24a6:	17 de       	rcall	.-978    	; 0x20d6 <prvUnlockQueue>
    24a8:	88 d2       	rcall	.+1296   	; 0x29ba <xTaskResumeAll>
    24aa:	81 11       	cpse	r24, r1
    24ac:	9a cf       	rjmp	.-204    	; 0x23e2 <xQueueGenericReceive+0x32>
    24ae:	e0 dc       	rcall	.-1600   	; 0x1e70 <vPortYield>
    24b0:	98 cf       	rjmp	.-208    	; 0x23e2 <xQueueGenericReceive+0x32>
    24b2:	c8 01       	movw	r24, r16
    24b4:	10 de       	rcall	.-992    	; 0x20d6 <prvUnlockQueue>
    24b6:	81 d2       	rcall	.+1282   	; 0x29ba <xTaskResumeAll>
    24b8:	94 cf       	rjmp	.-216    	; 0x23e2 <xQueueGenericReceive+0x32>
    24ba:	c8 01       	movw	r24, r16
    24bc:	0c de       	rcall	.-1000   	; 0x20d6 <prvUnlockQueue>
    24be:	7d d2       	rcall	.+1274   	; 0x29ba <xTaskResumeAll>
    24c0:	80 e0       	ldi	r24, 0x00	; 0
    24c2:	25 96       	adiw	r28, 0x05	; 5
    24c4:	cd bf       	out	0x3d, r28	; 61
    24c6:	de bf       	out	0x3e, r29	; 62
    24c8:	df 91       	pop	r29
    24ca:	cf 91       	pop	r28
    24cc:	1f 91       	pop	r17
    24ce:	0f 91       	pop	r16
    24d0:	ff 90       	pop	r15
    24d2:	ef 90       	pop	r14
    24d4:	df 90       	pop	r13
    24d6:	cf 90       	pop	r12
    24d8:	bf 90       	pop	r11
    24da:	af 90       	pop	r10
    24dc:	08 95       	ret

000024de <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    24de:	cf 93       	push	r28
    24e0:	df 93       	push	r29
    24e2:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    24e4:	0f b6       	in	r0, 0x3f	; 63
    24e6:	f8 94       	cli
    24e8:	0f 92       	push	r0
    24ea:	8d 8d       	ldd	r24, Y+29	; 0x1d
    24ec:	8f 3f       	cpi	r24, 0xFF	; 255
    24ee:	09 f4       	brne	.+2      	; 0x24f2 <vQueueWaitForMessageRestricted+0x14>
    24f0:	1d 8e       	std	Y+29, r1	; 0x1d
    24f2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    24f4:	8f 3f       	cpi	r24, 0xFF	; 255
    24f6:	09 f4       	brne	.+2      	; 0x24fa <vQueueWaitForMessageRestricted+0x1c>
    24f8:	1e 8e       	std	Y+30, r1	; 0x1e
    24fa:	0f 90       	pop	r0
    24fc:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    24fe:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2500:	81 11       	cpse	r24, r1
    2502:	03 c0       	rjmp	.+6      	; 0x250a <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    2504:	ce 01       	movw	r24, r28
    2506:	41 96       	adiw	r24, 0x11	; 17
    2508:	78 d3       	rcall	.+1776   	; 0x2bfa <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    250a:	ce 01       	movw	r24, r28
    250c:	e4 dd       	rcall	.-1080   	; 0x20d6 <prvUnlockQueue>
	}
    250e:	df 91       	pop	r29
    2510:	cf 91       	pop	r28
    2512:	08 95       	ret

00002514 <prvIdleTask>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    2514:	cd e8       	ldi	r28, 0x8D	; 141
    2516:	d2 e2       	ldi	r29, 0x22	; 34
    2518:	88 81       	ld	r24, Y
    251a:	82 30       	cpi	r24, 0x02	; 2
    251c:	f0 f3       	brcs	.-4      	; 0x251a <prvIdleTask+0x6>
    251e:	a8 dc       	rcall	.-1712   	; 0x1e70 <vPortYield>
    2520:	fb cf       	rjmp	.-10     	; 0x2518 <prvIdleTask+0x4>

00002522 <prvAddCurrentTaskToDelayedList>:
    2522:	cf 93       	push	r28
    2524:	df 93       	push	r29
    2526:	ec 01       	movw	r28, r24
    2528:	e0 91 ba 22 	lds	r30, 0x22BA	; 0x8022ba <pxCurrentTCB>
    252c:	f0 91 bb 22 	lds	r31, 0x22BB	; 0x8022bb <pxCurrentTCB+0x1>
    2530:	82 83       	std	Z+2, r24	; 0x02
    2532:	93 83       	std	Z+3, r25	; 0x03
    2534:	80 91 6b 22 	lds	r24, 0x226B	; 0x80226b <xTickCount>
    2538:	90 91 6c 22 	lds	r25, 0x226C	; 0x80226c <xTickCount+0x1>
    253c:	c8 17       	cp	r28, r24
    253e:	d9 07       	cpc	r29, r25
    2540:	60 f4       	brcc	.+24     	; 0x255a <prvAddCurrentTaskToDelayedList+0x38>
    2542:	60 91 ba 22 	lds	r22, 0x22BA	; 0x8022ba <pxCurrentTCB>
    2546:	70 91 bb 22 	lds	r23, 0x22BB	; 0x8022bb <pxCurrentTCB+0x1>
    254a:	80 91 77 22 	lds	r24, 0x2277	; 0x802277 <pxOverflowDelayedTaskList>
    254e:	90 91 78 22 	lds	r25, 0x2278	; 0x802278 <pxOverflowDelayedTaskList+0x1>
    2552:	6e 5f       	subi	r22, 0xFE	; 254
    2554:	7f 4f       	sbci	r23, 0xFF	; 255
    2556:	79 db       	rcall	.-2318   	; 0x1c4a <vListInsert>
    2558:	16 c0       	rjmp	.+44     	; 0x2586 <prvAddCurrentTaskToDelayedList+0x64>
    255a:	60 91 ba 22 	lds	r22, 0x22BA	; 0x8022ba <pxCurrentTCB>
    255e:	70 91 bb 22 	lds	r23, 0x22BB	; 0x8022bb <pxCurrentTCB+0x1>
    2562:	80 91 79 22 	lds	r24, 0x2279	; 0x802279 <pxDelayedTaskList>
    2566:	90 91 7a 22 	lds	r25, 0x227A	; 0x80227a <pxDelayedTaskList+0x1>
    256a:	6e 5f       	subi	r22, 0xFE	; 254
    256c:	7f 4f       	sbci	r23, 0xFF	; 255
    256e:	6d db       	rcall	.-2342   	; 0x1c4a <vListInsert>
    2570:	80 91 63 22 	lds	r24, 0x2263	; 0x802263 <xNextTaskUnblockTime>
    2574:	90 91 64 22 	lds	r25, 0x2264	; 0x802264 <xNextTaskUnblockTime+0x1>
    2578:	c8 17       	cp	r28, r24
    257a:	d9 07       	cpc	r29, r25
    257c:	20 f4       	brcc	.+8      	; 0x2586 <prvAddCurrentTaskToDelayedList+0x64>
    257e:	c0 93 63 22 	sts	0x2263, r28	; 0x802263 <xNextTaskUnblockTime>
    2582:	d0 93 64 22 	sts	0x2264, r29	; 0x802264 <xNextTaskUnblockTime+0x1>
    2586:	df 91       	pop	r29
    2588:	cf 91       	pop	r28
    258a:	08 95       	ret

0000258c <xTaskGenericCreate>:
    258c:	4f 92       	push	r4
    258e:	5f 92       	push	r5
    2590:	6f 92       	push	r6
    2592:	7f 92       	push	r7
    2594:	8f 92       	push	r8
    2596:	9f 92       	push	r9
    2598:	af 92       	push	r10
    259a:	bf 92       	push	r11
    259c:	cf 92       	push	r12
    259e:	df 92       	push	r13
    25a0:	ef 92       	push	r14
    25a2:	ff 92       	push	r15
    25a4:	0f 93       	push	r16
    25a6:	1f 93       	push	r17
    25a8:	cf 93       	push	r28
    25aa:	df 93       	push	r29
    25ac:	4c 01       	movw	r8, r24
    25ae:	eb 01       	movw	r28, r22
    25b0:	5a 01       	movw	r10, r20
    25b2:	29 01       	movw	r4, r18
    25b4:	c1 14       	cp	r12, r1
    25b6:	d1 04       	cpc	r13, r1
    25b8:	31 f4       	brne	.+12     	; 0x25c6 <xTaskGenericCreate+0x3a>
    25ba:	ca 01       	movw	r24, r20
    25bc:	0b dd       	rcall	.-1514   	; 0x1fd4 <pvPortMalloc>
    25be:	6c 01       	movw	r12, r24
    25c0:	89 2b       	or	r24, r25
    25c2:	09 f4       	brne	.+2      	; 0x25c6 <xTaskGenericCreate+0x3a>
    25c4:	d2 c0       	rjmp	.+420    	; 0x276a <xTaskGenericCreate+0x1de>
    25c6:	86 e2       	ldi	r24, 0x26	; 38
    25c8:	90 e0       	ldi	r25, 0x00	; 0
    25ca:	04 dd       	rcall	.-1528   	; 0x1fd4 <pvPortMalloc>
    25cc:	3c 01       	movw	r6, r24
    25ce:	00 97       	sbiw	r24, 0x00	; 0
    25d0:	79 f0       	breq	.+30     	; 0x25f0 <xTaskGenericCreate+0x64>
    25d2:	fc 01       	movw	r30, r24
    25d4:	c7 8a       	std	Z+23, r12	; 0x17
    25d6:	d0 8e       	std	Z+24, r13	; 0x18
    25d8:	f1 e0       	ldi	r31, 0x01	; 1
    25da:	af 1a       	sub	r10, r31
    25dc:	b1 08       	sbc	r11, r1
    25de:	ca 0c       	add	r12, r10
    25e0:	db 1c       	adc	r13, r11
    25e2:	88 81       	ld	r24, Y
    25e4:	f3 01       	movw	r30, r6
    25e6:	81 8f       	std	Z+25, r24	; 0x19
    25e8:	88 81       	ld	r24, Y
    25ea:	81 11       	cpse	r24, r1
    25ec:	04 c0       	rjmp	.+8      	; 0x25f6 <xTaskGenericCreate+0x6a>
    25ee:	13 c0       	rjmp	.+38     	; 0x2616 <xTaskGenericCreate+0x8a>
    25f0:	c6 01       	movw	r24, r12
    25f2:	fd dc       	rcall	.-1542   	; 0x1fee <vPortFree>
    25f4:	ba c0       	rjmp	.+372    	; 0x276a <xTaskGenericCreate+0x1de>
    25f6:	d3 01       	movw	r26, r6
    25f8:	5a 96       	adiw	r26, 0x1a	; 26
    25fa:	fe 01       	movw	r30, r28
    25fc:	31 96       	adiw	r30, 0x01	; 1
    25fe:	9e 01       	movw	r18, r28
    2600:	28 5f       	subi	r18, 0xF8	; 248
    2602:	3f 4f       	sbci	r19, 0xFF	; 255
    2604:	ef 01       	movw	r28, r30
    2606:	81 91       	ld	r24, Z+
    2608:	8d 93       	st	X+, r24
    260a:	88 81       	ld	r24, Y
    260c:	88 23       	and	r24, r24
    260e:	19 f0       	breq	.+6      	; 0x2616 <xTaskGenericCreate+0x8a>
    2610:	e2 17       	cp	r30, r18
    2612:	f3 07       	cpc	r31, r19
    2614:	b9 f7       	brne	.-18     	; 0x2604 <xTaskGenericCreate+0x78>
    2616:	f3 01       	movw	r30, r6
    2618:	10 a2       	std	Z+32, r1	; 0x20
    261a:	10 2f       	mov	r17, r16
    261c:	05 30       	cpi	r16, 0x05	; 5
    261e:	08 f0       	brcs	.+2      	; 0x2622 <xTaskGenericCreate+0x96>
    2620:	14 e0       	ldi	r17, 0x04	; 4
    2622:	f3 01       	movw	r30, r6
    2624:	16 8b       	std	Z+22, r17	; 0x16
    2626:	e3 01       	movw	r28, r6
    2628:	22 96       	adiw	r28, 0x02	; 2
    262a:	ce 01       	movw	r24, r28
    262c:	e9 da       	rcall	.-2606   	; 0x1c00 <vListInitialiseItem>
    262e:	c3 01       	movw	r24, r6
    2630:	0c 96       	adiw	r24, 0x0c	; 12
    2632:	e6 da       	rcall	.-2612   	; 0x1c00 <vListInitialiseItem>
    2634:	f3 01       	movw	r30, r6
    2636:	60 86       	std	Z+8, r6	; 0x08
    2638:	71 86       	std	Z+9, r7	; 0x09
    263a:	85 e0       	ldi	r24, 0x05	; 5
    263c:	90 e0       	ldi	r25, 0x00	; 0
    263e:	81 1b       	sub	r24, r17
    2640:	91 09       	sbc	r25, r1
    2642:	84 87       	std	Z+12, r24	; 0x0c
    2644:	95 87       	std	Z+13, r25	; 0x0d
    2646:	62 8a       	std	Z+18, r6	; 0x12
    2648:	73 8a       	std	Z+19, r7	; 0x13
    264a:	11 a2       	std	Z+33, r1	; 0x21
    264c:	12 a2       	std	Z+34, r1	; 0x22
    264e:	13 a2       	std	Z+35, r1	; 0x23
    2650:	14 a2       	std	Z+36, r1	; 0x24
    2652:	15 a2       	std	Z+37, r1	; 0x25
    2654:	a2 01       	movw	r20, r4
    2656:	b4 01       	movw	r22, r8
    2658:	c6 01       	movw	r24, r12
    265a:	4e db       	rcall	.-2404   	; 0x1cf8 <pxPortInitialiseStack>
    265c:	f3 01       	movw	r30, r6
    265e:	80 83       	st	Z, r24
    2660:	91 83       	std	Z+1, r25	; 0x01
    2662:	e1 14       	cp	r14, r1
    2664:	f1 04       	cpc	r15, r1
    2666:	19 f0       	breq	.+6      	; 0x266e <xTaskGenericCreate+0xe2>
    2668:	f7 01       	movw	r30, r14
    266a:	60 82       	st	Z, r6
    266c:	71 82       	std	Z+1, r7	; 0x01
    266e:	0f b6       	in	r0, 0x3f	; 63
    2670:	f8 94       	cli
    2672:	0f 92       	push	r0
    2674:	80 91 6d 22 	lds	r24, 0x226D	; 0x80226d <uxCurrentNumberOfTasks>
    2678:	8f 5f       	subi	r24, 0xFF	; 255
    267a:	80 93 6d 22 	sts	0x226D, r24	; 0x80226d <uxCurrentNumberOfTasks>
    267e:	80 91 ba 22 	lds	r24, 0x22BA	; 0x8022ba <pxCurrentTCB>
    2682:	90 91 bb 22 	lds	r25, 0x22BB	; 0x8022bb <pxCurrentTCB+0x1>
    2686:	89 2b       	or	r24, r25
    2688:	91 f5       	brne	.+100    	; 0x26ee <xTaskGenericCreate+0x162>
    268a:	60 92 ba 22 	sts	0x22BA, r6	; 0x8022ba <pxCurrentTCB>
    268e:	70 92 bb 22 	sts	0x22BB, r7	; 0x8022bb <pxCurrentTCB+0x1>
    2692:	80 91 6d 22 	lds	r24, 0x226D	; 0x80226d <uxCurrentNumberOfTasks>
    2696:	81 30       	cpi	r24, 0x01	; 1
    2698:	c9 f5       	brne	.+114    	; 0x270c <xTaskGenericCreate+0x180>
    269a:	0f 2e       	mov	r0, r31
    269c:	fd e8       	ldi	r31, 0x8D	; 141
    269e:	ef 2e       	mov	r14, r31
    26a0:	f2 e2       	ldi	r31, 0x22	; 34
    26a2:	ff 2e       	mov	r15, r31
    26a4:	f0 2d       	mov	r31, r0
    26a6:	0f 2e       	mov	r0, r31
    26a8:	fa eb       	ldi	r31, 0xBA	; 186
    26aa:	cf 2e       	mov	r12, r31
    26ac:	f2 e2       	ldi	r31, 0x22	; 34
    26ae:	df 2e       	mov	r13, r31
    26b0:	f0 2d       	mov	r31, r0
    26b2:	c7 01       	movw	r24, r14
    26b4:	97 da       	rcall	.-2770   	; 0x1be4 <vListInitialise>
    26b6:	f9 e0       	ldi	r31, 0x09	; 9
    26b8:	ef 0e       	add	r14, r31
    26ba:	f1 1c       	adc	r15, r1
    26bc:	ec 14       	cp	r14, r12
    26be:	fd 04       	cpc	r15, r13
    26c0:	c1 f7       	brne	.-16     	; 0x26b2 <xTaskGenericCreate+0x126>
    26c2:	84 e8       	ldi	r24, 0x84	; 132
    26c4:	92 e2       	ldi	r25, 0x22	; 34
    26c6:	8e da       	rcall	.-2788   	; 0x1be4 <vListInitialise>
    26c8:	8b e7       	ldi	r24, 0x7B	; 123
    26ca:	92 e2       	ldi	r25, 0x22	; 34
    26cc:	8b da       	rcall	.-2794   	; 0x1be4 <vListInitialise>
    26ce:	8e e6       	ldi	r24, 0x6E	; 110
    26d0:	92 e2       	ldi	r25, 0x22	; 34
    26d2:	88 da       	rcall	.-2800   	; 0x1be4 <vListInitialise>
    26d4:	84 e8       	ldi	r24, 0x84	; 132
    26d6:	92 e2       	ldi	r25, 0x22	; 34
    26d8:	80 93 79 22 	sts	0x2279, r24	; 0x802279 <pxDelayedTaskList>
    26dc:	90 93 7a 22 	sts	0x227A, r25	; 0x80227a <pxDelayedTaskList+0x1>
    26e0:	8b e7       	ldi	r24, 0x7B	; 123
    26e2:	92 e2       	ldi	r25, 0x22	; 34
    26e4:	80 93 77 22 	sts	0x2277, r24	; 0x802277 <pxOverflowDelayedTaskList>
    26e8:	90 93 78 22 	sts	0x2278, r25	; 0x802278 <pxOverflowDelayedTaskList+0x1>
    26ec:	0f c0       	rjmp	.+30     	; 0x270c <xTaskGenericCreate+0x180>
    26ee:	80 91 69 22 	lds	r24, 0x2269	; 0x802269 <xSchedulerRunning>
    26f2:	81 11       	cpse	r24, r1
    26f4:	0b c0       	rjmp	.+22     	; 0x270c <xTaskGenericCreate+0x180>
    26f6:	e0 91 ba 22 	lds	r30, 0x22BA	; 0x8022ba <pxCurrentTCB>
    26fa:	f0 91 bb 22 	lds	r31, 0x22BB	; 0x8022bb <pxCurrentTCB+0x1>
    26fe:	86 89       	ldd	r24, Z+22	; 0x16
    2700:	08 17       	cp	r16, r24
    2702:	20 f0       	brcs	.+8      	; 0x270c <xTaskGenericCreate+0x180>
    2704:	60 92 ba 22 	sts	0x22BA, r6	; 0x8022ba <pxCurrentTCB>
    2708:	70 92 bb 22 	sts	0x22BB, r7	; 0x8022bb <pxCurrentTCB+0x1>
    270c:	80 91 65 22 	lds	r24, 0x2265	; 0x802265 <uxTaskNumber>
    2710:	8f 5f       	subi	r24, 0xFF	; 255
    2712:	80 93 65 22 	sts	0x2265, r24	; 0x802265 <uxTaskNumber>
    2716:	f3 01       	movw	r30, r6
    2718:	86 89       	ldd	r24, Z+22	; 0x16
    271a:	90 91 6a 22 	lds	r25, 0x226A	; 0x80226a <uxTopReadyPriority>
    271e:	98 17       	cp	r25, r24
    2720:	10 f4       	brcc	.+4      	; 0x2726 <xTaskGenericCreate+0x19a>
    2722:	80 93 6a 22 	sts	0x226A, r24	; 0x80226a <uxTopReadyPriority>
    2726:	90 e0       	ldi	r25, 0x00	; 0
    2728:	9c 01       	movw	r18, r24
    272a:	22 0f       	add	r18, r18
    272c:	33 1f       	adc	r19, r19
    272e:	22 0f       	add	r18, r18
    2730:	33 1f       	adc	r19, r19
    2732:	22 0f       	add	r18, r18
    2734:	33 1f       	adc	r19, r19
    2736:	82 0f       	add	r24, r18
    2738:	93 1f       	adc	r25, r19
    273a:	be 01       	movw	r22, r28
    273c:	83 57       	subi	r24, 0x73	; 115
    273e:	9d 4d       	sbci	r25, 0xDD	; 221
    2740:	63 da       	rcall	.-2874   	; 0x1c08 <vListInsertEnd>
    2742:	0f 90       	pop	r0
    2744:	0f be       	out	0x3f, r0	; 63
    2746:	80 91 69 22 	lds	r24, 0x2269	; 0x802269 <xSchedulerRunning>
    274a:	88 23       	and	r24, r24
    274c:	51 f0       	breq	.+20     	; 0x2762 <xTaskGenericCreate+0x1d6>
    274e:	e0 91 ba 22 	lds	r30, 0x22BA	; 0x8022ba <pxCurrentTCB>
    2752:	f0 91 bb 22 	lds	r31, 0x22BB	; 0x8022bb <pxCurrentTCB+0x1>
    2756:	86 89       	ldd	r24, Z+22	; 0x16
    2758:	80 17       	cp	r24, r16
    275a:	28 f4       	brcc	.+10     	; 0x2766 <xTaskGenericCreate+0x1da>
    275c:	89 db       	rcall	.-2286   	; 0x1e70 <vPortYield>
    275e:	81 e0       	ldi	r24, 0x01	; 1
    2760:	05 c0       	rjmp	.+10     	; 0x276c <xTaskGenericCreate+0x1e0>
    2762:	81 e0       	ldi	r24, 0x01	; 1
    2764:	03 c0       	rjmp	.+6      	; 0x276c <xTaskGenericCreate+0x1e0>
    2766:	81 e0       	ldi	r24, 0x01	; 1
    2768:	01 c0       	rjmp	.+2      	; 0x276c <xTaskGenericCreate+0x1e0>
    276a:	8f ef       	ldi	r24, 0xFF	; 255
    276c:	df 91       	pop	r29
    276e:	cf 91       	pop	r28
    2770:	1f 91       	pop	r17
    2772:	0f 91       	pop	r16
    2774:	ff 90       	pop	r15
    2776:	ef 90       	pop	r14
    2778:	df 90       	pop	r13
    277a:	cf 90       	pop	r12
    277c:	bf 90       	pop	r11
    277e:	af 90       	pop	r10
    2780:	9f 90       	pop	r9
    2782:	8f 90       	pop	r8
    2784:	7f 90       	pop	r7
    2786:	6f 90       	pop	r6
    2788:	5f 90       	pop	r5
    278a:	4f 90       	pop	r4
    278c:	08 95       	ret

0000278e <vTaskStartScheduler>:
    278e:	af 92       	push	r10
    2790:	bf 92       	push	r11
    2792:	cf 92       	push	r12
    2794:	df 92       	push	r13
    2796:	ef 92       	push	r14
    2798:	ff 92       	push	r15
    279a:	0f 93       	push	r16
    279c:	a1 2c       	mov	r10, r1
    279e:	b1 2c       	mov	r11, r1
    27a0:	c1 2c       	mov	r12, r1
    27a2:	d1 2c       	mov	r13, r1
    27a4:	e1 2c       	mov	r14, r1
    27a6:	f1 2c       	mov	r15, r1
    27a8:	00 e0       	ldi	r16, 0x00	; 0
    27aa:	20 e0       	ldi	r18, 0x00	; 0
    27ac:	30 e0       	ldi	r19, 0x00	; 0
    27ae:	45 e5       	ldi	r20, 0x55	; 85
    27b0:	50 e0       	ldi	r21, 0x00	; 0
    27b2:	64 e1       	ldi	r22, 0x14	; 20
    27b4:	70 e2       	ldi	r23, 0x20	; 32
    27b6:	8a e8       	ldi	r24, 0x8A	; 138
    27b8:	92 e1       	ldi	r25, 0x12	; 18
    27ba:	e8 de       	rcall	.-560    	; 0x258c <xTaskGenericCreate>
    27bc:	81 30       	cpi	r24, 0x01	; 1
    27be:	91 f4       	brne	.+36     	; 0x27e4 <vTaskStartScheduler+0x56>
    27c0:	23 d3       	rcall	.+1606   	; 0x2e08 <xTimerCreateTimerTask>
    27c2:	81 30       	cpi	r24, 0x01	; 1
    27c4:	79 f4       	brne	.+30     	; 0x27e4 <vTaskStartScheduler+0x56>
    27c6:	f8 94       	cli
    27c8:	8f ef       	ldi	r24, 0xFF	; 255
    27ca:	9f ef       	ldi	r25, 0xFF	; 255
    27cc:	80 93 63 22 	sts	0x2263, r24	; 0x802263 <xNextTaskUnblockTime>
    27d0:	90 93 64 22 	sts	0x2264, r25	; 0x802264 <xNextTaskUnblockTime+0x1>
    27d4:	81 e0       	ldi	r24, 0x01	; 1
    27d6:	80 93 69 22 	sts	0x2269, r24	; 0x802269 <xSchedulerRunning>
    27da:	10 92 6b 22 	sts	0x226B, r1	; 0x80226b <xTickCount>
    27de:	10 92 6c 22 	sts	0x226C, r1	; 0x80226c <xTickCount+0x1>
    27e2:	01 db       	rcall	.-2558   	; 0x1de6 <xPortStartScheduler>
    27e4:	0f 91       	pop	r16
    27e6:	ff 90       	pop	r15
    27e8:	ef 90       	pop	r14
    27ea:	df 90       	pop	r13
    27ec:	cf 90       	pop	r12
    27ee:	bf 90       	pop	r11
    27f0:	af 90       	pop	r10
    27f2:	08 95       	ret

000027f4 <vTaskSuspendAll>:
    27f4:	80 91 62 22 	lds	r24, 0x2262	; 0x802262 <uxSchedulerSuspended>
    27f8:	8f 5f       	subi	r24, 0xFF	; 255
    27fa:	80 93 62 22 	sts	0x2262, r24	; 0x802262 <uxSchedulerSuspended>
    27fe:	08 95       	ret

00002800 <xTaskGetTickCount>:
    2800:	0f b6       	in	r0, 0x3f	; 63
    2802:	f8 94       	cli
    2804:	0f 92       	push	r0
    2806:	80 91 6b 22 	lds	r24, 0x226B	; 0x80226b <xTickCount>
    280a:	90 91 6c 22 	lds	r25, 0x226C	; 0x80226c <xTickCount+0x1>
    280e:	0f 90       	pop	r0
    2810:	0f be       	out	0x3f, r0	; 63
    2812:	08 95       	ret

00002814 <xTaskIncrementTick>:
    2814:	df 92       	push	r13
    2816:	ef 92       	push	r14
    2818:	ff 92       	push	r15
    281a:	0f 93       	push	r16
    281c:	1f 93       	push	r17
    281e:	cf 93       	push	r28
    2820:	df 93       	push	r29
    2822:	80 91 62 22 	lds	r24, 0x2262	; 0x802262 <uxSchedulerSuspended>
    2826:	81 11       	cpse	r24, r1
    2828:	b3 c0       	rjmp	.+358    	; 0x2990 <xTaskIncrementTick+0x17c>
    282a:	80 91 6b 22 	lds	r24, 0x226B	; 0x80226b <xTickCount>
    282e:	90 91 6c 22 	lds	r25, 0x226C	; 0x80226c <xTickCount+0x1>
    2832:	01 96       	adiw	r24, 0x01	; 1
    2834:	80 93 6b 22 	sts	0x226B, r24	; 0x80226b <xTickCount>
    2838:	90 93 6c 22 	sts	0x226C, r25	; 0x80226c <xTickCount+0x1>
    283c:	e0 90 6b 22 	lds	r14, 0x226B	; 0x80226b <xTickCount>
    2840:	f0 90 6c 22 	lds	r15, 0x226C	; 0x80226c <xTickCount+0x1>
    2844:	e1 14       	cp	r14, r1
    2846:	f1 04       	cpc	r15, r1
    2848:	99 f5       	brne	.+102    	; 0x28b0 <xTaskIncrementTick+0x9c>
    284a:	80 91 79 22 	lds	r24, 0x2279	; 0x802279 <pxDelayedTaskList>
    284e:	90 91 7a 22 	lds	r25, 0x227A	; 0x80227a <pxDelayedTaskList+0x1>
    2852:	20 91 77 22 	lds	r18, 0x2277	; 0x802277 <pxOverflowDelayedTaskList>
    2856:	30 91 78 22 	lds	r19, 0x2278	; 0x802278 <pxOverflowDelayedTaskList+0x1>
    285a:	20 93 79 22 	sts	0x2279, r18	; 0x802279 <pxDelayedTaskList>
    285e:	30 93 7a 22 	sts	0x227A, r19	; 0x80227a <pxDelayedTaskList+0x1>
    2862:	80 93 77 22 	sts	0x2277, r24	; 0x802277 <pxOverflowDelayedTaskList>
    2866:	90 93 78 22 	sts	0x2278, r25	; 0x802278 <pxOverflowDelayedTaskList+0x1>
    286a:	80 91 66 22 	lds	r24, 0x2266	; 0x802266 <xNumOfOverflows>
    286e:	8f 5f       	subi	r24, 0xFF	; 255
    2870:	80 93 66 22 	sts	0x2266, r24	; 0x802266 <xNumOfOverflows>
    2874:	e0 91 79 22 	lds	r30, 0x2279	; 0x802279 <pxDelayedTaskList>
    2878:	f0 91 7a 22 	lds	r31, 0x227A	; 0x80227a <pxDelayedTaskList+0x1>
    287c:	80 81       	ld	r24, Z
    287e:	81 11       	cpse	r24, r1
    2880:	07 c0       	rjmp	.+14     	; 0x2890 <xTaskIncrementTick+0x7c>
    2882:	8f ef       	ldi	r24, 0xFF	; 255
    2884:	9f ef       	ldi	r25, 0xFF	; 255
    2886:	80 93 63 22 	sts	0x2263, r24	; 0x802263 <xNextTaskUnblockTime>
    288a:	90 93 64 22 	sts	0x2264, r25	; 0x802264 <xNextTaskUnblockTime+0x1>
    288e:	10 c0       	rjmp	.+32     	; 0x28b0 <xTaskIncrementTick+0x9c>
    2890:	e0 91 79 22 	lds	r30, 0x2279	; 0x802279 <pxDelayedTaskList>
    2894:	f0 91 7a 22 	lds	r31, 0x227A	; 0x80227a <pxDelayedTaskList+0x1>
    2898:	05 80       	ldd	r0, Z+5	; 0x05
    289a:	f6 81       	ldd	r31, Z+6	; 0x06
    289c:	e0 2d       	mov	r30, r0
    289e:	06 80       	ldd	r0, Z+6	; 0x06
    28a0:	f7 81       	ldd	r31, Z+7	; 0x07
    28a2:	e0 2d       	mov	r30, r0
    28a4:	82 81       	ldd	r24, Z+2	; 0x02
    28a6:	93 81       	ldd	r25, Z+3	; 0x03
    28a8:	80 93 63 22 	sts	0x2263, r24	; 0x802263 <xNextTaskUnblockTime>
    28ac:	90 93 64 22 	sts	0x2264, r25	; 0x802264 <xNextTaskUnblockTime+0x1>
    28b0:	80 91 63 22 	lds	r24, 0x2263	; 0x802263 <xNextTaskUnblockTime>
    28b4:	90 91 64 22 	lds	r25, 0x2264	; 0x802264 <xNextTaskUnblockTime+0x1>
    28b8:	e8 16       	cp	r14, r24
    28ba:	f9 06       	cpc	r15, r25
    28bc:	10 f4       	brcc	.+4      	; 0x28c2 <xTaskIncrementTick+0xae>
    28be:	d1 2c       	mov	r13, r1
    28c0:	4f c0       	rjmp	.+158    	; 0x2960 <xTaskIncrementTick+0x14c>
    28c2:	d1 2c       	mov	r13, r1
    28c4:	e0 91 79 22 	lds	r30, 0x2279	; 0x802279 <pxDelayedTaskList>
    28c8:	f0 91 7a 22 	lds	r31, 0x227A	; 0x80227a <pxDelayedTaskList+0x1>
    28cc:	90 81       	ld	r25, Z
    28ce:	91 11       	cpse	r25, r1
    28d0:	07 c0       	rjmp	.+14     	; 0x28e0 <xTaskIncrementTick+0xcc>
    28d2:	8f ef       	ldi	r24, 0xFF	; 255
    28d4:	9f ef       	ldi	r25, 0xFF	; 255
    28d6:	80 93 63 22 	sts	0x2263, r24	; 0x802263 <xNextTaskUnblockTime>
    28da:	90 93 64 22 	sts	0x2264, r25	; 0x802264 <xNextTaskUnblockTime+0x1>
    28de:	40 c0       	rjmp	.+128    	; 0x2960 <xTaskIncrementTick+0x14c>
    28e0:	e0 91 79 22 	lds	r30, 0x2279	; 0x802279 <pxDelayedTaskList>
    28e4:	f0 91 7a 22 	lds	r31, 0x227A	; 0x80227a <pxDelayedTaskList+0x1>
    28e8:	05 80       	ldd	r0, Z+5	; 0x05
    28ea:	f6 81       	ldd	r31, Z+6	; 0x06
    28ec:	e0 2d       	mov	r30, r0
    28ee:	c6 81       	ldd	r28, Z+6	; 0x06
    28f0:	d7 81       	ldd	r29, Z+7	; 0x07
    28f2:	2a 81       	ldd	r18, Y+2	; 0x02
    28f4:	3b 81       	ldd	r19, Y+3	; 0x03
    28f6:	e2 16       	cp	r14, r18
    28f8:	f3 06       	cpc	r15, r19
    28fa:	28 f4       	brcc	.+10     	; 0x2906 <xTaskIncrementTick+0xf2>
    28fc:	20 93 63 22 	sts	0x2263, r18	; 0x802263 <xNextTaskUnblockTime>
    2900:	30 93 64 22 	sts	0x2264, r19	; 0x802264 <xNextTaskUnblockTime+0x1>
    2904:	2d c0       	rjmp	.+90     	; 0x2960 <xTaskIncrementTick+0x14c>
    2906:	8e 01       	movw	r16, r28
    2908:	0e 5f       	subi	r16, 0xFE	; 254
    290a:	1f 4f       	sbci	r17, 0xFF	; 255
    290c:	c8 01       	movw	r24, r16
    290e:	ce d9       	rcall	.-3172   	; 0x1cac <uxListRemove>
    2910:	8c 89       	ldd	r24, Y+20	; 0x14
    2912:	9d 89       	ldd	r25, Y+21	; 0x15
    2914:	89 2b       	or	r24, r25
    2916:	19 f0       	breq	.+6      	; 0x291e <xTaskIncrementTick+0x10a>
    2918:	ce 01       	movw	r24, r28
    291a:	0c 96       	adiw	r24, 0x0c	; 12
    291c:	c7 d9       	rcall	.-3186   	; 0x1cac <uxListRemove>
    291e:	2e 89       	ldd	r18, Y+22	; 0x16
    2920:	80 91 6a 22 	lds	r24, 0x226A	; 0x80226a <uxTopReadyPriority>
    2924:	82 17       	cp	r24, r18
    2926:	10 f4       	brcc	.+4      	; 0x292c <xTaskIncrementTick+0x118>
    2928:	20 93 6a 22 	sts	0x226A, r18	; 0x80226a <uxTopReadyPriority>
    292c:	30 e0       	ldi	r19, 0x00	; 0
    292e:	c9 01       	movw	r24, r18
    2930:	88 0f       	add	r24, r24
    2932:	99 1f       	adc	r25, r25
    2934:	88 0f       	add	r24, r24
    2936:	99 1f       	adc	r25, r25
    2938:	88 0f       	add	r24, r24
    293a:	99 1f       	adc	r25, r25
    293c:	82 0f       	add	r24, r18
    293e:	93 1f       	adc	r25, r19
    2940:	b8 01       	movw	r22, r16
    2942:	83 57       	subi	r24, 0x73	; 115
    2944:	9d 4d       	sbci	r25, 0xDD	; 221
    2946:	60 d9       	rcall	.-3392   	; 0x1c08 <vListInsertEnd>
    2948:	e0 91 ba 22 	lds	r30, 0x22BA	; 0x8022ba <pxCurrentTCB>
    294c:	f0 91 bb 22 	lds	r31, 0x22BB	; 0x8022bb <pxCurrentTCB+0x1>
    2950:	9e 89       	ldd	r25, Y+22	; 0x16
    2952:	86 89       	ldd	r24, Z+22	; 0x16
    2954:	98 17       	cp	r25, r24
    2956:	08 f4       	brcc	.+2      	; 0x295a <xTaskIncrementTick+0x146>
    2958:	b5 cf       	rjmp	.-150    	; 0x28c4 <xTaskIncrementTick+0xb0>
    295a:	dd 24       	eor	r13, r13
    295c:	d3 94       	inc	r13
    295e:	b2 cf       	rjmp	.-156    	; 0x28c4 <xTaskIncrementTick+0xb0>
    2960:	e0 91 ba 22 	lds	r30, 0x22BA	; 0x8022ba <pxCurrentTCB>
    2964:	f0 91 bb 22 	lds	r31, 0x22BB	; 0x8022bb <pxCurrentTCB+0x1>
    2968:	86 89       	ldd	r24, Z+22	; 0x16
    296a:	90 e0       	ldi	r25, 0x00	; 0
    296c:	fc 01       	movw	r30, r24
    296e:	ee 0f       	add	r30, r30
    2970:	ff 1f       	adc	r31, r31
    2972:	ee 0f       	add	r30, r30
    2974:	ff 1f       	adc	r31, r31
    2976:	ee 0f       	add	r30, r30
    2978:	ff 1f       	adc	r31, r31
    297a:	8e 0f       	add	r24, r30
    297c:	9f 1f       	adc	r25, r31
    297e:	fc 01       	movw	r30, r24
    2980:	e3 57       	subi	r30, 0x73	; 115
    2982:	fd 4d       	sbci	r31, 0xDD	; 221
    2984:	80 81       	ld	r24, Z
    2986:	82 30       	cpi	r24, 0x02	; 2
    2988:	48 f0       	brcs	.+18     	; 0x299c <xTaskIncrementTick+0x188>
    298a:	dd 24       	eor	r13, r13
    298c:	d3 94       	inc	r13
    298e:	06 c0       	rjmp	.+12     	; 0x299c <xTaskIncrementTick+0x188>
    2990:	80 91 68 22 	lds	r24, 0x2268	; 0x802268 <uxPendedTicks>
    2994:	8f 5f       	subi	r24, 0xFF	; 255
    2996:	80 93 68 22 	sts	0x2268, r24	; 0x802268 <uxPendedTicks>
    299a:	d1 2c       	mov	r13, r1
    299c:	80 91 67 22 	lds	r24, 0x2267	; 0x802267 <xYieldPending>
    29a0:	88 23       	and	r24, r24
    29a2:	11 f0       	breq	.+4      	; 0x29a8 <xTaskIncrementTick+0x194>
    29a4:	dd 24       	eor	r13, r13
    29a6:	d3 94       	inc	r13
    29a8:	8d 2d       	mov	r24, r13
    29aa:	df 91       	pop	r29
    29ac:	cf 91       	pop	r28
    29ae:	1f 91       	pop	r17
    29b0:	0f 91       	pop	r16
    29b2:	ff 90       	pop	r15
    29b4:	ef 90       	pop	r14
    29b6:	df 90       	pop	r13
    29b8:	08 95       	ret

000029ba <xTaskResumeAll>:
    29ba:	df 92       	push	r13
    29bc:	ef 92       	push	r14
    29be:	ff 92       	push	r15
    29c0:	0f 93       	push	r16
    29c2:	1f 93       	push	r17
    29c4:	cf 93       	push	r28
    29c6:	df 93       	push	r29
    29c8:	0f b6       	in	r0, 0x3f	; 63
    29ca:	f8 94       	cli
    29cc:	0f 92       	push	r0
    29ce:	80 91 62 22 	lds	r24, 0x2262	; 0x802262 <uxSchedulerSuspended>
    29d2:	81 50       	subi	r24, 0x01	; 1
    29d4:	80 93 62 22 	sts	0x2262, r24	; 0x802262 <uxSchedulerSuspended>
    29d8:	80 91 62 22 	lds	r24, 0x2262	; 0x802262 <uxSchedulerSuspended>
    29dc:	81 11       	cpse	r24, r1
    29de:	5d c0       	rjmp	.+186    	; 0x2a9a <xTaskResumeAll+0xe0>
    29e0:	80 91 6d 22 	lds	r24, 0x226D	; 0x80226d <uxCurrentNumberOfTasks>
    29e4:	81 11       	cpse	r24, r1
    29e6:	30 c0       	rjmp	.+96     	; 0x2a48 <xTaskResumeAll+0x8e>
    29e8:	5b c0       	rjmp	.+182    	; 0x2aa0 <xTaskResumeAll+0xe6>
    29ea:	d7 01       	movw	r26, r14
    29ec:	15 96       	adiw	r26, 0x05	; 5
    29ee:	ed 91       	ld	r30, X+
    29f0:	fc 91       	ld	r31, X
    29f2:	16 97       	sbiw	r26, 0x06	; 6
    29f4:	c6 81       	ldd	r28, Z+6	; 0x06
    29f6:	d7 81       	ldd	r29, Z+7	; 0x07
    29f8:	ce 01       	movw	r24, r28
    29fa:	0c 96       	adiw	r24, 0x0c	; 12
    29fc:	57 d9       	rcall	.-3410   	; 0x1cac <uxListRemove>
    29fe:	8e 01       	movw	r16, r28
    2a00:	0e 5f       	subi	r16, 0xFE	; 254
    2a02:	1f 4f       	sbci	r17, 0xFF	; 255
    2a04:	c8 01       	movw	r24, r16
    2a06:	52 d9       	rcall	.-3420   	; 0x1cac <uxListRemove>
    2a08:	2e 89       	ldd	r18, Y+22	; 0x16
    2a0a:	80 91 6a 22 	lds	r24, 0x226A	; 0x80226a <uxTopReadyPriority>
    2a0e:	82 17       	cp	r24, r18
    2a10:	10 f4       	brcc	.+4      	; 0x2a16 <xTaskResumeAll+0x5c>
    2a12:	20 93 6a 22 	sts	0x226A, r18	; 0x80226a <uxTopReadyPriority>
    2a16:	30 e0       	ldi	r19, 0x00	; 0
    2a18:	c9 01       	movw	r24, r18
    2a1a:	88 0f       	add	r24, r24
    2a1c:	99 1f       	adc	r25, r25
    2a1e:	88 0f       	add	r24, r24
    2a20:	99 1f       	adc	r25, r25
    2a22:	88 0f       	add	r24, r24
    2a24:	99 1f       	adc	r25, r25
    2a26:	82 0f       	add	r24, r18
    2a28:	93 1f       	adc	r25, r19
    2a2a:	b8 01       	movw	r22, r16
    2a2c:	83 57       	subi	r24, 0x73	; 115
    2a2e:	9d 4d       	sbci	r25, 0xDD	; 221
    2a30:	eb d8       	rcall	.-3626   	; 0x1c08 <vListInsertEnd>
    2a32:	e0 91 ba 22 	lds	r30, 0x22BA	; 0x8022ba <pxCurrentTCB>
    2a36:	f0 91 bb 22 	lds	r31, 0x22BB	; 0x8022bb <pxCurrentTCB+0x1>
    2a3a:	9e 89       	ldd	r25, Y+22	; 0x16
    2a3c:	86 89       	ldd	r24, Z+22	; 0x16
    2a3e:	98 17       	cp	r25, r24
    2a40:	58 f0       	brcs	.+22     	; 0x2a58 <xTaskResumeAll+0x9e>
    2a42:	d0 92 67 22 	sts	0x2267, r13	; 0x802267 <xYieldPending>
    2a46:	08 c0       	rjmp	.+16     	; 0x2a58 <xTaskResumeAll+0x9e>
    2a48:	0f 2e       	mov	r0, r31
    2a4a:	fe e6       	ldi	r31, 0x6E	; 110
    2a4c:	ef 2e       	mov	r14, r31
    2a4e:	f2 e2       	ldi	r31, 0x22	; 34
    2a50:	ff 2e       	mov	r15, r31
    2a52:	f0 2d       	mov	r31, r0
    2a54:	dd 24       	eor	r13, r13
    2a56:	d3 94       	inc	r13
    2a58:	f7 01       	movw	r30, r14
    2a5a:	80 81       	ld	r24, Z
    2a5c:	81 11       	cpse	r24, r1
    2a5e:	c5 cf       	rjmp	.-118    	; 0x29ea <xTaskResumeAll+0x30>
    2a60:	80 91 68 22 	lds	r24, 0x2268	; 0x802268 <uxPendedTicks>
    2a64:	88 23       	and	r24, r24
    2a66:	91 f0       	breq	.+36     	; 0x2a8c <xTaskResumeAll+0xd2>
    2a68:	80 91 68 22 	lds	r24, 0x2268	; 0x802268 <uxPendedTicks>
    2a6c:	88 23       	and	r24, r24
    2a6e:	71 f0       	breq	.+28     	; 0x2a8c <xTaskResumeAll+0xd2>
    2a70:	c1 e0       	ldi	r28, 0x01	; 1
    2a72:	d0 de       	rcall	.-608    	; 0x2814 <xTaskIncrementTick>
    2a74:	81 11       	cpse	r24, r1
    2a76:	c0 93 67 22 	sts	0x2267, r28	; 0x802267 <xYieldPending>
    2a7a:	80 91 68 22 	lds	r24, 0x2268	; 0x802268 <uxPendedTicks>
    2a7e:	81 50       	subi	r24, 0x01	; 1
    2a80:	80 93 68 22 	sts	0x2268, r24	; 0x802268 <uxPendedTicks>
    2a84:	80 91 68 22 	lds	r24, 0x2268	; 0x802268 <uxPendedTicks>
    2a88:	81 11       	cpse	r24, r1
    2a8a:	f3 cf       	rjmp	.-26     	; 0x2a72 <xTaskResumeAll+0xb8>
    2a8c:	80 91 67 22 	lds	r24, 0x2267	; 0x802267 <xYieldPending>
    2a90:	81 30       	cpi	r24, 0x01	; 1
    2a92:	29 f4       	brne	.+10     	; 0x2a9e <xTaskResumeAll+0xe4>
    2a94:	ed d9       	rcall	.-3110   	; 0x1e70 <vPortYield>
    2a96:	81 e0       	ldi	r24, 0x01	; 1
    2a98:	03 c0       	rjmp	.+6      	; 0x2aa0 <xTaskResumeAll+0xe6>
    2a9a:	80 e0       	ldi	r24, 0x00	; 0
    2a9c:	01 c0       	rjmp	.+2      	; 0x2aa0 <xTaskResumeAll+0xe6>
    2a9e:	80 e0       	ldi	r24, 0x00	; 0
    2aa0:	0f 90       	pop	r0
    2aa2:	0f be       	out	0x3f, r0	; 63
    2aa4:	df 91       	pop	r29
    2aa6:	cf 91       	pop	r28
    2aa8:	1f 91       	pop	r17
    2aaa:	0f 91       	pop	r16
    2aac:	ff 90       	pop	r15
    2aae:	ef 90       	pop	r14
    2ab0:	df 90       	pop	r13
    2ab2:	08 95       	ret

00002ab4 <vTaskDelay>:
    2ab4:	cf 93       	push	r28
    2ab6:	df 93       	push	r29
    2ab8:	ec 01       	movw	r28, r24
    2aba:	89 2b       	or	r24, r25
    2abc:	91 f0       	breq	.+36     	; 0x2ae2 <vTaskDelay+0x2e>
    2abe:	9a de       	rcall	.-716    	; 0x27f4 <vTaskSuspendAll>
    2ac0:	80 91 6b 22 	lds	r24, 0x226B	; 0x80226b <xTickCount>
    2ac4:	90 91 6c 22 	lds	r25, 0x226C	; 0x80226c <xTickCount+0x1>
    2ac8:	c8 0f       	add	r28, r24
    2aca:	d9 1f       	adc	r29, r25
    2acc:	80 91 ba 22 	lds	r24, 0x22BA	; 0x8022ba <pxCurrentTCB>
    2ad0:	90 91 bb 22 	lds	r25, 0x22BB	; 0x8022bb <pxCurrentTCB+0x1>
    2ad4:	02 96       	adiw	r24, 0x02	; 2
    2ad6:	ea d8       	rcall	.-3628   	; 0x1cac <uxListRemove>
    2ad8:	ce 01       	movw	r24, r28
    2ada:	23 dd       	rcall	.-1466   	; 0x2522 <prvAddCurrentTaskToDelayedList>
    2adc:	6e df       	rcall	.-292    	; 0x29ba <xTaskResumeAll>
    2ade:	81 11       	cpse	r24, r1
    2ae0:	01 c0       	rjmp	.+2      	; 0x2ae4 <vTaskDelay+0x30>
    2ae2:	c6 d9       	rcall	.-3188   	; 0x1e70 <vPortYield>
    2ae4:	df 91       	pop	r29
    2ae6:	cf 91       	pop	r28
    2ae8:	08 95       	ret

00002aea <vTaskSwitchContext>:
    2aea:	80 91 62 22 	lds	r24, 0x2262	; 0x802262 <uxSchedulerSuspended>
    2aee:	88 23       	and	r24, r24
    2af0:	21 f0       	breq	.+8      	; 0x2afa <vTaskSwitchContext+0x10>
    2af2:	81 e0       	ldi	r24, 0x01	; 1
    2af4:	80 93 67 22 	sts	0x2267, r24	; 0x802267 <xYieldPending>
    2af8:	08 95       	ret
    2afa:	10 92 67 22 	sts	0x2267, r1	; 0x802267 <xYieldPending>
    2afe:	80 91 6a 22 	lds	r24, 0x226A	; 0x80226a <uxTopReadyPriority>
    2b02:	90 e0       	ldi	r25, 0x00	; 0
    2b04:	fc 01       	movw	r30, r24
    2b06:	ee 0f       	add	r30, r30
    2b08:	ff 1f       	adc	r31, r31
    2b0a:	ee 0f       	add	r30, r30
    2b0c:	ff 1f       	adc	r31, r31
    2b0e:	ee 0f       	add	r30, r30
    2b10:	ff 1f       	adc	r31, r31
    2b12:	8e 0f       	add	r24, r30
    2b14:	9f 1f       	adc	r25, r31
    2b16:	fc 01       	movw	r30, r24
    2b18:	e3 57       	subi	r30, 0x73	; 115
    2b1a:	fd 4d       	sbci	r31, 0xDD	; 221
    2b1c:	80 81       	ld	r24, Z
    2b1e:	81 11       	cpse	r24, r1
    2b20:	17 c0       	rjmp	.+46     	; 0x2b50 <vTaskSwitchContext+0x66>
    2b22:	80 91 6a 22 	lds	r24, 0x226A	; 0x80226a <uxTopReadyPriority>
    2b26:	81 50       	subi	r24, 0x01	; 1
    2b28:	80 93 6a 22 	sts	0x226A, r24	; 0x80226a <uxTopReadyPriority>
    2b2c:	80 91 6a 22 	lds	r24, 0x226A	; 0x80226a <uxTopReadyPriority>
    2b30:	90 e0       	ldi	r25, 0x00	; 0
    2b32:	fc 01       	movw	r30, r24
    2b34:	ee 0f       	add	r30, r30
    2b36:	ff 1f       	adc	r31, r31
    2b38:	ee 0f       	add	r30, r30
    2b3a:	ff 1f       	adc	r31, r31
    2b3c:	ee 0f       	add	r30, r30
    2b3e:	ff 1f       	adc	r31, r31
    2b40:	8e 0f       	add	r24, r30
    2b42:	9f 1f       	adc	r25, r31
    2b44:	fc 01       	movw	r30, r24
    2b46:	e3 57       	subi	r30, 0x73	; 115
    2b48:	fd 4d       	sbci	r31, 0xDD	; 221
    2b4a:	80 81       	ld	r24, Z
    2b4c:	88 23       	and	r24, r24
    2b4e:	49 f3       	breq	.-46     	; 0x2b22 <vTaskSwitchContext+0x38>
    2b50:	80 91 6a 22 	lds	r24, 0x226A	; 0x80226a <uxTopReadyPriority>
    2b54:	90 e0       	ldi	r25, 0x00	; 0
    2b56:	9c 01       	movw	r18, r24
    2b58:	22 0f       	add	r18, r18
    2b5a:	33 1f       	adc	r19, r19
    2b5c:	22 0f       	add	r18, r18
    2b5e:	33 1f       	adc	r19, r19
    2b60:	22 0f       	add	r18, r18
    2b62:	33 1f       	adc	r19, r19
    2b64:	28 0f       	add	r18, r24
    2b66:	39 1f       	adc	r19, r25
    2b68:	d9 01       	movw	r26, r18
    2b6a:	a3 57       	subi	r26, 0x73	; 115
    2b6c:	bd 4d       	sbci	r27, 0xDD	; 221
    2b6e:	11 96       	adiw	r26, 0x01	; 1
    2b70:	ed 91       	ld	r30, X+
    2b72:	fc 91       	ld	r31, X
    2b74:	12 97       	sbiw	r26, 0x02	; 2
    2b76:	02 80       	ldd	r0, Z+2	; 0x02
    2b78:	f3 81       	ldd	r31, Z+3	; 0x03
    2b7a:	e0 2d       	mov	r30, r0
    2b7c:	11 96       	adiw	r26, 0x01	; 1
    2b7e:	ed 93       	st	X+, r30
    2b80:	fc 93       	st	X, r31
    2b82:	12 97       	sbiw	r26, 0x02	; 2
    2b84:	20 57       	subi	r18, 0x70	; 112
    2b86:	3d 4d       	sbci	r19, 0xDD	; 221
    2b88:	e2 17       	cp	r30, r18
    2b8a:	f3 07       	cpc	r31, r19
    2b8c:	29 f4       	brne	.+10     	; 0x2b98 <vTaskSwitchContext+0xae>
    2b8e:	22 81       	ldd	r18, Z+2	; 0x02
    2b90:	33 81       	ldd	r19, Z+3	; 0x03
    2b92:	fd 01       	movw	r30, r26
    2b94:	21 83       	std	Z+1, r18	; 0x01
    2b96:	32 83       	std	Z+2, r19	; 0x02
    2b98:	fc 01       	movw	r30, r24
    2b9a:	ee 0f       	add	r30, r30
    2b9c:	ff 1f       	adc	r31, r31
    2b9e:	ee 0f       	add	r30, r30
    2ba0:	ff 1f       	adc	r31, r31
    2ba2:	ee 0f       	add	r30, r30
    2ba4:	ff 1f       	adc	r31, r31
    2ba6:	8e 0f       	add	r24, r30
    2ba8:	9f 1f       	adc	r25, r31
    2baa:	fc 01       	movw	r30, r24
    2bac:	e3 57       	subi	r30, 0x73	; 115
    2bae:	fd 4d       	sbci	r31, 0xDD	; 221
    2bb0:	01 80       	ldd	r0, Z+1	; 0x01
    2bb2:	f2 81       	ldd	r31, Z+2	; 0x02
    2bb4:	e0 2d       	mov	r30, r0
    2bb6:	86 81       	ldd	r24, Z+6	; 0x06
    2bb8:	97 81       	ldd	r25, Z+7	; 0x07
    2bba:	80 93 ba 22 	sts	0x22BA, r24	; 0x8022ba <pxCurrentTCB>
    2bbe:	90 93 bb 22 	sts	0x22BB, r25	; 0x8022bb <pxCurrentTCB+0x1>
    2bc2:	08 95       	ret

00002bc4 <vTaskPlaceOnEventList>:
    2bc4:	cf 93       	push	r28
    2bc6:	df 93       	push	r29
    2bc8:	eb 01       	movw	r28, r22
    2bca:	20 91 ba 22 	lds	r18, 0x22BA	; 0x8022ba <pxCurrentTCB>
    2bce:	30 91 bb 22 	lds	r19, 0x22BB	; 0x8022bb <pxCurrentTCB+0x1>
    2bd2:	b9 01       	movw	r22, r18
    2bd4:	64 5f       	subi	r22, 0xF4	; 244
    2bd6:	7f 4f       	sbci	r23, 0xFF	; 255
    2bd8:	38 d8       	rcall	.-3984   	; 0x1c4a <vListInsert>
    2bda:	80 91 ba 22 	lds	r24, 0x22BA	; 0x8022ba <pxCurrentTCB>
    2bde:	90 91 bb 22 	lds	r25, 0x22BB	; 0x8022bb <pxCurrentTCB+0x1>
    2be2:	02 96       	adiw	r24, 0x02	; 2
    2be4:	63 d8       	rcall	.-3898   	; 0x1cac <uxListRemove>
    2be6:	80 91 6b 22 	lds	r24, 0x226B	; 0x80226b <xTickCount>
    2bea:	90 91 6c 22 	lds	r25, 0x226C	; 0x80226c <xTickCount+0x1>
    2bee:	8c 0f       	add	r24, r28
    2bf0:	9d 1f       	adc	r25, r29
    2bf2:	97 dc       	rcall	.-1746   	; 0x2522 <prvAddCurrentTaskToDelayedList>
    2bf4:	df 91       	pop	r29
    2bf6:	cf 91       	pop	r28
    2bf8:	08 95       	ret

00002bfa <vTaskPlaceOnEventListRestricted>:
    2bfa:	cf 93       	push	r28
    2bfc:	df 93       	push	r29
    2bfe:	eb 01       	movw	r28, r22
    2c00:	20 91 ba 22 	lds	r18, 0x22BA	; 0x8022ba <pxCurrentTCB>
    2c04:	30 91 bb 22 	lds	r19, 0x22BB	; 0x8022bb <pxCurrentTCB+0x1>
    2c08:	b9 01       	movw	r22, r18
    2c0a:	64 5f       	subi	r22, 0xF4	; 244
    2c0c:	7f 4f       	sbci	r23, 0xFF	; 255
    2c0e:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <vListInsertEnd>
    2c12:	80 91 ba 22 	lds	r24, 0x22BA	; 0x8022ba <pxCurrentTCB>
    2c16:	90 91 bb 22 	lds	r25, 0x22BB	; 0x8022bb <pxCurrentTCB+0x1>
    2c1a:	02 96       	adiw	r24, 0x02	; 2
    2c1c:	47 d8       	rcall	.-3954   	; 0x1cac <uxListRemove>
    2c1e:	80 91 6b 22 	lds	r24, 0x226B	; 0x80226b <xTickCount>
    2c22:	90 91 6c 22 	lds	r25, 0x226C	; 0x80226c <xTickCount+0x1>
    2c26:	8c 0f       	add	r24, r28
    2c28:	9d 1f       	adc	r25, r29
    2c2a:	7b dc       	rcall	.-1802   	; 0x2522 <prvAddCurrentTaskToDelayedList>
    2c2c:	df 91       	pop	r29
    2c2e:	cf 91       	pop	r28
    2c30:	08 95       	ret

00002c32 <xTaskRemoveFromEventList>:
    2c32:	0f 93       	push	r16
    2c34:	1f 93       	push	r17
    2c36:	cf 93       	push	r28
    2c38:	df 93       	push	r29
    2c3a:	dc 01       	movw	r26, r24
    2c3c:	15 96       	adiw	r26, 0x05	; 5
    2c3e:	ed 91       	ld	r30, X+
    2c40:	fc 91       	ld	r31, X
    2c42:	16 97       	sbiw	r26, 0x06	; 6
    2c44:	c6 81       	ldd	r28, Z+6	; 0x06
    2c46:	d7 81       	ldd	r29, Z+7	; 0x07
    2c48:	8e 01       	movw	r16, r28
    2c4a:	04 5f       	subi	r16, 0xF4	; 244
    2c4c:	1f 4f       	sbci	r17, 0xFF	; 255
    2c4e:	c8 01       	movw	r24, r16
    2c50:	2d d8       	rcall	.-4006   	; 0x1cac <uxListRemove>
    2c52:	80 91 62 22 	lds	r24, 0x2262	; 0x802262 <uxSchedulerSuspended>
    2c56:	81 11       	cpse	r24, r1
    2c58:	1b c0       	rjmp	.+54     	; 0x2c90 <xTaskRemoveFromEventList+0x5e>
    2c5a:	0a 50       	subi	r16, 0x0A	; 10
    2c5c:	11 09       	sbc	r17, r1
    2c5e:	c8 01       	movw	r24, r16
    2c60:	25 d8       	rcall	.-4022   	; 0x1cac <uxListRemove>
    2c62:	2e 89       	ldd	r18, Y+22	; 0x16
    2c64:	80 91 6a 22 	lds	r24, 0x226A	; 0x80226a <uxTopReadyPriority>
    2c68:	82 17       	cp	r24, r18
    2c6a:	10 f4       	brcc	.+4      	; 0x2c70 <xTaskRemoveFromEventList+0x3e>
    2c6c:	20 93 6a 22 	sts	0x226A, r18	; 0x80226a <uxTopReadyPriority>
    2c70:	30 e0       	ldi	r19, 0x00	; 0
    2c72:	c9 01       	movw	r24, r18
    2c74:	88 0f       	add	r24, r24
    2c76:	99 1f       	adc	r25, r25
    2c78:	88 0f       	add	r24, r24
    2c7a:	99 1f       	adc	r25, r25
    2c7c:	88 0f       	add	r24, r24
    2c7e:	99 1f       	adc	r25, r25
    2c80:	82 0f       	add	r24, r18
    2c82:	93 1f       	adc	r25, r19
    2c84:	b8 01       	movw	r22, r16
    2c86:	83 57       	subi	r24, 0x73	; 115
    2c88:	9d 4d       	sbci	r25, 0xDD	; 221
    2c8a:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <vListInsertEnd>
    2c8e:	05 c0       	rjmp	.+10     	; 0x2c9a <xTaskRemoveFromEventList+0x68>
    2c90:	b8 01       	movw	r22, r16
    2c92:	8e e6       	ldi	r24, 0x6E	; 110
    2c94:	92 e2       	ldi	r25, 0x22	; 34
    2c96:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <vListInsertEnd>
    2c9a:	e0 91 ba 22 	lds	r30, 0x22BA	; 0x8022ba <pxCurrentTCB>
    2c9e:	f0 91 bb 22 	lds	r31, 0x22BB	; 0x8022bb <pxCurrentTCB+0x1>
    2ca2:	9e 89       	ldd	r25, Y+22	; 0x16
    2ca4:	86 89       	ldd	r24, Z+22	; 0x16
    2ca6:	89 17       	cp	r24, r25
    2ca8:	20 f4       	brcc	.+8      	; 0x2cb2 <xTaskRemoveFromEventList+0x80>
    2caa:	81 e0       	ldi	r24, 0x01	; 1
    2cac:	80 93 67 22 	sts	0x2267, r24	; 0x802267 <xYieldPending>
    2cb0:	01 c0       	rjmp	.+2      	; 0x2cb4 <xTaskRemoveFromEventList+0x82>
    2cb2:	80 e0       	ldi	r24, 0x00	; 0
    2cb4:	df 91       	pop	r29
    2cb6:	cf 91       	pop	r28
    2cb8:	1f 91       	pop	r17
    2cba:	0f 91       	pop	r16
    2cbc:	08 95       	ret

00002cbe <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2cbe:	20 91 66 22 	lds	r18, 0x2266	; 0x802266 <xNumOfOverflows>
    2cc2:	fc 01       	movw	r30, r24
    2cc4:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2cc6:	20 91 6b 22 	lds	r18, 0x226B	; 0x80226b <xTickCount>
    2cca:	30 91 6c 22 	lds	r19, 0x226C	; 0x80226c <xTickCount+0x1>
    2cce:	21 83       	std	Z+1, r18	; 0x01
    2cd0:	32 83       	std	Z+2, r19	; 0x02
    2cd2:	08 95       	ret

00002cd4 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    2cd4:	cf 93       	push	r28
    2cd6:	df 93       	push	r29
    2cd8:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2cda:	0f b6       	in	r0, 0x3f	; 63
    2cdc:	f8 94       	cli
    2cde:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    2ce0:	20 91 6b 22 	lds	r18, 0x226B	; 0x80226b <xTickCount>
    2ce4:	30 91 6c 22 	lds	r19, 0x226C	; 0x80226c <xTickCount+0x1>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    2ce8:	80 91 66 22 	lds	r24, 0x2266	; 0x802266 <xNumOfOverflows>
    2cec:	90 81       	ld	r25, Z
    2cee:	98 17       	cp	r25, r24
    2cf0:	29 f0       	breq	.+10     	; 0x2cfc <xTaskCheckForTimeOut+0x28>
    2cf2:	81 81       	ldd	r24, Z+1	; 0x01
    2cf4:	92 81       	ldd	r25, Z+2	; 0x02
    2cf6:	28 17       	cp	r18, r24
    2cf8:	39 07       	cpc	r19, r25
    2cfa:	a8 f4       	brcc	.+42     	; 0x2d26 <xTaskCheckForTimeOut+0x52>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    2cfc:	a1 81       	ldd	r26, Z+1	; 0x01
    2cfe:	b2 81       	ldd	r27, Z+2	; 0x02
    2d00:	eb 01       	movw	r28, r22
    2d02:	48 81       	ld	r20, Y
    2d04:	59 81       	ldd	r21, Y+1	; 0x01
    2d06:	c9 01       	movw	r24, r18
    2d08:	8a 1b       	sub	r24, r26
    2d0a:	9b 0b       	sbc	r25, r27
    2d0c:	84 17       	cp	r24, r20
    2d0e:	95 07       	cpc	r25, r21
    2d10:	60 f4       	brcc	.+24     	; 0x2d2a <xTaskCheckForTimeOut+0x56>
    2d12:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    2d14:	a2 1b       	sub	r26, r18
    2d16:	b3 0b       	sbc	r27, r19
    2d18:	4a 0f       	add	r20, r26
    2d1a:	5b 1f       	adc	r21, r27
    2d1c:	48 83       	st	Y, r20
    2d1e:	59 83       	std	Y+1, r21	; 0x01
			vTaskSetTimeOutState( pxTimeOut );
    2d20:	ce df       	rcall	.-100    	; 0x2cbe <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2d22:	80 e0       	ldi	r24, 0x00	; 0
    2d24:	03 c0       	rjmp	.+6      	; 0x2d2c <xTaskCheckForTimeOut+0x58>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2d26:	81 e0       	ldi	r24, 0x01	; 1
    2d28:	01 c0       	rjmp	.+2      	; 0x2d2c <xTaskCheckForTimeOut+0x58>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2d2a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2d2c:	0f 90       	pop	r0
    2d2e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2d30:	df 91       	pop	r29
    2d32:	cf 91       	pop	r28
    2d34:	08 95       	ret

00002d36 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    2d36:	81 e0       	ldi	r24, 0x01	; 1
    2d38:	80 93 67 22 	sts	0x2267, r24	; 0x802267 <xYieldPending>
    2d3c:	08 95       	ret

00002d3e <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    2d3e:	80 91 69 22 	lds	r24, 0x2269	; 0x802269 <xSchedulerRunning>
    2d42:	88 23       	and	r24, r24
    2d44:	31 f0       	breq	.+12     	; 0x2d52 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2d46:	80 91 62 22 	lds	r24, 0x2262	; 0x802262 <uxSchedulerSuspended>
    2d4a:	88 23       	and	r24, r24
    2d4c:	21 f0       	breq	.+8      	; 0x2d56 <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    2d4e:	80 e0       	ldi	r24, 0x00	; 0
    2d50:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    2d52:	81 e0       	ldi	r24, 0x01	; 1
    2d54:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    2d56:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    2d58:	08 95       	ret

00002d5a <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    2d5a:	fc 01       	movw	r30, r24
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    2d5c:	62 83       	std	Z+2, r22	; 0x02
    2d5e:	73 83       	std	Z+3, r23	; 0x03
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2d60:	80 87       	std	Z+8, r24	; 0x08
    2d62:	91 87       	std	Z+9, r25	; 0x09

	if( xNextExpiryTime <= xTimeNow )
    2d64:	46 17       	cp	r20, r22
    2d66:	57 07       	cpc	r21, r23
    2d68:	90 f0       	brcs	.+36     	; 0x2d8e <prvInsertTimerInActiveList+0x34>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
    2d6a:	42 1b       	sub	r20, r18
    2d6c:	53 0b       	sbc	r21, r19
    2d6e:	84 85       	ldd	r24, Z+12	; 0x0c
    2d70:	95 85       	ldd	r25, Z+13	; 0x0d
    2d72:	48 17       	cp	r20, r24
    2d74:	59 07       	cpc	r21, r25
    2d76:	e0 f4       	brcc	.+56     	; 0x2db0 <prvInsertTimerInActiveList+0x56>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    2d78:	bf 01       	movw	r22, r30
    2d7a:	6e 5f       	subi	r22, 0xFE	; 254
    2d7c:	7f 4f       	sbci	r23, 0xFF	; 255
    2d7e:	80 91 c0 22 	lds	r24, 0x22C0	; 0x8022c0 <pxOverflowTimerList>
    2d82:	90 91 c1 22 	lds	r25, 0x22C1	; 0x8022c1 <pxOverflowTimerList+0x1>
    2d86:	0e 94 25 0e 	call	0x1c4a	; 0x1c4a <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    2d8a:	80 e0       	ldi	r24, 0x00	; 0
    2d8c:	08 95       	ret
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    2d8e:	42 17       	cp	r20, r18
    2d90:	53 07       	cpc	r21, r19
    2d92:	18 f4       	brcc	.+6      	; 0x2d9a <prvInsertTimerInActiveList+0x40>
    2d94:	62 17       	cp	r22, r18
    2d96:	73 07       	cpc	r23, r19
    2d98:	68 f4       	brcc	.+26     	; 0x2db4 <prvInsertTimerInActiveList+0x5a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2d9a:	bf 01       	movw	r22, r30
    2d9c:	6e 5f       	subi	r22, 0xFE	; 254
    2d9e:	7f 4f       	sbci	r23, 0xFF	; 255
    2da0:	80 91 c2 22 	lds	r24, 0x22C2	; 0x8022c2 <pxCurrentTimerList>
    2da4:	90 91 c3 22 	lds	r25, 0x22C3	; 0x8022c3 <pxCurrentTimerList+0x1>
    2da8:	0e 94 25 0e 	call	0x1c4a	; 0x1c4a <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    2dac:	80 e0       	ldi	r24, 0x00	; 0
    2dae:	08 95       	ret
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    2db0:	81 e0       	ldi	r24, 0x01	; 1
    2db2:	08 95       	ret
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    2db4:	81 e0       	ldi	r24, 0x01	; 1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
    2db6:	08 95       	ret

00002db8 <prvCheckForValidListAndQueue>:
static void prvCheckForValidListAndQueue( void )
{
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    2db8:	0f b6       	in	r0, 0x3f	; 63
    2dba:	f8 94       	cli
    2dbc:	0f 92       	push	r0
	{
		if( xTimerQueue == NULL )
    2dbe:	80 91 be 22 	lds	r24, 0x22BE	; 0x8022be <xTimerQueue>
    2dc2:	90 91 bf 22 	lds	r25, 0x22BF	; 0x8022bf <xTimerQueue+0x1>
    2dc6:	89 2b       	or	r24, r25
    2dc8:	e1 f4       	brne	.+56     	; 0x2e02 <prvCheckForValidListAndQueue+0x4a>
		{
			vListInitialise( &xActiveTimerList1 );
    2dca:	8d ec       	ldi	r24, 0xCD	; 205
    2dcc:	92 e2       	ldi	r25, 0x22	; 34
    2dce:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
    2dd2:	84 ec       	ldi	r24, 0xC4	; 196
    2dd4:	92 e2       	ldi	r25, 0x22	; 34
    2dd6:	0e 94 f2 0d 	call	0x1be4	; 0x1be4 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
    2dda:	8d ec       	ldi	r24, 0xCD	; 205
    2ddc:	92 e2       	ldi	r25, 0x22	; 34
    2dde:	80 93 c2 22 	sts	0x22C2, r24	; 0x8022c2 <pxCurrentTimerList>
    2de2:	90 93 c3 22 	sts	0x22C3, r25	; 0x8022c3 <pxCurrentTimerList+0x1>
			pxOverflowTimerList = &xActiveTimerList2;
    2de6:	84 ec       	ldi	r24, 0xC4	; 196
    2de8:	92 e2       	ldi	r25, 0x22	; 34
    2dea:	80 93 c0 22 	sts	0x22C0, r24	; 0x8022c0 <pxOverflowTimerList>
    2dee:	90 93 c1 22 	sts	0x22C1, r25	; 0x8022c1 <pxOverflowTimerList+0x1>
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    2df2:	40 e0       	ldi	r20, 0x00	; 0
    2df4:	65 e0       	ldi	r22, 0x05	; 5
    2df6:	8a e0       	ldi	r24, 0x0A	; 10
    2df8:	ef d9       	rcall	.-3106   	; 0x21d8 <xQueueGenericCreate>
    2dfa:	80 93 be 22 	sts	0x22BE, r24	; 0x8022be <xTimerQueue>
    2dfe:	90 93 bf 22 	sts	0x22BF, r25	; 0x8022bf <xTimerQueue+0x1>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    2e02:	0f 90       	pop	r0
    2e04:	0f be       	out	0x3f, r0	; 63
    2e06:	08 95       	ret

00002e08 <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
    2e08:	af 92       	push	r10
    2e0a:	bf 92       	push	r11
    2e0c:	cf 92       	push	r12
    2e0e:	df 92       	push	r13
    2e10:	ef 92       	push	r14
    2e12:	ff 92       	push	r15
    2e14:	0f 93       	push	r16

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
    2e16:	d0 df       	rcall	.-96     	; 0x2db8 <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
    2e18:	80 91 be 22 	lds	r24, 0x22BE	; 0x8022be <xTimerQueue>
    2e1c:	90 91 bf 22 	lds	r25, 0x22BF	; 0x8022bf <xTimerQueue+0x1>
    2e20:	89 2b       	or	r24, r25
    2e22:	89 f0       	breq	.+34     	; 0x2e46 <xTimerCreateTimerTask+0x3e>
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
    2e24:	a1 2c       	mov	r10, r1
    2e26:	b1 2c       	mov	r11, r1
    2e28:	c1 2c       	mov	r12, r1
    2e2a:	d1 2c       	mov	r13, r1
    2e2c:	e1 2c       	mov	r14, r1
    2e2e:	f1 2c       	mov	r15, r1
    2e30:	03 e0       	ldi	r16, 0x03	; 3
    2e32:	20 e0       	ldi	r18, 0x00	; 0
    2e34:	30 e0       	ldi	r19, 0x00	; 0
    2e36:	45 e5       	ldi	r20, 0x55	; 85
    2e38:	50 e0       	ldi	r21, 0x00	; 0
    2e3a:	69 e1       	ldi	r22, 0x19	; 25
    2e3c:	70 e2       	ldi	r23, 0x20	; 32
    2e3e:	82 e1       	ldi	r24, 0x12	; 18
    2e40:	98 e1       	ldi	r25, 0x18	; 24
    2e42:	a4 db       	rcall	.-2232   	; 0x258c <xTaskGenericCreate>
    2e44:	01 c0       	rjmp	.+2      	; 0x2e48 <xTimerCreateTimerTask+0x40>

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
BaseType_t xReturn = pdFAIL;
    2e46:	80 e0       	ldi	r24, 0x00	; 0
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
	return xReturn;
}
    2e48:	0f 91       	pop	r16
    2e4a:	ff 90       	pop	r15
    2e4c:	ef 90       	pop	r14
    2e4e:	df 90       	pop	r13
    2e50:	cf 90       	pop	r12
    2e52:	bf 90       	pop	r11
    2e54:	af 90       	pop	r10
    2e56:	08 95       	ret

00002e58 <xTimerCreate>:
/*-----------------------------------------------------------*/

TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    2e58:	8f 92       	push	r8
    2e5a:	9f 92       	push	r9
    2e5c:	bf 92       	push	r11
    2e5e:	cf 92       	push	r12
    2e60:	df 92       	push	r13
    2e62:	ef 92       	push	r14
    2e64:	ff 92       	push	r15
    2e66:	0f 93       	push	r16
    2e68:	1f 93       	push	r17
    2e6a:	cf 93       	push	r28
    2e6c:	df 93       	push	r29
Timer_t *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
    2e6e:	61 15       	cp	r22, r1
    2e70:	71 05       	cpc	r23, r1
    2e72:	c9 f0       	breq	.+50     	; 0x2ea6 <xTimerCreate+0x4e>
    2e74:	69 01       	movw	r12, r18
    2e76:	b4 2e       	mov	r11, r20
    2e78:	7b 01       	movw	r14, r22
    2e7a:	4c 01       	movw	r8, r24
	{
		pxNewTimer = NULL;
	}
	else
	{
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
    2e7c:	83 e1       	ldi	r24, 0x13	; 19
    2e7e:	90 e0       	ldi	r25, 0x00	; 0
    2e80:	a9 d8       	rcall	.-3758   	; 0x1fd4 <pvPortMalloc>
    2e82:	ec 01       	movw	r28, r24
		if( pxNewTimer != NULL )
    2e84:	89 2b       	or	r24, r25
    2e86:	89 f0       	breq	.+34     	; 0x2eaa <xTimerCreate+0x52>
		{
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();
    2e88:	97 df       	rcall	.-210    	; 0x2db8 <prvCheckForValidListAndQueue>

			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
    2e8a:	88 82       	st	Y, r8
    2e8c:	99 82       	std	Y+1, r9	; 0x01
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    2e8e:	ec 86       	std	Y+12, r14	; 0x0c
    2e90:	fd 86       	std	Y+13, r15	; 0x0d
			pxNewTimer->uxAutoReload = uxAutoReload;
    2e92:	be 86       	std	Y+14, r11	; 0x0e
			pxNewTimer->pvTimerID = pvTimerID;
    2e94:	cf 86       	std	Y+15, r12	; 0x0f
    2e96:	d8 8a       	std	Y+16, r13	; 0x10
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    2e98:	09 8b       	std	Y+17, r16	; 0x11
    2e9a:	1a 8b       	std	Y+18, r17	; 0x12
			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    2e9c:	ce 01       	movw	r24, r28
    2e9e:	02 96       	adiw	r24, 0x02	; 2
    2ea0:	0e 94 00 0e 	call	0x1c00	; 0x1c00 <vListInitialiseItem>
    2ea4:	02 c0       	rjmp	.+4      	; 0x2eaa <xTimerCreate+0x52>
Timer_t *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
	{
		pxNewTimer = NULL;
    2ea6:	c0 e0       	ldi	r28, 0x00	; 0
    2ea8:	d0 e0       	ldi	r29, 0x00	; 0

	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	return ( TimerHandle_t ) pxNewTimer;
}
    2eaa:	ce 01       	movw	r24, r28
    2eac:	df 91       	pop	r29
    2eae:	cf 91       	pop	r28
    2eb0:	1f 91       	pop	r17
    2eb2:	0f 91       	pop	r16
    2eb4:	ff 90       	pop	r15
    2eb6:	ef 90       	pop	r14
    2eb8:	df 90       	pop	r13
    2eba:	cf 90       	pop	r12
    2ebc:	bf 90       	pop	r11
    2ebe:	9f 90       	pop	r9
    2ec0:	8f 90       	pop	r8
    2ec2:	08 95       	ret

00002ec4 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    2ec4:	0f 93       	push	r16
    2ec6:	1f 93       	push	r17
    2ec8:	cf 93       	push	r28
    2eca:	df 93       	push	r29
    2ecc:	cd b7       	in	r28, 0x3d	; 61
    2ece:	de b7       	in	r29, 0x3e	; 62
    2ed0:	25 97       	sbiw	r28, 0x05	; 5
    2ed2:	cd bf       	out	0x3d, r28	; 61
    2ed4:	de bf       	out	0x3e, r29	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    2ed6:	e0 91 be 22 	lds	r30, 0x22BE	; 0x8022be <xTimerQueue>
    2eda:	f0 91 bf 22 	lds	r31, 0x22BF	; 0x8022bf <xTimerQueue+0x1>
    2ede:	30 97       	sbiw	r30, 0x00	; 0
    2ee0:	51 f1       	breq	.+84     	; 0x2f36 <xTimerGenericCommand+0x72>
    2ee2:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    2ee4:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    2ee6:	4a 83       	std	Y+2, r20	; 0x02
    2ee8:	5b 83       	std	Y+3, r21	; 0x03
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    2eea:	8c 83       	std	Y+4, r24	; 0x04
    2eec:	9d 83       	std	Y+5, r25	; 0x05

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    2eee:	66 30       	cpi	r22, 0x06	; 6
    2ef0:	d4 f4       	brge	.+52     	; 0x2f26 <xTimerGenericCommand+0x62>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    2ef2:	25 df       	rcall	.-438    	; 0x2d3e <xTaskGetSchedulerState>
    2ef4:	82 30       	cpi	r24, 0x02	; 2
    2ef6:	59 f4       	brne	.+22     	; 0x2f0e <xTimerGenericCommand+0x4a>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    2ef8:	20 e0       	ldi	r18, 0x00	; 0
    2efa:	a8 01       	movw	r20, r16
    2efc:	be 01       	movw	r22, r28
    2efe:	6f 5f       	subi	r22, 0xFF	; 255
    2f00:	7f 4f       	sbci	r23, 0xFF	; 255
    2f02:	80 91 be 22 	lds	r24, 0x22BE	; 0x8022be <xTimerQueue>
    2f06:	90 91 bf 22 	lds	r25, 0x22BF	; 0x8022bf <xTimerQueue+0x1>
    2f0a:	8f d9       	rcall	.-3298   	; 0x222a <xQueueGenericSend>
    2f0c:	15 c0       	rjmp	.+42     	; 0x2f38 <xTimerGenericCommand+0x74>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    2f0e:	20 e0       	ldi	r18, 0x00	; 0
    2f10:	40 e0       	ldi	r20, 0x00	; 0
    2f12:	50 e0       	ldi	r21, 0x00	; 0
    2f14:	be 01       	movw	r22, r28
    2f16:	6f 5f       	subi	r22, 0xFF	; 255
    2f18:	7f 4f       	sbci	r23, 0xFF	; 255
    2f1a:	80 91 be 22 	lds	r24, 0x22BE	; 0x8022be <xTimerQueue>
    2f1e:	90 91 bf 22 	lds	r25, 0x22BF	; 0x8022bf <xTimerQueue+0x1>
    2f22:	83 d9       	rcall	.-3322   	; 0x222a <xQueueGenericSend>
    2f24:	09 c0       	rjmp	.+18     	; 0x2f38 <xTimerGenericCommand+0x74>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    2f26:	20 e0       	ldi	r18, 0x00	; 0
    2f28:	ad 01       	movw	r20, r26
    2f2a:	be 01       	movw	r22, r28
    2f2c:	6f 5f       	subi	r22, 0xFF	; 255
    2f2e:	7f 4f       	sbci	r23, 0xFF	; 255
    2f30:	cf 01       	movw	r24, r30
    2f32:	08 da       	rcall	.-3056   	; 0x2344 <xQueueGenericSendFromISR>
    2f34:	01 c0       	rjmp	.+2      	; 0x2f38 <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    2f36:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    2f38:	25 96       	adiw	r28, 0x05	; 5
    2f3a:	cd bf       	out	0x3d, r28	; 61
    2f3c:	de bf       	out	0x3e, r29	; 62
    2f3e:	df 91       	pop	r29
    2f40:	cf 91       	pop	r28
    2f42:	1f 91       	pop	r17
    2f44:	0f 91       	pop	r16
    2f46:	08 95       	ret

00002f48 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    2f48:	af 92       	push	r10
    2f4a:	bf 92       	push	r11
    2f4c:	cf 92       	push	r12
    2f4e:	df 92       	push	r13
    2f50:	ef 92       	push	r14
    2f52:	ff 92       	push	r15
    2f54:	0f 93       	push	r16
    2f56:	1f 93       	push	r17
    2f58:	cf 93       	push	r28
    2f5a:	df 93       	push	r29
    2f5c:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    2f5e:	50 dc       	rcall	.-1888   	; 0x2800 <xTaskGetTickCount>
    2f60:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    2f62:	80 91 bc 22 	lds	r24, 0x22BC	; 0x8022bc <xLastTime.4281>
    2f66:	90 91 bd 22 	lds	r25, 0x22BD	; 0x8022bd <xLastTime.4281+0x1>
    2f6a:	e8 16       	cp	r14, r24
    2f6c:	f9 06       	cpc	r15, r25
    2f6e:	08 f0       	brcs	.+2      	; 0x2f72 <prvSampleTimeNow+0x2a>
    2f70:	47 c0       	rjmp	.+142    	; 0x3000 <prvSampleTimeNow+0xb8>
    2f72:	2f c0       	rjmp	.+94     	; 0x2fd2 <prvSampleTimeNow+0x8a>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2f74:	05 80       	ldd	r0, Z+5	; 0x05
    2f76:	f6 81       	ldd	r31, Z+6	; 0x06
    2f78:	e0 2d       	mov	r30, r0
    2f7a:	a0 80       	ld	r10, Z
    2f7c:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    2f7e:	c6 81       	ldd	r28, Z+6	; 0x06
    2f80:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2f82:	8e 01       	movw	r16, r28
    2f84:	0e 5f       	subi	r16, 0xFE	; 254
    2f86:	1f 4f       	sbci	r17, 0xFF	; 255
    2f88:	c8 01       	movw	r24, r16
    2f8a:	0e 94 56 0e 	call	0x1cac	; 0x1cac <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2f8e:	e9 89       	ldd	r30, Y+17	; 0x11
    2f90:	fa 89       	ldd	r31, Y+18	; 0x12
    2f92:	ce 01       	movw	r24, r28
    2f94:	19 95       	eicall

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2f96:	8e 85       	ldd	r24, Y+14	; 0x0e
    2f98:	81 30       	cpi	r24, 0x01	; 1
    2f9a:	d9 f4       	brne	.+54     	; 0x2fd2 <prvSampleTimeNow+0x8a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    2f9c:	8c 85       	ldd	r24, Y+12	; 0x0c
    2f9e:	9d 85       	ldd	r25, Y+13	; 0x0d
    2fa0:	8a 0d       	add	r24, r10
    2fa2:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    2fa4:	a8 16       	cp	r10, r24
    2fa6:	b9 06       	cpc	r11, r25
    2fa8:	60 f4       	brcc	.+24     	; 0x2fc2 <prvSampleTimeNow+0x7a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    2faa:	8a 83       	std	Y+2, r24	; 0x02
    2fac:	9b 83       	std	Y+3, r25	; 0x03
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2fae:	c8 87       	std	Y+8, r28	; 0x08
    2fb0:	d9 87       	std	Y+9, r29	; 0x09
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2fb2:	b8 01       	movw	r22, r16
    2fb4:	80 91 c2 22 	lds	r24, 0x22C2	; 0x8022c2 <pxCurrentTimerList>
    2fb8:	90 91 c3 22 	lds	r25, 0x22C3	; 0x8022c3 <pxCurrentTimerList+0x1>
    2fbc:	0e 94 25 0e 	call	0x1c4a	; 0x1c4a <vListInsert>
    2fc0:	08 c0       	rjmp	.+16     	; 0x2fd2 <prvSampleTimeNow+0x8a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2fc2:	00 e0       	ldi	r16, 0x00	; 0
    2fc4:	10 e0       	ldi	r17, 0x00	; 0
    2fc6:	20 e0       	ldi	r18, 0x00	; 0
    2fc8:	30 e0       	ldi	r19, 0x00	; 0
    2fca:	a5 01       	movw	r20, r10
    2fcc:	60 e0       	ldi	r22, 0x00	; 0
    2fce:	ce 01       	movw	r24, r28
    2fd0:	79 df       	rcall	.-270    	; 0x2ec4 <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2fd2:	e0 91 c2 22 	lds	r30, 0x22C2	; 0x8022c2 <pxCurrentTimerList>
    2fd6:	f0 91 c3 22 	lds	r31, 0x22C3	; 0x8022c3 <pxCurrentTimerList+0x1>
    2fda:	90 81       	ld	r25, Z
    2fdc:	91 11       	cpse	r25, r1
    2fde:	ca cf       	rjmp	.-108    	; 0x2f74 <prvSampleTimeNow+0x2c>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    2fe0:	80 91 c0 22 	lds	r24, 0x22C0	; 0x8022c0 <pxOverflowTimerList>
    2fe4:	90 91 c1 22 	lds	r25, 0x22C1	; 0x8022c1 <pxOverflowTimerList+0x1>
    2fe8:	80 93 c2 22 	sts	0x22C2, r24	; 0x8022c2 <pxCurrentTimerList>
    2fec:	90 93 c3 22 	sts	0x22C3, r25	; 0x8022c3 <pxCurrentTimerList+0x1>
	pxOverflowTimerList = pxTemp;
    2ff0:	e0 93 c0 22 	sts	0x22C0, r30	; 0x8022c0 <pxOverflowTimerList>
    2ff4:	f0 93 c1 22 	sts	0x22C1, r31	; 0x8022c1 <pxOverflowTimerList+0x1>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    2ff8:	81 e0       	ldi	r24, 0x01	; 1
    2ffa:	f6 01       	movw	r30, r12
    2ffc:	80 83       	st	Z, r24
    2ffe:	02 c0       	rjmp	.+4      	; 0x3004 <prvSampleTimeNow+0xbc>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    3000:	f6 01       	movw	r30, r12
    3002:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    3004:	e0 92 bc 22 	sts	0x22BC, r14	; 0x8022bc <xLastTime.4281>
    3008:	f0 92 bd 22 	sts	0x22BD, r15	; 0x8022bd <xLastTime.4281+0x1>

	return xTimeNow;
}
    300c:	c7 01       	movw	r24, r14
    300e:	df 91       	pop	r29
    3010:	cf 91       	pop	r28
    3012:	1f 91       	pop	r17
    3014:	0f 91       	pop	r16
    3016:	ff 90       	pop	r15
    3018:	ef 90       	pop	r14
    301a:	df 90       	pop	r13
    301c:	cf 90       	pop	r12
    301e:	bf 90       	pop	r11
    3020:	af 90       	pop	r10
    3022:	08 95       	ret

00003024 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    3024:	cf 93       	push	r28
    3026:	df 93       	push	r29
    3028:	00 d0       	rcall	.+0      	; 0x302a <prvTimerTask+0x6>
    302a:	00 d0       	rcall	.+0      	; 0x302c <prvTimerTask+0x8>
    302c:	cd b7       	in	r28, 0x3d	; 61
    302e:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3030:	ce 01       	movw	r24, r28
    3032:	01 96       	adiw	r24, 0x01	; 1
    3034:	5c 01       	movw	r10, r24
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    3036:	e8 2e       	mov	r14, r24
    3038:	fb 2c       	mov	r15, r11
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    303a:	e0 91 c2 22 	lds	r30, 0x22C2	; 0x8022c2 <pxCurrentTimerList>
    303e:	f0 91 c3 22 	lds	r31, 0x22C3	; 0x8022c3 <pxCurrentTimerList+0x1>
	if( *pxListWasEmpty == pdFALSE )
    3042:	80 81       	ld	r24, Z
    3044:	88 23       	and	r24, r24
    3046:	69 f0       	breq	.+26     	; 0x3062 <prvTimerTask+0x3e>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    3048:	05 80       	ldd	r0, Z+5	; 0x05
    304a:	f6 81       	ldd	r31, Z+6	; 0x06
    304c:	e0 2d       	mov	r30, r0
    304e:	c0 80       	ld	r12, Z
    3050:	d1 80       	ldd	r13, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    3052:	d0 db       	rcall	.-2144   	; 0x27f4 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3054:	c5 01       	movw	r24, r10
    3056:	78 df       	rcall	.-272    	; 0x2f48 <prvSampleTimeNow>
    3058:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    305a:	89 81       	ldd	r24, Y+1	; 0x01
    305c:	88 23       	and	r24, r24
    305e:	49 f0       	breq	.+18     	; 0x3072 <prvTimerTask+0x4e>
    3060:	56 c0       	rjmp	.+172    	; 0x310e <prvTimerTask+0xea>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    3062:	c8 db       	rcall	.-2160   	; 0x27f4 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3064:	c5 01       	movw	r24, r10
    3066:	70 df       	rcall	.-288    	; 0x2f48 <prvSampleTimeNow>
    3068:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    306a:	89 81       	ldd	r24, Y+1	; 0x01
    306c:	88 23       	and	r24, r24
    306e:	a9 f1       	breq	.+106    	; 0x30da <prvTimerTask+0xb6>
    3070:	4e c0       	rjmp	.+156    	; 0x310e <prvTimerTask+0xea>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    3072:	0c 15       	cp	r16, r12
    3074:	1d 05       	cpc	r17, r13
    3076:	08 f4       	brcc	.+2      	; 0x307a <prvTimerTask+0x56>
    3078:	3b c0       	rjmp	.+118    	; 0x30f0 <prvTimerTask+0xcc>
			{
				( void ) xTaskResumeAll();
    307a:	9f dc       	rcall	.-1730   	; 0x29ba <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    307c:	e0 91 c2 22 	lds	r30, 0x22C2	; 0x8022c2 <pxCurrentTimerList>
    3080:	f0 91 c3 22 	lds	r31, 0x22C3	; 0x8022c3 <pxCurrentTimerList+0x1>
    3084:	05 80       	ldd	r0, Z+5	; 0x05
    3086:	f6 81       	ldd	r31, Z+6	; 0x06
    3088:	e0 2d       	mov	r30, r0
    308a:	86 80       	ldd	r8, Z+6	; 0x06
    308c:	97 80       	ldd	r9, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    308e:	c4 01       	movw	r24, r8
    3090:	02 96       	adiw	r24, 0x02	; 2
    3092:	0e 94 56 0e 	call	0x1cac	; 0x1cac <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    3096:	d4 01       	movw	r26, r8
    3098:	1e 96       	adiw	r26, 0x0e	; 14
    309a:	8c 91       	ld	r24, X
    309c:	1e 97       	sbiw	r26, 0x0e	; 14
    309e:	81 30       	cpi	r24, 0x01	; 1
    30a0:	a1 f4       	brne	.+40     	; 0x30ca <prvTimerTask+0xa6>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
    30a2:	1c 96       	adiw	r26, 0x0c	; 12
    30a4:	6d 91       	ld	r22, X+
    30a6:	7c 91       	ld	r23, X
    30a8:	1d 97       	sbiw	r26, 0x0d	; 13
    30aa:	6c 0d       	add	r22, r12
    30ac:	7d 1d       	adc	r23, r13
    30ae:	96 01       	movw	r18, r12
    30b0:	a8 01       	movw	r20, r16
    30b2:	c4 01       	movw	r24, r8
    30b4:	52 de       	rcall	.-860    	; 0x2d5a <prvInsertTimerInActiveList>
    30b6:	81 30       	cpi	r24, 0x01	; 1
    30b8:	41 f4       	brne	.+16     	; 0x30ca <prvTimerTask+0xa6>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    30ba:	00 e0       	ldi	r16, 0x00	; 0
    30bc:	10 e0       	ldi	r17, 0x00	; 0
    30be:	20 e0       	ldi	r18, 0x00	; 0
    30c0:	30 e0       	ldi	r19, 0x00	; 0
    30c2:	a6 01       	movw	r20, r12
    30c4:	60 e0       	ldi	r22, 0x00	; 0
    30c6:	c4 01       	movw	r24, r8
    30c8:	fd de       	rcall	.-518    	; 0x2ec4 <xTimerGenericCommand>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    30ca:	d4 01       	movw	r26, r8
    30cc:	51 96       	adiw	r26, 0x11	; 17
    30ce:	ed 91       	ld	r30, X+
    30d0:	fc 91       	ld	r31, X
    30d2:	52 97       	sbiw	r26, 0x12	; 18
    30d4:	c4 01       	movw	r24, r8
    30d6:	19 95       	eicall
    30d8:	75 c0       	rjmp	.+234    	; 0x31c4 <prvTimerTask+0x1a0>
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    30da:	e0 91 c0 22 	lds	r30, 0x22C0	; 0x8022c0 <pxOverflowTimerList>
    30de:	f0 91 c1 22 	lds	r31, 0x22C1	; 0x8022c1 <pxOverflowTimerList+0x1>
    30e2:	41 e0       	ldi	r20, 0x01	; 1
    30e4:	80 81       	ld	r24, Z
    30e6:	81 11       	cpse	r24, r1
    30e8:	40 e0       	ldi	r20, 0x00	; 0
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    30ea:	c1 2c       	mov	r12, r1
    30ec:	d1 2c       	mov	r13, r1
    30ee:	01 c0       	rjmp	.+2      	; 0x30f2 <prvTimerTask+0xce>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    30f0:	40 e0       	ldi	r20, 0x00	; 0
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    30f2:	b6 01       	movw	r22, r12
    30f4:	60 1b       	sub	r22, r16
    30f6:	71 0b       	sbc	r23, r17
    30f8:	80 91 be 22 	lds	r24, 0x22BE	; 0x8022be <xTimerQueue>
    30fc:	90 91 bf 22 	lds	r25, 0x22BF	; 0x8022bf <xTimerQueue+0x1>
    3100:	ee d9       	rcall	.-3108   	; 0x24de <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    3102:	5b dc       	rcall	.-1866   	; 0x29ba <xTaskResumeAll>
    3104:	81 11       	cpse	r24, r1
    3106:	5e c0       	rjmp	.+188    	; 0x31c4 <prvTimerTask+0x1a0>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    3108:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <vPortYield>
    310c:	5b c0       	rjmp	.+182    	; 0x31c4 <prvTimerTask+0x1a0>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    310e:	55 dc       	rcall	.-1878   	; 0x29ba <xTaskResumeAll>
    3110:	59 c0       	rjmp	.+178    	; 0x31c4 <prvTimerTask+0x1a0>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    3112:	99 81       	ldd	r25, Y+1	; 0x01
    3114:	99 23       	and	r25, r25
    3116:	0c f4       	brge	.+2      	; 0x311a <prvTimerTask+0xf6>
    3118:	55 c0       	rjmp	.+170    	; 0x31c4 <prvTimerTask+0x1a0>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    311a:	cc 80       	ldd	r12, Y+4	; 0x04
    311c:	dd 80       	ldd	r13, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    311e:	f6 01       	movw	r30, r12
    3120:	82 85       	ldd	r24, Z+10	; 0x0a
    3122:	93 85       	ldd	r25, Z+11	; 0x0b
    3124:	89 2b       	or	r24, r25
    3126:	21 f0       	breq	.+8      	; 0x3130 <prvTimerTask+0x10c>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3128:	c6 01       	movw	r24, r12
    312a:	02 96       	adiw	r24, 0x02	; 2
    312c:	0e 94 56 0e 	call	0x1cac	; 0x1cac <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3130:	ce 01       	movw	r24, r28
    3132:	06 96       	adiw	r24, 0x06	; 6
    3134:	09 df       	rcall	.-494    	; 0x2f48 <prvSampleTimeNow>
    3136:	ac 01       	movw	r20, r24

			switch( xMessage.xMessageID )
    3138:	09 81       	ldd	r16, Y+1	; 0x01
    313a:	00 2e       	mov	r0, r16
    313c:	00 0c       	add	r0, r0
    313e:	11 0b       	sbc	r17, r17
    3140:	22 0b       	sbc	r18, r18
    3142:	33 0b       	sbc	r19, r19
    3144:	0a 30       	cpi	r16, 0x0A	; 10
    3146:	11 05       	cpc	r17, r1
    3148:	08 f0       	brcs	.+2      	; 0x314c <prvTimerTask+0x128>
    314a:	3c c0       	rjmp	.+120    	; 0x31c4 <prvTimerTask+0x1a0>
    314c:	f8 01       	movw	r30, r16
    314e:	88 27       	eor	r24, r24
    3150:	e2 50       	subi	r30, 0x02	; 2
    3152:	ff 4f       	sbci	r31, 0xFF	; 255
    3154:	8f 4f       	sbci	r24, 0xFF	; 255
    3156:	9d c3       	rjmp	.+1850   	; 0x3892 <__tablejump2__>
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
    3158:	2a 81       	ldd	r18, Y+2	; 0x02
    315a:	3b 81       	ldd	r19, Y+3	; 0x03
    315c:	d6 01       	movw	r26, r12
    315e:	1c 96       	adiw	r26, 0x0c	; 12
    3160:	6d 91       	ld	r22, X+
    3162:	7c 91       	ld	r23, X
    3164:	1d 97       	sbiw	r26, 0x0d	; 13
    3166:	62 0f       	add	r22, r18
    3168:	73 1f       	adc	r23, r19
    316a:	c6 01       	movw	r24, r12
    316c:	f6 dd       	rcall	.-1044   	; 0x2d5a <prvInsertTimerInActiveList>
    316e:	81 30       	cpi	r24, 0x01	; 1
    3170:	49 f5       	brne	.+82     	; 0x31c4 <prvTimerTask+0x1a0>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3172:	d6 01       	movw	r26, r12
    3174:	51 96       	adiw	r26, 0x11	; 17
    3176:	ed 91       	ld	r30, X+
    3178:	fc 91       	ld	r31, X
    317a:	52 97       	sbiw	r26, 0x12	; 18
    317c:	c6 01       	movw	r24, r12
    317e:	19 95       	eicall
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    3180:	f6 01       	movw	r30, r12
    3182:	86 85       	ldd	r24, Z+14	; 0x0e
    3184:	81 30       	cpi	r24, 0x01	; 1
    3186:	f1 f4       	brne	.+60     	; 0x31c4 <prvTimerTask+0x1a0>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    3188:	44 85       	ldd	r20, Z+12	; 0x0c
    318a:	55 85       	ldd	r21, Z+13	; 0x0d
    318c:	8a 81       	ldd	r24, Y+2	; 0x02
    318e:	9b 81       	ldd	r25, Y+3	; 0x03
    3190:	48 0f       	add	r20, r24
    3192:	59 1f       	adc	r21, r25
    3194:	00 e0       	ldi	r16, 0x00	; 0
    3196:	10 e0       	ldi	r17, 0x00	; 0
    3198:	20 e0       	ldi	r18, 0x00	; 0
    319a:	30 e0       	ldi	r19, 0x00	; 0
    319c:	60 e0       	ldi	r22, 0x00	; 0
    319e:	c6 01       	movw	r24, r12
    31a0:	91 de       	rcall	.-734    	; 0x2ec4 <xTimerGenericCommand>
    31a2:	10 c0       	rjmp	.+32     	; 0x31c4 <prvTimerTask+0x1a0>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    31a4:	6a 81       	ldd	r22, Y+2	; 0x02
    31a6:	7b 81       	ldd	r23, Y+3	; 0x03
    31a8:	d6 01       	movw	r26, r12
    31aa:	1c 96       	adiw	r26, 0x0c	; 12
    31ac:	6d 93       	st	X+, r22
    31ae:	7c 93       	st	X, r23
    31b0:	1d 97       	sbiw	r26, 0x0d	; 13
					longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot be
					zero the next expiry time can only be in the future, meaning
					(unlike for the xTimerStart() case above) there is no fail case
					that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    31b2:	64 0f       	add	r22, r20
    31b4:	75 1f       	adc	r23, r21
    31b6:	9a 01       	movw	r18, r20
    31b8:	c6 01       	movw	r24, r12
    31ba:	cf dd       	rcall	.-1122   	; 0x2d5a <prvInsertTimerInActiveList>
    31bc:	03 c0       	rjmp	.+6      	; 0x31c4 <prvTimerTask+0x1a0>
					break;

				case tmrCOMMAND_DELETE :
					/* The timer has already been removed from the active list,
					just free up the memory. */
					vPortFree( pxTimer );
    31be:	c6 01       	movw	r24, r12
    31c0:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <vPortFree>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    31c4:	20 e0       	ldi	r18, 0x00	; 0
    31c6:	40 e0       	ldi	r20, 0x00	; 0
    31c8:	50 e0       	ldi	r21, 0x00	; 0
    31ca:	6e 2d       	mov	r22, r14
    31cc:	7f 2d       	mov	r23, r15
    31ce:	80 91 be 22 	lds	r24, 0x22BE	; 0x8022be <xTimerQueue>
    31d2:	90 91 bf 22 	lds	r25, 0x22BF	; 0x8022bf <xTimerQueue+0x1>
    31d6:	ec d8       	rcall	.-3624   	; 0x23b0 <xQueueGenericReceive>
    31d8:	81 11       	cpse	r24, r1
    31da:	9b cf       	rjmp	.-202    	; 0x3112 <prvTimerTask+0xee>
    31dc:	2e cf       	rjmp	.-420    	; 0x303a <prvTimerTask+0x16>

000031de <ioport_configure_port_pin>:
#include "ioport_compat.h"

#if defined(IOPORT_XMEGA_COMPAT)
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
    31de:	cf 93       	push	r28
    31e0:	df 93       	push	r29
    31e2:	fc 01       	movw	r30, r24
    31e4:	70 96       	adiw	r30, 0x10	; 16
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    31e6:	20 e0       	ldi	r18, 0x00	; 0
    31e8:	30 e0       	ldi	r19, 0x00	; 0
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
    31ea:	c6 2f       	mov	r28, r22
    31ec:	d0 e0       	ldi	r29, 0x00	; 0
    31ee:	de 01       	movw	r26, r28
    31f0:	02 2e       	mov	r0, r18
    31f2:	02 c0       	rjmp	.+4      	; 0x31f8 <ioport_configure_port_pin+0x1a>
    31f4:	b5 95       	asr	r27
    31f6:	a7 95       	ror	r26
    31f8:	0a 94       	dec	r0
    31fa:	e2 f7       	brpl	.-8      	; 0x31f4 <ioport_configure_port_pin+0x16>
    31fc:	a0 fd       	sbrc	r26, 0
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    31fe:	50 83       	st	Z, r21
    3200:	2f 5f       	subi	r18, 0xFF	; 255
    3202:	3f 4f       	sbci	r19, 0xFF	; 255
    3204:	31 96       	adiw	r30, 0x01	; 1
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
    3206:	28 30       	cpi	r18, 0x08	; 8
    3208:	31 05       	cpc	r19, r1
    320a:	89 f7       	brne	.-30     	; 0x31ee <ioport_configure_port_pin+0x10>
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
		}
	}
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
    320c:	40 ff       	sbrs	r20, 0
    320e:	0a c0       	rjmp	.+20     	; 0x3224 <ioport_configure_port_pin+0x46>
		if (flags & IOPORT_INIT_HIGH) {
    3210:	41 ff       	sbrs	r20, 1
    3212:	03 c0       	rjmp	.+6      	; 0x321a <ioport_configure_port_pin+0x3c>
			*((uint8_t *)port + PORT_OUTSET) = pin_mask;
    3214:	fc 01       	movw	r30, r24
    3216:	65 83       	std	Z+5, r22	; 0x05
    3218:	02 c0       	rjmp	.+4      	; 0x321e <ioport_configure_port_pin+0x40>
		} else {
			*((uint8_t *)port + PORT_OUTCLR) = pin_mask;
    321a:	fc 01       	movw	r30, r24
    321c:	66 83       	std	Z+6, r22	; 0x06
		}

		*((uint8_t *)port + PORT_DIRSET) = pin_mask;
    321e:	fc 01       	movw	r30, r24
    3220:	61 83       	std	Z+1, r22	; 0x01
    3222:	02 c0       	rjmp	.+4      	; 0x3228 <ioport_configure_port_pin+0x4a>
	} else {
		*((uint8_t *)port + PORT_DIRCLR) = pin_mask;
    3224:	fc 01       	movw	r30, r24
    3226:	62 83       	std	Z+2, r22	; 0x02
	}
}
    3228:	df 91       	pop	r29
    322a:	cf 91       	pop	r28
    322c:	08 95       	ret

0000322e <board_init>:
 * \param flags Bitmask of flags specifying additional configuration
 * parameters.
 */
static inline void ioport_configure_pin(port_pin_t pin, port_pin_flags_t flags)
{
	ioport_configure_port_pin(arch_ioport_pin_to_base(pin),
    322e:	43 e0       	ldi	r20, 0x03	; 3
    3230:	50 e0       	ldi	r21, 0x00	; 0
    3232:	61 e0       	ldi	r22, 0x01	; 1
    3234:	80 ee       	ldi	r24, 0xE0	; 224
    3236:	97 e0       	ldi	r25, 0x07	; 7
    3238:	d2 df       	rcall	.-92     	; 0x31de <ioport_configure_port_pin>
    323a:	43 e0       	ldi	r20, 0x03	; 3
    323c:	50 e0       	ldi	r21, 0x00	; 0
    323e:	62 e0       	ldi	r22, 0x02	; 2
    3240:	80 ee       	ldi	r24, 0xE0	; 224
    3242:	97 e0       	ldi	r25, 0x07	; 7
    3244:	cc df       	rcall	.-104    	; 0x31de <ioport_configure_port_pin>
    3246:	43 e0       	ldi	r20, 0x03	; 3
    3248:	50 e0       	ldi	r21, 0x00	; 0
    324a:	60 e1       	ldi	r22, 0x10	; 16
    324c:	80 e6       	ldi	r24, 0x60	; 96
    324e:	96 e0       	ldi	r25, 0x06	; 6
    3250:	c6 df       	rcall	.-116    	; 0x31de <ioport_configure_port_pin>
    3252:	41 e0       	ldi	r20, 0x01	; 1
    3254:	50 e4       	ldi	r21, 0x40	; 64
    3256:	60 e2       	ldi	r22, 0x20	; 32
    3258:	80 e6       	ldi	r24, 0x60	; 96
    325a:	96 e0       	ldi	r25, 0x06	; 6
    325c:	c0 df       	rcall	.-128    	; 0x31de <ioport_configure_port_pin>
    325e:	40 e0       	ldi	r20, 0x00	; 0
    3260:	5b e1       	ldi	r21, 0x1B	; 27
    3262:	60 e2       	ldi	r22, 0x20	; 32
    3264:	80 e8       	ldi	r24, 0x80	; 128
    3266:	96 e0       	ldi	r25, 0x06	; 6
    3268:	ba df       	rcall	.-140    	; 0x31de <ioport_configure_port_pin>
    326a:	40 e0       	ldi	r20, 0x00	; 0
    326c:	5b e1       	ldi	r21, 0x1B	; 27
    326e:	62 e0       	ldi	r22, 0x02	; 2
    3270:	80 ea       	ldi	r24, 0xA0	; 160
    3272:	96 e0       	ldi	r25, 0x06	; 6
    3274:	b4 df       	rcall	.-152    	; 0x31de <ioport_configure_port_pin>
    3276:	40 e0       	ldi	r20, 0x00	; 0
    3278:	5b e1       	ldi	r21, 0x1B	; 27
    327a:	64 e0       	ldi	r22, 0x04	; 4
    327c:	80 ea       	ldi	r24, 0xA0	; 160
    327e:	96 e0       	ldi	r25, 0x06	; 6
    3280:	ae df       	rcall	.-164    	; 0x31de <ioport_configure_port_pin>
    3282:	43 e0       	ldi	r20, 0x03	; 3
    3284:	50 e0       	ldi	r21, 0x00	; 0
    3286:	62 e0       	ldi	r22, 0x02	; 2
    3288:	80 e6       	ldi	r24, 0x60	; 96
    328a:	96 e0       	ldi	r25, 0x06	; 6
    328c:	a8 df       	rcall	.-176    	; 0x31de <ioport_configure_port_pin>
    328e:	43 e0       	ldi	r20, 0x03	; 3
    3290:	50 e0       	ldi	r21, 0x00	; 0
    3292:	68 e0       	ldi	r22, 0x08	; 8
    3294:	80 e6       	ldi	r24, 0x60	; 96
    3296:	96 e0       	ldi	r25, 0x06	; 6
    3298:	a2 df       	rcall	.-188    	; 0x31de <ioport_configure_port_pin>
    329a:	43 e0       	ldi	r20, 0x03	; 3
    329c:	50 e0       	ldi	r21, 0x00	; 0
    329e:	68 e0       	ldi	r22, 0x08	; 8
    32a0:	80 ea       	ldi	r24, 0xA0	; 160
    32a2:	96 e0       	ldi	r25, 0x06	; 6
    32a4:	9c df       	rcall	.-200    	; 0x31de <ioport_configure_port_pin>
    32a6:	43 e0       	ldi	r20, 0x03	; 3
    32a8:	50 e0       	ldi	r21, 0x00	; 0
    32aa:	61 e0       	ldi	r22, 0x01	; 1
    32ac:	80 e6       	ldi	r24, 0x60	; 96
    32ae:	96 e0       	ldi	r25, 0x06	; 6
    32b0:	96 df       	rcall	.-212    	; 0x31de <ioport_configure_port_pin>
    32b2:	43 e0       	ldi	r20, 0x03	; 3
    32b4:	50 e0       	ldi	r21, 0x00	; 0
    32b6:	68 e0       	ldi	r22, 0x08	; 8
    32b8:	80 e0       	ldi	r24, 0x00	; 0
    32ba:	96 e0       	ldi	r25, 0x06	; 6
    32bc:	90 df       	rcall	.-224    	; 0x31de <ioport_configure_port_pin>
    32be:	41 e0       	ldi	r20, 0x01	; 1
    32c0:	50 e0       	ldi	r21, 0x00	; 0
    32c2:	60 e1       	ldi	r22, 0x10	; 16
    32c4:	80 e8       	ldi	r24, 0x80	; 128
    32c6:	96 e0       	ldi	r25, 0x06	; 6
    32c8:	8a df       	rcall	.-236    	; 0x31de <ioport_configure_port_pin>
    32ca:	43 e0       	ldi	r20, 0x03	; 3
    32cc:	50 e0       	ldi	r21, 0x00	; 0
    32ce:	62 e0       	ldi	r22, 0x02	; 2
    32d0:	80 e6       	ldi	r24, 0x60	; 96
    32d2:	96 e0       	ldi	r25, 0x06	; 6
    32d4:	84 df       	rcall	.-248    	; 0x31de <ioport_configure_port_pin>
    32d6:	43 e0       	ldi	r20, 0x03	; 3
    32d8:	50 e0       	ldi	r21, 0x00	; 0
    32da:	68 e0       	ldi	r22, 0x08	; 8
    32dc:	80 e6       	ldi	r24, 0x60	; 96
    32de:	96 e0       	ldi	r25, 0x06	; 6
    32e0:	7e df       	rcall	.-260    	; 0x31de <ioport_configure_port_pin>
    32e2:	40 e0       	ldi	r20, 0x00	; 0
    32e4:	50 e0       	ldi	r21, 0x00	; 0
    32e6:	64 e0       	ldi	r22, 0x04	; 4
    32e8:	80 e6       	ldi	r24, 0x60	; 96
    32ea:	96 e0       	ldi	r25, 0x06	; 6
    32ec:	78 df       	rcall	.-272    	; 0x31de <ioport_configure_port_pin>
    32ee:	43 e0       	ldi	r20, 0x03	; 3
    32f0:	50 e0       	ldi	r21, 0x00	; 0
    32f2:	60 e1       	ldi	r22, 0x10	; 16
    32f4:	80 ea       	ldi	r24, 0xA0	; 160
    32f6:	96 e0       	ldi	r25, 0x06	; 6
    32f8:	72 df       	rcall	.-284    	; 0x31de <ioport_configure_port_pin>
    32fa:	40 e0       	ldi	r20, 0x00	; 0
    32fc:	50 e0       	ldi	r21, 0x00	; 0
    32fe:	61 e0       	ldi	r22, 0x01	; 1
    3300:	80 e0       	ldi	r24, 0x00	; 0
    3302:	96 e0       	ldi	r25, 0x06	; 6
    3304:	6c df       	rcall	.-296    	; 0x31de <ioport_configure_port_pin>
    3306:	40 e0       	ldi	r20, 0x00	; 0
    3308:	50 e0       	ldi	r21, 0x00	; 0
    330a:	64 e0       	ldi	r22, 0x04	; 4
    330c:	80 e0       	ldi	r24, 0x00	; 0
    330e:	96 e0       	ldi	r25, 0x06	; 6
    3310:	66 df       	rcall	.-308    	; 0x31de <ioport_configure_port_pin>
    3312:	40 e0       	ldi	r20, 0x00	; 0
    3314:	50 e0       	ldi	r21, 0x00	; 0
    3316:	62 e0       	ldi	r22, 0x02	; 2
    3318:	80 e2       	ldi	r24, 0x20	; 32
    331a:	96 e0       	ldi	r25, 0x06	; 6
    331c:	60 df       	rcall	.-320    	; 0x31de <ioport_configure_port_pin>
    331e:	43 e0       	ldi	r20, 0x03	; 3
    3320:	50 e0       	ldi	r21, 0x00	; 0
    3322:	68 e0       	ldi	r22, 0x08	; 8
    3324:	80 e4       	ldi	r24, 0x40	; 64
    3326:	96 e0       	ldi	r25, 0x06	; 6
    3328:	5a df       	rcall	.-332    	; 0x31de <ioport_configure_port_pin>
    332a:	40 e0       	ldi	r20, 0x00	; 0
    332c:	50 e0       	ldi	r21, 0x00	; 0
    332e:	64 e0       	ldi	r22, 0x04	; 4
    3330:	80 e4       	ldi	r24, 0x40	; 64
    3332:	96 e0       	ldi	r25, 0x06	; 6
    3334:	54 df       	rcall	.-344    	; 0x31de <ioport_configure_port_pin>
    3336:	43 e0       	ldi	r20, 0x03	; 3
    3338:	50 e0       	ldi	r21, 0x00	; 0
    333a:	68 e0       	ldi	r22, 0x08	; 8
    333c:	80 e6       	ldi	r24, 0x60	; 96
    333e:	96 e0       	ldi	r25, 0x06	; 6
    3340:	4e df       	rcall	.-356    	; 0x31de <ioport_configure_port_pin>
    3342:	40 e0       	ldi	r20, 0x00	; 0
    3344:	50 e0       	ldi	r21, 0x00	; 0
    3346:	64 e0       	ldi	r22, 0x04	; 4
    3348:	80 e6       	ldi	r24, 0x60	; 96
    334a:	96 e0       	ldi	r25, 0x06	; 6
    334c:	48 df       	rcall	.-368    	; 0x31de <ioport_configure_port_pin>
    334e:	43 e0       	ldi	r20, 0x03	; 3
    3350:	50 e0       	ldi	r21, 0x00	; 0
    3352:	68 e0       	ldi	r22, 0x08	; 8
    3354:	80 e8       	ldi	r24, 0x80	; 128
    3356:	96 e0       	ldi	r25, 0x06	; 6
    3358:	42 df       	rcall	.-380    	; 0x31de <ioport_configure_port_pin>
    335a:	40 e0       	ldi	r20, 0x00	; 0
    335c:	50 e0       	ldi	r21, 0x00	; 0
    335e:	64 e0       	ldi	r22, 0x04	; 4
    3360:	80 e8       	ldi	r24, 0x80	; 128
    3362:	96 e0       	ldi	r25, 0x06	; 6
    3364:	3c cf       	rjmp	.-392    	; 0x31de <ioport_configure_port_pin>
    3366:	08 95       	ret

00003368 <vTimerCallback>:
	while(1){
		char inp = usart_getchar(USART_SERIAL_EXAMPLE);
		if(inp=='\n') break;
		else reads[i++] = inp;
	}
}
    3368:	80 91 d6 22 	lds	r24, 0x22D6	; 0x8022d6 <increment>
    336c:	90 91 d7 22 	lds	r25, 0x22D7	; 0x8022d7 <increment+0x1>
    3370:	a0 91 d8 22 	lds	r26, 0x22D8	; 0x8022d8 <increment+0x2>
    3374:	b0 91 d9 22 	lds	r27, 0x22D9	; 0x8022d9 <increment+0x3>
    3378:	01 96       	adiw	r24, 0x01	; 1
    337a:	a1 1d       	adc	r26, r1
    337c:	b1 1d       	adc	r27, r1
    337e:	80 93 d6 22 	sts	0x22D6, r24	; 0x8022d6 <increment>
    3382:	90 93 d7 22 	sts	0x22D7, r25	; 0x8022d7 <increment+0x1>
    3386:	a0 93 d8 22 	sts	0x22D8, r26	; 0x8022d8 <increment+0x2>
    338a:	b0 93 d9 22 	sts	0x22D9, r27	; 0x8022d9 <increment+0x3>
    338e:	08 95       	ret

00003390 <resetAll>:
    3390:	00 e8       	ldi	r16, 0x80	; 128
    3392:	16 e0       	ldi	r17, 0x06	; 6
    3394:	c0 ee       	ldi	r28, 0xE0	; 224
    3396:	d7 e0       	ldi	r29, 0x07	; 7
    3398:	bb 24       	eor	r11, r11
    339a:	b3 94       	inc	r11
    339c:	68 94       	set
    339e:	ee 24       	eor	r14, r14
    33a0:	e1 f8       	bld	r14, 1
    33a2:	0f 2e       	mov	r0, r31
    33a4:	f0 e6       	ldi	r31, 0x60	; 96
    33a6:	cf 2e       	mov	r12, r31
    33a8:	f6 e0       	ldi	r31, 0x06	; 6
    33aa:	df 2e       	mov	r13, r31
    33ac:	f0 2d       	mov	r31, r0
    33ae:	68 94       	set
    33b0:	ff 24       	eor	r15, r15
    33b2:	f4 f8       	bld	r15, 4
    33b4:	f8 01       	movw	r30, r16
    33b6:	80 85       	ldd	r24, Z+8	; 0x08
    33b8:	85 fd       	sbrc	r24, 5
    33ba:	14 c0       	rjmp	.+40     	; 0x33e4 <resetAll+0x54>
    33bc:	bd 82       	std	Y+5, r11	; 0x05
    33be:	ed 82       	std	Y+5, r14	; 0x05
    33c0:	f6 01       	movw	r30, r12
    33c2:	f5 82       	std	Z+5, r15	; 0x05
    33c4:	10 92 da 22 	sts	0x22DA, r1	; 0x8022da <pingtest>
    33c8:	10 92 db 22 	sts	0x22DB, r1	; 0x8022db <pingtest+0x1>
    33cc:	10 92 de 22 	sts	0x22DE, r1	; 0x8022de <servotest>
    33d0:	10 92 df 22 	sts	0x22DF, r1	; 0x8022df <servotest+0x1>
    33d4:	10 92 e0 22 	sts	0x22E0, r1	; 0x8022e0 <potensiotest>
    33d8:	10 92 e1 22 	sts	0x22E1, r1	; 0x8022e1 <potensiotest+0x1>
    33dc:	10 92 dc 22 	sts	0x22DC, r1	; 0x8022dc <qtouchtest>
    33e0:	10 92 dd 22 	sts	0x22DD, r1	; 0x8022dd <qtouchtest+0x1>
    33e4:	85 e0       	ldi	r24, 0x05	; 5
    33e6:	90 e0       	ldi	r25, 0x00	; 0
    33e8:	65 db       	rcall	.-2358   	; 0x2ab4 <vTaskDelay>
    33ea:	e4 cf       	rjmp	.-56     	; 0x33b4 <resetAll+0x24>

000033ec <testQtouch>:
    33ec:	0f 2e       	mov	r0, r31
    33ee:	f0 ea       	ldi	r31, 0xA0	; 160
    33f0:	ef 2e       	mov	r14, r31
    33f2:	f6 e0       	ldi	r31, 0x06	; 6
    33f4:	ff 2e       	mov	r15, r31
    33f6:	f0 2d       	mov	r31, r0
    33f8:	00 ee       	ldi	r16, 0xE0	; 224
    33fa:	17 e0       	ldi	r17, 0x07	; 7
    33fc:	c2 e0       	ldi	r28, 0x02	; 2
    33fe:	cc 24       	eor	r12, r12
    3400:	c3 94       	inc	r12
    3402:	d1 2c       	mov	r13, r1
    3404:	f7 01       	movw	r30, r14
    3406:	80 85       	ldd	r24, Z+8	; 0x08
    3408:	88 23       	and	r24, r24
    340a:	3c f4       	brge	.+14     	; 0x341a <testQtouch+0x2e>
    340c:	f8 01       	movw	r30, r16
    340e:	c6 83       	std	Z+6, r28	; 0x06
    3410:	c0 92 dc 22 	sts	0x22DC, r12	; 0x8022dc <qtouchtest>
    3414:	d0 92 dd 22 	sts	0x22DD, r13	; 0x8022dd <qtouchtest+0x1>
    3418:	06 c0       	rjmp	.+12     	; 0x3426 <testQtouch+0x3a>
    341a:	f8 01       	movw	r30, r16
    341c:	c5 83       	std	Z+5, r28	; 0x05
    341e:	10 92 dc 22 	sts	0x22DC, r1	; 0x8022dc <qtouchtest>
    3422:	10 92 dd 22 	sts	0x22DD, r1	; 0x8022dd <qtouchtest+0x1>
    3426:	82 e3       	ldi	r24, 0x32	; 50
    3428:	90 e0       	ldi	r25, 0x00	; 0
    342a:	44 db       	rcall	.-2424   	; 0x2ab4 <vTaskDelay>
    342c:	eb cf       	rjmp	.-42     	; 0x3404 <testQtouch+0x18>

0000342e <testLCD>:
    342e:	80 e1       	ldi	r24, 0x10	; 16
    3430:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
    3434:	0f 2e       	mov	r0, r31
    3436:	f1 e2       	ldi	r31, 0x21	; 33
    3438:	8f 2e       	mov	r8, r31
    343a:	f0 e2       	ldi	r31, 0x20	; 32
    343c:	9f 2e       	mov	r9, r31
    343e:	f0 2d       	mov	r31, r0
    3440:	19 ec       	ldi	r17, 0xC9	; 201
    3442:	c6 ee       	ldi	r28, 0xE6	; 230
    3444:	d2 e2       	ldi	r29, 0x22	; 34
    3446:	0f 2e       	mov	r0, r31
    3448:	f0 e3       	ldi	r31, 0x30	; 48
    344a:	af 2e       	mov	r10, r31
    344c:	f0 e2       	ldi	r31, 0x20	; 32
    344e:	bf 2e       	mov	r11, r31
    3450:	f0 2d       	mov	r31, r0
    3452:	0f 2e       	mov	r0, r31
    3454:	fd e3       	ldi	r31, 0x3D	; 61
    3456:	cf 2e       	mov	r12, r31
    3458:	f0 e2       	ldi	r31, 0x20	; 32
    345a:	df 2e       	mov	r13, r31
    345c:	f0 2d       	mov	r31, r0
    345e:	0f 2e       	mov	r0, r31
    3460:	fc e4       	ldi	r31, 0x4C	; 76
    3462:	ef 2e       	mov	r14, r31
    3464:	f0 e2       	ldi	r31, 0x20	; 32
    3466:	ff 2e       	mov	r15, r31
    3468:	f0 2d       	mov	r31, r0
    346a:	80 91 e5 22 	lds	r24, 0x22E5	; 0x8022e5 <result+0x1>
    346e:	8f 93       	push	r24
    3470:	80 91 e4 22 	lds	r24, 0x22E4	; 0x8022e4 <result>
    3474:	8f 93       	push	r24
    3476:	9f 92       	push	r9
    3478:	8f 92       	push	r8
    347a:	1f 92       	push	r1
    347c:	1f 93       	push	r17
    347e:	df 93       	push	r29
    3480:	cf 93       	push	r28
    3482:	45 d3       	rcall	.+1674   	; 0x3b0e <snprintf>
    3484:	26 e0       	ldi	r18, 0x06	; 6
    3486:	30 e2       	ldi	r19, 0x20	; 32
    3488:	40 e0       	ldi	r20, 0x00	; 0
    348a:	60 e0       	ldi	r22, 0x00	; 0
    348c:	ce 01       	movw	r24, r28
    348e:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <gfx_mono_draw_string>
    3492:	80 91 dd 22 	lds	r24, 0x22DD	; 0x8022dd <qtouchtest+0x1>
    3496:	8f 93       	push	r24
    3498:	80 91 dc 22 	lds	r24, 0x22DC	; 0x8022dc <qtouchtest>
    349c:	8f 93       	push	r24
    349e:	bf 92       	push	r11
    34a0:	af 92       	push	r10
    34a2:	1f 92       	push	r1
    34a4:	1f 93       	push	r17
    34a6:	df 93       	push	r29
    34a8:	cf 93       	push	r28
    34aa:	31 d3       	rcall	.+1634   	; 0x3b0e <snprintf>
    34ac:	26 e0       	ldi	r18, 0x06	; 6
    34ae:	30 e2       	ldi	r19, 0x20	; 32
    34b0:	48 e0       	ldi	r20, 0x08	; 8
    34b2:	60 e0       	ldi	r22, 0x00	; 0
    34b4:	ce 01       	movw	r24, r28
    34b6:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <gfx_mono_draw_string>
    34ba:	80 91 e3 22 	lds	r24, 0x22E3	; 0x8022e3 <result2+0x1>
    34be:	8f 93       	push	r24
    34c0:	80 91 e2 22 	lds	r24, 0x22E2	; 0x8022e2 <result2>
    34c4:	8f 93       	push	r24
    34c6:	df 92       	push	r13
    34c8:	cf 92       	push	r12
    34ca:	1f 92       	push	r1
    34cc:	1f 93       	push	r17
    34ce:	df 93       	push	r29
    34d0:	cf 93       	push	r28
    34d2:	1d d3       	rcall	.+1594   	; 0x3b0e <snprintf>
    34d4:	26 e0       	ldi	r18, 0x06	; 6
    34d6:	30 e2       	ldi	r19, 0x20	; 32
    34d8:	40 e1       	ldi	r20, 0x10	; 16
    34da:	60 e0       	ldi	r22, 0x00	; 0
    34dc:	ce 01       	movw	r24, r28
    34de:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <gfx_mono_draw_string>
    34e2:	80 91 df 22 	lds	r24, 0x22DF	; 0x8022df <servotest+0x1>
    34e6:	8f 93       	push	r24
    34e8:	80 91 de 22 	lds	r24, 0x22DE	; 0x8022de <servotest>
    34ec:	8f 93       	push	r24
    34ee:	ff 92       	push	r15
    34f0:	ef 92       	push	r14
    34f2:	1f 92       	push	r1
    34f4:	1f 93       	push	r17
    34f6:	df 93       	push	r29
    34f8:	cf 93       	push	r28
    34fa:	09 d3       	rcall	.+1554   	; 0x3b0e <snprintf>
    34fc:	8d b7       	in	r24, 0x3d	; 61
    34fe:	9e b7       	in	r25, 0x3e	; 62
    3500:	80 96       	adiw	r24, 0x20	; 32
    3502:	8d bf       	out	0x3d, r24	; 61
    3504:	9e bf       	out	0x3e, r25	; 62
    3506:	26 e0       	ldi	r18, 0x06	; 6
    3508:	30 e2       	ldi	r19, 0x20	; 32
    350a:	48 e1       	ldi	r20, 0x18	; 24
    350c:	60 e0       	ldi	r22, 0x00	; 0
    350e:	ce 01       	movw	r24, r28
    3510:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <gfx_mono_draw_string>
    3514:	82 e0       	ldi	r24, 0x02	; 2
    3516:	90 e0       	ldi	r25, 0x00	; 0
    3518:	cd da       	rcall	.-2662   	; 0x2ab4 <vTaskDelay>
    351a:	a7 cf       	rjmp	.-178    	; 0x346a <testLCD+0x3c>

0000351c <testLight>:
    351c:	c0 e0       	ldi	r28, 0x00	; 0
    351e:	d2 e0       	ldi	r29, 0x02	; 2
    3520:	68 94       	set
    3522:	ff 24       	eor	r15, r15
    3524:	f1 f8       	bld	r15, 1
    3526:	08 e2       	ldi	r16, 0x28	; 40
    3528:	12 e0       	ldi	r17, 0x02	; 2
    352a:	ce 01       	movw	r24, r28
    352c:	0e 94 46 07 	call	0xe8c	; 0xe8c <adc_enable>
    3530:	9f b7       	in	r25, 0x3f	; 63
    3532:	f8 94       	cli
    3534:	88 81       	ld	r24, Y
    3536:	88 60       	ori	r24, 0x08	; 8
    3538:	88 83       	st	Y, r24
    353a:	9f bf       	out	0x3f, r25	; 63
    353c:	9e 81       	ldd	r25, Y+6	; 0x06
    353e:	91 ff       	sbrs	r25, 1
    3540:	fd cf       	rjmp	.-6      	; 0x353c <testLight+0x20>
    3542:	fe 82       	std	Y+6, r15	; 0x06
    3544:	f8 01       	movw	r30, r16
    3546:	84 81       	ldd	r24, Z+4	; 0x04
    3548:	95 81       	ldd	r25, Z+5	; 0x05
    354a:	80 93 e2 22 	sts	0x22E2, r24	; 0x8022e2 <result2>
    354e:	90 93 e3 22 	sts	0x22E3, r25	; 0x8022e3 <result2+0x1>
    3552:	85 e0       	ldi	r24, 0x05	; 5
    3554:	90 e0       	ldi	r25, 0x00	; 0
    3556:	ae da       	rcall	.-2724   	; 0x2ab4 <vTaskDelay>
    3558:	e8 cf       	rjmp	.-48     	; 0x352a <testLight+0xe>

0000355a <testPotentio>:
    355a:	c0 e0       	ldi	r28, 0x00	; 0
    355c:	d2 e0       	ldi	r29, 0x02	; 2
    355e:	cc 24       	eor	r12, r12
    3560:	c3 94       	inc	r12
    3562:	00 e6       	ldi	r16, 0x60	; 96
    3564:	16 e0       	ldi	r17, 0x06	; 6
    3566:	68 94       	set
    3568:	dd 24       	eor	r13, r13
    356a:	d4 f8       	bld	r13, 4
    356c:	ee 24       	eor	r14, r14
    356e:	e3 94       	inc	r14
    3570:	f1 2c       	mov	r15, r1
    3572:	ce 01       	movw	r24, r28
    3574:	0e 94 46 07 	call	0xe8c	; 0xe8c <adc_enable>
    3578:	9f b7       	in	r25, 0x3f	; 63
    357a:	f8 94       	cli
    357c:	88 81       	ld	r24, Y
    357e:	84 60       	ori	r24, 0x04	; 4
    3580:	88 83       	st	Y, r24
    3582:	9f bf       	out	0x3f, r25	; 63
    3584:	9e 81       	ldd	r25, Y+6	; 0x06
    3586:	90 ff       	sbrs	r25, 0
    3588:	fd cf       	rjmp	.-6      	; 0x3584 <testPotentio+0x2a>
    358a:	ce 82       	std	Y+6, r12	; 0x06
    358c:	8c a1       	ldd	r24, Y+36	; 0x24
    358e:	9d a1       	ldd	r25, Y+37	; 0x25
    3590:	80 93 e4 22 	sts	0x22E4, r24	; 0x8022e4 <result>
    3594:	90 93 e5 22 	sts	0x22E5, r25	; 0x8022e5 <result+0x1>
    3598:	81 3d       	cpi	r24, 0xD1	; 209
    359a:	97 40       	sbci	r25, 0x07	; 7
    359c:	38 f4       	brcc	.+14     	; 0x35ac <testPotentio+0x52>
    359e:	f8 01       	movw	r30, r16
    35a0:	d6 82       	std	Z+6, r13	; 0x06
    35a2:	e0 92 e0 22 	sts	0x22E0, r14	; 0x8022e0 <potensiotest>
    35a6:	f0 92 e1 22 	sts	0x22E1, r15	; 0x8022e1 <potensiotest+0x1>
    35aa:	06 c0       	rjmp	.+12     	; 0x35b8 <testPotentio+0x5e>
    35ac:	f8 01       	movw	r30, r16
    35ae:	d5 82       	std	Z+5, r13	; 0x05
    35b0:	10 92 e0 22 	sts	0x22E0, r1	; 0x8022e0 <potensiotest>
    35b4:	10 92 e1 22 	sts	0x22E1, r1	; 0x8022e1 <potensiotest+0x1>
    35b8:	85 e0       	ldi	r24, 0x05	; 5
    35ba:	90 e0       	ldi	r25, 0x00	; 0
    35bc:	7b da       	rcall	.-2826   	; 0x2ab4 <vTaskDelay>
    35be:	d9 cf       	rjmp	.-78     	; 0x3572 <testPotentio+0x18>

000035c0 <PWM_Init>:
    35c0:	e0 e4       	ldi	r30, 0x40	; 64
    35c2:	f6 e0       	ldi	r31, 0x06	; 6
    35c4:	80 81       	ld	r24, Z
    35c6:	81 60       	ori	r24, 0x01	; 1
    35c8:	80 83       	st	Z, r24
    35ca:	e0 e0       	ldi	r30, 0x00	; 0
    35cc:	f8 e0       	ldi	r31, 0x08	; 8
    35ce:	85 e0       	ldi	r24, 0x05	; 5
    35d0:	80 83       	st	Z, r24
    35d2:	86 e1       	ldi	r24, 0x16	; 22
    35d4:	81 83       	std	Z+1, r24	; 0x01
    35d6:	88 ee       	ldi	r24, 0xE8	; 232
    35d8:	93 e0       	ldi	r25, 0x03	; 3
    35da:	86 a3       	std	Z+38, r24	; 0x26
    35dc:	97 a3       	std	Z+39, r25	; 0x27
    35de:	87 e7       	ldi	r24, 0x77	; 119
    35e0:	91 e0       	ldi	r25, 0x01	; 1
    35e2:	80 a7       	std	Z+40, r24	; 0x28
    35e4:	91 a7       	std	Z+41, r25	; 0x29
    35e6:	08 95       	ret

000035e8 <testServo>:
    35e8:	eb df       	rcall	.-42     	; 0x35c0 <PWM_Init>
    35ea:	c0 ea       	ldi	r28, 0xA0	; 160
    35ec:	d6 e0       	ldi	r29, 0x06	; 6
    35ee:	00 e0       	ldi	r16, 0x00	; 0
    35f0:	18 e0       	ldi	r17, 0x08	; 8
    35f2:	0f 2e       	mov	r0, r31
    35f4:	f7 e7       	ldi	r31, 0x77	; 119
    35f6:	8f 2e       	mov	r8, r31
    35f8:	99 24       	eor	r9, r9
    35fa:	93 94       	inc	r9
    35fc:	f0 2d       	mov	r31, r0
    35fe:	cc 24       	eor	r12, r12
    3600:	c3 94       	inc	r12
    3602:	d1 2c       	mov	r13, r1
    3604:	0f 2e       	mov	r0, r31
    3606:	f0 ee       	ldi	r31, 0xE0	; 224
    3608:	ef 2e       	mov	r14, r31
    360a:	f7 e0       	ldi	r31, 0x07	; 7
    360c:	ff 2e       	mov	r15, r31
    360e:	f0 2d       	mov	r31, r0
    3610:	77 24       	eor	r7, r7
    3612:	73 94       	inc	r7
    3614:	0f 2e       	mov	r0, r31
    3616:	f6 e9       	ldi	r31, 0x96	; 150
    3618:	af 2e       	mov	r10, r31
    361a:	b1 2c       	mov	r11, r1
    361c:	f0 2d       	mov	r31, r0
    361e:	88 85       	ldd	r24, Y+8	; 0x08
    3620:	81 fd       	sbrc	r24, 1
    3622:	0a c0       	rjmp	.+20     	; 0x3638 <testServo+0x50>
    3624:	f8 01       	movw	r30, r16
    3626:	a0 a6       	std	Z+40, r10	; 0x28
    3628:	b1 a6       	std	Z+41, r11	; 0x29
    362a:	f7 01       	movw	r30, r14
    362c:	76 82       	std	Z+6, r7	; 0x06
    362e:	c0 92 de 22 	sts	0x22DE, r12	; 0x8022de <servotest>
    3632:	d0 92 df 22 	sts	0x22DF, r13	; 0x8022df <servotest+0x1>
    3636:	10 c0       	rjmp	.+32     	; 0x3658 <testServo+0x70>
    3638:	88 85       	ldd	r24, Y+8	; 0x08
    363a:	82 fd       	sbrc	r24, 2
    363c:	0a c0       	rjmp	.+20     	; 0x3652 <testServo+0x6a>
    363e:	f8 01       	movw	r30, r16
    3640:	c0 a6       	std	Z+40, r12	; 0x28
    3642:	d1 a6       	std	Z+41, r13	; 0x29
    3644:	f7 01       	movw	r30, r14
    3646:	75 82       	std	Z+5, r7	; 0x05
    3648:	10 92 de 22 	sts	0x22DE, r1	; 0x8022de <servotest>
    364c:	10 92 df 22 	sts	0x22DF, r1	; 0x8022df <servotest+0x1>
    3650:	03 c0       	rjmp	.+6      	; 0x3658 <testServo+0x70>
    3652:	f8 01       	movw	r30, r16
    3654:	80 a6       	std	Z+40, r8	; 0x28
    3656:	91 a6       	std	Z+41, r9	; 0x29
    3658:	85 e0       	ldi	r24, 0x05	; 5
    365a:	90 e0       	ldi	r25, 0x00	; 0
    365c:	2b da       	rcall	.-2986   	; 0x2ab4 <vTaskDelay>
    365e:	df cf       	rjmp	.-66     	; 0x361e <testServo+0x36>

00003660 <setUpSerial>:
    3660:	10 92 a7 08 	sts	0x08A7, r1	; 0x8008a7 <__TEXT_REGION_LENGTH__+0x7008a7>
    3664:	8c e0       	ldi	r24, 0x0C	; 12
    3666:	80 93 a6 08 	sts	0x08A6, r24	; 0x8008a6 <__TEXT_REGION_LENGTH__+0x7008a6>
    366a:	10 92 a3 08 	sts	0x08A3, r1	; 0x8008a3 <__TEXT_REGION_LENGTH__+0x7008a3>
    366e:	83 e0       	ldi	r24, 0x03	; 3
    3670:	80 93 a5 08 	sts	0x08A5, r24	; 0x8008a5 <__TEXT_REGION_LENGTH__+0x7008a5>
    3674:	88 e1       	ldi	r24, 0x18	; 24
    3676:	80 93 a4 08 	sts	0x08A4, r24	; 0x8008a4 <__TEXT_REGION_LENGTH__+0x7008a4>
    367a:	08 95       	ret

0000367c <main>:

int main (void)
{
    367c:	8f 92       	push	r8
    367e:	9f 92       	push	r9
    3680:	af 92       	push	r10
    3682:	bf 92       	push	r11
    3684:	cf 92       	push	r12
    3686:	df 92       	push	r13
    3688:	ef 92       	push	r14
    368a:	ff 92       	push	r15
    368c:	0f 93       	push	r16
    368e:	1f 93       	push	r17
    3690:	cf 93       	push	r28
    3692:	df 93       	push	r29
    3694:	cd b7       	in	r28, 0x3d	; 61
    3696:	de b7       	in	r29, 0x3e	; 62
    3698:	2b 97       	sbiw	r28, 0x0b	; 11
    369a:	cd bf       	out	0x3d, r28	; 61
    369c:	de bf       	out	0x3e, r29	; 62
	// Insert system clock initialization code here (sysclk_init()).

	
	board_init();
    369e:	c7 dd       	rcall	.-1138   	; 0x322e <board_init>
 * Enables all interrupt levels, with vectors located in the application section
 * and fixed priority scheduling.
 */
static inline void pmic_init(void)
{
	PMIC.CTRL = PMIC_LVL_LOW | PMIC_LVL_MEDIUM |
    36a0:	87 e0       	ldi	r24, 0x07	; 7
    36a2:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
static void adc_init(void)
{
	struct adc_config adc_conf;
	struct adc_channel_config adcch_conf;

	adc_read_configuration(&MY_ADC, &adc_conf);
    36a6:	be 01       	movw	r22, r28
    36a8:	6f 5f       	subi	r22, 0xFF	; 255
    36aa:	7f 4f       	sbci	r23, 0xFF	; 255
    36ac:	80 e0       	ldi	r24, 0x00	; 0
    36ae:	92 e0       	ldi	r25, 0x02	; 2
    36b0:	0e 94 3d 09 	call	0x127a	; 0x127a <adc_read_configuration>
	adcch_read_configuration(&MY_ADC, MY_ADC_CH, &adcch_conf);
    36b4:	ae 01       	movw	r20, r28
    36b6:	48 5f       	subi	r20, 0xF8	; 248
    36b8:	5f 4f       	sbci	r21, 0xFF	; 255
    36ba:	61 e0       	ldi	r22, 0x01	; 1
    36bc:	80 e0       	ldi	r24, 0x00	; 0
    36be:	92 e0       	ldi	r25, 0x02	; 2
    36c0:	0e 94 99 09 	call	0x1332	; 0x1332 <adcch_read_configuration>
static inline void adc_set_conversion_parameters(struct adc_config *conf,
		enum adc_sign sign, enum adc_resolution res,
		enum adc_reference ref)
{
	/* Preserve all but conversion and resolution config. */
	conf->ctrlb &= ~(ADC_CONMODE_bm | ADC_RESOLUTION_gm);
    36c4:	9a 81       	ldd	r25, Y+2	; 0x02
	conf->ctrlb |= (uint8_t)res | (uint8_t)sign;

	conf->refctrl &= ~ADC_REFSEL_gm;
    36c6:	8b 81       	ldd	r24, Y+3	; 0x03
    36c8:	8f 78       	andi	r24, 0x8F	; 143
	conf->refctrl |= ref;
    36ca:	80 61       	ori	r24, 0x10	; 16
    36cc:	8b 83       	std	Y+3, r24	; 0x03
	Assert(base_ev_ch <= 3);
#endif

	switch (trig) {
	case ADC_TRIG_MANUAL:
		conf->ctrlb &= ~ADC_FREERUN_bm;
    36ce:	89 2f       	mov	r24, r25
    36d0:	81 7e       	andi	r24, 0xE1	; 225
    36d2:	8a 83       	std	Y+2, r24	; 0x02
		conf->evctrl = ADC_EVACT_NONE_gc;
    36d4:	1c 82       	std	Y+4, r1	; 0x04
		psc = ADC_PRESCALER_DIV256_gc;
	} else {
		psc = ADC_PRESCALER_DIV512_gc;
	}

	conf->prescaler = psc;
    36d6:	02 e0       	ldi	r16, 0x02	; 2
    36d8:	0d 83       	std	Y+5, r16	; 0x05
				ADC_CH_MUXPOS_gp;
	} else if (neg == ADCCH_NEG_NONE) {
		/* Configure for single-ended measurement. */
		Assert(gain == 1);

		ch_conf->ctrl = ADC_CH_INPUTMODE_SINGLEENDED_gc;
    36da:	11 e0       	ldi	r17, 0x01	; 1
    36dc:	18 87       	std	Y+8, r17	; 0x08
		ch_conf->muxctrl = pos << ADC_CH_MUXPOS_gp;
    36de:	80 e4       	ldi	r24, 0x40	; 64
    36e0:	89 87       	std	Y+9, r24	; 0x09
	adc_set_conversion_trigger(&adc_conf, ADC_TRIG_MANUAL, 1, 0);
	adc_set_clock_rate(&adc_conf, 200000UL);

	adcch_set_input(&adcch_conf, J2_PIN0, ADCCH_NEG_NONE, 1);

	adc_write_configuration(&MY_ADC, &adc_conf);
    36e2:	be 01       	movw	r22, r28
    36e4:	6f 5f       	subi	r22, 0xFF	; 255
    36e6:	7f 4f       	sbci	r23, 0xFF	; 255
    36e8:	80 e0       	ldi	r24, 0x00	; 0
    36ea:	92 e0       	ldi	r25, 0x02	; 2
    36ec:	0e 94 ed 08 	call	0x11da	; 0x11da <adc_write_configuration>
	adcch_write_configuration(&MY_ADC, MY_ADC_CH, &adcch_conf);
    36f0:	ae 01       	movw	r20, r28
    36f2:	48 5f       	subi	r20, 0xF8	; 248
    36f4:	5f 4f       	sbci	r21, 0xFF	; 255
    36f6:	61 e0       	ldi	r22, 0x01	; 1
    36f8:	80 e0       	ldi	r24, 0x00	; 0
    36fa:	92 e0       	ldi	r25, 0x02	; 2
    36fc:	0e 94 60 09 	call	0x12c0	; 0x12c0 <adcch_write_configuration>
static void adc_init2(void)
{
	struct adc_config adc_conf;
	struct adc_channel_config adcch_conf;

	adc_read_configuration(&MY_ADC2, &adc_conf);
    3700:	be 01       	movw	r22, r28
    3702:	6f 5f       	subi	r22, 0xFF	; 255
    3704:	7f 4f       	sbci	r23, 0xFF	; 255
    3706:	80 e0       	ldi	r24, 0x00	; 0
    3708:	92 e0       	ldi	r25, 0x02	; 2
    370a:	0e 94 3d 09 	call	0x127a	; 0x127a <adc_read_configuration>
	adcch_read_configuration(&MY_ADC2, MY_ADC2_CH, &adcch_conf);
    370e:	ae 01       	movw	r20, r28
    3710:	48 5f       	subi	r20, 0xF8	; 248
    3712:	5f 4f       	sbci	r21, 0xFF	; 255
    3714:	62 e0       	ldi	r22, 0x02	; 2
    3716:	80 e0       	ldi	r24, 0x00	; 0
    3718:	92 e0       	ldi	r25, 0x02	; 2
    371a:	0e 94 99 09 	call	0x1332	; 0x1332 <adcch_read_configuration>
static inline void adc_set_conversion_parameters(struct adc_config *conf,
		enum adc_sign sign, enum adc_resolution res,
		enum adc_reference ref)
{
	/* Preserve all but conversion and resolution config. */
	conf->ctrlb &= ~(ADC_CONMODE_bm | ADC_RESOLUTION_gm);
    371e:	9a 81       	ldd	r25, Y+2	; 0x02
	conf->ctrlb |= (uint8_t)res | (uint8_t)sign;

	conf->refctrl &= ~ADC_REFSEL_gm;
    3720:	8b 81       	ldd	r24, Y+3	; 0x03
    3722:	8f 78       	andi	r24, 0x8F	; 143
	conf->refctrl |= ref;
    3724:	80 61       	ori	r24, 0x10	; 16
    3726:	8b 83       	std	Y+3, r24	; 0x03
	Assert(base_ev_ch <= 3);
#endif

	switch (trig) {
	case ADC_TRIG_MANUAL:
		conf->ctrlb &= ~ADC_FREERUN_bm;
    3728:	89 2f       	mov	r24, r25
    372a:	81 7e       	andi	r24, 0xE1	; 225
    372c:	8a 83       	std	Y+2, r24	; 0x02
		conf->evctrl = ADC_EVACT_NONE_gc;
    372e:	1c 82       	std	Y+4, r1	; 0x04
		psc = ADC_PRESCALER_DIV256_gc;
	} else {
		psc = ADC_PRESCALER_DIV512_gc;
	}

	conf->prescaler = psc;
    3730:	0d 83       	std	Y+5, r16	; 0x05
				ADC_CH_MUXPOS_gp;
	} else if (neg == ADCCH_NEG_NONE) {
		/* Configure for single-ended measurement. */
		Assert(gain == 1);

		ch_conf->ctrl = ADC_CH_INPUTMODE_SINGLEENDED_gc;
    3732:	18 87       	std	Y+8, r17	; 0x08
		ch_conf->muxctrl = pos << ADC_CH_MUXPOS_gp;
    3734:	19 86       	std	Y+9, r1	; 0x09
	adc_set_conversion_trigger(&adc_conf, ADC_TRIG_MANUAL, 1, 0);
	adc_set_clock_rate(&adc_conf, 200000UL);

	adcch_set_input(&adcch_conf, J3_PIN0, ADCCH_NEG_NONE, 1);

	adc_write_configuration(&MY_ADC2, &adc_conf);
    3736:	be 01       	movw	r22, r28
    3738:	6f 5f       	subi	r22, 0xFF	; 255
    373a:	7f 4f       	sbci	r23, 0xFF	; 255
    373c:	80 e0       	ldi	r24, 0x00	; 0
    373e:	92 e0       	ldi	r25, 0x02	; 2
    3740:	0e 94 ed 08 	call	0x11da	; 0x11da <adc_write_configuration>
	adcch_write_configuration(&MY_ADC2, MY_ADC2_CH, &adcch_conf);
    3744:	ae 01       	movw	r20, r28
    3746:	48 5f       	subi	r20, 0xF8	; 248
    3748:	5f 4f       	sbci	r21, 0xFF	; 255
    374a:	62 e0       	ldi	r22, 0x02	; 2
    374c:	80 e0       	ldi	r24, 0x00	; 0
    374e:	92 e0       	ldi	r25, 0x02	; 2
    3750:	0e 94 60 09 	call	0x12c0	; 0x12c0 <adcch_write_configuration>
	board_init();
	
	pmic_init();
	adc_init();
	adc_init2();
	gfx_mono_init();
    3754:	0e 94 e7 04 	call	0x9ce	; 0x9ce <gfx_mono_st7565r_init>
    3758:	80 e1       	ldi	r24, 0x10	; 16
    375a:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
	ioport_set_pin_level(LCD_BACKLIGHT_ENABLE_PIN, 1);
	PORTC_OUTSET = PIN3_bm; // PC3 as TX
    375e:	88 e0       	ldi	r24, 0x08	; 8
    3760:	80 93 45 06 	sts	0x0645, r24	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>
	PORTC_DIRSET = PIN3_bm; //TX pin as output
    3764:	80 93 41 06 	sts	0x0641, r24	; 0x800641 <__TEXT_REGION_LENGTH__+0x700641>
	setUpSerial();
    3768:	7b df       	rcall	.-266    	; 0x3660 <setUpSerial>
		.baudrate = USART_SERIAL_EXAMPLE_BAUDRATE,
		.charlength = USART_SERIAL_CHAR_LENGTH,
		.paritytype = USART_SERIAL_PARITY,
		.stopbits = USART_SERIAL_STOP_BIT
	};
	usart_init_rs232(USART_SERIAL_EXAMPLE, &USART_SERIAL_OPTIONS);
    376a:	6d e0       	ldi	r22, 0x0D	; 13
    376c:	70 e2       	ldi	r23, 0x20	; 32
    376e:	80 ea       	ldi	r24, 0xA0	; 160
    3770:	98 e0       	ldi	r25, 0x08	; 8
    3772:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <usart_init_rs232>
	
	TimerHandle_t timerPing = xTimerCreate("tPing", 2/portTICK_PERIOD_MS, pdTRUE, (void *) 0, vTimerCallback);
    3776:	04 eb       	ldi	r16, 0xB4	; 180
    3778:	19 e1       	ldi	r17, 0x19	; 25
    377a:	20 e0       	ldi	r18, 0x00	; 0
    377c:	30 e0       	ldi	r19, 0x00	; 0
    377e:	41 e0       	ldi	r20, 0x01	; 1
    3780:	61 e0       	ldi	r22, 0x01	; 1
    3782:	70 e0       	ldi	r23, 0x00	; 0
    3784:	88 e5       	ldi	r24, 0x58	; 88
    3786:	90 e2       	ldi	r25, 0x20	; 32
    3788:	67 db       	rcall	.-2354   	; 0x2e58 <xTimerCreate>
    378a:	4c 01       	movw	r8, r24
	
	xTaskCreate(testPotentio,"",500,NULL,1,NULL);
    378c:	a1 2c       	mov	r10, r1
    378e:	b1 2c       	mov	r11, r1
    3790:	c1 2c       	mov	r12, r1
    3792:	d1 2c       	mov	r13, r1
    3794:	e1 2c       	mov	r14, r1
    3796:	f1 2c       	mov	r15, r1
    3798:	01 e0       	ldi	r16, 0x01	; 1
    379a:	20 e0       	ldi	r18, 0x00	; 0
    379c:	30 e0       	ldi	r19, 0x00	; 0
    379e:	44 ef       	ldi	r20, 0xF4	; 244
    37a0:	51 e0       	ldi	r21, 0x01	; 1
    37a2:	68 e1       	ldi	r22, 0x18	; 24
    37a4:	70 e2       	ldi	r23, 0x20	; 32
    37a6:	8d ea       	ldi	r24, 0xAD	; 173
    37a8:	9a e1       	ldi	r25, 0x1A	; 26
    37aa:	0e 94 c6 12 	call	0x258c	; 0x258c <xTaskGenericCreate>
	xTaskCreate(testServo,"",500,NULL,1,NULL);
    37ae:	20 e0       	ldi	r18, 0x00	; 0
    37b0:	30 e0       	ldi	r19, 0x00	; 0
    37b2:	44 ef       	ldi	r20, 0xF4	; 244
    37b4:	51 e0       	ldi	r21, 0x01	; 1
    37b6:	68 e1       	ldi	r22, 0x18	; 24
    37b8:	70 e2       	ldi	r23, 0x20	; 32
    37ba:	84 ef       	ldi	r24, 0xF4	; 244
    37bc:	9a e1       	ldi	r25, 0x1A	; 26
    37be:	0e 94 c6 12 	call	0x258c	; 0x258c <xTaskGenericCreate>
	xTaskCreate(testQtouch,"",500,NULL,1,NULL);
    37c2:	20 e0       	ldi	r18, 0x00	; 0
    37c4:	30 e0       	ldi	r19, 0x00	; 0
    37c6:	44 ef       	ldi	r20, 0xF4	; 244
    37c8:	51 e0       	ldi	r21, 0x01	; 1
    37ca:	68 e1       	ldi	r22, 0x18	; 24
    37cc:	70 e2       	ldi	r23, 0x20	; 32
    37ce:	86 ef       	ldi	r24, 0xF6	; 246
    37d0:	99 e1       	ldi	r25, 0x19	; 25
    37d2:	0e 94 c6 12 	call	0x258c	; 0x258c <xTaskGenericCreate>
	xTaskCreate(testLight,"",500,NULL,1,NULL);
    37d6:	20 e0       	ldi	r18, 0x00	; 0
    37d8:	30 e0       	ldi	r19, 0x00	; 0
    37da:	44 ef       	ldi	r20, 0xF4	; 244
    37dc:	51 e0       	ldi	r21, 0x01	; 1
    37de:	68 e1       	ldi	r22, 0x18	; 24
    37e0:	70 e2       	ldi	r23, 0x20	; 32
    37e2:	8e e8       	ldi	r24, 0x8E	; 142
    37e4:	9a e1       	ldi	r25, 0x1A	; 26
    37e6:	0e 94 c6 12 	call	0x258c	; 0x258c <xTaskGenericCreate>
	//xTaskCreate(testUsart,"",500,NULL,1,NULL);
	//xTaskCreate(testHeap,"",500,NULL,1,NULL);
	xTaskCreate(testLCD,"",500,NULL,1,NULL);
    37ea:	20 e0       	ldi	r18, 0x00	; 0
    37ec:	30 e0       	ldi	r19, 0x00	; 0
    37ee:	44 ef       	ldi	r20, 0xF4	; 244
    37f0:	51 e0       	ldi	r21, 0x01	; 1
    37f2:	68 e1       	ldi	r22, 0x18	; 24
    37f4:	70 e2       	ldi	r23, 0x20	; 32
    37f6:	87 e1       	ldi	r24, 0x17	; 23
    37f8:	9a e1       	ldi	r25, 0x1A	; 26
    37fa:	0e 94 c6 12 	call	0x258c	; 0x258c <xTaskGenericCreate>
	xTaskCreate(resetAll,"",500,NULL,1,NULL);
    37fe:	20 e0       	ldi	r18, 0x00	; 0
    3800:	30 e0       	ldi	r19, 0x00	; 0
    3802:	44 ef       	ldi	r20, 0xF4	; 244
    3804:	51 e0       	ldi	r21, 0x01	; 1
    3806:	68 e1       	ldi	r22, 0x18	; 24
    3808:	70 e2       	ldi	r23, 0x20	; 32
    380a:	88 ec       	ldi	r24, 0xC8	; 200
    380c:	99 e1       	ldi	r25, 0x19	; 25
    380e:	0e 94 c6 12 	call	0x258c	; 0x258c <xTaskGenericCreate>
		
	xTimerStart(timerPing, 0);
    3812:	0e 94 00 14 	call	0x2800	; 0x2800 <xTaskGetTickCount>
    3816:	00 e0       	ldi	r16, 0x00	; 0
    3818:	10 e0       	ldi	r17, 0x00	; 0
    381a:	20 e0       	ldi	r18, 0x00	; 0
    381c:	30 e0       	ldi	r19, 0x00	; 0
    381e:	ac 01       	movw	r20, r24
    3820:	61 e0       	ldi	r22, 0x01	; 1
    3822:	c4 01       	movw	r24, r8
    3824:	4f db       	rcall	.-2402   	; 0x2ec4 <xTimerGenericCommand>
	
	vTaskStartScheduler();
    3826:	0e 94 c7 13 	call	0x278e	; 0x278e <vTaskStartScheduler>

	// Insert application code here, after the board has been initialized.
}
    382a:	80 e0       	ldi	r24, 0x00	; 0
    382c:	90 e0       	ldi	r25, 0x00	; 0
    382e:	2b 96       	adiw	r28, 0x0b	; 11
    3830:	cd bf       	out	0x3d, r28	; 61
    3832:	de bf       	out	0x3e, r29	; 62
    3834:	df 91       	pop	r29
    3836:	cf 91       	pop	r28
    3838:	1f 91       	pop	r17
    383a:	0f 91       	pop	r16
    383c:	ff 90       	pop	r15
    383e:	ef 90       	pop	r14
    3840:	df 90       	pop	r13
    3842:	cf 90       	pop	r12
    3844:	bf 90       	pop	r11
    3846:	af 90       	pop	r10
    3848:	9f 90       	pop	r9
    384a:	8f 90       	pop	r8
    384c:	08 95       	ret

0000384e <__udivmodsi4>:
    384e:	a1 e2       	ldi	r26, 0x21	; 33
    3850:	1a 2e       	mov	r1, r26
    3852:	aa 1b       	sub	r26, r26
    3854:	bb 1b       	sub	r27, r27
    3856:	fd 01       	movw	r30, r26
    3858:	0d c0       	rjmp	.+26     	; 0x3874 <__udivmodsi4_ep>

0000385a <__udivmodsi4_loop>:
    385a:	aa 1f       	adc	r26, r26
    385c:	bb 1f       	adc	r27, r27
    385e:	ee 1f       	adc	r30, r30
    3860:	ff 1f       	adc	r31, r31
    3862:	a2 17       	cp	r26, r18
    3864:	b3 07       	cpc	r27, r19
    3866:	e4 07       	cpc	r30, r20
    3868:	f5 07       	cpc	r31, r21
    386a:	20 f0       	brcs	.+8      	; 0x3874 <__udivmodsi4_ep>
    386c:	a2 1b       	sub	r26, r18
    386e:	b3 0b       	sbc	r27, r19
    3870:	e4 0b       	sbc	r30, r20
    3872:	f5 0b       	sbc	r31, r21

00003874 <__udivmodsi4_ep>:
    3874:	66 1f       	adc	r22, r22
    3876:	77 1f       	adc	r23, r23
    3878:	88 1f       	adc	r24, r24
    387a:	99 1f       	adc	r25, r25
    387c:	1a 94       	dec	r1
    387e:	69 f7       	brne	.-38     	; 0x385a <__udivmodsi4_loop>
    3880:	60 95       	com	r22
    3882:	70 95       	com	r23
    3884:	80 95       	com	r24
    3886:	90 95       	com	r25
    3888:	9b 01       	movw	r18, r22
    388a:	ac 01       	movw	r20, r24
    388c:	bd 01       	movw	r22, r26
    388e:	cf 01       	movw	r24, r30
    3890:	08 95       	ret

00003892 <__tablejump2__>:
    3892:	ee 0f       	add	r30, r30
    3894:	ff 1f       	adc	r31, r31
    3896:	88 1f       	adc	r24, r24
    3898:	8b bf       	out	0x3b, r24	; 59
    389a:	07 90       	elpm	r0, Z+
    389c:	f6 91       	elpm	r31, Z
    389e:	e0 2d       	mov	r30, r0
    38a0:	19 94       	eijmp

000038a2 <malloc>:
    38a2:	cf 93       	push	r28
    38a4:	df 93       	push	r29
    38a6:	82 30       	cpi	r24, 0x02	; 2
    38a8:	91 05       	cpc	r25, r1
    38aa:	10 f4       	brcc	.+4      	; 0x38b0 <malloc+0xe>
    38ac:	82 e0       	ldi	r24, 0x02	; 2
    38ae:	90 e0       	ldi	r25, 0x00	; 0
    38b0:	e0 91 bb 23 	lds	r30, 0x23BB	; 0x8023bb <__flp>
    38b4:	f0 91 bc 23 	lds	r31, 0x23BC	; 0x8023bc <__flp+0x1>
    38b8:	20 e0       	ldi	r18, 0x00	; 0
    38ba:	30 e0       	ldi	r19, 0x00	; 0
    38bc:	c0 e0       	ldi	r28, 0x00	; 0
    38be:	d0 e0       	ldi	r29, 0x00	; 0
    38c0:	30 97       	sbiw	r30, 0x00	; 0
    38c2:	11 f1       	breq	.+68     	; 0x3908 <malloc+0x66>
    38c4:	40 81       	ld	r20, Z
    38c6:	51 81       	ldd	r21, Z+1	; 0x01
    38c8:	48 17       	cp	r20, r24
    38ca:	59 07       	cpc	r21, r25
    38cc:	c0 f0       	brcs	.+48     	; 0x38fe <malloc+0x5c>
    38ce:	48 17       	cp	r20, r24
    38d0:	59 07       	cpc	r21, r25
    38d2:	61 f4       	brne	.+24     	; 0x38ec <malloc+0x4a>
    38d4:	82 81       	ldd	r24, Z+2	; 0x02
    38d6:	93 81       	ldd	r25, Z+3	; 0x03
    38d8:	20 97       	sbiw	r28, 0x00	; 0
    38da:	19 f0       	breq	.+6      	; 0x38e2 <malloc+0x40>
    38dc:	8a 83       	std	Y+2, r24	; 0x02
    38de:	9b 83       	std	Y+3, r25	; 0x03
    38e0:	2b c0       	rjmp	.+86     	; 0x3938 <malloc+0x96>
    38e2:	80 93 bb 23 	sts	0x23BB, r24	; 0x8023bb <__flp>
    38e6:	90 93 bc 23 	sts	0x23BC, r25	; 0x8023bc <__flp+0x1>
    38ea:	26 c0       	rjmp	.+76     	; 0x3938 <malloc+0x96>
    38ec:	21 15       	cp	r18, r1
    38ee:	31 05       	cpc	r19, r1
    38f0:	19 f0       	breq	.+6      	; 0x38f8 <malloc+0x56>
    38f2:	42 17       	cp	r20, r18
    38f4:	53 07       	cpc	r21, r19
    38f6:	18 f4       	brcc	.+6      	; 0x38fe <malloc+0x5c>
    38f8:	9a 01       	movw	r18, r20
    38fa:	be 01       	movw	r22, r28
    38fc:	df 01       	movw	r26, r30
    38fe:	ef 01       	movw	r28, r30
    3900:	02 80       	ldd	r0, Z+2	; 0x02
    3902:	f3 81       	ldd	r31, Z+3	; 0x03
    3904:	e0 2d       	mov	r30, r0
    3906:	dc cf       	rjmp	.-72     	; 0x38c0 <malloc+0x1e>
    3908:	21 15       	cp	r18, r1
    390a:	31 05       	cpc	r19, r1
    390c:	09 f1       	breq	.+66     	; 0x3950 <malloc+0xae>
    390e:	28 1b       	sub	r18, r24
    3910:	39 0b       	sbc	r19, r25
    3912:	24 30       	cpi	r18, 0x04	; 4
    3914:	31 05       	cpc	r19, r1
    3916:	90 f4       	brcc	.+36     	; 0x393c <malloc+0x9a>
    3918:	12 96       	adiw	r26, 0x02	; 2
    391a:	8d 91       	ld	r24, X+
    391c:	9c 91       	ld	r25, X
    391e:	13 97       	sbiw	r26, 0x03	; 3
    3920:	61 15       	cp	r22, r1
    3922:	71 05       	cpc	r23, r1
    3924:	21 f0       	breq	.+8      	; 0x392e <malloc+0x8c>
    3926:	fb 01       	movw	r30, r22
    3928:	82 83       	std	Z+2, r24	; 0x02
    392a:	93 83       	std	Z+3, r25	; 0x03
    392c:	04 c0       	rjmp	.+8      	; 0x3936 <malloc+0x94>
    392e:	80 93 bb 23 	sts	0x23BB, r24	; 0x8023bb <__flp>
    3932:	90 93 bc 23 	sts	0x23BC, r25	; 0x8023bc <__flp+0x1>
    3936:	fd 01       	movw	r30, r26
    3938:	32 96       	adiw	r30, 0x02	; 2
    393a:	44 c0       	rjmp	.+136    	; 0x39c4 <malloc+0x122>
    393c:	fd 01       	movw	r30, r26
    393e:	e2 0f       	add	r30, r18
    3940:	f3 1f       	adc	r31, r19
    3942:	81 93       	st	Z+, r24
    3944:	91 93       	st	Z+, r25
    3946:	22 50       	subi	r18, 0x02	; 2
    3948:	31 09       	sbc	r19, r1
    394a:	2d 93       	st	X+, r18
    394c:	3c 93       	st	X, r19
    394e:	3a c0       	rjmp	.+116    	; 0x39c4 <malloc+0x122>
    3950:	20 91 b9 23 	lds	r18, 0x23B9	; 0x8023b9 <__brkval>
    3954:	30 91 ba 23 	lds	r19, 0x23BA	; 0x8023ba <__brkval+0x1>
    3958:	23 2b       	or	r18, r19
    395a:	41 f4       	brne	.+16     	; 0x396c <malloc+0xca>
    395c:	20 91 02 20 	lds	r18, 0x2002	; 0x802002 <__malloc_heap_start>
    3960:	30 91 03 20 	lds	r19, 0x2003	; 0x802003 <__malloc_heap_start+0x1>
    3964:	20 93 b9 23 	sts	0x23B9, r18	; 0x8023b9 <__brkval>
    3968:	30 93 ba 23 	sts	0x23BA, r19	; 0x8023ba <__brkval+0x1>
    396c:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    3970:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    3974:	21 15       	cp	r18, r1
    3976:	31 05       	cpc	r19, r1
    3978:	41 f4       	brne	.+16     	; 0x398a <malloc+0xe8>
    397a:	2d b7       	in	r18, 0x3d	; 61
    397c:	3e b7       	in	r19, 0x3e	; 62
    397e:	40 91 04 20 	lds	r20, 0x2004	; 0x802004 <__malloc_margin>
    3982:	50 91 05 20 	lds	r21, 0x2005	; 0x802005 <__malloc_margin+0x1>
    3986:	24 1b       	sub	r18, r20
    3988:	35 0b       	sbc	r19, r21
    398a:	e0 91 b9 23 	lds	r30, 0x23B9	; 0x8023b9 <__brkval>
    398e:	f0 91 ba 23 	lds	r31, 0x23BA	; 0x8023ba <__brkval+0x1>
    3992:	e2 17       	cp	r30, r18
    3994:	f3 07       	cpc	r31, r19
    3996:	a0 f4       	brcc	.+40     	; 0x39c0 <malloc+0x11e>
    3998:	2e 1b       	sub	r18, r30
    399a:	3f 0b       	sbc	r19, r31
    399c:	28 17       	cp	r18, r24
    399e:	39 07       	cpc	r19, r25
    39a0:	78 f0       	brcs	.+30     	; 0x39c0 <malloc+0x11e>
    39a2:	ac 01       	movw	r20, r24
    39a4:	4e 5f       	subi	r20, 0xFE	; 254
    39a6:	5f 4f       	sbci	r21, 0xFF	; 255
    39a8:	24 17       	cp	r18, r20
    39aa:	35 07       	cpc	r19, r21
    39ac:	48 f0       	brcs	.+18     	; 0x39c0 <malloc+0x11e>
    39ae:	4e 0f       	add	r20, r30
    39b0:	5f 1f       	adc	r21, r31
    39b2:	40 93 b9 23 	sts	0x23B9, r20	; 0x8023b9 <__brkval>
    39b6:	50 93 ba 23 	sts	0x23BA, r21	; 0x8023ba <__brkval+0x1>
    39ba:	81 93       	st	Z+, r24
    39bc:	91 93       	st	Z+, r25
    39be:	02 c0       	rjmp	.+4      	; 0x39c4 <malloc+0x122>
    39c0:	e0 e0       	ldi	r30, 0x00	; 0
    39c2:	f0 e0       	ldi	r31, 0x00	; 0
    39c4:	cf 01       	movw	r24, r30
    39c6:	df 91       	pop	r29
    39c8:	cf 91       	pop	r28
    39ca:	08 95       	ret

000039cc <free>:
    39cc:	0f 93       	push	r16
    39ce:	1f 93       	push	r17
    39d0:	cf 93       	push	r28
    39d2:	df 93       	push	r29
    39d4:	00 97       	sbiw	r24, 0x00	; 0
    39d6:	09 f4       	brne	.+2      	; 0x39da <free+0xe>
    39d8:	8c c0       	rjmp	.+280    	; 0x3af2 <free+0x126>
    39da:	fc 01       	movw	r30, r24
    39dc:	32 97       	sbiw	r30, 0x02	; 2
    39de:	12 82       	std	Z+2, r1	; 0x02
    39e0:	13 82       	std	Z+3, r1	; 0x03
    39e2:	00 91 bb 23 	lds	r16, 0x23BB	; 0x8023bb <__flp>
    39e6:	10 91 bc 23 	lds	r17, 0x23BC	; 0x8023bc <__flp+0x1>
    39ea:	01 15       	cp	r16, r1
    39ec:	11 05       	cpc	r17, r1
    39ee:	81 f4       	brne	.+32     	; 0x3a10 <free+0x44>
    39f0:	20 81       	ld	r18, Z
    39f2:	31 81       	ldd	r19, Z+1	; 0x01
    39f4:	82 0f       	add	r24, r18
    39f6:	93 1f       	adc	r25, r19
    39f8:	20 91 b9 23 	lds	r18, 0x23B9	; 0x8023b9 <__brkval>
    39fc:	30 91 ba 23 	lds	r19, 0x23BA	; 0x8023ba <__brkval+0x1>
    3a00:	28 17       	cp	r18, r24
    3a02:	39 07       	cpc	r19, r25
    3a04:	79 f5       	brne	.+94     	; 0x3a64 <free+0x98>
    3a06:	e0 93 b9 23 	sts	0x23B9, r30	; 0x8023b9 <__brkval>
    3a0a:	f0 93 ba 23 	sts	0x23BA, r31	; 0x8023ba <__brkval+0x1>
    3a0e:	71 c0       	rjmp	.+226    	; 0x3af2 <free+0x126>
    3a10:	d8 01       	movw	r26, r16
    3a12:	40 e0       	ldi	r20, 0x00	; 0
    3a14:	50 e0       	ldi	r21, 0x00	; 0
    3a16:	ae 17       	cp	r26, r30
    3a18:	bf 07       	cpc	r27, r31
    3a1a:	50 f4       	brcc	.+20     	; 0x3a30 <free+0x64>
    3a1c:	12 96       	adiw	r26, 0x02	; 2
    3a1e:	2d 91       	ld	r18, X+
    3a20:	3c 91       	ld	r19, X
    3a22:	13 97       	sbiw	r26, 0x03	; 3
    3a24:	ad 01       	movw	r20, r26
    3a26:	21 15       	cp	r18, r1
    3a28:	31 05       	cpc	r19, r1
    3a2a:	09 f1       	breq	.+66     	; 0x3a6e <free+0xa2>
    3a2c:	d9 01       	movw	r26, r18
    3a2e:	f3 cf       	rjmp	.-26     	; 0x3a16 <free+0x4a>
    3a30:	9d 01       	movw	r18, r26
    3a32:	da 01       	movw	r26, r20
    3a34:	22 83       	std	Z+2, r18	; 0x02
    3a36:	33 83       	std	Z+3, r19	; 0x03
    3a38:	60 81       	ld	r22, Z
    3a3a:	71 81       	ldd	r23, Z+1	; 0x01
    3a3c:	86 0f       	add	r24, r22
    3a3e:	97 1f       	adc	r25, r23
    3a40:	82 17       	cp	r24, r18
    3a42:	93 07       	cpc	r25, r19
    3a44:	69 f4       	brne	.+26     	; 0x3a60 <free+0x94>
    3a46:	ec 01       	movw	r28, r24
    3a48:	28 81       	ld	r18, Y
    3a4a:	39 81       	ldd	r19, Y+1	; 0x01
    3a4c:	26 0f       	add	r18, r22
    3a4e:	37 1f       	adc	r19, r23
    3a50:	2e 5f       	subi	r18, 0xFE	; 254
    3a52:	3f 4f       	sbci	r19, 0xFF	; 255
    3a54:	20 83       	st	Z, r18
    3a56:	31 83       	std	Z+1, r19	; 0x01
    3a58:	8a 81       	ldd	r24, Y+2	; 0x02
    3a5a:	9b 81       	ldd	r25, Y+3	; 0x03
    3a5c:	82 83       	std	Z+2, r24	; 0x02
    3a5e:	93 83       	std	Z+3, r25	; 0x03
    3a60:	45 2b       	or	r20, r21
    3a62:	29 f4       	brne	.+10     	; 0x3a6e <free+0xa2>
    3a64:	e0 93 bb 23 	sts	0x23BB, r30	; 0x8023bb <__flp>
    3a68:	f0 93 bc 23 	sts	0x23BC, r31	; 0x8023bc <__flp+0x1>
    3a6c:	42 c0       	rjmp	.+132    	; 0x3af2 <free+0x126>
    3a6e:	12 96       	adiw	r26, 0x02	; 2
    3a70:	ed 93       	st	X+, r30
    3a72:	fc 93       	st	X, r31
    3a74:	13 97       	sbiw	r26, 0x03	; 3
    3a76:	ed 01       	movw	r28, r26
    3a78:	49 91       	ld	r20, Y+
    3a7a:	59 91       	ld	r21, Y+
    3a7c:	9e 01       	movw	r18, r28
    3a7e:	24 0f       	add	r18, r20
    3a80:	35 1f       	adc	r19, r21
    3a82:	e2 17       	cp	r30, r18
    3a84:	f3 07       	cpc	r31, r19
    3a86:	71 f4       	brne	.+28     	; 0x3aa4 <free+0xd8>
    3a88:	80 81       	ld	r24, Z
    3a8a:	91 81       	ldd	r25, Z+1	; 0x01
    3a8c:	84 0f       	add	r24, r20
    3a8e:	95 1f       	adc	r25, r21
    3a90:	02 96       	adiw	r24, 0x02	; 2
    3a92:	8d 93       	st	X+, r24
    3a94:	9c 93       	st	X, r25
    3a96:	11 97       	sbiw	r26, 0x01	; 1
    3a98:	82 81       	ldd	r24, Z+2	; 0x02
    3a9a:	93 81       	ldd	r25, Z+3	; 0x03
    3a9c:	12 96       	adiw	r26, 0x02	; 2
    3a9e:	8d 93       	st	X+, r24
    3aa0:	9c 93       	st	X, r25
    3aa2:	13 97       	sbiw	r26, 0x03	; 3
    3aa4:	e0 e0       	ldi	r30, 0x00	; 0
    3aa6:	f0 e0       	ldi	r31, 0x00	; 0
    3aa8:	d8 01       	movw	r26, r16
    3aaa:	12 96       	adiw	r26, 0x02	; 2
    3aac:	8d 91       	ld	r24, X+
    3aae:	9c 91       	ld	r25, X
    3ab0:	13 97       	sbiw	r26, 0x03	; 3
    3ab2:	00 97       	sbiw	r24, 0x00	; 0
    3ab4:	19 f0       	breq	.+6      	; 0x3abc <free+0xf0>
    3ab6:	f8 01       	movw	r30, r16
    3ab8:	8c 01       	movw	r16, r24
    3aba:	f6 cf       	rjmp	.-20     	; 0x3aa8 <free+0xdc>
    3abc:	8d 91       	ld	r24, X+
    3abe:	9c 91       	ld	r25, X
    3ac0:	98 01       	movw	r18, r16
    3ac2:	2e 5f       	subi	r18, 0xFE	; 254
    3ac4:	3f 4f       	sbci	r19, 0xFF	; 255
    3ac6:	82 0f       	add	r24, r18
    3ac8:	93 1f       	adc	r25, r19
    3aca:	20 91 b9 23 	lds	r18, 0x23B9	; 0x8023b9 <__brkval>
    3ace:	30 91 ba 23 	lds	r19, 0x23BA	; 0x8023ba <__brkval+0x1>
    3ad2:	28 17       	cp	r18, r24
    3ad4:	39 07       	cpc	r19, r25
    3ad6:	69 f4       	brne	.+26     	; 0x3af2 <free+0x126>
    3ad8:	30 97       	sbiw	r30, 0x00	; 0
    3ada:	29 f4       	brne	.+10     	; 0x3ae6 <free+0x11a>
    3adc:	10 92 bb 23 	sts	0x23BB, r1	; 0x8023bb <__flp>
    3ae0:	10 92 bc 23 	sts	0x23BC, r1	; 0x8023bc <__flp+0x1>
    3ae4:	02 c0       	rjmp	.+4      	; 0x3aea <free+0x11e>
    3ae6:	12 82       	std	Z+2, r1	; 0x02
    3ae8:	13 82       	std	Z+3, r1	; 0x03
    3aea:	00 93 b9 23 	sts	0x23B9, r16	; 0x8023b9 <__brkval>
    3aee:	10 93 ba 23 	sts	0x23BA, r17	; 0x8023ba <__brkval+0x1>
    3af2:	df 91       	pop	r29
    3af4:	cf 91       	pop	r28
    3af6:	1f 91       	pop	r17
    3af8:	0f 91       	pop	r16
    3afa:	08 95       	ret

00003afc <memcpy>:
    3afc:	fb 01       	movw	r30, r22
    3afe:	dc 01       	movw	r26, r24
    3b00:	02 c0       	rjmp	.+4      	; 0x3b06 <memcpy+0xa>
    3b02:	01 90       	ld	r0, Z+
    3b04:	0d 92       	st	X+, r0
    3b06:	41 50       	subi	r20, 0x01	; 1
    3b08:	50 40       	sbci	r21, 0x00	; 0
    3b0a:	d8 f7       	brcc	.-10     	; 0x3b02 <memcpy+0x6>
    3b0c:	08 95       	ret

00003b0e <snprintf>:
    3b0e:	0f 93       	push	r16
    3b10:	1f 93       	push	r17
    3b12:	cf 93       	push	r28
    3b14:	df 93       	push	r29
    3b16:	cd b7       	in	r28, 0x3d	; 61
    3b18:	de b7       	in	r29, 0x3e	; 62
    3b1a:	2e 97       	sbiw	r28, 0x0e	; 14
    3b1c:	cd bf       	out	0x3d, r28	; 61
    3b1e:	de bf       	out	0x3e, r29	; 62
    3b20:	0e 89       	ldd	r16, Y+22	; 0x16
    3b22:	1f 89       	ldd	r17, Y+23	; 0x17
    3b24:	88 8d       	ldd	r24, Y+24	; 0x18
    3b26:	99 8d       	ldd	r25, Y+25	; 0x19
    3b28:	26 e0       	ldi	r18, 0x06	; 6
    3b2a:	2c 83       	std	Y+4, r18	; 0x04
    3b2c:	09 83       	std	Y+1, r16	; 0x01
    3b2e:	1a 83       	std	Y+2, r17	; 0x02
    3b30:	97 ff       	sbrs	r25, 7
    3b32:	02 c0       	rjmp	.+4      	; 0x3b38 <snprintf+0x2a>
    3b34:	80 e0       	ldi	r24, 0x00	; 0
    3b36:	90 e8       	ldi	r25, 0x80	; 128
    3b38:	01 97       	sbiw	r24, 0x01	; 1
    3b3a:	8d 83       	std	Y+5, r24	; 0x05
    3b3c:	9e 83       	std	Y+6, r25	; 0x06
    3b3e:	ae 01       	movw	r20, r28
    3b40:	44 5e       	subi	r20, 0xE4	; 228
    3b42:	5f 4f       	sbci	r21, 0xFF	; 255
    3b44:	6a 8d       	ldd	r22, Y+26	; 0x1a
    3b46:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3b48:	ce 01       	movw	r24, r28
    3b4a:	01 96       	adiw	r24, 0x01	; 1
    3b4c:	16 d0       	rcall	.+44     	; 0x3b7a <vfprintf>
    3b4e:	4d 81       	ldd	r20, Y+5	; 0x05
    3b50:	5e 81       	ldd	r21, Y+6	; 0x06
    3b52:	57 fd       	sbrc	r21, 7
    3b54:	0a c0       	rjmp	.+20     	; 0x3b6a <snprintf+0x5c>
    3b56:	2f 81       	ldd	r18, Y+7	; 0x07
    3b58:	38 85       	ldd	r19, Y+8	; 0x08
    3b5a:	42 17       	cp	r20, r18
    3b5c:	53 07       	cpc	r21, r19
    3b5e:	0c f4       	brge	.+2      	; 0x3b62 <snprintf+0x54>
    3b60:	9a 01       	movw	r18, r20
    3b62:	f8 01       	movw	r30, r16
    3b64:	e2 0f       	add	r30, r18
    3b66:	f3 1f       	adc	r31, r19
    3b68:	10 82       	st	Z, r1
    3b6a:	2e 96       	adiw	r28, 0x0e	; 14
    3b6c:	cd bf       	out	0x3d, r28	; 61
    3b6e:	de bf       	out	0x3e, r29	; 62
    3b70:	df 91       	pop	r29
    3b72:	cf 91       	pop	r28
    3b74:	1f 91       	pop	r17
    3b76:	0f 91       	pop	r16
    3b78:	08 95       	ret

00003b7a <vfprintf>:
    3b7a:	2f 92       	push	r2
    3b7c:	3f 92       	push	r3
    3b7e:	4f 92       	push	r4
    3b80:	5f 92       	push	r5
    3b82:	6f 92       	push	r6
    3b84:	7f 92       	push	r7
    3b86:	8f 92       	push	r8
    3b88:	9f 92       	push	r9
    3b8a:	af 92       	push	r10
    3b8c:	bf 92       	push	r11
    3b8e:	cf 92       	push	r12
    3b90:	df 92       	push	r13
    3b92:	ef 92       	push	r14
    3b94:	ff 92       	push	r15
    3b96:	0f 93       	push	r16
    3b98:	1f 93       	push	r17
    3b9a:	cf 93       	push	r28
    3b9c:	df 93       	push	r29
    3b9e:	cd b7       	in	r28, 0x3d	; 61
    3ba0:	de b7       	in	r29, 0x3e	; 62
    3ba2:	2c 97       	sbiw	r28, 0x0c	; 12
    3ba4:	cd bf       	out	0x3d, r28	; 61
    3ba6:	de bf       	out	0x3e, r29	; 62
    3ba8:	7c 01       	movw	r14, r24
    3baa:	6b 01       	movw	r12, r22
    3bac:	8a 01       	movw	r16, r20
    3bae:	fc 01       	movw	r30, r24
    3bb0:	16 82       	std	Z+6, r1	; 0x06
    3bb2:	17 82       	std	Z+7, r1	; 0x07
    3bb4:	83 81       	ldd	r24, Z+3	; 0x03
    3bb6:	81 ff       	sbrs	r24, 1
    3bb8:	b0 c1       	rjmp	.+864    	; 0x3f1a <vfprintf+0x3a0>
    3bba:	ce 01       	movw	r24, r28
    3bbc:	01 96       	adiw	r24, 0x01	; 1
    3bbe:	4c 01       	movw	r8, r24
    3bc0:	f7 01       	movw	r30, r14
    3bc2:	93 81       	ldd	r25, Z+3	; 0x03
    3bc4:	f6 01       	movw	r30, r12
    3bc6:	93 fd       	sbrc	r25, 3
    3bc8:	85 91       	lpm	r24, Z+
    3bca:	93 ff       	sbrs	r25, 3
    3bcc:	81 91       	ld	r24, Z+
    3bce:	6f 01       	movw	r12, r30
    3bd0:	88 23       	and	r24, r24
    3bd2:	09 f4       	brne	.+2      	; 0x3bd6 <vfprintf+0x5c>
    3bd4:	9e c1       	rjmp	.+828    	; 0x3f12 <vfprintf+0x398>
    3bd6:	85 32       	cpi	r24, 0x25	; 37
    3bd8:	39 f4       	brne	.+14     	; 0x3be8 <vfprintf+0x6e>
    3bda:	93 fd       	sbrc	r25, 3
    3bdc:	85 91       	lpm	r24, Z+
    3bde:	93 ff       	sbrs	r25, 3
    3be0:	81 91       	ld	r24, Z+
    3be2:	6f 01       	movw	r12, r30
    3be4:	85 32       	cpi	r24, 0x25	; 37
    3be6:	21 f4       	brne	.+8      	; 0x3bf0 <vfprintf+0x76>
    3be8:	b7 01       	movw	r22, r14
    3bea:	90 e0       	ldi	r25, 0x00	; 0
    3bec:	c4 d1       	rcall	.+904    	; 0x3f76 <fputc>
    3bee:	e8 cf       	rjmp	.-48     	; 0x3bc0 <vfprintf+0x46>
    3bf0:	51 2c       	mov	r5, r1
    3bf2:	31 2c       	mov	r3, r1
    3bf4:	20 e0       	ldi	r18, 0x00	; 0
    3bf6:	20 32       	cpi	r18, 0x20	; 32
    3bf8:	a0 f4       	brcc	.+40     	; 0x3c22 <vfprintf+0xa8>
    3bfa:	8b 32       	cpi	r24, 0x2B	; 43
    3bfc:	69 f0       	breq	.+26     	; 0x3c18 <vfprintf+0x9e>
    3bfe:	30 f4       	brcc	.+12     	; 0x3c0c <vfprintf+0x92>
    3c00:	80 32       	cpi	r24, 0x20	; 32
    3c02:	59 f0       	breq	.+22     	; 0x3c1a <vfprintf+0xa0>
    3c04:	83 32       	cpi	r24, 0x23	; 35
    3c06:	69 f4       	brne	.+26     	; 0x3c22 <vfprintf+0xa8>
    3c08:	20 61       	ori	r18, 0x10	; 16
    3c0a:	2c c0       	rjmp	.+88     	; 0x3c64 <vfprintf+0xea>
    3c0c:	8d 32       	cpi	r24, 0x2D	; 45
    3c0e:	39 f0       	breq	.+14     	; 0x3c1e <vfprintf+0xa4>
    3c10:	80 33       	cpi	r24, 0x30	; 48
    3c12:	39 f4       	brne	.+14     	; 0x3c22 <vfprintf+0xa8>
    3c14:	21 60       	ori	r18, 0x01	; 1
    3c16:	26 c0       	rjmp	.+76     	; 0x3c64 <vfprintf+0xea>
    3c18:	22 60       	ori	r18, 0x02	; 2
    3c1a:	24 60       	ori	r18, 0x04	; 4
    3c1c:	23 c0       	rjmp	.+70     	; 0x3c64 <vfprintf+0xea>
    3c1e:	28 60       	ori	r18, 0x08	; 8
    3c20:	21 c0       	rjmp	.+66     	; 0x3c64 <vfprintf+0xea>
    3c22:	27 fd       	sbrc	r18, 7
    3c24:	27 c0       	rjmp	.+78     	; 0x3c74 <vfprintf+0xfa>
    3c26:	30 ed       	ldi	r19, 0xD0	; 208
    3c28:	38 0f       	add	r19, r24
    3c2a:	3a 30       	cpi	r19, 0x0A	; 10
    3c2c:	78 f4       	brcc	.+30     	; 0x3c4c <vfprintf+0xd2>
    3c2e:	26 ff       	sbrs	r18, 6
    3c30:	06 c0       	rjmp	.+12     	; 0x3c3e <vfprintf+0xc4>
    3c32:	fa e0       	ldi	r31, 0x0A	; 10
    3c34:	5f 9e       	mul	r5, r31
    3c36:	30 0d       	add	r19, r0
    3c38:	11 24       	eor	r1, r1
    3c3a:	53 2e       	mov	r5, r19
    3c3c:	13 c0       	rjmp	.+38     	; 0x3c64 <vfprintf+0xea>
    3c3e:	8a e0       	ldi	r24, 0x0A	; 10
    3c40:	38 9e       	mul	r3, r24
    3c42:	30 0d       	add	r19, r0
    3c44:	11 24       	eor	r1, r1
    3c46:	33 2e       	mov	r3, r19
    3c48:	20 62       	ori	r18, 0x20	; 32
    3c4a:	0c c0       	rjmp	.+24     	; 0x3c64 <vfprintf+0xea>
    3c4c:	8e 32       	cpi	r24, 0x2E	; 46
    3c4e:	21 f4       	brne	.+8      	; 0x3c58 <vfprintf+0xde>
    3c50:	26 fd       	sbrc	r18, 6
    3c52:	5f c1       	rjmp	.+702    	; 0x3f12 <vfprintf+0x398>
    3c54:	20 64       	ori	r18, 0x40	; 64
    3c56:	06 c0       	rjmp	.+12     	; 0x3c64 <vfprintf+0xea>
    3c58:	8c 36       	cpi	r24, 0x6C	; 108
    3c5a:	11 f4       	brne	.+4      	; 0x3c60 <vfprintf+0xe6>
    3c5c:	20 68       	ori	r18, 0x80	; 128
    3c5e:	02 c0       	rjmp	.+4      	; 0x3c64 <vfprintf+0xea>
    3c60:	88 36       	cpi	r24, 0x68	; 104
    3c62:	41 f4       	brne	.+16     	; 0x3c74 <vfprintf+0xfa>
    3c64:	f6 01       	movw	r30, r12
    3c66:	93 fd       	sbrc	r25, 3
    3c68:	85 91       	lpm	r24, Z+
    3c6a:	93 ff       	sbrs	r25, 3
    3c6c:	81 91       	ld	r24, Z+
    3c6e:	6f 01       	movw	r12, r30
    3c70:	81 11       	cpse	r24, r1
    3c72:	c1 cf       	rjmp	.-126    	; 0x3bf6 <vfprintf+0x7c>
    3c74:	98 2f       	mov	r25, r24
    3c76:	9f 7d       	andi	r25, 0xDF	; 223
    3c78:	95 54       	subi	r25, 0x45	; 69
    3c7a:	93 30       	cpi	r25, 0x03	; 3
    3c7c:	28 f4       	brcc	.+10     	; 0x3c88 <vfprintf+0x10e>
    3c7e:	0c 5f       	subi	r16, 0xFC	; 252
    3c80:	1f 4f       	sbci	r17, 0xFF	; 255
    3c82:	ff e3       	ldi	r31, 0x3F	; 63
    3c84:	f9 83       	std	Y+1, r31	; 0x01
    3c86:	0d c0       	rjmp	.+26     	; 0x3ca2 <vfprintf+0x128>
    3c88:	83 36       	cpi	r24, 0x63	; 99
    3c8a:	31 f0       	breq	.+12     	; 0x3c98 <vfprintf+0x11e>
    3c8c:	83 37       	cpi	r24, 0x73	; 115
    3c8e:	71 f0       	breq	.+28     	; 0x3cac <vfprintf+0x132>
    3c90:	83 35       	cpi	r24, 0x53	; 83
    3c92:	09 f0       	breq	.+2      	; 0x3c96 <vfprintf+0x11c>
    3c94:	57 c0       	rjmp	.+174    	; 0x3d44 <vfprintf+0x1ca>
    3c96:	21 c0       	rjmp	.+66     	; 0x3cda <vfprintf+0x160>
    3c98:	f8 01       	movw	r30, r16
    3c9a:	80 81       	ld	r24, Z
    3c9c:	89 83       	std	Y+1, r24	; 0x01
    3c9e:	0e 5f       	subi	r16, 0xFE	; 254
    3ca0:	1f 4f       	sbci	r17, 0xFF	; 255
    3ca2:	44 24       	eor	r4, r4
    3ca4:	43 94       	inc	r4
    3ca6:	51 2c       	mov	r5, r1
    3ca8:	54 01       	movw	r10, r8
    3caa:	14 c0       	rjmp	.+40     	; 0x3cd4 <vfprintf+0x15a>
    3cac:	38 01       	movw	r6, r16
    3cae:	f2 e0       	ldi	r31, 0x02	; 2
    3cb0:	6f 0e       	add	r6, r31
    3cb2:	71 1c       	adc	r7, r1
    3cb4:	f8 01       	movw	r30, r16
    3cb6:	a0 80       	ld	r10, Z
    3cb8:	b1 80       	ldd	r11, Z+1	; 0x01
    3cba:	26 ff       	sbrs	r18, 6
    3cbc:	03 c0       	rjmp	.+6      	; 0x3cc4 <vfprintf+0x14a>
    3cbe:	65 2d       	mov	r22, r5
    3cc0:	70 e0       	ldi	r23, 0x00	; 0
    3cc2:	02 c0       	rjmp	.+4      	; 0x3cc8 <vfprintf+0x14e>
    3cc4:	6f ef       	ldi	r22, 0xFF	; 255
    3cc6:	7f ef       	ldi	r23, 0xFF	; 255
    3cc8:	c5 01       	movw	r24, r10
    3cca:	2c 87       	std	Y+12, r18	; 0x0c
    3ccc:	49 d1       	rcall	.+658    	; 0x3f60 <strnlen>
    3cce:	2c 01       	movw	r4, r24
    3cd0:	83 01       	movw	r16, r6
    3cd2:	2c 85       	ldd	r18, Y+12	; 0x0c
    3cd4:	2f 77       	andi	r18, 0x7F	; 127
    3cd6:	22 2e       	mov	r2, r18
    3cd8:	16 c0       	rjmp	.+44     	; 0x3d06 <vfprintf+0x18c>
    3cda:	38 01       	movw	r6, r16
    3cdc:	f2 e0       	ldi	r31, 0x02	; 2
    3cde:	6f 0e       	add	r6, r31
    3ce0:	71 1c       	adc	r7, r1
    3ce2:	f8 01       	movw	r30, r16
    3ce4:	a0 80       	ld	r10, Z
    3ce6:	b1 80       	ldd	r11, Z+1	; 0x01
    3ce8:	26 ff       	sbrs	r18, 6
    3cea:	03 c0       	rjmp	.+6      	; 0x3cf2 <vfprintf+0x178>
    3cec:	65 2d       	mov	r22, r5
    3cee:	70 e0       	ldi	r23, 0x00	; 0
    3cf0:	02 c0       	rjmp	.+4      	; 0x3cf6 <vfprintf+0x17c>
    3cf2:	6f ef       	ldi	r22, 0xFF	; 255
    3cf4:	7f ef       	ldi	r23, 0xFF	; 255
    3cf6:	c5 01       	movw	r24, r10
    3cf8:	2c 87       	std	Y+12, r18	; 0x0c
    3cfa:	27 d1       	rcall	.+590    	; 0x3f4a <strnlen_P>
    3cfc:	2c 01       	movw	r4, r24
    3cfe:	2c 85       	ldd	r18, Y+12	; 0x0c
    3d00:	20 68       	ori	r18, 0x80	; 128
    3d02:	22 2e       	mov	r2, r18
    3d04:	83 01       	movw	r16, r6
    3d06:	23 fc       	sbrc	r2, 3
    3d08:	19 c0       	rjmp	.+50     	; 0x3d3c <vfprintf+0x1c2>
    3d0a:	83 2d       	mov	r24, r3
    3d0c:	90 e0       	ldi	r25, 0x00	; 0
    3d0e:	48 16       	cp	r4, r24
    3d10:	59 06       	cpc	r5, r25
    3d12:	a0 f4       	brcc	.+40     	; 0x3d3c <vfprintf+0x1c2>
    3d14:	b7 01       	movw	r22, r14
    3d16:	80 e2       	ldi	r24, 0x20	; 32
    3d18:	90 e0       	ldi	r25, 0x00	; 0
    3d1a:	2d d1       	rcall	.+602    	; 0x3f76 <fputc>
    3d1c:	3a 94       	dec	r3
    3d1e:	f5 cf       	rjmp	.-22     	; 0x3d0a <vfprintf+0x190>
    3d20:	f5 01       	movw	r30, r10
    3d22:	27 fc       	sbrc	r2, 7
    3d24:	85 91       	lpm	r24, Z+
    3d26:	27 fe       	sbrs	r2, 7
    3d28:	81 91       	ld	r24, Z+
    3d2a:	5f 01       	movw	r10, r30
    3d2c:	b7 01       	movw	r22, r14
    3d2e:	90 e0       	ldi	r25, 0x00	; 0
    3d30:	22 d1       	rcall	.+580    	; 0x3f76 <fputc>
    3d32:	31 10       	cpse	r3, r1
    3d34:	3a 94       	dec	r3
    3d36:	f1 e0       	ldi	r31, 0x01	; 1
    3d38:	4f 1a       	sub	r4, r31
    3d3a:	51 08       	sbc	r5, r1
    3d3c:	41 14       	cp	r4, r1
    3d3e:	51 04       	cpc	r5, r1
    3d40:	79 f7       	brne	.-34     	; 0x3d20 <vfprintf+0x1a6>
    3d42:	de c0       	rjmp	.+444    	; 0x3f00 <vfprintf+0x386>
    3d44:	84 36       	cpi	r24, 0x64	; 100
    3d46:	11 f0       	breq	.+4      	; 0x3d4c <vfprintf+0x1d2>
    3d48:	89 36       	cpi	r24, 0x69	; 105
    3d4a:	31 f5       	brne	.+76     	; 0x3d98 <vfprintf+0x21e>
    3d4c:	f8 01       	movw	r30, r16
    3d4e:	27 ff       	sbrs	r18, 7
    3d50:	07 c0       	rjmp	.+14     	; 0x3d60 <vfprintf+0x1e6>
    3d52:	60 81       	ld	r22, Z
    3d54:	71 81       	ldd	r23, Z+1	; 0x01
    3d56:	82 81       	ldd	r24, Z+2	; 0x02
    3d58:	93 81       	ldd	r25, Z+3	; 0x03
    3d5a:	0c 5f       	subi	r16, 0xFC	; 252
    3d5c:	1f 4f       	sbci	r17, 0xFF	; 255
    3d5e:	08 c0       	rjmp	.+16     	; 0x3d70 <vfprintf+0x1f6>
    3d60:	60 81       	ld	r22, Z
    3d62:	71 81       	ldd	r23, Z+1	; 0x01
    3d64:	07 2e       	mov	r0, r23
    3d66:	00 0c       	add	r0, r0
    3d68:	88 0b       	sbc	r24, r24
    3d6a:	99 0b       	sbc	r25, r25
    3d6c:	0e 5f       	subi	r16, 0xFE	; 254
    3d6e:	1f 4f       	sbci	r17, 0xFF	; 255
    3d70:	2f 76       	andi	r18, 0x6F	; 111
    3d72:	72 2e       	mov	r7, r18
    3d74:	97 ff       	sbrs	r25, 7
    3d76:	09 c0       	rjmp	.+18     	; 0x3d8a <vfprintf+0x210>
    3d78:	90 95       	com	r25
    3d7a:	80 95       	com	r24
    3d7c:	70 95       	com	r23
    3d7e:	61 95       	neg	r22
    3d80:	7f 4f       	sbci	r23, 0xFF	; 255
    3d82:	8f 4f       	sbci	r24, 0xFF	; 255
    3d84:	9f 4f       	sbci	r25, 0xFF	; 255
    3d86:	20 68       	ori	r18, 0x80	; 128
    3d88:	72 2e       	mov	r7, r18
    3d8a:	2a e0       	ldi	r18, 0x0A	; 10
    3d8c:	30 e0       	ldi	r19, 0x00	; 0
    3d8e:	a4 01       	movw	r20, r8
    3d90:	2a d1       	rcall	.+596    	; 0x3fe6 <__ultoa_invert>
    3d92:	a8 2e       	mov	r10, r24
    3d94:	a8 18       	sub	r10, r8
    3d96:	43 c0       	rjmp	.+134    	; 0x3e1e <vfprintf+0x2a4>
    3d98:	85 37       	cpi	r24, 0x75	; 117
    3d9a:	29 f4       	brne	.+10     	; 0x3da6 <vfprintf+0x22c>
    3d9c:	2f 7e       	andi	r18, 0xEF	; 239
    3d9e:	b2 2e       	mov	r11, r18
    3da0:	2a e0       	ldi	r18, 0x0A	; 10
    3da2:	30 e0       	ldi	r19, 0x00	; 0
    3da4:	25 c0       	rjmp	.+74     	; 0x3df0 <vfprintf+0x276>
    3da6:	f2 2f       	mov	r31, r18
    3da8:	f9 7f       	andi	r31, 0xF9	; 249
    3daa:	bf 2e       	mov	r11, r31
    3dac:	8f 36       	cpi	r24, 0x6F	; 111
    3dae:	c1 f0       	breq	.+48     	; 0x3de0 <vfprintf+0x266>
    3db0:	18 f4       	brcc	.+6      	; 0x3db8 <vfprintf+0x23e>
    3db2:	88 35       	cpi	r24, 0x58	; 88
    3db4:	79 f0       	breq	.+30     	; 0x3dd4 <vfprintf+0x25a>
    3db6:	ad c0       	rjmp	.+346    	; 0x3f12 <vfprintf+0x398>
    3db8:	80 37       	cpi	r24, 0x70	; 112
    3dba:	19 f0       	breq	.+6      	; 0x3dc2 <vfprintf+0x248>
    3dbc:	88 37       	cpi	r24, 0x78	; 120
    3dbe:	21 f0       	breq	.+8      	; 0x3dc8 <vfprintf+0x24e>
    3dc0:	a8 c0       	rjmp	.+336    	; 0x3f12 <vfprintf+0x398>
    3dc2:	2f 2f       	mov	r18, r31
    3dc4:	20 61       	ori	r18, 0x10	; 16
    3dc6:	b2 2e       	mov	r11, r18
    3dc8:	b4 fe       	sbrs	r11, 4
    3dca:	0d c0       	rjmp	.+26     	; 0x3de6 <vfprintf+0x26c>
    3dcc:	8b 2d       	mov	r24, r11
    3dce:	84 60       	ori	r24, 0x04	; 4
    3dd0:	b8 2e       	mov	r11, r24
    3dd2:	09 c0       	rjmp	.+18     	; 0x3de6 <vfprintf+0x26c>
    3dd4:	24 ff       	sbrs	r18, 4
    3dd6:	0a c0       	rjmp	.+20     	; 0x3dec <vfprintf+0x272>
    3dd8:	9f 2f       	mov	r25, r31
    3dda:	96 60       	ori	r25, 0x06	; 6
    3ddc:	b9 2e       	mov	r11, r25
    3dde:	06 c0       	rjmp	.+12     	; 0x3dec <vfprintf+0x272>
    3de0:	28 e0       	ldi	r18, 0x08	; 8
    3de2:	30 e0       	ldi	r19, 0x00	; 0
    3de4:	05 c0       	rjmp	.+10     	; 0x3df0 <vfprintf+0x276>
    3de6:	20 e1       	ldi	r18, 0x10	; 16
    3de8:	30 e0       	ldi	r19, 0x00	; 0
    3dea:	02 c0       	rjmp	.+4      	; 0x3df0 <vfprintf+0x276>
    3dec:	20 e1       	ldi	r18, 0x10	; 16
    3dee:	32 e0       	ldi	r19, 0x02	; 2
    3df0:	f8 01       	movw	r30, r16
    3df2:	b7 fe       	sbrs	r11, 7
    3df4:	07 c0       	rjmp	.+14     	; 0x3e04 <vfprintf+0x28a>
    3df6:	60 81       	ld	r22, Z
    3df8:	71 81       	ldd	r23, Z+1	; 0x01
    3dfa:	82 81       	ldd	r24, Z+2	; 0x02
    3dfc:	93 81       	ldd	r25, Z+3	; 0x03
    3dfe:	0c 5f       	subi	r16, 0xFC	; 252
    3e00:	1f 4f       	sbci	r17, 0xFF	; 255
    3e02:	06 c0       	rjmp	.+12     	; 0x3e10 <vfprintf+0x296>
    3e04:	60 81       	ld	r22, Z
    3e06:	71 81       	ldd	r23, Z+1	; 0x01
    3e08:	80 e0       	ldi	r24, 0x00	; 0
    3e0a:	90 e0       	ldi	r25, 0x00	; 0
    3e0c:	0e 5f       	subi	r16, 0xFE	; 254
    3e0e:	1f 4f       	sbci	r17, 0xFF	; 255
    3e10:	a4 01       	movw	r20, r8
    3e12:	e9 d0       	rcall	.+466    	; 0x3fe6 <__ultoa_invert>
    3e14:	a8 2e       	mov	r10, r24
    3e16:	a8 18       	sub	r10, r8
    3e18:	fb 2d       	mov	r31, r11
    3e1a:	ff 77       	andi	r31, 0x7F	; 127
    3e1c:	7f 2e       	mov	r7, r31
    3e1e:	76 fe       	sbrs	r7, 6
    3e20:	0b c0       	rjmp	.+22     	; 0x3e38 <vfprintf+0x2be>
    3e22:	37 2d       	mov	r19, r7
    3e24:	3e 7f       	andi	r19, 0xFE	; 254
    3e26:	a5 14       	cp	r10, r5
    3e28:	50 f4       	brcc	.+20     	; 0x3e3e <vfprintf+0x2c4>
    3e2a:	74 fe       	sbrs	r7, 4
    3e2c:	0a c0       	rjmp	.+20     	; 0x3e42 <vfprintf+0x2c8>
    3e2e:	72 fc       	sbrc	r7, 2
    3e30:	08 c0       	rjmp	.+16     	; 0x3e42 <vfprintf+0x2c8>
    3e32:	37 2d       	mov	r19, r7
    3e34:	3e 7e       	andi	r19, 0xEE	; 238
    3e36:	05 c0       	rjmp	.+10     	; 0x3e42 <vfprintf+0x2c8>
    3e38:	ba 2c       	mov	r11, r10
    3e3a:	37 2d       	mov	r19, r7
    3e3c:	03 c0       	rjmp	.+6      	; 0x3e44 <vfprintf+0x2ca>
    3e3e:	ba 2c       	mov	r11, r10
    3e40:	01 c0       	rjmp	.+2      	; 0x3e44 <vfprintf+0x2ca>
    3e42:	b5 2c       	mov	r11, r5
    3e44:	34 ff       	sbrs	r19, 4
    3e46:	0d c0       	rjmp	.+26     	; 0x3e62 <vfprintf+0x2e8>
    3e48:	fe 01       	movw	r30, r28
    3e4a:	ea 0d       	add	r30, r10
    3e4c:	f1 1d       	adc	r31, r1
    3e4e:	80 81       	ld	r24, Z
    3e50:	80 33       	cpi	r24, 0x30	; 48
    3e52:	11 f4       	brne	.+4      	; 0x3e58 <vfprintf+0x2de>
    3e54:	39 7e       	andi	r19, 0xE9	; 233
    3e56:	09 c0       	rjmp	.+18     	; 0x3e6a <vfprintf+0x2f0>
    3e58:	32 ff       	sbrs	r19, 2
    3e5a:	06 c0       	rjmp	.+12     	; 0x3e68 <vfprintf+0x2ee>
    3e5c:	b3 94       	inc	r11
    3e5e:	b3 94       	inc	r11
    3e60:	04 c0       	rjmp	.+8      	; 0x3e6a <vfprintf+0x2f0>
    3e62:	83 2f       	mov	r24, r19
    3e64:	86 78       	andi	r24, 0x86	; 134
    3e66:	09 f0       	breq	.+2      	; 0x3e6a <vfprintf+0x2f0>
    3e68:	b3 94       	inc	r11
    3e6a:	33 fd       	sbrc	r19, 3
    3e6c:	12 c0       	rjmp	.+36     	; 0x3e92 <vfprintf+0x318>
    3e6e:	30 ff       	sbrs	r19, 0
    3e70:	06 c0       	rjmp	.+12     	; 0x3e7e <vfprintf+0x304>
    3e72:	5a 2c       	mov	r5, r10
    3e74:	b3 14       	cp	r11, r3
    3e76:	18 f4       	brcc	.+6      	; 0x3e7e <vfprintf+0x304>
    3e78:	53 0c       	add	r5, r3
    3e7a:	5b 18       	sub	r5, r11
    3e7c:	b3 2c       	mov	r11, r3
    3e7e:	b3 14       	cp	r11, r3
    3e80:	60 f4       	brcc	.+24     	; 0x3e9a <vfprintf+0x320>
    3e82:	b7 01       	movw	r22, r14
    3e84:	80 e2       	ldi	r24, 0x20	; 32
    3e86:	90 e0       	ldi	r25, 0x00	; 0
    3e88:	3c 87       	std	Y+12, r19	; 0x0c
    3e8a:	75 d0       	rcall	.+234    	; 0x3f76 <fputc>
    3e8c:	b3 94       	inc	r11
    3e8e:	3c 85       	ldd	r19, Y+12	; 0x0c
    3e90:	f6 cf       	rjmp	.-20     	; 0x3e7e <vfprintf+0x304>
    3e92:	b3 14       	cp	r11, r3
    3e94:	10 f4       	brcc	.+4      	; 0x3e9a <vfprintf+0x320>
    3e96:	3b 18       	sub	r3, r11
    3e98:	01 c0       	rjmp	.+2      	; 0x3e9c <vfprintf+0x322>
    3e9a:	31 2c       	mov	r3, r1
    3e9c:	34 ff       	sbrs	r19, 4
    3e9e:	11 c0       	rjmp	.+34     	; 0x3ec2 <vfprintf+0x348>
    3ea0:	b7 01       	movw	r22, r14
    3ea2:	80 e3       	ldi	r24, 0x30	; 48
    3ea4:	90 e0       	ldi	r25, 0x00	; 0
    3ea6:	3c 87       	std	Y+12, r19	; 0x0c
    3ea8:	66 d0       	rcall	.+204    	; 0x3f76 <fputc>
    3eaa:	3c 85       	ldd	r19, Y+12	; 0x0c
    3eac:	32 ff       	sbrs	r19, 2
    3eae:	16 c0       	rjmp	.+44     	; 0x3edc <vfprintf+0x362>
    3eb0:	31 fd       	sbrc	r19, 1
    3eb2:	03 c0       	rjmp	.+6      	; 0x3eba <vfprintf+0x340>
    3eb4:	88 e7       	ldi	r24, 0x78	; 120
    3eb6:	90 e0       	ldi	r25, 0x00	; 0
    3eb8:	02 c0       	rjmp	.+4      	; 0x3ebe <vfprintf+0x344>
    3eba:	88 e5       	ldi	r24, 0x58	; 88
    3ebc:	90 e0       	ldi	r25, 0x00	; 0
    3ebe:	b7 01       	movw	r22, r14
    3ec0:	0c c0       	rjmp	.+24     	; 0x3eda <vfprintf+0x360>
    3ec2:	83 2f       	mov	r24, r19
    3ec4:	86 78       	andi	r24, 0x86	; 134
    3ec6:	51 f0       	breq	.+20     	; 0x3edc <vfprintf+0x362>
    3ec8:	31 ff       	sbrs	r19, 1
    3eca:	02 c0       	rjmp	.+4      	; 0x3ed0 <vfprintf+0x356>
    3ecc:	8b e2       	ldi	r24, 0x2B	; 43
    3ece:	01 c0       	rjmp	.+2      	; 0x3ed2 <vfprintf+0x358>
    3ed0:	80 e2       	ldi	r24, 0x20	; 32
    3ed2:	37 fd       	sbrc	r19, 7
    3ed4:	8d e2       	ldi	r24, 0x2D	; 45
    3ed6:	b7 01       	movw	r22, r14
    3ed8:	90 e0       	ldi	r25, 0x00	; 0
    3eda:	4d d0       	rcall	.+154    	; 0x3f76 <fputc>
    3edc:	a5 14       	cp	r10, r5
    3ede:	30 f4       	brcc	.+12     	; 0x3eec <vfprintf+0x372>
    3ee0:	b7 01       	movw	r22, r14
    3ee2:	80 e3       	ldi	r24, 0x30	; 48
    3ee4:	90 e0       	ldi	r25, 0x00	; 0
    3ee6:	47 d0       	rcall	.+142    	; 0x3f76 <fputc>
    3ee8:	5a 94       	dec	r5
    3eea:	f8 cf       	rjmp	.-16     	; 0x3edc <vfprintf+0x362>
    3eec:	aa 94       	dec	r10
    3eee:	f4 01       	movw	r30, r8
    3ef0:	ea 0d       	add	r30, r10
    3ef2:	f1 1d       	adc	r31, r1
    3ef4:	80 81       	ld	r24, Z
    3ef6:	b7 01       	movw	r22, r14
    3ef8:	90 e0       	ldi	r25, 0x00	; 0
    3efa:	3d d0       	rcall	.+122    	; 0x3f76 <fputc>
    3efc:	a1 10       	cpse	r10, r1
    3efe:	f6 cf       	rjmp	.-20     	; 0x3eec <vfprintf+0x372>
    3f00:	33 20       	and	r3, r3
    3f02:	09 f4       	brne	.+2      	; 0x3f06 <vfprintf+0x38c>
    3f04:	5d ce       	rjmp	.-838    	; 0x3bc0 <vfprintf+0x46>
    3f06:	b7 01       	movw	r22, r14
    3f08:	80 e2       	ldi	r24, 0x20	; 32
    3f0a:	90 e0       	ldi	r25, 0x00	; 0
    3f0c:	34 d0       	rcall	.+104    	; 0x3f76 <fputc>
    3f0e:	3a 94       	dec	r3
    3f10:	f7 cf       	rjmp	.-18     	; 0x3f00 <vfprintf+0x386>
    3f12:	f7 01       	movw	r30, r14
    3f14:	86 81       	ldd	r24, Z+6	; 0x06
    3f16:	97 81       	ldd	r25, Z+7	; 0x07
    3f18:	02 c0       	rjmp	.+4      	; 0x3f1e <vfprintf+0x3a4>
    3f1a:	8f ef       	ldi	r24, 0xFF	; 255
    3f1c:	9f ef       	ldi	r25, 0xFF	; 255
    3f1e:	2c 96       	adiw	r28, 0x0c	; 12
    3f20:	cd bf       	out	0x3d, r28	; 61
    3f22:	de bf       	out	0x3e, r29	; 62
    3f24:	df 91       	pop	r29
    3f26:	cf 91       	pop	r28
    3f28:	1f 91       	pop	r17
    3f2a:	0f 91       	pop	r16
    3f2c:	ff 90       	pop	r15
    3f2e:	ef 90       	pop	r14
    3f30:	df 90       	pop	r13
    3f32:	cf 90       	pop	r12
    3f34:	bf 90       	pop	r11
    3f36:	af 90       	pop	r10
    3f38:	9f 90       	pop	r9
    3f3a:	8f 90       	pop	r8
    3f3c:	7f 90       	pop	r7
    3f3e:	6f 90       	pop	r6
    3f40:	5f 90       	pop	r5
    3f42:	4f 90       	pop	r4
    3f44:	3f 90       	pop	r3
    3f46:	2f 90       	pop	r2
    3f48:	08 95       	ret

00003f4a <strnlen_P>:
    3f4a:	fc 01       	movw	r30, r24
    3f4c:	05 90       	lpm	r0, Z+
    3f4e:	61 50       	subi	r22, 0x01	; 1
    3f50:	70 40       	sbci	r23, 0x00	; 0
    3f52:	01 10       	cpse	r0, r1
    3f54:	d8 f7       	brcc	.-10     	; 0x3f4c <strnlen_P+0x2>
    3f56:	80 95       	com	r24
    3f58:	90 95       	com	r25
    3f5a:	8e 0f       	add	r24, r30
    3f5c:	9f 1f       	adc	r25, r31
    3f5e:	08 95       	ret

00003f60 <strnlen>:
    3f60:	fc 01       	movw	r30, r24
    3f62:	61 50       	subi	r22, 0x01	; 1
    3f64:	70 40       	sbci	r23, 0x00	; 0
    3f66:	01 90       	ld	r0, Z+
    3f68:	01 10       	cpse	r0, r1
    3f6a:	d8 f7       	brcc	.-10     	; 0x3f62 <strnlen+0x2>
    3f6c:	80 95       	com	r24
    3f6e:	90 95       	com	r25
    3f70:	8e 0f       	add	r24, r30
    3f72:	9f 1f       	adc	r25, r31
    3f74:	08 95       	ret

00003f76 <fputc>:
    3f76:	0f 93       	push	r16
    3f78:	1f 93       	push	r17
    3f7a:	cf 93       	push	r28
    3f7c:	df 93       	push	r29
    3f7e:	fb 01       	movw	r30, r22
    3f80:	23 81       	ldd	r18, Z+3	; 0x03
    3f82:	21 fd       	sbrc	r18, 1
    3f84:	03 c0       	rjmp	.+6      	; 0x3f8c <fputc+0x16>
    3f86:	8f ef       	ldi	r24, 0xFF	; 255
    3f88:	9f ef       	ldi	r25, 0xFF	; 255
    3f8a:	28 c0       	rjmp	.+80     	; 0x3fdc <fputc+0x66>
    3f8c:	22 ff       	sbrs	r18, 2
    3f8e:	16 c0       	rjmp	.+44     	; 0x3fbc <fputc+0x46>
    3f90:	46 81       	ldd	r20, Z+6	; 0x06
    3f92:	57 81       	ldd	r21, Z+7	; 0x07
    3f94:	24 81       	ldd	r18, Z+4	; 0x04
    3f96:	35 81       	ldd	r19, Z+5	; 0x05
    3f98:	42 17       	cp	r20, r18
    3f9a:	53 07       	cpc	r21, r19
    3f9c:	44 f4       	brge	.+16     	; 0x3fae <fputc+0x38>
    3f9e:	a0 81       	ld	r26, Z
    3fa0:	b1 81       	ldd	r27, Z+1	; 0x01
    3fa2:	9d 01       	movw	r18, r26
    3fa4:	2f 5f       	subi	r18, 0xFF	; 255
    3fa6:	3f 4f       	sbci	r19, 0xFF	; 255
    3fa8:	20 83       	st	Z, r18
    3faa:	31 83       	std	Z+1, r19	; 0x01
    3fac:	8c 93       	st	X, r24
    3fae:	26 81       	ldd	r18, Z+6	; 0x06
    3fb0:	37 81       	ldd	r19, Z+7	; 0x07
    3fb2:	2f 5f       	subi	r18, 0xFF	; 255
    3fb4:	3f 4f       	sbci	r19, 0xFF	; 255
    3fb6:	26 83       	std	Z+6, r18	; 0x06
    3fb8:	37 83       	std	Z+7, r19	; 0x07
    3fba:	10 c0       	rjmp	.+32     	; 0x3fdc <fputc+0x66>
    3fbc:	eb 01       	movw	r28, r22
    3fbe:	09 2f       	mov	r16, r25
    3fc0:	18 2f       	mov	r17, r24
    3fc2:	00 84       	ldd	r0, Z+8	; 0x08
    3fc4:	f1 85       	ldd	r31, Z+9	; 0x09
    3fc6:	e0 2d       	mov	r30, r0
    3fc8:	19 95       	eicall
    3fca:	89 2b       	or	r24, r25
    3fcc:	e1 f6       	brne	.-72     	; 0x3f86 <fputc+0x10>
    3fce:	8e 81       	ldd	r24, Y+6	; 0x06
    3fd0:	9f 81       	ldd	r25, Y+7	; 0x07
    3fd2:	01 96       	adiw	r24, 0x01	; 1
    3fd4:	8e 83       	std	Y+6, r24	; 0x06
    3fd6:	9f 83       	std	Y+7, r25	; 0x07
    3fd8:	81 2f       	mov	r24, r17
    3fda:	90 2f       	mov	r25, r16
    3fdc:	df 91       	pop	r29
    3fde:	cf 91       	pop	r28
    3fe0:	1f 91       	pop	r17
    3fe2:	0f 91       	pop	r16
    3fe4:	08 95       	ret

00003fe6 <__ultoa_invert>:
    3fe6:	fa 01       	movw	r30, r20
    3fe8:	aa 27       	eor	r26, r26
    3fea:	28 30       	cpi	r18, 0x08	; 8
    3fec:	51 f1       	breq	.+84     	; 0x4042 <__ultoa_invert+0x5c>
    3fee:	20 31       	cpi	r18, 0x10	; 16
    3ff0:	81 f1       	breq	.+96     	; 0x4052 <__ultoa_invert+0x6c>
    3ff2:	e8 94       	clt
    3ff4:	6f 93       	push	r22
    3ff6:	6e 7f       	andi	r22, 0xFE	; 254
    3ff8:	6e 5f       	subi	r22, 0xFE	; 254
    3ffa:	7f 4f       	sbci	r23, 0xFF	; 255
    3ffc:	8f 4f       	sbci	r24, 0xFF	; 255
    3ffe:	9f 4f       	sbci	r25, 0xFF	; 255
    4000:	af 4f       	sbci	r26, 0xFF	; 255
    4002:	b1 e0       	ldi	r27, 0x01	; 1
    4004:	3e d0       	rcall	.+124    	; 0x4082 <__ultoa_invert+0x9c>
    4006:	b4 e0       	ldi	r27, 0x04	; 4
    4008:	3c d0       	rcall	.+120    	; 0x4082 <__ultoa_invert+0x9c>
    400a:	67 0f       	add	r22, r23
    400c:	78 1f       	adc	r23, r24
    400e:	89 1f       	adc	r24, r25
    4010:	9a 1f       	adc	r25, r26
    4012:	a1 1d       	adc	r26, r1
    4014:	68 0f       	add	r22, r24
    4016:	79 1f       	adc	r23, r25
    4018:	8a 1f       	adc	r24, r26
    401a:	91 1d       	adc	r25, r1
    401c:	a1 1d       	adc	r26, r1
    401e:	6a 0f       	add	r22, r26
    4020:	71 1d       	adc	r23, r1
    4022:	81 1d       	adc	r24, r1
    4024:	91 1d       	adc	r25, r1
    4026:	a1 1d       	adc	r26, r1
    4028:	20 d0       	rcall	.+64     	; 0x406a <__ultoa_invert+0x84>
    402a:	09 f4       	brne	.+2      	; 0x402e <__ultoa_invert+0x48>
    402c:	68 94       	set
    402e:	3f 91       	pop	r19
    4030:	2a e0       	ldi	r18, 0x0A	; 10
    4032:	26 9f       	mul	r18, r22
    4034:	11 24       	eor	r1, r1
    4036:	30 19       	sub	r19, r0
    4038:	30 5d       	subi	r19, 0xD0	; 208
    403a:	31 93       	st	Z+, r19
    403c:	de f6       	brtc	.-74     	; 0x3ff4 <__ultoa_invert+0xe>
    403e:	cf 01       	movw	r24, r30
    4040:	08 95       	ret
    4042:	46 2f       	mov	r20, r22
    4044:	47 70       	andi	r20, 0x07	; 7
    4046:	40 5d       	subi	r20, 0xD0	; 208
    4048:	41 93       	st	Z+, r20
    404a:	b3 e0       	ldi	r27, 0x03	; 3
    404c:	0f d0       	rcall	.+30     	; 0x406c <__ultoa_invert+0x86>
    404e:	c9 f7       	brne	.-14     	; 0x4042 <__ultoa_invert+0x5c>
    4050:	f6 cf       	rjmp	.-20     	; 0x403e <__ultoa_invert+0x58>
    4052:	46 2f       	mov	r20, r22
    4054:	4f 70       	andi	r20, 0x0F	; 15
    4056:	40 5d       	subi	r20, 0xD0	; 208
    4058:	4a 33       	cpi	r20, 0x3A	; 58
    405a:	18 f0       	brcs	.+6      	; 0x4062 <__ultoa_invert+0x7c>
    405c:	49 5d       	subi	r20, 0xD9	; 217
    405e:	31 fd       	sbrc	r19, 1
    4060:	40 52       	subi	r20, 0x20	; 32
    4062:	41 93       	st	Z+, r20
    4064:	02 d0       	rcall	.+4      	; 0x406a <__ultoa_invert+0x84>
    4066:	a9 f7       	brne	.-22     	; 0x4052 <__ultoa_invert+0x6c>
    4068:	ea cf       	rjmp	.-44     	; 0x403e <__ultoa_invert+0x58>
    406a:	b4 e0       	ldi	r27, 0x04	; 4
    406c:	a6 95       	lsr	r26
    406e:	97 95       	ror	r25
    4070:	87 95       	ror	r24
    4072:	77 95       	ror	r23
    4074:	67 95       	ror	r22
    4076:	ba 95       	dec	r27
    4078:	c9 f7       	brne	.-14     	; 0x406c <__ultoa_invert+0x86>
    407a:	00 97       	sbiw	r24, 0x00	; 0
    407c:	61 05       	cpc	r22, r1
    407e:	71 05       	cpc	r23, r1
    4080:	08 95       	ret
    4082:	9b 01       	movw	r18, r22
    4084:	ac 01       	movw	r20, r24
    4086:	0a 2e       	mov	r0, r26
    4088:	06 94       	lsr	r0
    408a:	57 95       	ror	r21
    408c:	47 95       	ror	r20
    408e:	37 95       	ror	r19
    4090:	27 95       	ror	r18
    4092:	ba 95       	dec	r27
    4094:	c9 f7       	brne	.-14     	; 0x4088 <__ultoa_invert+0xa2>
    4096:	62 0f       	add	r22, r18
    4098:	73 1f       	adc	r23, r19
    409a:	84 1f       	adc	r24, r20
    409c:	95 1f       	adc	r25, r21
    409e:	a0 1d       	adc	r26, r0
    40a0:	08 95       	ret

000040a2 <_exit>:
    40a2:	f8 94       	cli

000040a4 <__stop_program>:
    40a4:	ff cf       	rjmp	.-2      	; 0x40a4 <__stop_program>


Praktikum_5_Template_6_2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000405a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000064  00802000  0000405a  000040ee  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000035f  00802064  00802064  00004152  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00004152  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000044  00000000  00000000  000041b0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006e8  00000000  00000000  000041f8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00012548  00000000  00000000  000048e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003137  00000000  00000000  00016e28  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000aed7  00000000  00000000  00019f5f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001744  00000000  00000000  00024e38  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000356d5  00000000  00000000  0002657c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00009a19  00000000  00000000  0005bc51  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000920  00000000  00000000  00065670  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000c877  00000000  00000000  00065f90  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	50 c2       	rjmp	.+1184   	; 0x4a2 <__ctors_end>
       2:	00 00       	nop
       4:	6f c2       	rjmp	.+1246   	; 0x4e4 <__bad_interrupt>
       6:	00 00       	nop
       8:	6d c2       	rjmp	.+1242   	; 0x4e4 <__bad_interrupt>
       a:	00 00       	nop
       c:	6b c2       	rjmp	.+1238   	; 0x4e4 <__bad_interrupt>
       e:	00 00       	nop
      10:	69 c2       	rjmp	.+1234   	; 0x4e4 <__bad_interrupt>
      12:	00 00       	nop
      14:	67 c2       	rjmp	.+1230   	; 0x4e4 <__bad_interrupt>
      16:	00 00       	nop
      18:	65 c2       	rjmp	.+1226   	; 0x4e4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	63 c2       	rjmp	.+1222   	; 0x4e4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	61 c2       	rjmp	.+1218   	; 0x4e4 <__bad_interrupt>
      22:	00 00       	nop
      24:	5f c2       	rjmp	.+1214   	; 0x4e4 <__bad_interrupt>
      26:	00 00       	nop
      28:	5d c2       	rjmp	.+1210   	; 0x4e4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5b c2       	rjmp	.+1206   	; 0x4e4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	59 c2       	rjmp	.+1202   	; 0x4e4 <__bad_interrupt>
      32:	00 00       	nop
      34:	57 c2       	rjmp	.+1198   	; 0x4e4 <__bad_interrupt>
      36:	00 00       	nop
      38:	0c 94 98 0f 	jmp	0x1f30	; 0x1f30 <__vector_14>
      3c:	53 c2       	rjmp	.+1190   	; 0x4e4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	51 c2       	rjmp	.+1186   	; 0x4e4 <__bad_interrupt>
      42:	00 00       	nop
      44:	4f c2       	rjmp	.+1182   	; 0x4e4 <__bad_interrupt>
      46:	00 00       	nop
      48:	4d c2       	rjmp	.+1178   	; 0x4e4 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	4b c2       	rjmp	.+1174   	; 0x4e4 <__bad_interrupt>
      4e:	00 00       	nop
      50:	49 c2       	rjmp	.+1170   	; 0x4e4 <__bad_interrupt>
      52:	00 00       	nop
      54:	47 c2       	rjmp	.+1166   	; 0x4e4 <__bad_interrupt>
      56:	00 00       	nop
      58:	45 c2       	rjmp	.+1162   	; 0x4e4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	43 c2       	rjmp	.+1158   	; 0x4e4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	41 c2       	rjmp	.+1154   	; 0x4e4 <__bad_interrupt>
      62:	00 00       	nop
      64:	3f c2       	rjmp	.+1150   	; 0x4e4 <__bad_interrupt>
      66:	00 00       	nop
      68:	3d c2       	rjmp	.+1146   	; 0x4e4 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3b c2       	rjmp	.+1142   	; 0x4e4 <__bad_interrupt>
      6e:	00 00       	nop
      70:	39 c2       	rjmp	.+1138   	; 0x4e4 <__bad_interrupt>
      72:	00 00       	nop
      74:	37 c2       	rjmp	.+1134   	; 0x4e4 <__bad_interrupt>
      76:	00 00       	nop
      78:	35 c2       	rjmp	.+1130   	; 0x4e4 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	33 c2       	rjmp	.+1126   	; 0x4e4 <__bad_interrupt>
      7e:	00 00       	nop
      80:	31 c2       	rjmp	.+1122   	; 0x4e4 <__bad_interrupt>
      82:	00 00       	nop
      84:	2f c2       	rjmp	.+1118   	; 0x4e4 <__bad_interrupt>
      86:	00 00       	nop
      88:	2d c2       	rjmp	.+1114   	; 0x4e4 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	2b c2       	rjmp	.+1110   	; 0x4e4 <__bad_interrupt>
      8e:	00 00       	nop
      90:	29 c2       	rjmp	.+1106   	; 0x4e4 <__bad_interrupt>
      92:	00 00       	nop
      94:	27 c2       	rjmp	.+1102   	; 0x4e4 <__bad_interrupt>
      96:	00 00       	nop
      98:	25 c2       	rjmp	.+1098   	; 0x4e4 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	d6 c7       	rjmp	.+4012   	; 0x104a <__vector_39>
      9e:	00 00       	nop
      a0:	0c 94 57 08 	jmp	0x10ae	; 0x10ae <__vector_40>
      a4:	0c 94 89 08 	jmp	0x1112	; 0x1112 <__vector_41>
      a8:	0c 94 bb 08 	jmp	0x1176	; 0x1176 <__vector_42>
      ac:	1b c2       	rjmp	.+1078   	; 0x4e4 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	19 c2       	rjmp	.+1074   	; 0x4e4 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	17 c2       	rjmp	.+1070   	; 0x4e4 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	15 c2       	rjmp	.+1066   	; 0x4e4 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	13 c2       	rjmp	.+1062   	; 0x4e4 <__bad_interrupt>
      be:	00 00       	nop
      c0:	11 c2       	rjmp	.+1058   	; 0x4e4 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	0f c2       	rjmp	.+1054   	; 0x4e4 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	0d c2       	rjmp	.+1050   	; 0x4e4 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0b c2       	rjmp	.+1046   	; 0x4e4 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	09 c2       	rjmp	.+1042   	; 0x4e4 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	07 c2       	rjmp	.+1038   	; 0x4e4 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	05 c2       	rjmp	.+1034   	; 0x4e4 <__bad_interrupt>
      da:	00 00       	nop
      dc:	03 c2       	rjmp	.+1030   	; 0x4e4 <__bad_interrupt>
      de:	00 00       	nop
      e0:	01 c2       	rjmp	.+1026   	; 0x4e4 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	ff c1       	rjmp	.+1022   	; 0x4e4 <__bad_interrupt>
      e6:	00 00       	nop
      e8:	fd c1       	rjmp	.+1018   	; 0x4e4 <__bad_interrupt>
      ea:	00 00       	nop
      ec:	fb c1       	rjmp	.+1014   	; 0x4e4 <__bad_interrupt>
      ee:	00 00       	nop
      f0:	f9 c1       	rjmp	.+1010   	; 0x4e4 <__bad_interrupt>
      f2:	00 00       	nop
      f4:	f7 c1       	rjmp	.+1006   	; 0x4e4 <__bad_interrupt>
      f6:	00 00       	nop
      f8:	f5 c1       	rjmp	.+1002   	; 0x4e4 <__bad_interrupt>
      fa:	00 00       	nop
      fc:	f3 c1       	rjmp	.+998    	; 0x4e4 <__bad_interrupt>
      fe:	00 00       	nop
     100:	f1 c1       	rjmp	.+994    	; 0x4e4 <__bad_interrupt>
     102:	00 00       	nop
     104:	ef c1       	rjmp	.+990    	; 0x4e4 <__bad_interrupt>
     106:	00 00       	nop
     108:	ed c1       	rjmp	.+986    	; 0x4e4 <__bad_interrupt>
     10a:	00 00       	nop
     10c:	eb c1       	rjmp	.+982    	; 0x4e4 <__bad_interrupt>
     10e:	00 00       	nop
     110:	e9 c1       	rjmp	.+978    	; 0x4e4 <__bad_interrupt>
     112:	00 00       	nop
     114:	e7 c1       	rjmp	.+974    	; 0x4e4 <__bad_interrupt>
     116:	00 00       	nop
     118:	e5 c1       	rjmp	.+970    	; 0x4e4 <__bad_interrupt>
     11a:	00 00       	nop
     11c:	ce c6       	rjmp	.+3484   	; 0xeba <__vector_71>
     11e:	00 00       	nop
     120:	fe c6       	rjmp	.+3580   	; 0xf1e <__vector_72>
     122:	00 00       	nop
     124:	2e c7       	rjmp	.+3676   	; 0xf82 <__vector_73>
     126:	00 00       	nop
     128:	5e c7       	rjmp	.+3772   	; 0xfe6 <__vector_74>
     12a:	00 00       	nop
     12c:	db c1       	rjmp	.+950    	; 0x4e4 <__bad_interrupt>
     12e:	00 00       	nop
     130:	d9 c1       	rjmp	.+946    	; 0x4e4 <__bad_interrupt>
     132:	00 00       	nop
     134:	d7 c1       	rjmp	.+942    	; 0x4e4 <__bad_interrupt>
     136:	00 00       	nop
     138:	d5 c1       	rjmp	.+938    	; 0x4e4 <__bad_interrupt>
     13a:	00 00       	nop
     13c:	d3 c1       	rjmp	.+934    	; 0x4e4 <__bad_interrupt>
     13e:	00 00       	nop
     140:	d1 c1       	rjmp	.+930    	; 0x4e4 <__bad_interrupt>
     142:	00 00       	nop
     144:	cf c1       	rjmp	.+926    	; 0x4e4 <__bad_interrupt>
     146:	00 00       	nop
     148:	cd c1       	rjmp	.+922    	; 0x4e4 <__bad_interrupt>
     14a:	00 00       	nop
     14c:	cb c1       	rjmp	.+918    	; 0x4e4 <__bad_interrupt>
     14e:	00 00       	nop
     150:	c9 c1       	rjmp	.+914    	; 0x4e4 <__bad_interrupt>
     152:	00 00       	nop
     154:	c7 c1       	rjmp	.+910    	; 0x4e4 <__bad_interrupt>
     156:	00 00       	nop
     158:	c5 c1       	rjmp	.+906    	; 0x4e4 <__bad_interrupt>
     15a:	00 00       	nop
     15c:	c3 c1       	rjmp	.+902    	; 0x4e4 <__bad_interrupt>
     15e:	00 00       	nop
     160:	c1 c1       	rjmp	.+898    	; 0x4e4 <__bad_interrupt>
     162:	00 00       	nop
     164:	bf c1       	rjmp	.+894    	; 0x4e4 <__bad_interrupt>
     166:	00 00       	nop
     168:	bd c1       	rjmp	.+890    	; 0x4e4 <__bad_interrupt>
     16a:	00 00       	nop
     16c:	bb c1       	rjmp	.+886    	; 0x4e4 <__bad_interrupt>
     16e:	00 00       	nop
     170:	b9 c1       	rjmp	.+882    	; 0x4e4 <__bad_interrupt>
     172:	00 00       	nop
     174:	b7 c1       	rjmp	.+878    	; 0x4e4 <__bad_interrupt>
     176:	00 00       	nop
     178:	b5 c1       	rjmp	.+874    	; 0x4e4 <__bad_interrupt>
     17a:	00 00       	nop
     17c:	b3 c1       	rjmp	.+870    	; 0x4e4 <__bad_interrupt>
     17e:	00 00       	nop
     180:	b1 c1       	rjmp	.+866    	; 0x4e4 <__bad_interrupt>
     182:	00 00       	nop
     184:	af c1       	rjmp	.+862    	; 0x4e4 <__bad_interrupt>
     186:	00 00       	nop
     188:	ad c1       	rjmp	.+858    	; 0x4e4 <__bad_interrupt>
     18a:	00 00       	nop
     18c:	ab c1       	rjmp	.+854    	; 0x4e4 <__bad_interrupt>
     18e:	00 00       	nop
     190:	a9 c1       	rjmp	.+850    	; 0x4e4 <__bad_interrupt>
     192:	00 00       	nop
     194:	a7 c1       	rjmp	.+846    	; 0x4e4 <__bad_interrupt>
     196:	00 00       	nop
     198:	a5 c1       	rjmp	.+842    	; 0x4e4 <__bad_interrupt>
     19a:	00 00       	nop
     19c:	a3 c1       	rjmp	.+838    	; 0x4e4 <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	a1 c1       	rjmp	.+834    	; 0x4e4 <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	9f c1       	rjmp	.+830    	; 0x4e4 <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	9d c1       	rjmp	.+826    	; 0x4e4 <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	9b c1       	rjmp	.+822    	; 0x4e4 <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	99 c1       	rjmp	.+818    	; 0x4e4 <__bad_interrupt>
     1b2:	00 00       	nop
     1b4:	97 c1       	rjmp	.+814    	; 0x4e4 <__bad_interrupt>
     1b6:	00 00       	nop
     1b8:	95 c1       	rjmp	.+810    	; 0x4e4 <__bad_interrupt>
     1ba:	00 00       	nop
     1bc:	93 c1       	rjmp	.+806    	; 0x4e4 <__bad_interrupt>
     1be:	00 00       	nop
     1c0:	91 c1       	rjmp	.+802    	; 0x4e4 <__bad_interrupt>
     1c2:	00 00       	nop
     1c4:	8f c1       	rjmp	.+798    	; 0x4e4 <__bad_interrupt>
     1c6:	00 00       	nop
     1c8:	8d c1       	rjmp	.+794    	; 0x4e4 <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	8b c1       	rjmp	.+790    	; 0x4e4 <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	89 c1       	rjmp	.+786    	; 0x4e4 <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	87 c1       	rjmp	.+782    	; 0x4e4 <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	85 c1       	rjmp	.+778    	; 0x4e4 <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	83 c1       	rjmp	.+774    	; 0x4e4 <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	81 c1       	rjmp	.+770    	; 0x4e4 <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	7f c1       	rjmp	.+766    	; 0x4e4 <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	7d c1       	rjmp	.+762    	; 0x4e4 <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	7b c1       	rjmp	.+758    	; 0x4e4 <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	79 c1       	rjmp	.+754    	; 0x4e4 <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	77 c1       	rjmp	.+750    	; 0x4e4 <__bad_interrupt>
     1f6:	00 00       	nop
     1f8:	75 c1       	rjmp	.+746    	; 0x4e4 <__bad_interrupt>
     1fa:	00 00       	nop
     1fc:	b4 18       	sub	r11, r4
     1fe:	b4 18       	sub	r11, r4
     200:	b4 18       	sub	r11, r4
     202:	ea 18       	sub	r14, r10
     204:	da 18       	sub	r13, r10
     206:	e7 18       	sub	r14, r7
     208:	b4 18       	sub	r11, r4
     20a:	b4 18       	sub	r11, r4
     20c:	ea 18       	sub	r14, r10
     20e:	da 18       	sub	r13, r10

00000210 <__trampolines_end>:
     210:	00 00       	nop
     212:	00 00       	nop
     214:	00 00       	nop
     216:	00 20       	and	r0, r0
     218:	20 20       	and	r2, r0
     21a:	20 20       	and	r2, r0
     21c:	00 20       	and	r0, r0
     21e:	50 50       	subi	r21, 0x00	; 0
     220:	50 00       	.word	0x0050	; ????
     222:	00 00       	nop
     224:	00 50       	subi	r16, 0x00	; 0
     226:	50 f8       	bld	r5, 0
     228:	50 f8       	bld	r5, 0
     22a:	50 50       	subi	r21, 0x00	; 0
     22c:	20 78       	andi	r18, 0x80	; 128
     22e:	a0 70       	andi	r26, 0x00	; 0
     230:	28 f0       	brcs	.+10     	; 0x23c <__trampolines_end+0x2c>
     232:	20 c0       	rjmp	.+64     	; 0x274 <__trampolines_end+0x64>
     234:	c8 10       	cpse	r12, r8
     236:	20 40       	sbci	r18, 0x00	; 0
     238:	98 18       	sub	r9, r8
     23a:	60 90 a0 40 	lds	r6, 0x40A0	; 0x8040a0 <__bss_end+0x1cdd>
     23e:	a8 90       	.word	0x90a8	; ????
     240:	68 60       	ori	r22, 0x08	; 8
     242:	20 40       	sbci	r18, 0x00	; 0
     244:	00 00       	nop
     246:	00 00       	nop
     248:	10 20       	and	r1, r0
     24a:	40 40       	sbci	r20, 0x00	; 0
     24c:	40 20       	and	r4, r0
     24e:	10 40       	sbci	r17, 0x00	; 0
     250:	20 10       	cpse	r2, r0
     252:	10 10       	cpse	r1, r0
     254:	20 40       	sbci	r18, 0x00	; 0
     256:	00 50       	subi	r16, 0x00	; 0
     258:	20 f8       	bld	r2, 0
     25a:	20 50       	subi	r18, 0x00	; 0
     25c:	00 00       	nop
     25e:	20 20       	and	r2, r0
     260:	f8 20       	and	r15, r8
     262:	20 00       	.word	0x0020	; ????
     264:	00 00       	nop
     266:	00 00       	nop
     268:	60 20       	and	r6, r0
     26a:	40 00       	.word	0x0040	; ????
     26c:	00 00       	nop
     26e:	f8 00       	.word	0x00f8	; ????
     270:	00 00       	nop
     272:	00 00       	nop
     274:	00 00       	nop
     276:	00 60       	ori	r16, 0x00	; 0
     278:	60 00       	.word	0x0060	; ????
     27a:	08 10       	cpse	r0, r8
     27c:	20 40       	sbci	r18, 0x00	; 0
     27e:	80 00       	.word	0x0080	; ????
     280:	70 88       	ldd	r7, Z+16	; 0x10
     282:	98 a8       	ldd	r9, Y+48	; 0x30
     284:	c8 88       	ldd	r12, Y+16	; 0x10
     286:	70 20       	and	r7, r0
     288:	60 20       	and	r6, r0
     28a:	20 20       	and	r2, r0
     28c:	20 70       	andi	r18, 0x00	; 0
     28e:	70 88       	ldd	r7, Z+16	; 0x10
     290:	08 10       	cpse	r0, r8
     292:	20 40       	sbci	r18, 0x00	; 0
     294:	f8 f8       	.word	0xf8f8	; ????
     296:	10 20       	and	r1, r0
     298:	10 08       	sbc	r1, r0
     29a:	88 70       	andi	r24, 0x08	; 8
     29c:	10 30       	cpi	r17, 0x00	; 0
     29e:	50 90 f8 10 	lds	r5, 0x10F8	; 0x8010f8 <__TEXT_REGION_LENGTH__+0x7010f8>
     2a2:	10 f8       	bld	r1, 0
     2a4:	80 f0       	brcs	.+32     	; 0x2c6 <__trampolines_end+0xb6>
     2a6:	08 08       	sbc	r0, r8
     2a8:	88 70       	andi	r24, 0x08	; 8
     2aa:	30 40       	sbci	r19, 0x00	; 0
     2ac:	80 f0       	brcs	.+32     	; 0x2ce <__trampolines_end+0xbe>
     2ae:	88 88       	ldd	r8, Y+16	; 0x10
     2b0:	70 f8       	bld	r7, 0
     2b2:	08 10       	cpse	r0, r8
     2b4:	20 40       	sbci	r18, 0x00	; 0
     2b6:	40 40       	sbci	r20, 0x00	; 0
     2b8:	70 88       	ldd	r7, Z+16	; 0x10
     2ba:	88 70       	andi	r24, 0x08	; 8
     2bc:	88 88       	ldd	r8, Y+16	; 0x10
     2be:	70 70       	andi	r23, 0x00	; 0
     2c0:	88 88       	ldd	r8, Y+16	; 0x10
     2c2:	78 08       	sbc	r7, r8
     2c4:	10 60       	ori	r17, 0x00	; 0
     2c6:	00 60       	ori	r16, 0x00	; 0
     2c8:	60 00       	.word	0x0060	; ????
     2ca:	60 60       	ori	r22, 0x00	; 0
     2cc:	00 00       	nop
     2ce:	60 60       	ori	r22, 0x00	; 0
     2d0:	00 60       	ori	r16, 0x00	; 0
     2d2:	20 40       	sbci	r18, 0x00	; 0
     2d4:	08 10       	cpse	r0, r8
     2d6:	20 40       	sbci	r18, 0x00	; 0
     2d8:	20 10       	cpse	r2, r0
     2da:	08 00       	.word	0x0008	; ????
     2dc:	00 f8       	bld	r0, 0
     2de:	00 f8       	bld	r0, 0
     2e0:	00 00       	nop
     2e2:	80 40       	sbci	r24, 0x00	; 0
     2e4:	20 10       	cpse	r2, r0
     2e6:	20 40       	sbci	r18, 0x00	; 0
     2e8:	80 70       	andi	r24, 0x00	; 0
     2ea:	88 08       	sbc	r8, r8
     2ec:	10 20       	and	r1, r0
     2ee:	00 20       	and	r0, r0
     2f0:	70 88       	ldd	r7, Z+16	; 0x10
     2f2:	08 68       	ori	r16, 0x88	; 136
     2f4:	a8 a8       	ldd	r10, Y+48	; 0x30
     2f6:	70 70       	andi	r23, 0x00	; 0
     2f8:	88 88       	ldd	r8, Y+16	; 0x10
     2fa:	88 f8       	.word	0xf888	; ????
     2fc:	88 88       	ldd	r8, Y+16	; 0x10
     2fe:	f0 88       	ldd	r15, Z+16	; 0x10
     300:	88 f0       	brcs	.+34     	; 0x324 <__trampolines_end+0x114>
     302:	88 88       	ldd	r8, Y+16	; 0x10
     304:	f0 70       	andi	r31, 0x00	; 0
     306:	88 80       	ld	r8, Y
     308:	80 80       	ld	r8, Z
     30a:	88 70       	andi	r24, 0x08	; 8
     30c:	e0 90 88 88 	lds	r14, 0x8888	; 0x808888 <__bss_end+0x64c5>
     310:	88 90       	.word	0x9088	; ????
     312:	e0 f8       	bld	r14, 0
     314:	80 80       	ld	r8, Z
     316:	f0 80       	ld	r15, Z
     318:	80 f8       	bld	r8, 0
     31a:	f8 80       	ld	r15, Y
     31c:	80 e0       	ldi	r24, 0x00	; 0
     31e:	80 80       	ld	r8, Z
     320:	80 70       	andi	r24, 0x00	; 0
     322:	88 80       	ld	r8, Y
     324:	80 98       	cbi	0x10, 0	; 16
     326:	88 70       	andi	r24, 0x08	; 8
     328:	88 88       	ldd	r8, Y+16	; 0x10
     32a:	88 f8       	.word	0xf888	; ????
     32c:	88 88       	ldd	r8, Y+16	; 0x10
     32e:	88 70       	andi	r24, 0x08	; 8
     330:	20 20       	and	r2, r0
     332:	20 20       	and	r2, r0
     334:	20 70       	andi	r18, 0x00	; 0
     336:	38 10       	cpse	r3, r8
     338:	10 10       	cpse	r1, r0
     33a:	10 90 60 88 	lds	r1, 0x8860	; 0x808860 <__bss_end+0x649d>
     33e:	90 a0       	ldd	r9, Z+32	; 0x20
     340:	c0 a0       	ldd	r12, Z+32	; 0x20
     342:	90 88       	ldd	r9, Z+16	; 0x10
     344:	80 80       	ld	r8, Z
     346:	80 80       	ld	r8, Z
     348:	80 80       	ld	r8, Z
     34a:	f8 88       	ldd	r15, Y+16	; 0x10
     34c:	d8 a8       	ldd	r13, Y+48	; 0x30
     34e:	88 88       	ldd	r8, Y+16	; 0x10
     350:	88 88       	ldd	r8, Y+16	; 0x10
     352:	88 88       	ldd	r8, Y+16	; 0x10
     354:	c8 a8       	ldd	r12, Y+48	; 0x30
     356:	98 88       	ldd	r9, Y+16	; 0x10
     358:	88 70       	andi	r24, 0x08	; 8
     35a:	88 88       	ldd	r8, Y+16	; 0x10
     35c:	88 88       	ldd	r8, Y+16	; 0x10
     35e:	88 70       	andi	r24, 0x08	; 8
     360:	f0 88       	ldd	r15, Z+16	; 0x10
     362:	88 f0       	brcs	.+34     	; 0x386 <__trampolines_end+0x176>
     364:	80 80       	ld	r8, Z
     366:	80 70       	andi	r24, 0x00	; 0
     368:	88 88       	ldd	r8, Y+16	; 0x10
     36a:	88 a8       	ldd	r8, Y+48	; 0x30
     36c:	90 68       	ori	r25, 0x80	; 128
     36e:	f0 88       	ldd	r15, Z+16	; 0x10
     370:	88 f0       	brcs	.+34     	; 0x394 <__trampolines_end+0x184>
     372:	a0 90 88 78 	lds	r10, 0x7888	; 0x807888 <__bss_end+0x54c5>
     376:	80 80       	ld	r8, Z
     378:	70 08       	sbc	r7, r0
     37a:	08 f0       	brcs	.+2      	; 0x37e <__trampolines_end+0x16e>
     37c:	f8 20       	and	r15, r8
     37e:	20 20       	and	r2, r0
     380:	20 20       	and	r2, r0
     382:	20 88       	ldd	r2, Z+16	; 0x10
     384:	88 88       	ldd	r8, Y+16	; 0x10
     386:	88 88       	ldd	r8, Y+16	; 0x10
     388:	88 70       	andi	r24, 0x08	; 8
     38a:	88 88       	ldd	r8, Y+16	; 0x10
     38c:	88 88       	ldd	r8, Y+16	; 0x10
     38e:	88 50       	subi	r24, 0x08	; 8
     390:	20 88       	ldd	r2, Z+16	; 0x10
     392:	88 88       	ldd	r8, Y+16	; 0x10
     394:	a8 a8       	ldd	r10, Y+48	; 0x30
     396:	d8 88       	ldd	r13, Y+16	; 0x10
     398:	88 88       	ldd	r8, Y+16	; 0x10
     39a:	50 20       	and	r5, r0
     39c:	50 88       	ldd	r5, Z+16	; 0x10
     39e:	88 88       	ldd	r8, Y+16	; 0x10
     3a0:	88 50       	subi	r24, 0x08	; 8
     3a2:	20 20       	and	r2, r0
     3a4:	20 20       	and	r2, r0
     3a6:	f8 08       	sbc	r15, r8
     3a8:	10 20       	and	r1, r0
     3aa:	40 80       	ld	r4, Z
     3ac:	f8 38       	cpi	r31, 0x88	; 136
     3ae:	20 20       	and	r2, r0
     3b0:	20 20       	and	r2, r0
     3b2:	20 38       	cpi	r18, 0x80	; 128
     3b4:	00 80       	ld	r0, Z
     3b6:	40 20       	and	r4, r0
     3b8:	10 08       	sbc	r1, r0
     3ba:	00 e0       	ldi	r16, 0x00	; 0
     3bc:	20 20       	and	r2, r0
     3be:	20 20       	and	r2, r0
     3c0:	20 e0       	ldi	r18, 0x00	; 0
     3c2:	20 50       	subi	r18, 0x00	; 0
     3c4:	88 00       	.word	0x0088	; ????
	...
     3ce:	00 f8       	bld	r0, 0
     3d0:	40 20       	and	r4, r0
     3d2:	10 00       	.word	0x0010	; ????
     3d4:	00 00       	nop
     3d6:	00 00       	nop
     3d8:	00 70       	andi	r16, 0x00	; 0
     3da:	08 78       	andi	r16, 0x88	; 136
     3dc:	88 78       	andi	r24, 0x88	; 136
     3de:	80 80       	ld	r8, Z
     3e0:	b0 c8       	rjmp	.-3744   	; 0xfffff542 <__eeprom_end+0xff7ef542>
     3e2:	88 88       	ldd	r8, Y+16	; 0x10
     3e4:	f0 00       	.word	0x00f0	; ????
     3e6:	00 70       	andi	r16, 0x00	; 0
     3e8:	80 80       	ld	r8, Z
     3ea:	88 70       	andi	r24, 0x08	; 8
     3ec:	08 08       	sbc	r0, r8
     3ee:	68 98       	cbi	0x0d, 0	; 13
     3f0:	88 88       	ldd	r8, Y+16	; 0x10
     3f2:	78 00       	.word	0x0078	; ????
     3f4:	00 70       	andi	r16, 0x00	; 0
     3f6:	88 f8       	.word	0xf888	; ????
     3f8:	80 70       	andi	r24, 0x00	; 0
     3fa:	30 48       	sbci	r19, 0x80	; 128
     3fc:	40 e0       	ldi	r20, 0x00	; 0
     3fe:	40 40       	sbci	r20, 0x00	; 0
     400:	40 00       	.word	0x0040	; ????
     402:	00 78       	andi	r16, 0x80	; 128
     404:	88 78       	andi	r24, 0x88	; 136
     406:	08 30       	cpi	r16, 0x08	; 8
     408:	80 80       	ld	r8, Z
     40a:	b0 c8       	rjmp	.-3744   	; 0xfffff56c <__eeprom_end+0xff7ef56c>
     40c:	88 88       	ldd	r8, Y+16	; 0x10
     40e:	88 20       	and	r8, r8
     410:	00 60       	ori	r16, 0x00	; 0
     412:	20 20       	and	r2, r0
     414:	20 70       	andi	r18, 0x00	; 0
     416:	10 00       	.word	0x0010	; ????
     418:	30 10       	cpse	r3, r0
     41a:	10 90 60 40 	lds	r1, 0x4060	; 0x804060 <__bss_end+0x1c9d>
     41e:	40 48       	sbci	r20, 0x80	; 128
     420:	50 60       	ori	r21, 0x00	; 0
     422:	50 48       	sbci	r21, 0x80	; 128
     424:	60 20       	and	r6, r0
     426:	20 20       	and	r2, r0
     428:	20 20       	and	r2, r0
     42a:	70 00       	.word	0x0070	; ????
     42c:	00 d0       	rcall	.+0      	; 0x42e <__FUSE_REGION_LENGTH__+0x2e>
     42e:	a8 a8       	ldd	r10, Y+48	; 0x30
     430:	88 88       	ldd	r8, Y+16	; 0x10
     432:	00 00       	nop
     434:	b0 c8       	rjmp	.-3744   	; 0xfffff596 <__eeprom_end+0xff7ef596>
     436:	88 88       	ldd	r8, Y+16	; 0x10
     438:	88 00       	.word	0x0088	; ????
     43a:	00 70       	andi	r16, 0x00	; 0
     43c:	88 88       	ldd	r8, Y+16	; 0x10
     43e:	88 70       	andi	r24, 0x08	; 8
     440:	00 00       	nop
     442:	f0 88       	ldd	r15, Z+16	; 0x10
     444:	f0 80       	ld	r15, Z
     446:	80 00       	.word	0x0080	; ????
     448:	00 68       	ori	r16, 0x80	; 128
     44a:	98 78       	andi	r25, 0x88	; 136
     44c:	08 08       	sbc	r0, r8
     44e:	00 00       	nop
     450:	b0 c8       	rjmp	.-3744   	; 0xfffff5b2 <__eeprom_end+0xff7ef5b2>
     452:	80 80       	ld	r8, Z
     454:	80 00       	.word	0x0080	; ????
     456:	00 70       	andi	r16, 0x00	; 0
     458:	80 70       	andi	r24, 0x00	; 0
     45a:	08 f0       	brcs	.+2      	; 0x45e <__FUSE_REGION_LENGTH__+0x5e>
     45c:	40 40       	sbci	r20, 0x00	; 0
     45e:	e0 40       	sbci	r30, 0x00	; 0
     460:	40 48       	sbci	r20, 0x80	; 128
     462:	30 00       	.word	0x0030	; ????
     464:	00 88       	ldd	r0, Z+16	; 0x10
     466:	88 88       	ldd	r8, Y+16	; 0x10
     468:	98 68       	ori	r25, 0x88	; 136
     46a:	00 00       	nop
     46c:	88 88       	ldd	r8, Y+16	; 0x10
     46e:	88 50       	subi	r24, 0x08	; 8
     470:	20 00       	.word	0x0020	; ????
     472:	00 88       	ldd	r0, Z+16	; 0x10
     474:	88 a8       	ldd	r8, Y+48	; 0x30
     476:	a8 50       	subi	r26, 0x08	; 8
     478:	00 00       	nop
     47a:	88 50       	subi	r24, 0x08	; 8
     47c:	20 50       	subi	r18, 0x00	; 0
     47e:	88 00       	.word	0x0088	; ????
     480:	00 88       	ldd	r0, Z+16	; 0x10
     482:	88 78       	andi	r24, 0x88	; 136
     484:	08 70       	andi	r16, 0x08	; 8
     486:	00 00       	nop
     488:	f8 10       	cpse	r15, r8
     48a:	20 40       	sbci	r18, 0x00	; 0
     48c:	f8 10       	cpse	r15, r8
     48e:	20 20       	and	r2, r0
     490:	40 20       	and	r4, r0
     492:	20 10       	cpse	r2, r0
     494:	20 20       	and	r2, r0
     496:	20 20       	and	r2, r0
     498:	20 20       	and	r2, r0
     49a:	20 40       	sbci	r18, 0x00	; 0
     49c:	20 20       	and	r2, r0
     49e:	10 20       	and	r1, r0
     4a0:	20 40       	sbci	r18, 0x00	; 0

000004a2 <__ctors_end>:
     4a2:	11 24       	eor	r1, r1
     4a4:	1f be       	out	0x3f, r1	; 63
     4a6:	cf ef       	ldi	r28, 0xFF	; 255
     4a8:	cd bf       	out	0x3d, r28	; 61
     4aa:	df e5       	ldi	r29, 0x5F	; 95
     4ac:	de bf       	out	0x3e, r29	; 62
     4ae:	00 e0       	ldi	r16, 0x00	; 0
     4b0:	0c bf       	out	0x3c, r16	; 60

000004b2 <__do_copy_data>:
     4b2:	10 e2       	ldi	r17, 0x20	; 32
     4b4:	a0 e0       	ldi	r26, 0x00	; 0
     4b6:	b0 e2       	ldi	r27, 0x20	; 32
     4b8:	ea e5       	ldi	r30, 0x5A	; 90
     4ba:	f0 e4       	ldi	r31, 0x40	; 64
     4bc:	00 e0       	ldi	r16, 0x00	; 0
     4be:	0b bf       	out	0x3b, r16	; 59
     4c0:	02 c0       	rjmp	.+4      	; 0x4c6 <__do_copy_data+0x14>
     4c2:	07 90       	elpm	r0, Z+
     4c4:	0d 92       	st	X+, r0
     4c6:	a4 36       	cpi	r26, 0x64	; 100
     4c8:	b1 07       	cpc	r27, r17
     4ca:	d9 f7       	brne	.-10     	; 0x4c2 <__do_copy_data+0x10>

000004cc <__do_clear_bss>:
     4cc:	23 e2       	ldi	r18, 0x23	; 35
     4ce:	a4 e6       	ldi	r26, 0x64	; 100
     4d0:	b0 e2       	ldi	r27, 0x20	; 32
     4d2:	01 c0       	rjmp	.+2      	; 0x4d6 <.do_clear_bss_start>

000004d4 <.do_clear_bss_loop>:
     4d4:	1d 92       	st	X+, r1

000004d6 <.do_clear_bss_start>:
     4d6:	a3 3c       	cpi	r26, 0xC3	; 195
     4d8:	b2 07       	cpc	r27, r18
     4da:	e1 f7       	brne	.-8      	; 0x4d4 <.do_clear_bss_loop>
     4dc:	0e 94 4d 1b 	call	0x369a	; 0x369a <main>
     4e0:	0c 94 2b 20 	jmp	0x4056	; 0x4056 <_exit>

000004e4 <__bad_interrupt>:
     4e4:	8d cd       	rjmp	.-1254   	; 0x0 <__vectors>

000004e6 <st7565r_init>:
 * Call this function to initialize the hardware interface and the LCD
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void st7565r_init(void)
{
     4e6:	bf 92       	push	r11
     4e8:	cf 92       	push	r12
     4ea:	df 92       	push	r13
     4ec:	ef 92       	push	r14
     4ee:	ff 92       	push	r15
     4f0:	0f 93       	push	r16
     4f2:	1f 93       	push	r17
     4f4:	cf 93       	push	r28
     4f6:	df 93       	push	r29
     4f8:	1f 92       	push	r1
     4fa:	cd b7       	in	r28, 0x3d	; 61
     4fc:	de b7       	in	r29, 0x3e	; 62
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     4fe:	e0 e0       	ldi	r30, 0x00	; 0
     500:	f6 e0       	ldi	r31, 0x06	; 6
     502:	88 e0       	ldi	r24, 0x08	; 8
     504:	86 83       	std	Z+6, r24	; 0x06
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     506:	85 83       	std	Z+5, r24	; 0x05
	spi_flags_t spi_flags = SPI_MODE_3;
	board_spi_select_id_t spi_select_id = 0;
#endif

#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {
     508:	0f 2e       	mov	r0, r31
     50a:	fb e2       	ldi	r31, 0x2B	; 43
     50c:	bf 2e       	mov	r11, r31
     50e:	f0 2d       	mov	r31, r0
     510:	b9 82       	std	Y+1, r11	; 0x01
		.id = ST7565R_CS_PIN,
	};
	usart_spi_init(ST7565R_USART_SPI);
     512:	80 ea       	ldi	r24, 0xA0	; 160
     514:	99 e0       	ldi	r25, 0x09	; 9
     516:	09 d4       	rcall	.+2066   	; 0xd2a <usart_spi_init>
	usart_spi_setup_device(ST7565R_USART_SPI, &device, spi_flags,
     518:	c1 2c       	mov	r12, r1
     51a:	d1 2c       	mov	r13, r1
     51c:	76 01       	movw	r14, r12
     51e:	00 e4       	ldi	r16, 0x40	; 64
     520:	12 e4       	ldi	r17, 0x42	; 66
     522:	2f e0       	ldi	r18, 0x0F	; 15
     524:	30 e0       	ldi	r19, 0x00	; 0
     526:	43 e0       	ldi	r20, 0x03	; 3
     528:	be 01       	movw	r22, r28
     52a:	6f 5f       	subi	r22, 0xFF	; 255
     52c:	7f 4f       	sbci	r23, 0xFF	; 255
     52e:	80 ea       	ldi	r24, 0xA0	; 160
     530:	99 e0       	ldi	r25, 0x09	; 9
     532:	2a d4       	rcall	.+2132   	; 0xd88 <usart_spi_setup_device>
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     534:	00 e6       	ldi	r16, 0x60	; 96
     536:	16 e0       	ldi	r17, 0x06	; 6
     538:	ff 24       	eor	r15, r15
     53a:	f3 94       	inc	r15
     53c:	f8 01       	movw	r30, r16
     53e:	f6 82       	std	Z+6, r15	; 0x06
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     540:	b9 82       	std	Y+1, r11	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     542:	be 01       	movw	r22, r28
     544:	6f 5f       	subi	r22, 0xFF	; 255
     546:	7f 4f       	sbci	r23, 0xFF	; 255
     548:	80 ea       	ldi	r24, 0xA0	; 160
     54a:	99 e0       	ldi	r25, 0x09	; 9
     54c:	37 d4       	rcall	.+2158   	; 0xdbc <usart_spi_select_device>
     54e:	f8 01       	movw	r30, r16
     550:	f6 82       	std	Z+6, r15	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     552:	e0 ea       	ldi	r30, 0xA0	; 160
     554:	f9 e0       	ldi	r31, 0x09	; 9
     556:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     558:	85 ff       	sbrs	r24, 5
     55a:	fd cf       	rjmp	.-6      	; 0x556 <st7565r_init+0x70>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     55c:	80 ea       	ldi	r24, 0xA0	; 160
     55e:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     562:	e0 ea       	ldi	r30, 0xA0	; 160
     564:	f9 e0       	ldi	r31, 0x09	; 9
     566:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     568:	86 ff       	sbrs	r24, 6
     56a:	fd cf       	rjmp	.-6      	; 0x566 <st7565r_init+0x80>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     56c:	e0 ea       	ldi	r30, 0xA0	; 160
     56e:	f9 e0       	ldi	r31, 0x09	; 9
     570:	80 e4       	ldi	r24, 0x40	; 64
     572:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     574:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     576:	be 01       	movw	r22, r28
     578:	6f 5f       	subi	r22, 0xFF	; 255
     57a:	7f 4f       	sbci	r23, 0xFF	; 255
     57c:	80 ea       	ldi	r24, 0xA0	; 160
     57e:	99 e0       	ldi	r25, 0x09	; 9
     580:	33 d4       	rcall	.+2150   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     582:	8b e2       	ldi	r24, 0x2B	; 43
     584:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     586:	be 01       	movw	r22, r28
     588:	6f 5f       	subi	r22, 0xFF	; 255
     58a:	7f 4f       	sbci	r23, 0xFF	; 255
     58c:	80 ea       	ldi	r24, 0xA0	; 160
     58e:	99 e0       	ldi	r25, 0x09	; 9
     590:	15 d4       	rcall	.+2090   	; 0xdbc <usart_spi_select_device>
     592:	81 e0       	ldi	r24, 0x01	; 1
     594:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     598:	e0 ea       	ldi	r30, 0xA0	; 160
     59a:	f9 e0       	ldi	r31, 0x09	; 9
     59c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     59e:	85 ff       	sbrs	r24, 5
     5a0:	fd cf       	rjmp	.-6      	; 0x59c <st7565r_init+0xb6>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     5a2:	86 ea       	ldi	r24, 0xA6	; 166
     5a4:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     5a8:	e0 ea       	ldi	r30, 0xA0	; 160
     5aa:	f9 e0       	ldi	r31, 0x09	; 9
     5ac:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     5ae:	86 ff       	sbrs	r24, 6
     5b0:	fd cf       	rjmp	.-6      	; 0x5ac <st7565r_init+0xc6>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     5b2:	e0 ea       	ldi	r30, 0xA0	; 160
     5b4:	f9 e0       	ldi	r31, 0x09	; 9
     5b6:	80 e4       	ldi	r24, 0x40	; 64
     5b8:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     5ba:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     5bc:	be 01       	movw	r22, r28
     5be:	6f 5f       	subi	r22, 0xFF	; 255
     5c0:	7f 4f       	sbci	r23, 0xFF	; 255
     5c2:	80 ea       	ldi	r24, 0xA0	; 160
     5c4:	99 e0       	ldi	r25, 0x09	; 9
     5c6:	10 d4       	rcall	.+2080   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     5c8:	8b e2       	ldi	r24, 0x2B	; 43
     5ca:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     5cc:	be 01       	movw	r22, r28
     5ce:	6f 5f       	subi	r22, 0xFF	; 255
     5d0:	7f 4f       	sbci	r23, 0xFF	; 255
     5d2:	80 ea       	ldi	r24, 0xA0	; 160
     5d4:	99 e0       	ldi	r25, 0x09	; 9
     5d6:	f2 d3       	rcall	.+2020   	; 0xdbc <usart_spi_select_device>
     5d8:	81 e0       	ldi	r24, 0x01	; 1
     5da:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     5de:	e0 ea       	ldi	r30, 0xA0	; 160
     5e0:	f9 e0       	ldi	r31, 0x09	; 9
     5e2:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     5e4:	85 ff       	sbrs	r24, 5
     5e6:	fd cf       	rjmp	.-6      	; 0x5e2 <st7565r_init+0xfc>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     5e8:	88 ec       	ldi	r24, 0xC8	; 200
     5ea:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     5ee:	e0 ea       	ldi	r30, 0xA0	; 160
     5f0:	f9 e0       	ldi	r31, 0x09	; 9
     5f2:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     5f4:	86 ff       	sbrs	r24, 6
     5f6:	fd cf       	rjmp	.-6      	; 0x5f2 <st7565r_init+0x10c>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     5f8:	e0 ea       	ldi	r30, 0xA0	; 160
     5fa:	f9 e0       	ldi	r31, 0x09	; 9
     5fc:	80 e4       	ldi	r24, 0x40	; 64
     5fe:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     600:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     602:	be 01       	movw	r22, r28
     604:	6f 5f       	subi	r22, 0xFF	; 255
     606:	7f 4f       	sbci	r23, 0xFF	; 255
     608:	80 ea       	ldi	r24, 0xA0	; 160
     60a:	99 e0       	ldi	r25, 0x09	; 9
     60c:	ed d3       	rcall	.+2010   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     60e:	8b e2       	ldi	r24, 0x2B	; 43
     610:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     612:	be 01       	movw	r22, r28
     614:	6f 5f       	subi	r22, 0xFF	; 255
     616:	7f 4f       	sbci	r23, 0xFF	; 255
     618:	80 ea       	ldi	r24, 0xA0	; 160
     61a:	99 e0       	ldi	r25, 0x09	; 9
     61c:	cf d3       	rcall	.+1950   	; 0xdbc <usart_spi_select_device>
     61e:	81 e0       	ldi	r24, 0x01	; 1
     620:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     624:	e0 ea       	ldi	r30, 0xA0	; 160
     626:	f9 e0       	ldi	r31, 0x09	; 9
     628:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     62a:	85 ff       	sbrs	r24, 5
     62c:	fd cf       	rjmp	.-6      	; 0x628 <st7565r_init+0x142>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     62e:	82 ea       	ldi	r24, 0xA2	; 162
     630:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     634:	e0 ea       	ldi	r30, 0xA0	; 160
     636:	f9 e0       	ldi	r31, 0x09	; 9
     638:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     63a:	86 ff       	sbrs	r24, 6
     63c:	fd cf       	rjmp	.-6      	; 0x638 <st7565r_init+0x152>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     63e:	e0 ea       	ldi	r30, 0xA0	; 160
     640:	f9 e0       	ldi	r31, 0x09	; 9
     642:	80 e4       	ldi	r24, 0x40	; 64
     644:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     646:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     648:	be 01       	movw	r22, r28
     64a:	6f 5f       	subi	r22, 0xFF	; 255
     64c:	7f 4f       	sbci	r23, 0xFF	; 255
     64e:	80 ea       	ldi	r24, 0xA0	; 160
     650:	99 e0       	ldi	r25, 0x09	; 9
     652:	ca d3       	rcall	.+1940   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     654:	8b e2       	ldi	r24, 0x2B	; 43
     656:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     658:	be 01       	movw	r22, r28
     65a:	6f 5f       	subi	r22, 0xFF	; 255
     65c:	7f 4f       	sbci	r23, 0xFF	; 255
     65e:	80 ea       	ldi	r24, 0xA0	; 160
     660:	99 e0       	ldi	r25, 0x09	; 9
     662:	ac d3       	rcall	.+1880   	; 0xdbc <usart_spi_select_device>
     664:	81 e0       	ldi	r24, 0x01	; 1
     666:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     66a:	e0 ea       	ldi	r30, 0xA0	; 160
     66c:	f9 e0       	ldi	r31, 0x09	; 9
     66e:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     670:	85 ff       	sbrs	r24, 5
     672:	fd cf       	rjmp	.-6      	; 0x66e <st7565r_init+0x188>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     674:	8f e2       	ldi	r24, 0x2F	; 47
     676:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     67a:	e0 ea       	ldi	r30, 0xA0	; 160
     67c:	f9 e0       	ldi	r31, 0x09	; 9
     67e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     680:	86 ff       	sbrs	r24, 6
     682:	fd cf       	rjmp	.-6      	; 0x67e <st7565r_init+0x198>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     684:	e0 ea       	ldi	r30, 0xA0	; 160
     686:	f9 e0       	ldi	r31, 0x09	; 9
     688:	80 e4       	ldi	r24, 0x40	; 64
     68a:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     68c:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     68e:	be 01       	movw	r22, r28
     690:	6f 5f       	subi	r22, 0xFF	; 255
     692:	7f 4f       	sbci	r23, 0xFF	; 255
     694:	80 ea       	ldi	r24, 0xA0	; 160
     696:	99 e0       	ldi	r25, 0x09	; 9
     698:	a7 d3       	rcall	.+1870   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     69a:	8b e2       	ldi	r24, 0x2B	; 43
     69c:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     69e:	be 01       	movw	r22, r28
     6a0:	6f 5f       	subi	r22, 0xFF	; 255
     6a2:	7f 4f       	sbci	r23, 0xFF	; 255
     6a4:	80 ea       	ldi	r24, 0xA0	; 160
     6a6:	99 e0       	ldi	r25, 0x09	; 9
     6a8:	89 d3       	rcall	.+1810   	; 0xdbc <usart_spi_select_device>
     6aa:	81 e0       	ldi	r24, 0x01	; 1
     6ac:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     6b0:	e0 ea       	ldi	r30, 0xA0	; 160
     6b2:	f9 e0       	ldi	r31, 0x09	; 9
     6b4:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     6b6:	85 ff       	sbrs	r24, 5
     6b8:	fd cf       	rjmp	.-6      	; 0x6b4 <st7565r_init+0x1ce>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     6ba:	88 ef       	ldi	r24, 0xF8	; 248
     6bc:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     6c0:	e0 ea       	ldi	r30, 0xA0	; 160
     6c2:	f9 e0       	ldi	r31, 0x09	; 9
     6c4:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     6c6:	86 ff       	sbrs	r24, 6
     6c8:	fd cf       	rjmp	.-6      	; 0x6c4 <st7565r_init+0x1de>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     6ca:	e0 ea       	ldi	r30, 0xA0	; 160
     6cc:	f9 e0       	ldi	r31, 0x09	; 9
     6ce:	80 e4       	ldi	r24, 0x40	; 64
     6d0:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     6d2:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     6d4:	be 01       	movw	r22, r28
     6d6:	6f 5f       	subi	r22, 0xFF	; 255
     6d8:	7f 4f       	sbci	r23, 0xFF	; 255
     6da:	80 ea       	ldi	r24, 0xA0	; 160
     6dc:	99 e0       	ldi	r25, 0x09	; 9
     6de:	84 d3       	rcall	.+1800   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     6e0:	8b e2       	ldi	r24, 0x2B	; 43
     6e2:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     6e4:	be 01       	movw	r22, r28
     6e6:	6f 5f       	subi	r22, 0xFF	; 255
     6e8:	7f 4f       	sbci	r23, 0xFF	; 255
     6ea:	80 ea       	ldi	r24, 0xA0	; 160
     6ec:	99 e0       	ldi	r25, 0x09	; 9
     6ee:	66 d3       	rcall	.+1740   	; 0xdbc <usart_spi_select_device>
     6f0:	81 e0       	ldi	r24, 0x01	; 1
     6f2:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     6f6:	e0 ea       	ldi	r30, 0xA0	; 160
     6f8:	f9 e0       	ldi	r31, 0x09	; 9
     6fa:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     6fc:	85 ff       	sbrs	r24, 5
     6fe:	fd cf       	rjmp	.-6      	; 0x6fa <st7565r_init+0x214>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     700:	10 92 a0 09 	sts	0x09A0, r1	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     704:	e0 ea       	ldi	r30, 0xA0	; 160
     706:	f9 e0       	ldi	r31, 0x09	; 9
     708:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     70a:	86 ff       	sbrs	r24, 6
     70c:	fd cf       	rjmp	.-6      	; 0x708 <st7565r_init+0x222>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     70e:	e0 ea       	ldi	r30, 0xA0	; 160
     710:	f9 e0       	ldi	r31, 0x09	; 9
     712:	80 e4       	ldi	r24, 0x40	; 64
     714:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     716:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     718:	be 01       	movw	r22, r28
     71a:	6f 5f       	subi	r22, 0xFF	; 255
     71c:	7f 4f       	sbci	r23, 0xFF	; 255
     71e:	80 ea       	ldi	r24, 0xA0	; 160
     720:	99 e0       	ldi	r25, 0x09	; 9
     722:	62 d3       	rcall	.+1732   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     724:	8b e2       	ldi	r24, 0x2B	; 43
     726:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     728:	be 01       	movw	r22, r28
     72a:	6f 5f       	subi	r22, 0xFF	; 255
     72c:	7f 4f       	sbci	r23, 0xFF	; 255
     72e:	80 ea       	ldi	r24, 0xA0	; 160
     730:	99 e0       	ldi	r25, 0x09	; 9
     732:	44 d3       	rcall	.+1672   	; 0xdbc <usart_spi_select_device>
     734:	81 e0       	ldi	r24, 0x01	; 1
     736:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     73a:	e0 ea       	ldi	r30, 0xA0	; 160
     73c:	f9 e0       	ldi	r31, 0x09	; 9
     73e:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     740:	85 ff       	sbrs	r24, 5
     742:	fd cf       	rjmp	.-6      	; 0x73e <st7565r_init+0x258>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     744:	81 e2       	ldi	r24, 0x21	; 33
     746:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     74a:	e0 ea       	ldi	r30, 0xA0	; 160
     74c:	f9 e0       	ldi	r31, 0x09	; 9
     74e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     750:	86 ff       	sbrs	r24, 6
     752:	fd cf       	rjmp	.-6      	; 0x74e <st7565r_init+0x268>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     754:	e0 ea       	ldi	r30, 0xA0	; 160
     756:	f9 e0       	ldi	r31, 0x09	; 9
     758:	80 e4       	ldi	r24, 0x40	; 64
     75a:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     75c:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     75e:	be 01       	movw	r22, r28
     760:	6f 5f       	subi	r22, 0xFF	; 255
     762:	7f 4f       	sbci	r23, 0xFF	; 255
     764:	80 ea       	ldi	r24, 0xA0	; 160
     766:	99 e0       	ldi	r25, 0x09	; 9
     768:	3f d3       	rcall	.+1662   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     76a:	8b e2       	ldi	r24, 0x2B	; 43
     76c:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     76e:	be 01       	movw	r22, r28
     770:	6f 5f       	subi	r22, 0xFF	; 255
     772:	7f 4f       	sbci	r23, 0xFF	; 255
     774:	80 ea       	ldi	r24, 0xA0	; 160
     776:	99 e0       	ldi	r25, 0x09	; 9
     778:	21 d3       	rcall	.+1602   	; 0xdbc <usart_spi_select_device>
     77a:	81 e0       	ldi	r24, 0x01	; 1
     77c:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     780:	e0 ea       	ldi	r30, 0xA0	; 160
     782:	f9 e0       	ldi	r31, 0x09	; 9
     784:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     786:	85 ff       	sbrs	r24, 5
     788:	fd cf       	rjmp	.-6      	; 0x784 <st7565r_init+0x29e>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     78a:	81 e8       	ldi	r24, 0x81	; 129
     78c:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     790:	e0 ea       	ldi	r30, 0xA0	; 160
     792:	f9 e0       	ldi	r31, 0x09	; 9
     794:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     796:	86 ff       	sbrs	r24, 6
     798:	fd cf       	rjmp	.-6      	; 0x794 <st7565r_init+0x2ae>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     79a:	e0 ea       	ldi	r30, 0xA0	; 160
     79c:	f9 e0       	ldi	r31, 0x09	; 9
     79e:	80 e4       	ldi	r24, 0x40	; 64
     7a0:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     7a2:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     7a4:	be 01       	movw	r22, r28
     7a6:	6f 5f       	subi	r22, 0xFF	; 255
     7a8:	7f 4f       	sbci	r23, 0xFF	; 255
     7aa:	80 ea       	ldi	r24, 0xA0	; 160
     7ac:	99 e0       	ldi	r25, 0x09	; 9
     7ae:	1c d3       	rcall	.+1592   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     7b0:	8b e2       	ldi	r24, 0x2B	; 43
     7b2:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     7b4:	be 01       	movw	r22, r28
     7b6:	6f 5f       	subi	r22, 0xFF	; 255
     7b8:	7f 4f       	sbci	r23, 0xFF	; 255
     7ba:	80 ea       	ldi	r24, 0xA0	; 160
     7bc:	99 e0       	ldi	r25, 0x09	; 9
     7be:	fe d2       	rcall	.+1532   	; 0xdbc <usart_spi_select_device>
     7c0:	81 e0       	ldi	r24, 0x01	; 1
     7c2:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     7c6:	e0 ea       	ldi	r30, 0xA0	; 160
     7c8:	f9 e0       	ldi	r31, 0x09	; 9
     7ca:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     7cc:	85 ff       	sbrs	r24, 5
     7ce:	fd cf       	rjmp	.-6      	; 0x7ca <st7565r_init+0x2e4>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     7d0:	81 e2       	ldi	r24, 0x21	; 33
     7d2:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     7d6:	e0 ea       	ldi	r30, 0xA0	; 160
     7d8:	f9 e0       	ldi	r31, 0x09	; 9
     7da:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     7dc:	86 ff       	sbrs	r24, 6
     7de:	fd cf       	rjmp	.-6      	; 0x7da <st7565r_init+0x2f4>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     7e0:	e0 ea       	ldi	r30, 0xA0	; 160
     7e2:	f9 e0       	ldi	r31, 0x09	; 9
     7e4:	80 e4       	ldi	r24, 0x40	; 64
     7e6:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     7e8:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     7ea:	be 01       	movw	r22, r28
     7ec:	6f 5f       	subi	r22, 0xFF	; 255
     7ee:	7f 4f       	sbci	r23, 0xFF	; 255
     7f0:	80 ea       	ldi	r24, 0xA0	; 160
     7f2:	99 e0       	ldi	r25, 0x09	; 9
     7f4:	f9 d2       	rcall	.+1522   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     7f6:	8b e2       	ldi	r24, 0x2B	; 43
     7f8:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     7fa:	be 01       	movw	r22, r28
     7fc:	6f 5f       	subi	r22, 0xFF	; 255
     7fe:	7f 4f       	sbci	r23, 0xFF	; 255
     800:	80 ea       	ldi	r24, 0xA0	; 160
     802:	99 e0       	ldi	r25, 0x09	; 9
     804:	db d2       	rcall	.+1462   	; 0xdbc <usart_spi_select_device>
     806:	81 e0       	ldi	r24, 0x01	; 1
     808:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     80c:	e0 ea       	ldi	r30, 0xA0	; 160
     80e:	f9 e0       	ldi	r31, 0x09	; 9
     810:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     812:	85 ff       	sbrs	r24, 5
     814:	fd cf       	rjmp	.-6      	; 0x810 <st7565r_init+0x32a>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     816:	8f ea       	ldi	r24, 0xAF	; 175
     818:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     81c:	e0 ea       	ldi	r30, 0xA0	; 160
     81e:	f9 e0       	ldi	r31, 0x09	; 9
     820:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     822:	86 ff       	sbrs	r24, 6
     824:	fd cf       	rjmp	.-6      	; 0x820 <st7565r_init+0x33a>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     826:	e0 ea       	ldi	r30, 0xA0	; 160
     828:	f9 e0       	ldi	r31, 0x09	; 9
     82a:	80 e4       	ldi	r24, 0x40	; 64
     82c:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     82e:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     830:	be 01       	movw	r22, r28
     832:	6f 5f       	subi	r22, 0xFF	; 255
     834:	7f 4f       	sbci	r23, 0xFF	; 255
     836:	80 ea       	ldi	r24, 0xA0	; 160
     838:	99 e0       	ldi	r25, 0x09	; 9
     83a:	d6 d2       	rcall	.+1452   	; 0xde8 <usart_spi_deselect_device>
	is set to the defined min*/
	st7565r_set_contrast(ST7565R_DISPLAY_CONTRAST_MIN);

	// Turn on the display
	st7565r_display_on();
}
     83c:	0f 90       	pop	r0
     83e:	df 91       	pop	r29
     840:	cf 91       	pop	r28
     842:	1f 91       	pop	r17
     844:	0f 91       	pop	r16
     846:	ff 90       	pop	r15
     848:	ef 90       	pop	r14
     84a:	df 90       	pop	r13
     84c:	cf 90       	pop	r12
     84e:	bf 90       	pop	r11
     850:	08 95       	ret

00000852 <sysclk_enable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     852:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
     854:	f8 94       	cli

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
     856:	e8 2f       	mov	r30, r24
     858:	f0 e0       	ldi	r31, 0x00	; 0
     85a:	e0 59       	subi	r30, 0x90	; 144
     85c:	ff 4f       	sbci	r31, 0xFF	; 255
     85e:	60 95       	com	r22
     860:	80 81       	ld	r24, Z
     862:	68 23       	and	r22, r24
     864:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     866:	9f bf       	out	0x3f, r25	; 63
     868:	08 95       	ret

0000086a <sysclk_disable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     86a:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
     86c:	f8 94       	cli

void sysclk_disable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) |= id;
     86e:	e8 2f       	mov	r30, r24
     870:	f0 e0       	ldi	r31, 0x00	; 0
     872:	e0 59       	subi	r30, 0x90	; 144
     874:	ff 4f       	sbci	r31, 0xFF	; 255
     876:	80 81       	ld	r24, Z
     878:	68 2b       	or	r22, r24
     87a:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     87c:	9f bf       	out	0x3f, r25	; 63
     87e:	08 95       	ret

00000880 <gfx_mono_st7565r_put_byte>:
	gfx_mono_st7565r_put_byte(0, 0, 0xFF);
\endcode
 */
void gfx_mono_st7565r_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
     880:	ff 92       	push	r15
     882:	0f 93       	push	r16
     884:	1f 93       	push	r17
     886:	cf 93       	push	r28
     888:	df 93       	push	r29
     88a:	1f 92       	push	r1
     88c:	cd b7       	in	r28, 0x3d	; 61
     88e:	de b7       	in	r29, 0x3e	; 62
     890:	08 2f       	mov	r16, r24
     892:	f6 2e       	mov	r15, r22
     894:	14 2f       	mov	r17, r20
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_framebuffer_put_byte(page, column, data);
     896:	22 d1       	rcall	.+580    	; 0xadc <gfx_mono_framebuffer_put_byte>
 * \param address the page address
 */
static inline void st7565r_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
     898:	0f 70       	andi	r16, 0x0F	; 15
	st7565r_write_command(ST7565R_CMD_PAGE_ADDRESS_SET(address));
     89a:	00 6b       	ori	r16, 0xB0	; 176
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     89c:	8b e2       	ldi	r24, 0x2B	; 43
     89e:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     8a0:	be 01       	movw	r22, r28
     8a2:	6f 5f       	subi	r22, 0xFF	; 255
     8a4:	7f 4f       	sbci	r23, 0xFF	; 255
     8a6:	80 ea       	ldi	r24, 0xA0	; 160
     8a8:	99 e0       	ldi	r25, 0x09	; 9
     8aa:	88 d2       	rcall	.+1296   	; 0xdbc <usart_spi_select_device>
     8ac:	81 e0       	ldi	r24, 0x01	; 1
     8ae:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     8b2:	e0 ea       	ldi	r30, 0xA0	; 160
     8b4:	f9 e0       	ldi	r31, 0x09	; 9
     8b6:	91 81       	ldd	r25, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     8b8:	95 ff       	sbrs	r25, 5
     8ba:	fd cf       	rjmp	.-6      	; 0x8b6 <gfx_mono_st7565r_put_byte+0x36>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     8bc:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     8c0:	e0 ea       	ldi	r30, 0xA0	; 160
     8c2:	f9 e0       	ldi	r31, 0x09	; 9
     8c4:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     8c6:	86 ff       	sbrs	r24, 6
     8c8:	fd cf       	rjmp	.-6      	; 0x8c4 <gfx_mono_st7565r_put_byte+0x44>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     8ca:	e0 ea       	ldi	r30, 0xA0	; 160
     8cc:	f9 e0       	ldi	r31, 0x09	; 9
     8ce:	80 e4       	ldi	r24, 0x40	; 64
     8d0:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     8d2:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     8d4:	be 01       	movw	r22, r28
     8d6:	6f 5f       	subi	r22, 0xFF	; 255
     8d8:	7f 4f       	sbci	r23, 0xFF	; 255
     8da:	80 ea       	ldi	r24, 0xA0	; 160
     8dc:	99 e0       	ldi	r25, 0x09	; 9
     8de:	84 d2       	rcall	.+1288   	; 0xde8 <usart_spi_deselect_device>
 * \param address the column address
 */
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
     8e0:	0f 2d       	mov	r16, r15
     8e2:	0f 77       	andi	r16, 0x7F	; 127
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
     8e4:	02 95       	swap	r16
     8e6:	0f 70       	andi	r16, 0x0F	; 15
     8e8:	00 61       	ori	r16, 0x10	; 16
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     8ea:	8b e2       	ldi	r24, 0x2B	; 43
     8ec:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     8ee:	be 01       	movw	r22, r28
     8f0:	6f 5f       	subi	r22, 0xFF	; 255
     8f2:	7f 4f       	sbci	r23, 0xFF	; 255
     8f4:	80 ea       	ldi	r24, 0xA0	; 160
     8f6:	99 e0       	ldi	r25, 0x09	; 9
     8f8:	61 d2       	rcall	.+1218   	; 0xdbc <usart_spi_select_device>
     8fa:	81 e0       	ldi	r24, 0x01	; 1
     8fc:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     900:	e0 ea       	ldi	r30, 0xA0	; 160
     902:	f9 e0       	ldi	r31, 0x09	; 9
     904:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     906:	85 ff       	sbrs	r24, 5
     908:	fd cf       	rjmp	.-6      	; 0x904 <gfx_mono_st7565r_put_byte+0x84>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     90a:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     90e:	e0 ea       	ldi	r30, 0xA0	; 160
     910:	f9 e0       	ldi	r31, 0x09	; 9
     912:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     914:	86 ff       	sbrs	r24, 6
     916:	fd cf       	rjmp	.-6      	; 0x912 <gfx_mono_st7565r_put_byte+0x92>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     918:	e0 ea       	ldi	r30, 0xA0	; 160
     91a:	f9 e0       	ldi	r31, 0x09	; 9
     91c:	80 e4       	ldi	r24, 0x40	; 64
     91e:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     920:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     922:	be 01       	movw	r22, r28
     924:	6f 5f       	subi	r22, 0xFF	; 255
     926:	7f 4f       	sbci	r23, 0xFF	; 255
     928:	80 ea       	ldi	r24, 0xA0	; 160
     92a:	99 e0       	ldi	r25, 0x09	; 9
     92c:	5d d2       	rcall	.+1210   	; 0xde8 <usart_spi_deselect_device>
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_LSB(address & 0x0F));
     92e:	0f 2d       	mov	r16, r15
     930:	0f 70       	andi	r16, 0x0F	; 15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     932:	8b e2       	ldi	r24, 0x2B	; 43
     934:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     936:	be 01       	movw	r22, r28
     938:	6f 5f       	subi	r22, 0xFF	; 255
     93a:	7f 4f       	sbci	r23, 0xFF	; 255
     93c:	80 ea       	ldi	r24, 0xA0	; 160
     93e:	99 e0       	ldi	r25, 0x09	; 9
     940:	3d d2       	rcall	.+1146   	; 0xdbc <usart_spi_select_device>
     942:	81 e0       	ldi	r24, 0x01	; 1
     944:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     948:	e0 ea       	ldi	r30, 0xA0	; 160
     94a:	f9 e0       	ldi	r31, 0x09	; 9
     94c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     94e:	85 ff       	sbrs	r24, 5
     950:	fd cf       	rjmp	.-6      	; 0x94c <gfx_mono_st7565r_put_byte+0xcc>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     952:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     956:	e0 ea       	ldi	r30, 0xA0	; 160
     958:	f9 e0       	ldi	r31, 0x09	; 9
     95a:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     95c:	86 ff       	sbrs	r24, 6
     95e:	fd cf       	rjmp	.-6      	; 0x95a <gfx_mono_st7565r_put_byte+0xda>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     960:	e0 ea       	ldi	r30, 0xA0	; 160
     962:	f9 e0       	ldi	r31, 0x09	; 9
     964:	80 e4       	ldi	r24, 0x40	; 64
     966:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     968:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     96a:	be 01       	movw	r22, r28
     96c:	6f 5f       	subi	r22, 0xFF	; 255
     96e:	7f 4f       	sbci	r23, 0xFF	; 255
     970:	80 ea       	ldi	r24, 0xA0	; 160
     972:	99 e0       	ldi	r25, 0x09	; 9
     974:	39 d2       	rcall	.+1138   	; 0xde8 <usart_spi_deselect_device>
 * \param data the data to write
 */
static inline void st7565r_write_data(uint8_t data)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     976:	8b e2       	ldi	r24, 0x2B	; 43
     978:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     97a:	be 01       	movw	r22, r28
     97c:	6f 5f       	subi	r22, 0xFF	; 255
     97e:	7f 4f       	sbci	r23, 0xFF	; 255
     980:	80 ea       	ldi	r24, 0xA0	; 160
     982:	99 e0       	ldi	r25, 0x09	; 9
     984:	1b d2       	rcall	.+1078   	; 0xdbc <usart_spi_select_device>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     986:	81 e0       	ldi	r24, 0x01	; 1
     988:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x700665>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     98c:	e0 ea       	ldi	r30, 0xA0	; 160
     98e:	f9 e0       	ldi	r31, 0x09	; 9
     990:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     992:	85 ff       	sbrs	r24, 5
     994:	fd cf       	rjmp	.-6      	; 0x990 <gfx_mono_st7565r_put_byte+0x110>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     996:	10 93 a0 09 	sts	0x09A0, r17	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     99a:	e0 ea       	ldi	r30, 0xA0	; 160
     99c:	f9 e0       	ldi	r31, 0x09	; 9
     99e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     9a0:	86 ff       	sbrs	r24, 6
     9a2:	fd cf       	rjmp	.-6      	; 0x99e <gfx_mono_st7565r_put_byte+0x11e>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     9a4:	e0 ea       	ldi	r30, 0xA0	; 160
     9a6:	f9 e0       	ldi	r31, 0x09	; 9
     9a8:	80 e4       	ldi	r24, 0x40	; 64
     9aa:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     9ac:	80 81       	ld	r24, Z
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     9ae:	81 e0       	ldi	r24, 0x01	; 1
     9b0:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
	ioport_set_pin_high(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, data);
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     9b4:	be 01       	movw	r22, r28
     9b6:	6f 5f       	subi	r22, 0xFF	; 255
     9b8:	7f 4f       	sbci	r23, 0xFF	; 255
     9ba:	80 ea       	ldi	r24, 0xA0	; 160
     9bc:	99 e0       	ldi	r25, 0x09	; 9
     9be:	14 d2       	rcall	.+1064   	; 0xde8 <usart_spi_deselect_device>

	st7565r_set_page_address(page);
	st7565r_set_column_address(column);

	st7565r_write_data(data);
}
     9c0:	0f 90       	pop	r0
     9c2:	df 91       	pop	r29
     9c4:	cf 91       	pop	r28
     9c6:	1f 91       	pop	r17
     9c8:	0f 91       	pop	r16
     9ca:	ff 90       	pop	r15
     9cc:	08 95       	ret

000009ce <gfx_mono_st7565r_init>:
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     9ce:	0f 93       	push	r16
     9d0:	1f 93       	push	r17
     9d2:	cf 93       	push	r28
     9d4:	df 93       	push	r29
     9d6:	1f 92       	push	r1
     9d8:	cd b7       	in	r28, 0x3d	; 61
     9da:	de b7       	in	r29, 0x3e	; 62
	uint8_t page;
	uint8_t column;

#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_set_framebuffer(framebuffer);
     9dc:	84 e6       	ldi	r24, 0x64	; 100
     9de:	90 e2       	ldi	r25, 0x20	; 32
     9e0:	78 d0       	rcall	.+240    	; 0xad2 <gfx_mono_set_framebuffer>
#endif

	/* Initialize the low-level display controller. */
	st7565r_init();
     9e2:	81 dd       	rcall	.-1278   	; 0x4e6 <st7565r_init>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     9e4:	8b e2       	ldi	r24, 0x2B	; 43
     9e6:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     9e8:	be 01       	movw	r22, r28
     9ea:	6f 5f       	subi	r22, 0xFF	; 255
     9ec:	7f 4f       	sbci	r23, 0xFF	; 255
     9ee:	80 ea       	ldi	r24, 0xA0	; 160
     9f0:	99 e0       	ldi	r25, 0x09	; 9
     9f2:	e4 d1       	rcall	.+968    	; 0xdbc <usart_spi_select_device>
     9f4:	81 e0       	ldi	r24, 0x01	; 1
     9f6:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     9fa:	e0 ea       	ldi	r30, 0xA0	; 160
     9fc:	f9 e0       	ldi	r31, 0x09	; 9
     9fe:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     a00:	85 ff       	sbrs	r24, 5
     a02:	fd cf       	rjmp	.-6      	; 0x9fe <gfx_mono_st7565r_init+0x30>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     a04:	80 e4       	ldi	r24, 0x40	; 64
     a06:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     a0a:	e0 ea       	ldi	r30, 0xA0	; 160
     a0c:	f9 e0       	ldi	r31, 0x09	; 9
     a0e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     a10:	86 ff       	sbrs	r24, 6
     a12:	fd cf       	rjmp	.-6      	; 0xa0e <gfx_mono_st7565r_init+0x40>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     a14:	e0 ea       	ldi	r30, 0xA0	; 160
     a16:	f9 e0       	ldi	r31, 0x09	; 9
     a18:	80 e4       	ldi	r24, 0x40	; 64
     a1a:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     a1c:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     a1e:	be 01       	movw	r22, r28
     a20:	6f 5f       	subi	r22, 0xFF	; 255
     a22:	7f 4f       	sbci	r23, 0xFF	; 255
     a24:	80 ea       	ldi	r24, 0xA0	; 160
     a26:	99 e0       	ldi	r25, 0x09	; 9
     a28:	df d1       	rcall	.+958    	; 0xde8 <usart_spi_deselect_device>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     a2a:	00 e0       	ldi	r16, 0x00	; 0
     a2c:	0a c0       	rjmp	.+20     	; 0xa42 <gfx_mono_st7565r_init+0x74>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
     a2e:	40 e0       	ldi	r20, 0x00	; 0
     a30:	61 2f       	mov	r22, r17
     a32:	80 2f       	mov	r24, r16
     a34:	25 df       	rcall	.-438    	; 0x880 <gfx_mono_st7565r_put_byte>
	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
     a36:	1f 5f       	subi	r17, 0xFF	; 255
     a38:	10 38       	cpi	r17, 0x80	; 128
     a3a:	c9 f7       	brne	.-14     	; 0xa2e <gfx_mono_st7565r_init+0x60>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     a3c:	0f 5f       	subi	r16, 0xFF	; 255
     a3e:	04 30       	cpi	r16, 0x04	; 4
     a40:	11 f0       	breq	.+4      	; 0xa46 <gfx_mono_st7565r_init+0x78>
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     a42:	10 e0       	ldi	r17, 0x00	; 0
     a44:	f4 cf       	rjmp	.-24     	; 0xa2e <gfx_mono_st7565r_init+0x60>
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
		}
	}
}
     a46:	0f 90       	pop	r0
     a48:	df 91       	pop	r29
     a4a:	cf 91       	pop	r28
     a4c:	1f 91       	pop	r17
     a4e:	0f 91       	pop	r16
     a50:	08 95       	ret

00000a52 <gfx_mono_st7565r_draw_pixel>:
	gfx_mono_st7565r_draw_pixel(10, 10, GFX_PIXEL_XOR);
\endcode
 */
void gfx_mono_st7565r_draw_pixel(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t color)
{
     a52:	ff 92       	push	r15
     a54:	0f 93       	push	r16
     a56:	1f 93       	push	r17
     a58:	cf 93       	push	r28
     a5a:	df 93       	push	r29
	uint8_t page;
	uint8_t pixel_mask;
	uint8_t pixel_value;

	/* Discard pixels drawn outside the screen */
	if ((x > GFX_MONO_LCD_WIDTH - 1) || (y > GFX_MONO_LCD_HEIGHT - 1)) {
     a5c:	88 23       	and	r24, r24
     a5e:	8c f1       	brlt	.+98     	; 0xac2 <gfx_mono_st7565r_draw_pixel+0x70>
     a60:	60 32       	cpi	r22, 0x20	; 32
     a62:	78 f5       	brcc	.+94     	; 0xac2 <gfx_mono_st7565r_draw_pixel+0x70>
     a64:	d4 2f       	mov	r29, r20
     a66:	c8 2f       	mov	r28, r24
		return;
	}

	page = y / GFX_MONO_LCD_PIXELS_PER_BYTE;
     a68:	f6 2e       	mov	r15, r22
     a6a:	f6 94       	lsr	r15
     a6c:	f6 94       	lsr	r15
     a6e:	f6 94       	lsr	r15
	pixel_mask = (1 << (y - (page * 8)));
     a70:	2f 2d       	mov	r18, r15
     a72:	30 e0       	ldi	r19, 0x00	; 0
     a74:	31 95       	neg	r19
     a76:	21 95       	neg	r18
     a78:	31 09       	sbc	r19, r1
     a7a:	22 0f       	add	r18, r18
     a7c:	33 1f       	adc	r19, r19
     a7e:	22 0f       	add	r18, r18
     a80:	33 1f       	adc	r19, r19
     a82:	22 0f       	add	r18, r18
     a84:	33 1f       	adc	r19, r19
     a86:	26 0f       	add	r18, r22
     a88:	31 1d       	adc	r19, r1
     a8a:	61 e0       	ldi	r22, 0x01	; 1
     a8c:	70 e0       	ldi	r23, 0x00	; 0
     a8e:	8b 01       	movw	r16, r22
     a90:	02 c0       	rjmp	.+4      	; 0xa96 <gfx_mono_st7565r_draw_pixel+0x44>
     a92:	00 0f       	add	r16, r16
     a94:	11 1f       	adc	r17, r17
     a96:	2a 95       	dec	r18
     a98:	e2 f7       	brpl	.-8      	; 0xa92 <gfx_mono_st7565r_draw_pixel+0x40>
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     a9a:	68 2f       	mov	r22, r24
     a9c:	8f 2d       	mov	r24, r15
     a9e:	2c d0       	rcall	.+88     	; 0xaf8 <gfx_mono_framebuffer_get_byte>
	 * requested action on this pixel before writing the page back to the
	 * display.
	 */
	pixel_value = gfx_mono_get_byte(page, x);

	switch (color) {
     aa0:	d1 30       	cpi	r29, 0x01	; 1
     aa2:	21 f0       	breq	.+8      	; 0xaac <gfx_mono_st7565r_draw_pixel+0x5a>
     aa4:	28 f0       	brcs	.+10     	; 0xab0 <gfx_mono_st7565r_draw_pixel+0x5e>
     aa6:	d2 30       	cpi	r29, 0x02	; 2
     aa8:	39 f0       	breq	.+14     	; 0xab8 <gfx_mono_st7565r_draw_pixel+0x66>
     aaa:	07 c0       	rjmp	.+14     	; 0xaba <gfx_mono_st7565r_draw_pixel+0x68>
	case GFX_PIXEL_SET:
		pixel_value |= pixel_mask;
     aac:	80 2b       	or	r24, r16
		break;
     aae:	05 c0       	rjmp	.+10     	; 0xaba <gfx_mono_st7565r_draw_pixel+0x68>

	case GFX_PIXEL_CLR:
		pixel_value &= ~pixel_mask;
     ab0:	60 2f       	mov	r22, r16
     ab2:	60 95       	com	r22
     ab4:	86 23       	and	r24, r22
		break;
     ab6:	01 c0       	rjmp	.+2      	; 0xaba <gfx_mono_st7565r_draw_pixel+0x68>

	case GFX_PIXEL_XOR:
		pixel_value ^= pixel_mask;
     ab8:	80 27       	eor	r24, r16

	default:
		break;
	}

	gfx_mono_put_byte(page, x, pixel_value);
     aba:	48 2f       	mov	r20, r24
     abc:	6c 2f       	mov	r22, r28
     abe:	8f 2d       	mov	r24, r15
     ac0:	df de       	rcall	.-578    	; 0x880 <gfx_mono_st7565r_put_byte>
}
     ac2:	df 91       	pop	r29
     ac4:	cf 91       	pop	r28
     ac6:	1f 91       	pop	r17
     ac8:	0f 91       	pop	r16
     aca:	ff 90       	pop	r15
     acc:	08 95       	ret

00000ace <gfx_mono_st7565r_get_byte>:
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     ace:	14 c0       	rjmp	.+40     	; 0xaf8 <gfx_mono_framebuffer_get_byte>
	st7565r_set_column_address(column);

	return st7565r_read_data();

#endif
}
     ad0:	08 95       	ret

00000ad2 <gfx_mono_set_framebuffer>:
	gfx_coord_t *framebuffer_pt = fbpointer +
			((page * GFX_MONO_LCD_WIDTH) + column);
	do {
		*data++ = *framebuffer_pt++;
	} while (--width > 0);
}
     ad2:	80 93 64 22 	sts	0x2264, r24	; 0x802264 <fbpointer>
     ad6:	90 93 65 22 	sts	0x2265, r25	; 0x802265 <fbpointer+0x1>
     ada:	08 95       	ret

00000adc <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
     adc:	20 e8       	ldi	r18, 0x80	; 128
     ade:	82 9f       	mul	r24, r18
     ae0:	c0 01       	movw	r24, r0
     ae2:	11 24       	eor	r1, r1
     ae4:	86 0f       	add	r24, r22
     ae6:	91 1d       	adc	r25, r1
     ae8:	e0 91 64 22 	lds	r30, 0x2264	; 0x802264 <fbpointer>
     aec:	f0 91 65 22 	lds	r31, 0x2265	; 0x802265 <fbpointer+0x1>
     af0:	e8 0f       	add	r30, r24
     af2:	f9 1f       	adc	r31, r25
     af4:	40 83       	st	Z, r20
     af6:	08 95       	ret

00000af8 <gfx_mono_framebuffer_get_byte>:
	data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(gfx_coord_t page, gfx_coord_t column)
{
	return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
     af8:	20 e8       	ldi	r18, 0x80	; 128
     afa:	82 9f       	mul	r24, r18
     afc:	c0 01       	movw	r24, r0
     afe:	11 24       	eor	r1, r1
     b00:	86 0f       	add	r24, r22
     b02:	91 1d       	adc	r25, r1
     b04:	e0 91 64 22 	lds	r30, 0x2264	; 0x802264 <fbpointer>
     b08:	f0 91 65 22 	lds	r31, 0x2265	; 0x802265 <fbpointer+0x1>
     b0c:	e8 0f       	add	r30, r24
     b0e:	f9 1f       	adc	r31, r25
}
     b10:	80 81       	ld	r24, Z
     b12:	08 95       	ret

00000b14 <gfx_mono_generic_draw_horizontal_line>:
	gfx_mono_draw_horizontal_line(x, y, width, color);
	gfx_mono_draw_horizontal_line(x, y + height - 1, width, color);

	gfx_mono_draw_vertical_line(x, y, height, color);
	gfx_mono_draw_vertical_line(x + width - 1, y, height, color);
}
     b14:	ff 92       	push	r15
     b16:	0f 93       	push	r16
     b18:	1f 93       	push	r17
     b1a:	cf 93       	push	r28
     b1c:	df 93       	push	r29
     b1e:	e4 2f       	mov	r30, r20
     b20:	f0 e0       	ldi	r31, 0x00	; 0
     b22:	e8 0f       	add	r30, r24
     b24:	f1 1d       	adc	r31, r1
     b26:	e1 38       	cpi	r30, 0x81	; 129
     b28:	f1 05       	cpc	r31, r1
     b2a:	1c f0       	brlt	.+6      	; 0xb32 <gfx_mono_generic_draw_horizontal_line+0x1e>
     b2c:	c0 e8       	ldi	r28, 0x80	; 128
     b2e:	4c 2f       	mov	r20, r28
     b30:	48 1b       	sub	r20, r24
     b32:	44 23       	and	r20, r20
     b34:	09 f4       	brne	.+2      	; 0xb38 <gfx_mono_generic_draw_horizontal_line+0x24>
     b36:	53 c0       	rjmp	.+166    	; 0xbde <gfx_mono_generic_draw_horizontal_line+0xca>
     b38:	d6 2f       	mov	r29, r22
     b3a:	d6 95       	lsr	r29
     b3c:	d6 95       	lsr	r29
     b3e:	d6 95       	lsr	r29
     b40:	ed 2f       	mov	r30, r29
     b42:	f0 e0       	ldi	r31, 0x00	; 0
     b44:	f1 95       	neg	r31
     b46:	e1 95       	neg	r30
     b48:	f1 09       	sbc	r31, r1
     b4a:	ee 0f       	add	r30, r30
     b4c:	ff 1f       	adc	r31, r31
     b4e:	ee 0f       	add	r30, r30
     b50:	ff 1f       	adc	r31, r31
     b52:	ee 0f       	add	r30, r30
     b54:	ff 1f       	adc	r31, r31
     b56:	df 01       	movw	r26, r30
     b58:	a6 0f       	add	r26, r22
     b5a:	b1 1d       	adc	r27, r1
     b5c:	bd 01       	movw	r22, r26
     b5e:	e1 e0       	ldi	r30, 0x01	; 1
     b60:	f0 e0       	ldi	r31, 0x00	; 0
     b62:	df 01       	movw	r26, r30
     b64:	02 c0       	rjmp	.+4      	; 0xb6a <gfx_mono_generic_draw_horizontal_line+0x56>
     b66:	aa 0f       	add	r26, r26
     b68:	bb 1f       	adc	r27, r27
     b6a:	6a 95       	dec	r22
     b6c:	e2 f7       	brpl	.-8      	; 0xb66 <gfx_mono_generic_draw_horizontal_line+0x52>
     b6e:	fa 2e       	mov	r15, r26
     b70:	21 30       	cpi	r18, 0x01	; 1
     b72:	21 f0       	breq	.+8      	; 0xb7c <gfx_mono_generic_draw_horizontal_line+0x68>
     b74:	98 f0       	brcs	.+38     	; 0xb9c <gfx_mono_generic_draw_horizontal_line+0x88>
     b76:	22 30       	cpi	r18, 0x02	; 2
     b78:	19 f1       	breq	.+70     	; 0xbc0 <gfx_mono_generic_draw_horizontal_line+0xac>
     b7a:	31 c0       	rjmp	.+98     	; 0xbde <gfx_mono_generic_draw_horizontal_line+0xca>
     b7c:	c4 2f       	mov	r28, r20
     b7e:	1f ef       	ldi	r17, 0xFF	; 255
     b80:	18 0f       	add	r17, r24
     b82:	01 2f       	mov	r16, r17
     b84:	0c 0f       	add	r16, r28
     b86:	60 2f       	mov	r22, r16
     b88:	8d 2f       	mov	r24, r29
     b8a:	a1 df       	rcall	.-190    	; 0xace <gfx_mono_st7565r_get_byte>
     b8c:	48 2f       	mov	r20, r24
     b8e:	4f 29       	or	r20, r15
     b90:	60 2f       	mov	r22, r16
     b92:	8d 2f       	mov	r24, r29
     b94:	75 de       	rcall	.-790    	; 0x880 <gfx_mono_st7565r_put_byte>
     b96:	c1 50       	subi	r28, 0x01	; 1
     b98:	a1 f7       	brne	.-24     	; 0xb82 <gfx_mono_generic_draw_horizontal_line+0x6e>
     b9a:	21 c0       	rjmp	.+66     	; 0xbde <gfx_mono_generic_draw_horizontal_line+0xca>
     b9c:	c4 2f       	mov	r28, r20
     b9e:	1f ef       	ldi	r17, 0xFF	; 255
     ba0:	18 0f       	add	r17, r24
     ba2:	fa 2e       	mov	r15, r26
     ba4:	f0 94       	com	r15
     ba6:	01 2f       	mov	r16, r17
     ba8:	0c 0f       	add	r16, r28
     baa:	60 2f       	mov	r22, r16
     bac:	8d 2f       	mov	r24, r29
     bae:	8f df       	rcall	.-226    	; 0xace <gfx_mono_st7565r_get_byte>
     bb0:	48 2f       	mov	r20, r24
     bb2:	4f 21       	and	r20, r15
     bb4:	60 2f       	mov	r22, r16
     bb6:	8d 2f       	mov	r24, r29
     bb8:	63 de       	rcall	.-826    	; 0x880 <gfx_mono_st7565r_put_byte>
     bba:	c1 50       	subi	r28, 0x01	; 1
     bbc:	a1 f7       	brne	.-24     	; 0xba6 <gfx_mono_generic_draw_horizontal_line+0x92>
     bbe:	0f c0       	rjmp	.+30     	; 0xbde <gfx_mono_generic_draw_horizontal_line+0xca>
     bc0:	c4 2f       	mov	r28, r20
     bc2:	1f ef       	ldi	r17, 0xFF	; 255
     bc4:	18 0f       	add	r17, r24
     bc6:	01 2f       	mov	r16, r17
     bc8:	0c 0f       	add	r16, r28
     bca:	60 2f       	mov	r22, r16
     bcc:	8d 2f       	mov	r24, r29
     bce:	7f df       	rcall	.-258    	; 0xace <gfx_mono_st7565r_get_byte>
     bd0:	48 2f       	mov	r20, r24
     bd2:	4f 25       	eor	r20, r15
     bd4:	60 2f       	mov	r22, r16
     bd6:	8d 2f       	mov	r24, r29
     bd8:	53 de       	rcall	.-858    	; 0x880 <gfx_mono_st7565r_put_byte>
     bda:	c1 50       	subi	r28, 0x01	; 1
     bdc:	a1 f7       	brne	.-24     	; 0xbc6 <gfx_mono_generic_draw_horizontal_line+0xb2>
     bde:	df 91       	pop	r29
     be0:	cf 91       	pop	r28
     be2:	1f 91       	pop	r17
     be4:	0f 91       	pop	r16
     be6:	ff 90       	pop	r15
     be8:	08 95       	ret

00000bea <gfx_mono_generic_draw_filled_rect>:
 * \param  color       Pixel operation of the line
 */
void gfx_mono_generic_draw_filled_rect(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t width, gfx_coord_t height,
		enum gfx_mono_color color)
{
     bea:	ff 92       	push	r15
     bec:	0f 93       	push	r16
     bee:	1f 93       	push	r17
     bf0:	cf 93       	push	r28
     bf2:	df 93       	push	r29
	if (height == 0) {
     bf4:	22 23       	and	r18, r18
     bf6:	69 f0       	breq	.+26     	; 0xc12 <gfx_mono_generic_draw_filled_rect+0x28>
     bf8:	c2 2f       	mov	r28, r18
     bfa:	f4 2e       	mov	r15, r20
     bfc:	18 2f       	mov	r17, r24
     bfe:	df ef       	ldi	r29, 0xFF	; 255
     c00:	d6 0f       	add	r29, r22
     c02:	6d 2f       	mov	r22, r29
     c04:	6c 0f       	add	r22, r28
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
     c06:	20 2f       	mov	r18, r16
     c08:	4f 2d       	mov	r20, r15
     c0a:	81 2f       	mov	r24, r17
     c0c:	83 df       	rcall	.-250    	; 0xb14 <gfx_mono_generic_draw_horizontal_line>
     c0e:	c1 50       	subi	r28, 0x01	; 1
	if (height == 0) {
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
     c10:	c1 f7       	brne	.-16     	; 0xc02 <gfx_mono_generic_draw_filled_rect+0x18>
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
	}
}
     c12:	df 91       	pop	r29
     c14:	cf 91       	pop	r28
     c16:	1f 91       	pop	r17
     c18:	0f 91       	pop	r16
     c1a:	ff 90       	pop	r15
     c1c:	08 95       	ret

00000c1e <gfx_mono_draw_char>:
 * \param y        Y coordinate on screen.
 * \param font     Font to draw character in
 */
void gfx_mono_draw_char(const char c, const gfx_coord_t x, const gfx_coord_t y,
		const struct font *font)
{
     c1e:	af 92       	push	r10
     c20:	bf 92       	push	r11
     c22:	cf 92       	push	r12
     c24:	df 92       	push	r13
     c26:	ef 92       	push	r14
     c28:	ff 92       	push	r15
     c2a:	0f 93       	push	r16
     c2c:	1f 93       	push	r17
     c2e:	cf 93       	push	r28
     c30:	df 93       	push	r29
     c32:	c8 2f       	mov	r28, r24
     c34:	e6 2e       	mov	r14, r22
     c36:	b4 2e       	mov	r11, r20
     c38:	69 01       	movw	r12, r18
	gfx_mono_draw_filled_rect(x, y, font->width, font->height,
     c3a:	00 e0       	ldi	r16, 0x00	; 0
     c3c:	f9 01       	movw	r30, r18
     c3e:	24 81       	ldd	r18, Z+4	; 0x04
     c40:	43 81       	ldd	r20, Z+3	; 0x03
     c42:	6b 2d       	mov	r22, r11
     c44:	8e 2d       	mov	r24, r14
     c46:	d1 df       	rcall	.-94     	; 0xbea <gfx_mono_generic_draw_filled_rect>
			GFX_PIXEL_CLR);

	switch (font->type) {
     c48:	f6 01       	movw	r30, r12
     c4a:	80 81       	ld	r24, Z
     c4c:	81 11       	cpse	r24, r1
     c4e:	39 c0       	rjmp	.+114    	; 0xcc2 <gfx_mono_draw_char+0xa4>
	Assert(font != NULL);

	gfx_coord_t inc_x = x;
	gfx_coord_t inc_y = y;

	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
     c50:	83 81       	ldd	r24, Z+3	; 0x03
     c52:	28 2f       	mov	r18, r24
     c54:	26 95       	lsr	r18
     c56:	26 95       	lsr	r18
     c58:	26 95       	lsr	r18
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
     c5a:	87 70       	andi	r24, 0x07	; 7
     c5c:	09 f0       	breq	.+2      	; 0xc60 <gfx_mono_draw_char+0x42>
		char_row_size++;
     c5e:	2f 5f       	subi	r18, 0xFF	; 255
	}

	glyph_data_offset = char_row_size * font->height *
     c60:	f6 01       	movw	r30, r12
     c62:	a4 80       	ldd	r10, Z+4	; 0x04
     c64:	2a 9d       	mul	r18, r10
     c66:	90 01       	movw	r18, r0
     c68:	11 24       	eor	r1, r1
			((uint8_t)ch - font->first_char);
     c6a:	8c 2f       	mov	r24, r28
     c6c:	90 e0       	ldi	r25, 0x00	; 0
     c6e:	45 81       	ldd	r20, Z+5	; 0x05
     c70:	84 1b       	sub	r24, r20
     c72:	91 09       	sbc	r25, r1
	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
		char_row_size++;
	}

	glyph_data_offset = char_row_size * font->height *
     c74:	28 9f       	mul	r18, r24
     c76:	a0 01       	movw	r20, r0
     c78:	29 9f       	mul	r18, r25
     c7a:	50 0d       	add	r21, r0
     c7c:	38 9f       	mul	r19, r24
     c7e:	50 0d       	add	r21, r0
     c80:	11 24       	eor	r1, r1
			((uint8_t)ch - font->first_char);
	glyph_data = font->data.progmem + glyph_data_offset;
     c82:	01 81       	ldd	r16, Z+1	; 0x01
     c84:	12 81       	ldd	r17, Z+2	; 0x02
     c86:	04 0f       	add	r16, r20
     c88:	15 1f       	adc	r17, r21
	rows_left = font->height;

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;
     c8a:	f6 01       	movw	r30, r12
     c8c:	f3 80       	ldd	r15, Z+3	; 0x03

		for (i = 0; i < pixelsToDraw; i++) {
     c8e:	ff 20       	and	r15, r15
     c90:	a1 f0       	breq	.+40     	; 0xcba <gfx_mono_draw_char+0x9c>
     c92:	d0 e0       	ldi	r29, 0x00	; 0
     c94:	c0 e0       	ldi	r28, 0x00	; 0
     c96:	8c 2f       	mov	r24, r28
     c98:	8e 0d       	add	r24, r14
			if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
     c9a:	9c 2f       	mov	r25, r28
     c9c:	97 70       	andi	r25, 0x07	; 7
     c9e:	21 f4       	brne	.+8      	; 0xca8 <gfx_mono_draw_char+0x8a>
				glyph_byte = PROGMEM_READ_BYTE(glyph_data);
     ca0:	f8 01       	movw	r30, r16
     ca2:	d4 91       	lpm	r29, Z
				glyph_data++;
     ca4:	0f 5f       	subi	r16, 0xFF	; 255
     ca6:	1f 4f       	sbci	r17, 0xFF	; 255
			}

			if ((glyph_byte & 0x80)) {
     ca8:	dd 23       	and	r29, r29
     caa:	1c f4       	brge	.+6      	; 0xcb2 <gfx_mono_draw_char+0x94>
				gfx_mono_draw_pixel(inc_x, inc_y,
     cac:	41 e0       	ldi	r20, 0x01	; 1
     cae:	6b 2d       	mov	r22, r11
     cb0:	d0 de       	rcall	.-608    	; 0xa52 <gfx_mono_st7565r_draw_pixel>
						GFX_PIXEL_SET);
			}

			inc_x += 1;
			glyph_byte <<= 1;
     cb2:	dd 0f       	add	r29, r29

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
     cb4:	cf 5f       	subi	r28, 0xFF	; 255
     cb6:	cf 11       	cpse	r28, r15
     cb8:	ee cf       	rjmp	.-36     	; 0xc96 <gfx_mono_draw_char+0x78>

			inc_x += 1;
			glyph_byte <<= 1;
		}

		inc_y += 1;
     cba:	b3 94       	inc	r11
		inc_x = x;
		rows_left--;
     cbc:	aa 94       	dec	r10
	} while (rows_left > 0);
     cbe:	a1 10       	cpse	r10, r1
     cc0:	e4 cf       	rjmp	.-56     	; 0xc8a <gfx_mono_draw_char+0x6c>
	default:
		/* Unsupported mode, call assert */
		Assert(false);
		break;
	}
}
     cc2:	df 91       	pop	r29
     cc4:	cf 91       	pop	r28
     cc6:	1f 91       	pop	r17
     cc8:	0f 91       	pop	r16
     cca:	ff 90       	pop	r15
     ccc:	ef 90       	pop	r14
     cce:	df 90       	pop	r13
     cd0:	cf 90       	pop	r12
     cd2:	bf 90       	pop	r11
     cd4:	af 90       	pop	r10
     cd6:	08 95       	ret

00000cd8 <gfx_mono_draw_string>:
 * \param y         Y coordinate on screen.
 * \param font      Font to draw string in
 */
void gfx_mono_draw_string(const char *str, gfx_coord_t x, gfx_coord_t y,
		const struct font *font)
{
     cd8:	df 92       	push	r13
     cda:	ef 92       	push	r14
     cdc:	ff 92       	push	r15
     cde:	0f 93       	push	r16
     ce0:	1f 93       	push	r17
     ce2:	cf 93       	push	r28
     ce4:	df 93       	push	r29
     ce6:	04 2f       	mov	r16, r20
     ce8:	79 01       	movw	r14, r18
     cea:	ec 01       	movw	r28, r24
     cec:	16 2f       	mov	r17, r22

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
     cee:	d6 2e       	mov	r13, r22
	Assert(font != NULL);

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
     cf0:	89 91       	ld	r24, Y+
     cf2:	8a 30       	cpi	r24, 0x0A	; 10
     cf4:	31 f4       	brne	.+12     	; 0xd02 <gfx_mono_draw_string+0x2a>
     cf6:	f7 01       	movw	r30, r14
     cf8:	84 81       	ldd	r24, Z+4	; 0x04
     cfa:	8f 5f       	subi	r24, 0xFF	; 255
			x = start_of_string_position_x;
			y += font->height + 1;
     cfc:	08 0f       	add	r16, r24

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
     cfe:	1d 2d       	mov	r17, r13
     d00:	09 c0       	rjmp	.+18     	; 0xd14 <gfx_mono_draw_string+0x3c>
			y += font->height + 1;
		} else if (*str == '\r') {
     d02:	8d 30       	cpi	r24, 0x0D	; 13
     d04:	39 f0       	breq	.+14     	; 0xd14 <gfx_mono_draw_string+0x3c>
			/* Skip '\r' characters. */
		} else {
			gfx_mono_draw_char(*str, x, y, font);
     d06:	97 01       	movw	r18, r14
     d08:	40 2f       	mov	r20, r16
     d0a:	61 2f       	mov	r22, r17
     d0c:	88 df       	rcall	.-240    	; 0xc1e <gfx_mono_draw_char>
			x += font->width;
     d0e:	f7 01       	movw	r30, r14
     d10:	83 81       	ldd	r24, Z+3	; 0x03
     d12:	18 0f       	add	r17, r24
		}
	} while (*(++str));
     d14:	88 81       	ld	r24, Y
     d16:	81 11       	cpse	r24, r1
     d18:	eb cf       	rjmp	.-42     	; 0xcf0 <gfx_mono_draw_string+0x18>
}
     d1a:	df 91       	pop	r29
     d1c:	cf 91       	pop	r28
     d1e:	1f 91       	pop	r17
     d20:	0f 91       	pop	r16
     d22:	ff 90       	pop	r15
     d24:	ef 90       	pop	r14
     d26:	df 90       	pop	r13
     d28:	08 95       	ret

00000d2a <usart_spi_init>:
		*data = usart_spi_transmit(usart, CONFIG_USART_SPI_DUMMY);
		len--;
		data++;
 	}
	return STATUS_OK;
}
     d2a:	80 3a       	cpi	r24, 0xA0	; 160
     d2c:	28 e0       	ldi	r18, 0x08	; 8
     d2e:	92 07       	cpc	r25, r18
     d30:	21 f4       	brne	.+8      	; 0xd3a <usart_spi_init+0x10>
     d32:	60 e1       	ldi	r22, 0x10	; 16
     d34:	83 e0       	ldi	r24, 0x03	; 3
     d36:	8d cd       	rjmp	.-1254   	; 0x852 <sysclk_enable_module>
     d38:	08 95       	ret
     d3a:	80 3b       	cpi	r24, 0xB0	; 176
     d3c:	28 e0       	ldi	r18, 0x08	; 8
     d3e:	92 07       	cpc	r25, r18
     d40:	21 f4       	brne	.+8      	; 0xd4a <usart_spi_init+0x20>
     d42:	60 e2       	ldi	r22, 0x20	; 32
     d44:	83 e0       	ldi	r24, 0x03	; 3
     d46:	85 cd       	rjmp	.-1270   	; 0x852 <sysclk_enable_module>
     d48:	08 95       	ret
     d4a:	80 3a       	cpi	r24, 0xA0	; 160
     d4c:	29 e0       	ldi	r18, 0x09	; 9
     d4e:	92 07       	cpc	r25, r18
     d50:	21 f4       	brne	.+8      	; 0xd5a <usart_spi_init+0x30>
     d52:	60 e1       	ldi	r22, 0x10	; 16
     d54:	84 e0       	ldi	r24, 0x04	; 4
     d56:	7d cd       	rjmp	.-1286   	; 0x852 <sysclk_enable_module>
     d58:	08 95       	ret
     d5a:	80 3b       	cpi	r24, 0xB0	; 176
     d5c:	29 e0       	ldi	r18, 0x09	; 9
     d5e:	92 07       	cpc	r25, r18
     d60:	21 f4       	brne	.+8      	; 0xd6a <usart_spi_init+0x40>
     d62:	60 e2       	ldi	r22, 0x20	; 32
     d64:	84 e0       	ldi	r24, 0x04	; 4
     d66:	75 cd       	rjmp	.-1302   	; 0x852 <sysclk_enable_module>
     d68:	08 95       	ret
     d6a:	80 3a       	cpi	r24, 0xA0	; 160
     d6c:	2a e0       	ldi	r18, 0x0A	; 10
     d6e:	92 07       	cpc	r25, r18
     d70:	21 f4       	brne	.+8      	; 0xd7a <usart_spi_init+0x50>
     d72:	60 e1       	ldi	r22, 0x10	; 16
     d74:	85 e0       	ldi	r24, 0x05	; 5
     d76:	6d cd       	rjmp	.-1318   	; 0x852 <sysclk_enable_module>
     d78:	08 95       	ret
     d7a:	80 3a       	cpi	r24, 0xA0	; 160
     d7c:	9b 40       	sbci	r25, 0x0B	; 11
     d7e:	19 f4       	brne	.+6      	; 0xd86 <usart_spi_init+0x5c>
     d80:	60 e1       	ldi	r22, 0x10	; 16
     d82:	86 e0       	ldi	r24, 0x06	; 6
     d84:	66 cd       	rjmp	.-1332   	; 0x852 <sysclk_enable_module>
     d86:	08 95       	ret

00000d88 <usart_spi_setup_device>:
     d88:	0f 93       	push	r16
     d8a:	1f 93       	push	r17
     d8c:	cf 93       	push	r28
     d8e:	df 93       	push	r29
     d90:	00 d0       	rcall	.+0      	; 0xd92 <usart_spi_setup_device+0xa>
     d92:	00 d0       	rcall	.+0      	; 0xd94 <usart_spi_setup_device+0xc>
     d94:	cd b7       	in	r28, 0x3d	; 61
     d96:	de b7       	in	r29, 0x3e	; 62
     d98:	09 83       	std	Y+1, r16	; 0x01
     d9a:	1a 83       	std	Y+2, r17	; 0x02
     d9c:	2b 83       	std	Y+3, r18	; 0x03
     d9e:	3c 83       	std	Y+4, r19	; 0x04
     da0:	4d 83       	std	Y+5, r20	; 0x05
     da2:	1e 82       	std	Y+6, r1	; 0x06
     da4:	be 01       	movw	r22, r28
     da6:	6f 5f       	subi	r22, 0xFF	; 255
     da8:	7f 4f       	sbci	r23, 0xFF	; 255
     daa:	6a d5       	rcall	.+2772   	; 0x1880 <usart_init_spi>
     dac:	26 96       	adiw	r28, 0x06	; 6
     dae:	cd bf       	out	0x3d, r28	; 61
     db0:	de bf       	out	0x3e, r29	; 62
     db2:	df 91       	pop	r29
     db4:	cf 91       	pop	r28
     db6:	1f 91       	pop	r17
     db8:	0f 91       	pop	r16
     dba:	08 95       	ret

00000dbc <usart_spi_select_device>:

void usart_spi_select_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_low(device->id);
     dbc:	fb 01       	movw	r30, r22
     dbe:	80 81       	ld	r24, Z
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
     dc0:	e8 2f       	mov	r30, r24
     dc2:	e6 95       	lsr	r30
     dc4:	e6 95       	lsr	r30
     dc6:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
     dc8:	40 e2       	ldi	r20, 0x20	; 32
     dca:	e4 9f       	mul	r30, r20
     dcc:	f0 01       	movw	r30, r0
     dce:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
     dd0:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
     dd2:	87 70       	andi	r24, 0x07	; 7
     dd4:	21 e0       	ldi	r18, 0x01	; 1
     dd6:	30 e0       	ldi	r19, 0x00	; 0
     dd8:	a9 01       	movw	r20, r18
     dda:	02 c0       	rjmp	.+4      	; 0xde0 <usart_spi_select_device+0x24>
     ddc:	44 0f       	add	r20, r20
     dde:	55 1f       	adc	r21, r21
     de0:	8a 95       	dec	r24
     de2:	e2 f7       	brpl	.-8      	; 0xddc <usart_spi_select_device+0x20>
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     de4:	46 83       	std	Z+6, r20	; 0x06
     de6:	08 95       	ret

00000de8 <usart_spi_deselect_device>:
}

void usart_spi_deselect_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_high(device->id);
     de8:	fb 01       	movw	r30, r22
     dea:	80 81       	ld	r24, Z
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
     dec:	e8 2f       	mov	r30, r24
     dee:	e6 95       	lsr	r30
     df0:	e6 95       	lsr	r30
     df2:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
     df4:	40 e2       	ldi	r20, 0x20	; 32
     df6:	e4 9f       	mul	r30, r20
     df8:	f0 01       	movw	r30, r0
     dfa:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
     dfc:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
     dfe:	87 70       	andi	r24, 0x07	; 7
     e00:	21 e0       	ldi	r18, 0x01	; 1
     e02:	30 e0       	ldi	r19, 0x00	; 0
     e04:	a9 01       	movw	r20, r18
     e06:	02 c0       	rjmp	.+4      	; 0xe0c <usart_spi_deselect_device+0x24>
     e08:	44 0f       	add	r20, r20
     e0a:	55 1f       	adc	r21, r21
     e0c:	8a 95       	dec	r24
     e0e:	e2 f7       	brpl	.-8      	; 0xe08 <usart_spi_deselect_device+0x20>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     e10:	45 83       	std	Z+5, r20	; 0x05
     e12:	08 95       	ret

00000e14 <adc_enable_clock>:
void adc_enable_clock(ADC_t *adc);

void adc_enable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
     e14:	81 15       	cp	r24, r1
     e16:	22 e0       	ldi	r18, 0x02	; 2
     e18:	92 07       	cpc	r25, r18
     e1a:	61 f4       	brne	.+24     	; 0xe34 <adc_enable_clock+0x20>
		Assert(adca_enable_count < 0xff);
		if (!adca_enable_count++) {
     e1c:	80 91 67 22 	lds	r24, 0x2267	; 0x802267 <adca_enable_count>
     e20:	91 e0       	ldi	r25, 0x01	; 1
     e22:	98 0f       	add	r25, r24
     e24:	90 93 67 22 	sts	0x2267, r25	; 0x802267 <adca_enable_count>
     e28:	81 11       	cpse	r24, r1
     e2a:	12 c0       	rjmp	.+36     	; 0xe50 <adc_enable_clock+0x3c>
			sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
     e2c:	62 e0       	ldi	r22, 0x02	; 2
     e2e:	81 e0       	ldi	r24, 0x01	; 1
     e30:	10 cd       	rjmp	.-1504   	; 0x852 <sysclk_enable_module>
     e32:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
     e34:	80 34       	cpi	r24, 0x40	; 64
     e36:	92 40       	sbci	r25, 0x02	; 2
     e38:	59 f4       	brne	.+22     	; 0xe50 <adc_enable_clock+0x3c>
		Assert(adcb_enable_count < 0xff);
		if (!adcb_enable_count++) {
     e3a:	80 91 66 22 	lds	r24, 0x2266	; 0x802266 <adcb_enable_count>
     e3e:	91 e0       	ldi	r25, 0x01	; 1
     e40:	98 0f       	add	r25, r24
     e42:	90 93 66 22 	sts	0x2266, r25	; 0x802266 <adcb_enable_count>
     e46:	81 11       	cpse	r24, r1
     e48:	03 c0       	rjmp	.+6      	; 0xe50 <adc_enable_clock+0x3c>
			sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
     e4a:	62 e0       	ldi	r22, 0x02	; 2
     e4c:	82 e0       	ldi	r24, 0x02	; 2
     e4e:	01 cd       	rjmp	.-1534   	; 0x852 <sysclk_enable_module>
     e50:	08 95       	ret

00000e52 <adc_disable_clock>:
void adc_disable_clock(ADC_t *adc);

void adc_disable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
     e52:	81 15       	cp	r24, r1
     e54:	22 e0       	ldi	r18, 0x02	; 2
     e56:	92 07       	cpc	r25, r18
     e58:	59 f4       	brne	.+22     	; 0xe70 <adc_disable_clock+0x1e>
		Assert(adca_enable_count);
		if (!--adca_enable_count) {
     e5a:	80 91 67 22 	lds	r24, 0x2267	; 0x802267 <adca_enable_count>
     e5e:	81 50       	subi	r24, 0x01	; 1
     e60:	80 93 67 22 	sts	0x2267, r24	; 0x802267 <adca_enable_count>
     e64:	81 11       	cpse	r24, r1
     e66:	11 c0       	rjmp	.+34     	; 0xe8a <adc_disable_clock+0x38>
			sysclk_disable_module(SYSCLK_PORT_A, SYSCLK_ADC);
     e68:	62 e0       	ldi	r22, 0x02	; 2
     e6a:	81 e0       	ldi	r24, 0x01	; 1
     e6c:	fe cc       	rjmp	.-1540   	; 0x86a <sysclk_disable_module>
     e6e:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
     e70:	80 34       	cpi	r24, 0x40	; 64
     e72:	92 40       	sbci	r25, 0x02	; 2
     e74:	51 f4       	brne	.+20     	; 0xe8a <adc_disable_clock+0x38>
		Assert(adcb_enable_count);
		if (!--adcb_enable_count) {
     e76:	80 91 66 22 	lds	r24, 0x2266	; 0x802266 <adcb_enable_count>
     e7a:	81 50       	subi	r24, 0x01	; 1
     e7c:	80 93 66 22 	sts	0x2266, r24	; 0x802266 <adcb_enable_count>
     e80:	81 11       	cpse	r24, r1
     e82:	03 c0       	rjmp	.+6      	; 0xe8a <adc_disable_clock+0x38>
			sysclk_disable_module(SYSCLK_PORT_B, SYSCLK_ADC);
     e84:	62 e0       	ldi	r22, 0x02	; 2
     e86:	82 e0       	ldi	r24, 0x02	; 2
     e88:	f0 cc       	rjmp	.-1568   	; 0x86a <sysclk_disable_module>
     e8a:	08 95       	ret

00000e8c <adc_enable>:
 * a conversion. For most XMEGA devices the start-up time is specified
 * to be a maximum of 24 ADC clock cycles. Please verify the start-up time for
 * the device in use.
 */
void adc_enable(ADC_t *adc)
{
     e8c:	1f 93       	push	r17
     e8e:	cf 93       	push	r28
     e90:	df 93       	push	r29
     e92:	ec 01       	movw	r28, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     e94:	1f b7       	in	r17, 0x3f	; 63
	cpu_irq_disable();
     e96:	f8 94       	cli
	irqflags_t flags = cpu_irq_save();
	adc_enable_clock(adc);
     e98:	bd df       	rcall	.-134    	; 0xe14 <adc_enable_clock>
	adc->CTRLA |= ADC_ENABLE_bm;
     e9a:	88 81       	ld	r24, Y
     e9c:	81 60       	ori	r24, 0x01	; 1
     e9e:	88 83       	st	Y, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     ea0:	1f bf       	out	0x3f, r17	; 63

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     ea2:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
     ea4:	f8 94       	cli
	Assert(sleepmgr_locks[mode] < 0xff);

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
     ea6:	e5 eb       	ldi	r30, 0xB5	; 181
     ea8:	f3 e2       	ldi	r31, 0x23	; 35
     eaa:	81 81       	ldd	r24, Z+1	; 0x01
     eac:	8f 5f       	subi	r24, 0xFF	; 255
     eae:	81 83       	std	Z+1, r24	; 0x01
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     eb0:	9f bf       	out	0x3f, r25	; 63
	cpu_irq_restore(flags);

	sleepmgr_lock_mode(SLEEPMGR_IDLE);
}
     eb2:	df 91       	pop	r29
     eb4:	cf 91       	pop	r28
     eb6:	1f 91       	pop	r17
     eb8:	08 95       	ret

00000eba <__vector_71>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH0_vect)
{
     eba:	1f 92       	push	r1
     ebc:	0f 92       	push	r0
     ebe:	0f b6       	in	r0, 0x3f	; 63
     ec0:	0f 92       	push	r0
     ec2:	11 24       	eor	r1, r1
     ec4:	0b b6       	in	r0, 0x3b	; 59
     ec6:	0f 92       	push	r0
     ec8:	2f 93       	push	r18
     eca:	3f 93       	push	r19
     ecc:	4f 93       	push	r20
     ece:	5f 93       	push	r21
     ed0:	6f 93       	push	r22
     ed2:	7f 93       	push	r23
     ed4:	8f 93       	push	r24
     ed6:	9f 93       	push	r25
     ed8:	af 93       	push	r26
     eda:	bf 93       	push	r27
     edc:	ef 93       	push	r30
     ede:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH0, adc_get_result(&ADCA, ADC_CH0));
     ee0:	40 91 24 02 	lds	r20, 0x0224	; 0x800224 <__TEXT_REGION_LENGTH__+0x700224>
     ee4:	50 91 25 02 	lds	r21, 0x0225	; 0x800225 <__TEXT_REGION_LENGTH__+0x700225>
     ee8:	e0 91 bd 23 	lds	r30, 0x23BD	; 0x8023bd <adca_callback>
     eec:	f0 91 be 23 	lds	r31, 0x23BE	; 0x8023be <adca_callback+0x1>
     ef0:	61 e0       	ldi	r22, 0x01	; 1
     ef2:	80 e0       	ldi	r24, 0x00	; 0
     ef4:	92 e0       	ldi	r25, 0x02	; 2
     ef6:	19 95       	eicall
}
     ef8:	ff 91       	pop	r31
     efa:	ef 91       	pop	r30
     efc:	bf 91       	pop	r27
     efe:	af 91       	pop	r26
     f00:	9f 91       	pop	r25
     f02:	8f 91       	pop	r24
     f04:	7f 91       	pop	r23
     f06:	6f 91       	pop	r22
     f08:	5f 91       	pop	r21
     f0a:	4f 91       	pop	r20
     f0c:	3f 91       	pop	r19
     f0e:	2f 91       	pop	r18
     f10:	0f 90       	pop	r0
     f12:	0b be       	out	0x3b, r0	; 59
     f14:	0f 90       	pop	r0
     f16:	0f be       	out	0x3f, r0	; 63
     f18:	0f 90       	pop	r0
     f1a:	1f 90       	pop	r1
     f1c:	18 95       	reti

00000f1e <__vector_72>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH1_vect)
{
     f1e:	1f 92       	push	r1
     f20:	0f 92       	push	r0
     f22:	0f b6       	in	r0, 0x3f	; 63
     f24:	0f 92       	push	r0
     f26:	11 24       	eor	r1, r1
     f28:	0b b6       	in	r0, 0x3b	; 59
     f2a:	0f 92       	push	r0
     f2c:	2f 93       	push	r18
     f2e:	3f 93       	push	r19
     f30:	4f 93       	push	r20
     f32:	5f 93       	push	r21
     f34:	6f 93       	push	r22
     f36:	7f 93       	push	r23
     f38:	8f 93       	push	r24
     f3a:	9f 93       	push	r25
     f3c:	af 93       	push	r26
     f3e:	bf 93       	push	r27
     f40:	ef 93       	push	r30
     f42:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH1, adc_get_result(&ADCA, ADC_CH1));
     f44:	40 91 2c 02 	lds	r20, 0x022C	; 0x80022c <__TEXT_REGION_LENGTH__+0x70022c>
     f48:	50 91 2d 02 	lds	r21, 0x022D	; 0x80022d <__TEXT_REGION_LENGTH__+0x70022d>
     f4c:	e0 91 bd 23 	lds	r30, 0x23BD	; 0x8023bd <adca_callback>
     f50:	f0 91 be 23 	lds	r31, 0x23BE	; 0x8023be <adca_callback+0x1>
     f54:	62 e0       	ldi	r22, 0x02	; 2
     f56:	80 e0       	ldi	r24, 0x00	; 0
     f58:	92 e0       	ldi	r25, 0x02	; 2
     f5a:	19 95       	eicall
}
     f5c:	ff 91       	pop	r31
     f5e:	ef 91       	pop	r30
     f60:	bf 91       	pop	r27
     f62:	af 91       	pop	r26
     f64:	9f 91       	pop	r25
     f66:	8f 91       	pop	r24
     f68:	7f 91       	pop	r23
     f6a:	6f 91       	pop	r22
     f6c:	5f 91       	pop	r21
     f6e:	4f 91       	pop	r20
     f70:	3f 91       	pop	r19
     f72:	2f 91       	pop	r18
     f74:	0f 90       	pop	r0
     f76:	0b be       	out	0x3b, r0	; 59
     f78:	0f 90       	pop	r0
     f7a:	0f be       	out	0x3f, r0	; 63
     f7c:	0f 90       	pop	r0
     f7e:	1f 90       	pop	r1
     f80:	18 95       	reti

00000f82 <__vector_73>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH2_vect)
{
     f82:	1f 92       	push	r1
     f84:	0f 92       	push	r0
     f86:	0f b6       	in	r0, 0x3f	; 63
     f88:	0f 92       	push	r0
     f8a:	11 24       	eor	r1, r1
     f8c:	0b b6       	in	r0, 0x3b	; 59
     f8e:	0f 92       	push	r0
     f90:	2f 93       	push	r18
     f92:	3f 93       	push	r19
     f94:	4f 93       	push	r20
     f96:	5f 93       	push	r21
     f98:	6f 93       	push	r22
     f9a:	7f 93       	push	r23
     f9c:	8f 93       	push	r24
     f9e:	9f 93       	push	r25
     fa0:	af 93       	push	r26
     fa2:	bf 93       	push	r27
     fa4:	ef 93       	push	r30
     fa6:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH2, adc_get_result(&ADCA, ADC_CH2));
     fa8:	40 91 34 02 	lds	r20, 0x0234	; 0x800234 <__TEXT_REGION_LENGTH__+0x700234>
     fac:	50 91 35 02 	lds	r21, 0x0235	; 0x800235 <__TEXT_REGION_LENGTH__+0x700235>
     fb0:	e0 91 bd 23 	lds	r30, 0x23BD	; 0x8023bd <adca_callback>
     fb4:	f0 91 be 23 	lds	r31, 0x23BE	; 0x8023be <adca_callback+0x1>
     fb8:	64 e0       	ldi	r22, 0x04	; 4
     fba:	80 e0       	ldi	r24, 0x00	; 0
     fbc:	92 e0       	ldi	r25, 0x02	; 2
     fbe:	19 95       	eicall
}
     fc0:	ff 91       	pop	r31
     fc2:	ef 91       	pop	r30
     fc4:	bf 91       	pop	r27
     fc6:	af 91       	pop	r26
     fc8:	9f 91       	pop	r25
     fca:	8f 91       	pop	r24
     fcc:	7f 91       	pop	r23
     fce:	6f 91       	pop	r22
     fd0:	5f 91       	pop	r21
     fd2:	4f 91       	pop	r20
     fd4:	3f 91       	pop	r19
     fd6:	2f 91       	pop	r18
     fd8:	0f 90       	pop	r0
     fda:	0b be       	out	0x3b, r0	; 59
     fdc:	0f 90       	pop	r0
     fde:	0f be       	out	0x3f, r0	; 63
     fe0:	0f 90       	pop	r0
     fe2:	1f 90       	pop	r1
     fe4:	18 95       	reti

00000fe6 <__vector_74>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH3_vect)
{
     fe6:	1f 92       	push	r1
     fe8:	0f 92       	push	r0
     fea:	0f b6       	in	r0, 0x3f	; 63
     fec:	0f 92       	push	r0
     fee:	11 24       	eor	r1, r1
     ff0:	0b b6       	in	r0, 0x3b	; 59
     ff2:	0f 92       	push	r0
     ff4:	2f 93       	push	r18
     ff6:	3f 93       	push	r19
     ff8:	4f 93       	push	r20
     ffa:	5f 93       	push	r21
     ffc:	6f 93       	push	r22
     ffe:	7f 93       	push	r23
    1000:	8f 93       	push	r24
    1002:	9f 93       	push	r25
    1004:	af 93       	push	r26
    1006:	bf 93       	push	r27
    1008:	ef 93       	push	r30
    100a:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH3, adc_get_result(&ADCA, ADC_CH3));
    100c:	40 91 3c 02 	lds	r20, 0x023C	; 0x80023c <__TEXT_REGION_LENGTH__+0x70023c>
    1010:	50 91 3d 02 	lds	r21, 0x023D	; 0x80023d <__TEXT_REGION_LENGTH__+0x70023d>
    1014:	e0 91 bd 23 	lds	r30, 0x23BD	; 0x8023bd <adca_callback>
    1018:	f0 91 be 23 	lds	r31, 0x23BE	; 0x8023be <adca_callback+0x1>
    101c:	68 e0       	ldi	r22, 0x08	; 8
    101e:	80 e0       	ldi	r24, 0x00	; 0
    1020:	92 e0       	ldi	r25, 0x02	; 2
    1022:	19 95       	eicall
}
    1024:	ff 91       	pop	r31
    1026:	ef 91       	pop	r30
    1028:	bf 91       	pop	r27
    102a:	af 91       	pop	r26
    102c:	9f 91       	pop	r25
    102e:	8f 91       	pop	r24
    1030:	7f 91       	pop	r23
    1032:	6f 91       	pop	r22
    1034:	5f 91       	pop	r21
    1036:	4f 91       	pop	r20
    1038:	3f 91       	pop	r19
    103a:	2f 91       	pop	r18
    103c:	0f 90       	pop	r0
    103e:	0b be       	out	0x3b, r0	; 59
    1040:	0f 90       	pop	r0
    1042:	0f be       	out	0x3f, r0	; 63
    1044:	0f 90       	pop	r0
    1046:	1f 90       	pop	r1
    1048:	18 95       	reti

0000104a <__vector_39>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH0_vect)
{
    104a:	1f 92       	push	r1
    104c:	0f 92       	push	r0
    104e:	0f b6       	in	r0, 0x3f	; 63
    1050:	0f 92       	push	r0
    1052:	11 24       	eor	r1, r1
    1054:	0b b6       	in	r0, 0x3b	; 59
    1056:	0f 92       	push	r0
    1058:	2f 93       	push	r18
    105a:	3f 93       	push	r19
    105c:	4f 93       	push	r20
    105e:	5f 93       	push	r21
    1060:	6f 93       	push	r22
    1062:	7f 93       	push	r23
    1064:	8f 93       	push	r24
    1066:	9f 93       	push	r25
    1068:	af 93       	push	r26
    106a:	bf 93       	push	r27
    106c:	ef 93       	push	r30
    106e:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH0, adc_get_result(&ADCB, ADC_CH0));
    1070:	40 91 64 02 	lds	r20, 0x0264	; 0x800264 <__TEXT_REGION_LENGTH__+0x700264>
    1074:	50 91 65 02 	lds	r21, 0x0265	; 0x800265 <__TEXT_REGION_LENGTH__+0x700265>
    1078:	e0 91 bb 23 	lds	r30, 0x23BB	; 0x8023bb <adcb_callback>
    107c:	f0 91 bc 23 	lds	r31, 0x23BC	; 0x8023bc <adcb_callback+0x1>
    1080:	61 e0       	ldi	r22, 0x01	; 1
    1082:	80 e4       	ldi	r24, 0x40	; 64
    1084:	92 e0       	ldi	r25, 0x02	; 2
    1086:	19 95       	eicall
}
    1088:	ff 91       	pop	r31
    108a:	ef 91       	pop	r30
    108c:	bf 91       	pop	r27
    108e:	af 91       	pop	r26
    1090:	9f 91       	pop	r25
    1092:	8f 91       	pop	r24
    1094:	7f 91       	pop	r23
    1096:	6f 91       	pop	r22
    1098:	5f 91       	pop	r21
    109a:	4f 91       	pop	r20
    109c:	3f 91       	pop	r19
    109e:	2f 91       	pop	r18
    10a0:	0f 90       	pop	r0
    10a2:	0b be       	out	0x3b, r0	; 59
    10a4:	0f 90       	pop	r0
    10a6:	0f be       	out	0x3f, r0	; 63
    10a8:	0f 90       	pop	r0
    10aa:	1f 90       	pop	r1
    10ac:	18 95       	reti

000010ae <__vector_40>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH1_vect)
{
    10ae:	1f 92       	push	r1
    10b0:	0f 92       	push	r0
    10b2:	0f b6       	in	r0, 0x3f	; 63
    10b4:	0f 92       	push	r0
    10b6:	11 24       	eor	r1, r1
    10b8:	0b b6       	in	r0, 0x3b	; 59
    10ba:	0f 92       	push	r0
    10bc:	2f 93       	push	r18
    10be:	3f 93       	push	r19
    10c0:	4f 93       	push	r20
    10c2:	5f 93       	push	r21
    10c4:	6f 93       	push	r22
    10c6:	7f 93       	push	r23
    10c8:	8f 93       	push	r24
    10ca:	9f 93       	push	r25
    10cc:	af 93       	push	r26
    10ce:	bf 93       	push	r27
    10d0:	ef 93       	push	r30
    10d2:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH1, adc_get_result(&ADCB, ADC_CH1));
    10d4:	40 91 6c 02 	lds	r20, 0x026C	; 0x80026c <__TEXT_REGION_LENGTH__+0x70026c>
    10d8:	50 91 6d 02 	lds	r21, 0x026D	; 0x80026d <__TEXT_REGION_LENGTH__+0x70026d>
    10dc:	e0 91 bb 23 	lds	r30, 0x23BB	; 0x8023bb <adcb_callback>
    10e0:	f0 91 bc 23 	lds	r31, 0x23BC	; 0x8023bc <adcb_callback+0x1>
    10e4:	62 e0       	ldi	r22, 0x02	; 2
    10e6:	80 e4       	ldi	r24, 0x40	; 64
    10e8:	92 e0       	ldi	r25, 0x02	; 2
    10ea:	19 95       	eicall
}
    10ec:	ff 91       	pop	r31
    10ee:	ef 91       	pop	r30
    10f0:	bf 91       	pop	r27
    10f2:	af 91       	pop	r26
    10f4:	9f 91       	pop	r25
    10f6:	8f 91       	pop	r24
    10f8:	7f 91       	pop	r23
    10fa:	6f 91       	pop	r22
    10fc:	5f 91       	pop	r21
    10fe:	4f 91       	pop	r20
    1100:	3f 91       	pop	r19
    1102:	2f 91       	pop	r18
    1104:	0f 90       	pop	r0
    1106:	0b be       	out	0x3b, r0	; 59
    1108:	0f 90       	pop	r0
    110a:	0f be       	out	0x3f, r0	; 63
    110c:	0f 90       	pop	r0
    110e:	1f 90       	pop	r1
    1110:	18 95       	reti

00001112 <__vector_41>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH2_vect)
{
    1112:	1f 92       	push	r1
    1114:	0f 92       	push	r0
    1116:	0f b6       	in	r0, 0x3f	; 63
    1118:	0f 92       	push	r0
    111a:	11 24       	eor	r1, r1
    111c:	0b b6       	in	r0, 0x3b	; 59
    111e:	0f 92       	push	r0
    1120:	2f 93       	push	r18
    1122:	3f 93       	push	r19
    1124:	4f 93       	push	r20
    1126:	5f 93       	push	r21
    1128:	6f 93       	push	r22
    112a:	7f 93       	push	r23
    112c:	8f 93       	push	r24
    112e:	9f 93       	push	r25
    1130:	af 93       	push	r26
    1132:	bf 93       	push	r27
    1134:	ef 93       	push	r30
    1136:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH2, adc_get_result(&ADCB, ADC_CH2));
    1138:	40 91 74 02 	lds	r20, 0x0274	; 0x800274 <__TEXT_REGION_LENGTH__+0x700274>
    113c:	50 91 75 02 	lds	r21, 0x0275	; 0x800275 <__TEXT_REGION_LENGTH__+0x700275>
    1140:	e0 91 bb 23 	lds	r30, 0x23BB	; 0x8023bb <adcb_callback>
    1144:	f0 91 bc 23 	lds	r31, 0x23BC	; 0x8023bc <adcb_callback+0x1>
    1148:	64 e0       	ldi	r22, 0x04	; 4
    114a:	80 e4       	ldi	r24, 0x40	; 64
    114c:	92 e0       	ldi	r25, 0x02	; 2
    114e:	19 95       	eicall
}
    1150:	ff 91       	pop	r31
    1152:	ef 91       	pop	r30
    1154:	bf 91       	pop	r27
    1156:	af 91       	pop	r26
    1158:	9f 91       	pop	r25
    115a:	8f 91       	pop	r24
    115c:	7f 91       	pop	r23
    115e:	6f 91       	pop	r22
    1160:	5f 91       	pop	r21
    1162:	4f 91       	pop	r20
    1164:	3f 91       	pop	r19
    1166:	2f 91       	pop	r18
    1168:	0f 90       	pop	r0
    116a:	0b be       	out	0x3b, r0	; 59
    116c:	0f 90       	pop	r0
    116e:	0f be       	out	0x3f, r0	; 63
    1170:	0f 90       	pop	r0
    1172:	1f 90       	pop	r1
    1174:	18 95       	reti

00001176 <__vector_42>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH3_vect)
{
    1176:	1f 92       	push	r1
    1178:	0f 92       	push	r0
    117a:	0f b6       	in	r0, 0x3f	; 63
    117c:	0f 92       	push	r0
    117e:	11 24       	eor	r1, r1
    1180:	0b b6       	in	r0, 0x3b	; 59
    1182:	0f 92       	push	r0
    1184:	2f 93       	push	r18
    1186:	3f 93       	push	r19
    1188:	4f 93       	push	r20
    118a:	5f 93       	push	r21
    118c:	6f 93       	push	r22
    118e:	7f 93       	push	r23
    1190:	8f 93       	push	r24
    1192:	9f 93       	push	r25
    1194:	af 93       	push	r26
    1196:	bf 93       	push	r27
    1198:	ef 93       	push	r30
    119a:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH3, adc_get_result(&ADCB, ADC_CH3));
    119c:	40 91 7c 02 	lds	r20, 0x027C	; 0x80027c <__TEXT_REGION_LENGTH__+0x70027c>
    11a0:	50 91 7d 02 	lds	r21, 0x027D	; 0x80027d <__TEXT_REGION_LENGTH__+0x70027d>
    11a4:	e0 91 bb 23 	lds	r30, 0x23BB	; 0x8023bb <adcb_callback>
    11a8:	f0 91 bc 23 	lds	r31, 0x23BC	; 0x8023bc <adcb_callback+0x1>
    11ac:	68 e0       	ldi	r22, 0x08	; 8
    11ae:	80 e4       	ldi	r24, 0x40	; 64
    11b0:	92 e0       	ldi	r25, 0x02	; 2
    11b2:	19 95       	eicall
}
    11b4:	ff 91       	pop	r31
    11b6:	ef 91       	pop	r30
    11b8:	bf 91       	pop	r27
    11ba:	af 91       	pop	r26
    11bc:	9f 91       	pop	r25
    11be:	8f 91       	pop	r24
    11c0:	7f 91       	pop	r23
    11c2:	6f 91       	pop	r22
    11c4:	5f 91       	pop	r21
    11c6:	4f 91       	pop	r20
    11c8:	3f 91       	pop	r19
    11ca:	2f 91       	pop	r18
    11cc:	0f 90       	pop	r0
    11ce:	0b be       	out	0x3b, r0	; 59
    11d0:	0f 90       	pop	r0
    11d2:	0f be       	out	0x3f, r0	; 63
    11d4:	0f 90       	pop	r0
    11d6:	1f 90       	pop	r1
    11d8:	18 95       	reti

000011da <adc_write_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_write_configuration(ADC_t *adc, const struct adc_config *conf)
{
    11da:	df 92       	push	r13
    11dc:	ef 92       	push	r14
    11de:	ff 92       	push	r15
    11e0:	0f 93       	push	r16
    11e2:	1f 93       	push	r17
    11e4:	cf 93       	push	r28
    11e6:	df 93       	push	r29
    11e8:	ec 01       	movw	r28, r24
    11ea:	8b 01       	movw	r16, r22
	uint16_t cal;
	uint8_t enable;
	irqflags_t flags;

#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)&ADCA) {
    11ec:	c1 15       	cp	r28, r1
    11ee:	22 e0       	ldi	r18, 0x02	; 2
    11f0:	d2 07       	cpc	r29, r18
    11f2:	71 f4       	brne	.+28     	; 0x1210 <adc_write_configuration+0x36>
 *
 * \param address Byte offset into the signature row
 */
static inline uint8_t nvm_read_production_signature_row(uint8_t address)
{
	return nvm_read_byte(NVM_CMD_READ_CALIB_ROW_gc, address);
    11f4:	61 e2       	ldi	r22, 0x21	; 33
    11f6:	70 e0       	ldi	r23, 0x00	; 0
    11f8:	82 e0       	ldi	r24, 0x02	; 2
    11fa:	d4 d0       	rcall	.+424    	; 0x13a4 <nvm_read_byte>
	uint16_t data;

	switch (cal) {
#ifdef ADCA
	case ADC_CAL_ADCA:
		data = nvm_read_production_signature_row(ADCACAL1);
    11fc:	e8 2e       	mov	r14, r24
    11fe:	f1 2c       	mov	r15, r1
    1200:	60 e2       	ldi	r22, 0x20	; 32
    1202:	70 e0       	ldi	r23, 0x00	; 0
    1204:	82 e0       	ldi	r24, 0x02	; 2
    1206:	ce d0       	rcall	.+412    	; 0x13a4 <nvm_read_byte>
		data <<= 8;
    1208:	fe 2c       	mov	r15, r14
    120a:	ee 24       	eor	r14, r14
		data |= nvm_read_production_signature_row(ADCACAL0);
    120c:	e8 2a       	or	r14, r24
    120e:	10 c0       	rjmp	.+32     	; 0x1230 <adc_write_configuration+0x56>
		cal = adc_get_calibration_data(ADC_CAL_ADCA);
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)&ADCB) {
    1210:	80 34       	cpi	r24, 0x40	; 64
    1212:	92 40       	sbci	r25, 0x02	; 2
    1214:	51 f5       	brne	.+84     	; 0x126a <adc_write_configuration+0x90>
    1216:	65 e2       	ldi	r22, 0x25	; 37
    1218:	70 e0       	ldi	r23, 0x00	; 0
    121a:	82 e0       	ldi	r24, 0x02	; 2
    121c:	c3 d0       	rcall	.+390    	; 0x13a4 <nvm_read_byte>
		break;
#endif

#ifdef ADCB
	case ADC_CAL_ADCB:
		data = nvm_read_production_signature_row(ADCBCAL1);
    121e:	e8 2e       	mov	r14, r24
    1220:	f1 2c       	mov	r15, r1
    1222:	64 e2       	ldi	r22, 0x24	; 36
    1224:	70 e0       	ldi	r23, 0x00	; 0
    1226:	82 e0       	ldi	r24, 0x02	; 2
    1228:	bd d0       	rcall	.+378    	; 0x13a4 <nvm_read_byte>
		data <<= 8;
    122a:	fe 2c       	mov	r15, r14
    122c:	ee 24       	eor	r14, r14
		data |= nvm_read_production_signature_row(ADCBCAL0);
    122e:	e8 2a       	or	r14, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1230:	df b6       	in	r13, 0x3f	; 63
	cpu_irq_disable();
    1232:	f8 94       	cli
		Assert(0);
		return;
	}

	flags = cpu_irq_save();
	adc_enable_clock(adc);
    1234:	ce 01       	movw	r24, r28
    1236:	ee dd       	rcall	.-1060   	; 0xe14 <adc_enable_clock>
	enable = adc->CTRLA & ADC_ENABLE_bm;
    1238:	88 81       	ld	r24, Y

	adc->CTRLA = ADC_FLUSH_bm;
    123a:	92 e0       	ldi	r25, 0x02	; 2
    123c:	98 83       	st	Y, r25
	adc->CAL = cal;
    123e:	ec 86       	std	Y+12, r14	; 0x0c
    1240:	fd 86       	std	Y+13, r15	; 0x0d
	adc->CMP = conf->cmp;
    1242:	f8 01       	movw	r30, r16
    1244:	25 81       	ldd	r18, Z+5	; 0x05
    1246:	36 81       	ldd	r19, Z+6	; 0x06
    1248:	28 8f       	std	Y+24, r18	; 0x18
    124a:	39 8f       	std	Y+25, r19	; 0x19
	adc->REFCTRL = conf->refctrl;
    124c:	92 81       	ldd	r25, Z+2	; 0x02
    124e:	9a 83       	std	Y+2, r25	; 0x02
	adc->PRESCALER = conf->prescaler;
    1250:	94 81       	ldd	r25, Z+4	; 0x04
    1252:	9c 83       	std	Y+4, r25	; 0x04
	adc->EVCTRL = conf->evctrl;
    1254:	93 81       	ldd	r25, Z+3	; 0x03
    1256:	9b 83       	std	Y+3, r25	; 0x03
	adc->CTRLB = conf->ctrlb;
    1258:	91 81       	ldd	r25, Z+1	; 0x01
    125a:	99 83       	std	Y+1, r25	; 0x01
		return;
	}

	flags = cpu_irq_save();
	adc_enable_clock(adc);
	enable = adc->CTRLA & ADC_ENABLE_bm;
    125c:	81 70       	andi	r24, 0x01	; 1
	adc->REFCTRL = conf->refctrl;
	adc->PRESCALER = conf->prescaler;
	adc->EVCTRL = conf->evctrl;
	adc->CTRLB = conf->ctrlb;

	adc->CTRLA = enable | conf->ctrla;
    125e:	90 81       	ld	r25, Z
    1260:	89 2b       	or	r24, r25
    1262:	88 83       	st	Y, r24

	adc_disable_clock(adc);
    1264:	ce 01       	movw	r24, r28
    1266:	f5 dd       	rcall	.-1046   	; 0xe52 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1268:	df be       	out	0x3f, r13	; 63

	cpu_irq_restore(flags);
}
    126a:	df 91       	pop	r29
    126c:	cf 91       	pop	r28
    126e:	1f 91       	pop	r17
    1270:	0f 91       	pop	r16
    1272:	ff 90       	pop	r15
    1274:	ef 90       	pop	r14
    1276:	df 90       	pop	r13
    1278:	08 95       	ret

0000127a <adc_read_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_read_configuration(ADC_t *adc, struct adc_config *conf)
{
    127a:	ff 92       	push	r15
    127c:	0f 93       	push	r16
    127e:	1f 93       	push	r17
    1280:	cf 93       	push	r28
    1282:	df 93       	push	r29
    1284:	ec 01       	movw	r28, r24
    1286:	8b 01       	movw	r16, r22

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1288:	ff b6       	in	r15, 0x3f	; 63
	cpu_irq_disable();
    128a:	f8 94       	cli
	irqflags_t flags = cpu_irq_save();

	adc_enable_clock(adc);
    128c:	c3 dd       	rcall	.-1146   	; 0xe14 <adc_enable_clock>

	conf->ctrla = adc->CTRLA & ADC_DMASEL_gm;
    128e:	88 81       	ld	r24, Y
    1290:	80 7c       	andi	r24, 0xC0	; 192
    1292:	f8 01       	movw	r30, r16
    1294:	80 83       	st	Z, r24

	conf->cmp = adc->CMP;
    1296:	88 8d       	ldd	r24, Y+24	; 0x18
    1298:	99 8d       	ldd	r25, Y+25	; 0x19
    129a:	85 83       	std	Z+5, r24	; 0x05
    129c:	96 83       	std	Z+6, r25	; 0x06
	conf->refctrl = adc->REFCTRL;
    129e:	8a 81       	ldd	r24, Y+2	; 0x02
    12a0:	82 83       	std	Z+2, r24	; 0x02
	conf->prescaler = adc->PRESCALER;
    12a2:	8c 81       	ldd	r24, Y+4	; 0x04
    12a4:	84 83       	std	Z+4, r24	; 0x04
	conf->evctrl = adc->EVCTRL;
    12a6:	8b 81       	ldd	r24, Y+3	; 0x03
    12a8:	83 83       	std	Z+3, r24	; 0x03
	conf->ctrlb = adc->CTRLB;
    12aa:	89 81       	ldd	r24, Y+1	; 0x01
    12ac:	81 83       	std	Z+1, r24	; 0x01

	adc_disable_clock(adc);
    12ae:	ce 01       	movw	r24, r28
    12b0:	d0 dd       	rcall	.-1120   	; 0xe52 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    12b2:	ff be       	out	0x3f, r15	; 63

	cpu_irq_restore(flags);
}
    12b4:	df 91       	pop	r29
    12b6:	cf 91       	pop	r28
    12b8:	1f 91       	pop	r17
    12ba:	0f 91       	pop	r16
    12bc:	ff 90       	pop	r15
    12be:	08 95       	ret

000012c0 <adcch_write_configuration>:
 * is called if callbacks are enabled and interrupts are enabled in the
 * channel configuration.
 */
void adcch_write_configuration(ADC_t *adc, uint8_t ch_mask,
		const struct adc_channel_config *ch_conf)
{
    12c0:	cf 92       	push	r12
    12c2:	df 92       	push	r13
    12c4:	ef 92       	push	r14
    12c6:	ff 92       	push	r15
    12c8:	0f 93       	push	r16
    12ca:	1f 93       	push	r17
    12cc:	cf 93       	push	r28
    12ce:	df 93       	push	r29
    12d0:	7c 01       	movw	r14, r24
    12d2:	d6 2e       	mov	r13, r22
    12d4:	8a 01       	movw	r16, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    12d6:	86 2f       	mov	r24, r22
    12d8:	83 70       	andi	r24, 0x03	; 3
    12da:	29 f4       	brne	.+10     	; 0x12e6 <adcch_write_configuration+0x26>
		index += 2;
		ch_mask >>= 2;
    12dc:	96 2f       	mov	r25, r22
    12de:	96 95       	lsr	r25
    12e0:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    12e2:	82 e0       	ldi	r24, 0x02	; 2
    12e4:	02 c0       	rjmp	.+4      	; 0x12ea <adcch_write_configuration+0x2a>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    12e6:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
static __always_inline ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    12e8:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    12ea:	90 ff       	sbrs	r25, 0
		index++;
    12ec:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    12ee:	e7 01       	movw	r28, r14
    12f0:	a0 96       	adiw	r28, 0x20	; 32
    12f2:	98 e0       	ldi	r25, 0x08	; 8
    12f4:	89 9f       	mul	r24, r25
    12f6:	c0 0d       	add	r28, r0
    12f8:	d1 1d       	adc	r29, r1
    12fa:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    12fc:	cf b6       	in	r12, 0x3f	; 63
	cpu_irq_disable();
    12fe:	f8 94       	cli
			return;
		}
	}
#endif

	adc_enable_clock(adc);
    1300:	c7 01       	movw	r24, r14
    1302:	88 dd       	rcall	.-1264   	; 0xe14 <adc_enable_clock>
	adc_ch->CTRL = ch_conf->ctrl;
    1304:	f8 01       	movw	r30, r16
    1306:	80 81       	ld	r24, Z
    1308:	88 83       	st	Y, r24
	adc_ch->INTCTRL = ch_conf->intctrl;
    130a:	82 81       	ldd	r24, Z+2	; 0x02
    130c:	8a 83       	std	Y+2, r24	; 0x02
	adc_ch->MUXCTRL = ch_conf->muxctrl;
    130e:	81 81       	ldd	r24, Z+1	; 0x01
    1310:	89 83       	std	Y+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    1312:	d0 fe       	sbrs	r13, 0
    1314:	02 c0       	rjmp	.+4      	; 0x131a <adcch_write_configuration+0x5a>
		/* USB devices has channel scan available on ADC channel 0 */
		adc_ch->SCAN = ch_conf->scan;
    1316:	83 81       	ldd	r24, Z+3	; 0x03
    1318:	8e 83       	std	Y+6, r24	; 0x06
	}
	adc_disable_clock(adc);
    131a:	c7 01       	movw	r24, r14
    131c:	9a dd       	rcall	.-1228   	; 0xe52 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    131e:	cf be       	out	0x3f, r12	; 63

	cpu_irq_restore(flags);
}
    1320:	df 91       	pop	r29
    1322:	cf 91       	pop	r28
    1324:	1f 91       	pop	r17
    1326:	0f 91       	pop	r16
    1328:	ff 90       	pop	r15
    132a:	ef 90       	pop	r14
    132c:	df 90       	pop	r13
    132e:	cf 90       	pop	r12
    1330:	08 95       	ret

00001332 <adcch_read_configuration>:
 * can be given in mask)
 * \param ch_conf Pointer to ADC channel configuration.
 */
void adcch_read_configuration(ADC_t *adc, uint8_t ch_mask,
		struct adc_channel_config *ch_conf)
{
    1332:	cf 92       	push	r12
    1334:	df 92       	push	r13
    1336:	ef 92       	push	r14
    1338:	ff 92       	push	r15
    133a:	0f 93       	push	r16
    133c:	1f 93       	push	r17
    133e:	cf 93       	push	r28
    1340:	df 93       	push	r29
    1342:	7c 01       	movw	r14, r24
    1344:	d6 2e       	mov	r13, r22
    1346:	8a 01       	movw	r16, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1348:	86 2f       	mov	r24, r22
    134a:	83 70       	andi	r24, 0x03	; 3
    134c:	29 f4       	brne	.+10     	; 0x1358 <adcch_read_configuration+0x26>
		index += 2;
		ch_mask >>= 2;
    134e:	96 2f       	mov	r25, r22
    1350:	96 95       	lsr	r25
    1352:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    1354:	82 e0       	ldi	r24, 0x02	; 2
    1356:	02 c0       	rjmp	.+4      	; 0x135c <adcch_read_configuration+0x2a>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1358:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
static __always_inline ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    135a:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    135c:	90 ff       	sbrs	r25, 0
		index++;
    135e:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    1360:	e7 01       	movw	r28, r14
    1362:	a0 96       	adiw	r28, 0x20	; 32
    1364:	98 e0       	ldi	r25, 0x08	; 8
    1366:	89 9f       	mul	r24, r25
    1368:	c0 0d       	add	r28, r0
    136a:	d1 1d       	adc	r29, r1
    136c:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    136e:	cf b6       	in	r12, 0x3f	; 63
	cpu_irq_disable();
    1370:	f8 94       	cli

	adc_ch = adc_get_channel(adc, ch_mask);

	flags = cpu_irq_save();

	adc_enable_clock(adc);
    1372:	c7 01       	movw	r24, r14
    1374:	4f dd       	rcall	.-1378   	; 0xe14 <adc_enable_clock>
	ch_conf->ctrl = adc_ch->CTRL;
    1376:	88 81       	ld	r24, Y
    1378:	f8 01       	movw	r30, r16
    137a:	80 83       	st	Z, r24
	ch_conf->intctrl = adc_ch->INTCTRL;
    137c:	8a 81       	ldd	r24, Y+2	; 0x02
    137e:	82 83       	std	Z+2, r24	; 0x02
	ch_conf->muxctrl = adc_ch->MUXCTRL;
    1380:	89 81       	ldd	r24, Y+1	; 0x01
    1382:	81 83       	std	Z+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    1384:	d0 fe       	sbrs	r13, 0
    1386:	02 c0       	rjmp	.+4      	; 0x138c <adcch_read_configuration+0x5a>
		/* USB devices has channel scan available on ADC channel 0 */
		ch_conf->scan = adc_ch->SCAN;
    1388:	8e 81       	ldd	r24, Y+6	; 0x06
    138a:	83 83       	std	Z+3, r24	; 0x03
	}
	adc_disable_clock(adc);
    138c:	c7 01       	movw	r24, r14
    138e:	61 dd       	rcall	.-1342   	; 0xe52 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1390:	cf be       	out	0x3f, r12	; 63

	cpu_irq_restore(flags);
}
    1392:	df 91       	pop	r29
    1394:	cf 91       	pop	r28
    1396:	1f 91       	pop	r17
    1398:	0f 91       	pop	r16
    139a:	ff 90       	pop	r15
    139c:	ef 90       	pop	r14
    139e:	df 90       	pop	r13
    13a0:	cf 90       	pop	r12
    13a2:	08 95       	ret

000013a4 <nvm_read_byte>:
#endif

#ifndef __DOXYGEN__
	PUBLIC_FUNCTION(nvm_read_byte)
#if defined(__GNUC__)
	lds r20, NVM_CMD          ; Store NVM command register
    13a4:	40 91 ca 01 	lds	r20, 0x01CA	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	mov ZL, r22               ; Load byte index into low byte of Z.
    13a8:	e6 2f       	mov	r30, r22
	mov ZH, r23               ; Load high byte into Z.
    13aa:	f7 2f       	mov	r31, r23
	sts NVM_CMD, r24          ; Load prepared command into NVM Command register.
    13ac:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	lpm r24, Z                ; Perform an LPM to read out byte
    13b0:	84 91       	lpm	r24, Z
	sts NVM_CMD, r20          ; Restore NVM command register
    13b2:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	sts NVM_CMD, r16          ; Load prepared command into NVM Command register.
	lpm r16, Z                ; Perform an LPM to read out byte
	sts NVM_CMD, r20          ; Restore NVM command register
#endif

	ret
    13b6:	08 95       	ret

000013b8 <usart_putchar>:

	if (baud_offset != USART_BAUD_UNDEFINED) {
		(usart)->BAUDCTRLB = (uint8_t)((uint16_t)baudctrl);
		(usart)->BAUDCTRLA = (uint8_t)((uint16_t)baudctrl >> 8);
	}
}
    13b8:	fc 01       	movw	r30, r24
    13ba:	91 81       	ldd	r25, Z+1	; 0x01
    13bc:	95 ff       	sbrs	r25, 5
    13be:	fd cf       	rjmp	.-6      	; 0x13ba <usart_putchar+0x2>
    13c0:	60 83       	st	Z, r22
    13c2:	80 e0       	ldi	r24, 0x00	; 0
    13c4:	90 e0       	ldi	r25, 0x00	; 0
    13c6:	08 95       	ret

000013c8 <usart_set_baudrate>:
 * \retval true if the hardware supports the baud rate
 * \retval false if the hardware does not support the baud rate (i.e. it's
 *               either too high or too low.)
 */
bool usart_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    13c8:	2f 92       	push	r2
    13ca:	3f 92       	push	r3
    13cc:	4f 92       	push	r4
    13ce:	5f 92       	push	r5
    13d0:	6f 92       	push	r6
    13d2:	7f 92       	push	r7
    13d4:	8f 92       	push	r8
    13d6:	9f 92       	push	r9
    13d8:	af 92       	push	r10
    13da:	bf 92       	push	r11
    13dc:	cf 92       	push	r12
    13de:	df 92       	push	r13
    13e0:	ef 92       	push	r14
    13e2:	ff 92       	push	r15
    13e4:	0f 93       	push	r16
    13e6:	1f 93       	push	r17
    13e8:	cf 93       	push	r28
    13ea:	1c 01       	movw	r2, r24
    13ec:	2a 01       	movw	r4, r20
    13ee:	3b 01       	movw	r6, r22
    13f0:	48 01       	movw	r8, r16
    13f2:	59 01       	movw	r10, r18

	/*
	 * Check if the hardware supports the given baud rate
	 */
	/* 8 = (2^0) * 8 * (2^0) = (2^BSCALE_MIN) * 8 * (BSEL_MIN) */
	max_rate = cpu_hz / 8;
    13f4:	d9 01       	movw	r26, r18
    13f6:	c8 01       	movw	r24, r16
    13f8:	68 94       	set
    13fa:	12 f8       	bld	r1, 2
    13fc:	b6 95       	lsr	r27
    13fe:	a7 95       	ror	r26
    1400:	97 95       	ror	r25
    1402:	87 95       	ror	r24
    1404:	16 94       	lsr	r1
    1406:	d1 f7       	brne	.-12     	; 0x13fc <usart_set_baudrate+0x34>
	/* 4194304 = (2^7) * 8 * (2^12) = (2^BSCALE_MAX) * 8 * (BSEL_MAX+1) */
	min_rate = cpu_hz / 4194304;
    1408:	b9 01       	movw	r22, r18
    140a:	a8 01       	movw	r20, r16
    140c:	03 2e       	mov	r0, r19
    140e:	36 e1       	ldi	r19, 0x16	; 22
    1410:	76 95       	lsr	r23
    1412:	67 95       	ror	r22
    1414:	57 95       	ror	r21
    1416:	47 95       	ror	r20
    1418:	3a 95       	dec	r19
    141a:	d1 f7       	brne	.-12     	; 0x1410 <usart_set_baudrate+0x48>
    141c:	30 2d       	mov	r19, r0

	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
    141e:	f1 01       	movw	r30, r2
    1420:	24 81       	ldd	r18, Z+4	; 0x04
    1422:	22 fd       	sbrc	r18, 2
    1424:	08 c0       	rjmp	.+16     	; 0x1436 <usart_set_baudrate+0x6e>
		max_rate /= 2;
    1426:	b6 95       	lsr	r27
    1428:	a7 95       	ror	r26
    142a:	97 95       	ror	r25
    142c:	87 95       	ror	r24
		min_rate /= 2;
    142e:	76 95       	lsr	r23
    1430:	67 95       	ror	r22
    1432:	57 95       	ror	r21
    1434:	47 95       	ror	r20
	}

	if ((baud > max_rate) || (baud < min_rate)) {
    1436:	84 15       	cp	r24, r4
    1438:	95 05       	cpc	r25, r5
    143a:	a6 05       	cpc	r26, r6
    143c:	b7 05       	cpc	r27, r7
    143e:	08 f4       	brcc	.+2      	; 0x1442 <usart_set_baudrate+0x7a>
    1440:	ae c0       	rjmp	.+348    	; 0x159e <usart_set_baudrate+0x1d6>
    1442:	44 16       	cp	r4, r20
    1444:	55 06       	cpc	r5, r21
    1446:	66 06       	cpc	r6, r22
    1448:	77 06       	cpc	r7, r23
    144a:	08 f4       	brcc	.+2      	; 0x144e <usart_set_baudrate+0x86>
    144c:	aa c0       	rjmp	.+340    	; 0x15a2 <usart_set_baudrate+0x1da>
		return false;
	}

	/* Check if double speed is enabled. */
	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
    144e:	f1 01       	movw	r30, r2
    1450:	84 81       	ldd	r24, Z+4	; 0x04
    1452:	82 fd       	sbrc	r24, 2
    1454:	04 c0       	rjmp	.+8      	; 0x145e <usart_set_baudrate+0x96>
		baud *= 2;
    1456:	44 0c       	add	r4, r4
    1458:	55 1c       	adc	r5, r5
    145a:	66 1c       	adc	r6, r6
    145c:	77 1c       	adc	r7, r7
	}

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;
    145e:	c5 01       	movw	r24, r10
    1460:	b4 01       	movw	r22, r8
    1462:	a3 01       	movw	r20, r6
    1464:	92 01       	movw	r18, r4
    1466:	0e 94 01 1c 	call	0x3802	; 0x3802 <__udivmodsi4>

	for (exp = -7; exp < 7; exp++) {
		if (ratio < limit) {
    146a:	2f 3f       	cpi	r18, 0xFF	; 255
    146c:	31 05       	cpc	r19, r1
    146e:	41 05       	cpc	r20, r1
    1470:	51 05       	cpc	r21, r1
    1472:	08 f4       	brcc	.+2      	; 0x1476 <usart_set_baudrate+0xae>
    1474:	98 c0       	rjmp	.+304    	; 0x15a6 <usart_set_baudrate+0x1de>
    1476:	c1 2c       	mov	r12, r1
    1478:	d1 2c       	mov	r13, r1
    147a:	76 01       	movw	r14, r12
    147c:	ca 94       	dec	r12
    147e:	c9 ef       	ldi	r28, 0xF9	; 249
    1480:	05 c0       	rjmp	.+10     	; 0x148c <usart_set_baudrate+0xc4>
    1482:	2c 15       	cp	r18, r12
    1484:	3d 05       	cpc	r19, r13
    1486:	4e 05       	cpc	r20, r14
    1488:	5f 05       	cpc	r21, r15
    148a:	68 f0       	brcs	.+26     	; 0x14a6 <usart_set_baudrate+0xde>
			break;
		}

		limit <<= 1;
    148c:	cc 0c       	add	r12, r12
    148e:	dd 1c       	adc	r13, r13
    1490:	ee 1c       	adc	r14, r14
    1492:	ff 1c       	adc	r15, r15

		if (exp < -3) {
    1494:	cd 3f       	cpi	r28, 0xFD	; 253
    1496:	14 f4       	brge	.+4      	; 0x149c <usart_set_baudrate+0xd4>
			limit |= 1;
    1498:	68 94       	set
    149a:	c0 f8       	bld	r12, 0
    149c:	cf 5f       	subi	r28, 0xFF	; 255

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;

	for (exp = -7; exp < 7; exp++) {
    149e:	c7 30       	cpi	r28, 0x07	; 7
    14a0:	81 f7       	brne	.-32     	; 0x1482 <usart_set_baudrate+0xba>
    14a2:	8c 2f       	mov	r24, r28
    14a4:	56 c0       	rjmp	.+172    	; 0x1552 <usart_set_baudrate+0x18a>
    14a6:	8c 2f       	mov	r24, r28
	 * point.
	 *
	 * The formula for calculating BSEL is slightly different when exp is
	 * negative than it is when exp is positive.
	 */
	if (exp < 0) {
    14a8:	cc 23       	and	r28, r28
    14aa:	0c f0       	brlt	.+2      	; 0x14ae <usart_set_baudrate+0xe6>
    14ac:	52 c0       	rjmp	.+164    	; 0x1552 <usart_set_baudrate+0x18a>
		/* We are supposed to subtract 1, then apply BSCALE. We want to
		 * apply BSCALE first, so we need to turn everything inside the
		 * parenthesis into a single fractional expression.
		 */
		cpu_hz -= 8 * baud;
    14ae:	d3 01       	movw	r26, r6
    14b0:	c2 01       	movw	r24, r4
    14b2:	88 0f       	add	r24, r24
    14b4:	99 1f       	adc	r25, r25
    14b6:	aa 1f       	adc	r26, r26
    14b8:	bb 1f       	adc	r27, r27
    14ba:	88 0f       	add	r24, r24
    14bc:	99 1f       	adc	r25, r25
    14be:	aa 1f       	adc	r26, r26
    14c0:	bb 1f       	adc	r27, r27
    14c2:	88 0f       	add	r24, r24
    14c4:	99 1f       	adc	r25, r25
    14c6:	aa 1f       	adc	r26, r26
    14c8:	bb 1f       	adc	r27, r27
    14ca:	85 01       	movw	r16, r10
    14cc:	74 01       	movw	r14, r8
    14ce:	e8 1a       	sub	r14, r24
    14d0:	f9 0a       	sbc	r15, r25
    14d2:	0a 0b       	sbc	r16, r26
    14d4:	1b 0b       	sbc	r17, r27
    14d6:	d8 01       	movw	r26, r16
    14d8:	c7 01       	movw	r24, r14
		/* If we end up with a left-shift after taking the final
		 * divide-by-8 into account, do the shift before the divide.
		 * Otherwise, left-shift the denominator instead (effectively
		 * resulting in an overall right shift.)
		 */
		if (exp <= -3) {
    14da:	ce 3f       	cpi	r28, 0xFE	; 254
    14dc:	f4 f4       	brge	.+60     	; 0x151a <usart_set_baudrate+0x152>
			div = ((cpu_hz << (-exp - 3)) + baud / 2) / baud;
    14de:	2d ef       	ldi	r18, 0xFD	; 253
    14e0:	3f ef       	ldi	r19, 0xFF	; 255
    14e2:	2c 1b       	sub	r18, r28
    14e4:	31 09       	sbc	r19, r1
    14e6:	c7 fd       	sbrc	r28, 7
    14e8:	33 95       	inc	r19
    14ea:	04 c0       	rjmp	.+8      	; 0x14f4 <usart_set_baudrate+0x12c>
    14ec:	88 0f       	add	r24, r24
    14ee:	99 1f       	adc	r25, r25
    14f0:	aa 1f       	adc	r26, r26
    14f2:	bb 1f       	adc	r27, r27
    14f4:	2a 95       	dec	r18
    14f6:	d2 f7       	brpl	.-12     	; 0x14ec <usart_set_baudrate+0x124>
    14f8:	73 01       	movw	r14, r6
    14fa:	62 01       	movw	r12, r4
    14fc:	f6 94       	lsr	r15
    14fe:	e7 94       	ror	r14
    1500:	d7 94       	ror	r13
    1502:	c7 94       	ror	r12
    1504:	bc 01       	movw	r22, r24
    1506:	cd 01       	movw	r24, r26
    1508:	6c 0d       	add	r22, r12
    150a:	7d 1d       	adc	r23, r13
    150c:	8e 1d       	adc	r24, r14
    150e:	9f 1d       	adc	r25, r15
    1510:	a3 01       	movw	r20, r6
    1512:	92 01       	movw	r18, r4
    1514:	0e 94 01 1c 	call	0x3802	; 0x3802 <__udivmodsi4>
    1518:	38 c0       	rjmp	.+112    	; 0x158a <usart_set_baudrate+0x1c2>
		} else {
			baud <<= exp + 3;
    151a:	23 e0       	ldi	r18, 0x03	; 3
    151c:	2c 0f       	add	r18, r28
    151e:	83 01       	movw	r16, r6
    1520:	72 01       	movw	r14, r4
    1522:	04 c0       	rjmp	.+8      	; 0x152c <usart_set_baudrate+0x164>
    1524:	ee 0c       	add	r14, r14
    1526:	ff 1c       	adc	r15, r15
    1528:	00 1f       	adc	r16, r16
    152a:	11 1f       	adc	r17, r17
    152c:	2a 95       	dec	r18
    152e:	d2 f7       	brpl	.-12     	; 0x1524 <usart_set_baudrate+0x15c>
    1530:	a8 01       	movw	r20, r16
    1532:	97 01       	movw	r18, r14
			div = (cpu_hz + baud / 2) / baud;
    1534:	67 01       	movw	r12, r14
    1536:	78 01       	movw	r14, r16
    1538:	f6 94       	lsr	r15
    153a:	e7 94       	ror	r14
    153c:	d7 94       	ror	r13
    153e:	c7 94       	ror	r12
    1540:	bc 01       	movw	r22, r24
    1542:	cd 01       	movw	r24, r26
    1544:	6c 0d       	add	r22, r12
    1546:	7d 1d       	adc	r23, r13
    1548:	8e 1d       	adc	r24, r14
    154a:	9f 1d       	adc	r25, r15
    154c:	0e 94 01 1c 	call	0x3802	; 0x3802 <__udivmodsi4>
    1550:	1c c0       	rjmp	.+56     	; 0x158a <usart_set_baudrate+0x1c2>
		}
	} else {
		/* We will always do a right shift in this case, but we need to
		 * shift three extra positions because of the divide-by-8.
		 */
		baud <<= exp + 3;
    1552:	8d 5f       	subi	r24, 0xFD	; 253
    1554:	a3 01       	movw	r20, r6
    1556:	92 01       	movw	r18, r4
    1558:	04 c0       	rjmp	.+8      	; 0x1562 <usart_set_baudrate+0x19a>
    155a:	22 0f       	add	r18, r18
    155c:	33 1f       	adc	r19, r19
    155e:	44 1f       	adc	r20, r20
    1560:	55 1f       	adc	r21, r21
    1562:	8a 95       	dec	r24
    1564:	d2 f7       	brpl	.-12     	; 0x155a <usart_set_baudrate+0x192>
		div = (cpu_hz + baud / 2) / baud - 1;
    1566:	da 01       	movw	r26, r20
    1568:	c9 01       	movw	r24, r18
    156a:	b6 95       	lsr	r27
    156c:	a7 95       	ror	r26
    156e:	97 95       	ror	r25
    1570:	87 95       	ror	r24
    1572:	bc 01       	movw	r22, r24
    1574:	cd 01       	movw	r24, r26
    1576:	68 0d       	add	r22, r8
    1578:	79 1d       	adc	r23, r9
    157a:	8a 1d       	adc	r24, r10
    157c:	9b 1d       	adc	r25, r11
    157e:	0e 94 01 1c 	call	0x3802	; 0x3802 <__udivmodsi4>
    1582:	21 50       	subi	r18, 0x01	; 1
    1584:	31 09       	sbc	r19, r1
    1586:	41 09       	sbc	r20, r1
    1588:	51 09       	sbc	r21, r1
	}

	(usart)->BAUDCTRLB = (uint8_t)(((div >> 8) & 0X0F) | (exp << 4));
    158a:	83 2f       	mov	r24, r19
    158c:	8f 70       	andi	r24, 0x0F	; 15
    158e:	c2 95       	swap	r28
    1590:	c0 7f       	andi	r28, 0xF0	; 240
    1592:	c8 2b       	or	r28, r24
    1594:	f1 01       	movw	r30, r2
    1596:	c7 83       	std	Z+7, r28	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)div;
    1598:	26 83       	std	Z+6, r18	; 0x06

	return true;
    159a:	81 e0       	ldi	r24, 0x01	; 1
    159c:	1c c0       	rjmp	.+56     	; 0x15d6 <usart_set_baudrate+0x20e>
		max_rate /= 2;
		min_rate /= 2;
	}

	if ((baud > max_rate) || (baud < min_rate)) {
		return false;
    159e:	80 e0       	ldi	r24, 0x00	; 0
    15a0:	1a c0       	rjmp	.+52     	; 0x15d6 <usart_set_baudrate+0x20e>
    15a2:	80 e0       	ldi	r24, 0x00	; 0
    15a4:	18 c0       	rjmp	.+48     	; 0x15d6 <usart_set_baudrate+0x20e>
	if (exp < 0) {
		/* We are supposed to subtract 1, then apply BSCALE. We want to
		 * apply BSCALE first, so we need to turn everything inside the
		 * parenthesis into a single fractional expression.
		 */
		cpu_hz -= 8 * baud;
    15a6:	d3 01       	movw	r26, r6
    15a8:	c2 01       	movw	r24, r4
    15aa:	88 0f       	add	r24, r24
    15ac:	99 1f       	adc	r25, r25
    15ae:	aa 1f       	adc	r26, r26
    15b0:	bb 1f       	adc	r27, r27
    15b2:	88 0f       	add	r24, r24
    15b4:	99 1f       	adc	r25, r25
    15b6:	aa 1f       	adc	r26, r26
    15b8:	bb 1f       	adc	r27, r27
    15ba:	88 0f       	add	r24, r24
    15bc:	99 1f       	adc	r25, r25
    15be:	aa 1f       	adc	r26, r26
    15c0:	bb 1f       	adc	r27, r27
    15c2:	85 01       	movw	r16, r10
    15c4:	74 01       	movw	r14, r8
    15c6:	e8 1a       	sub	r14, r24
    15c8:	f9 0a       	sbc	r15, r25
    15ca:	0a 0b       	sbc	r16, r26
    15cc:	1b 0b       	sbc	r17, r27
    15ce:	d8 01       	movw	r26, r16
    15d0:	c7 01       	movw	r24, r14

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;

	for (exp = -7; exp < 7; exp++) {
    15d2:	c9 ef       	ldi	r28, 0xF9	; 249
    15d4:	84 cf       	rjmp	.-248    	; 0x14de <usart_set_baudrate+0x116>

	(usart)->BAUDCTRLB = (uint8_t)(((div >> 8) & 0X0F) | (exp << 4));
	(usart)->BAUDCTRLA = (uint8_t)div;

	return true;
}
    15d6:	cf 91       	pop	r28
    15d8:	1f 91       	pop	r17
    15da:	0f 91       	pop	r16
    15dc:	ff 90       	pop	r15
    15de:	ef 90       	pop	r14
    15e0:	df 90       	pop	r13
    15e2:	cf 90       	pop	r12
    15e4:	bf 90       	pop	r11
    15e6:	af 90       	pop	r10
    15e8:	9f 90       	pop	r9
    15ea:	8f 90       	pop	r8
    15ec:	7f 90       	pop	r7
    15ee:	6f 90       	pop	r6
    15f0:	5f 90       	pop	r5
    15f2:	4f 90       	pop	r4
    15f4:	3f 90       	pop	r3
    15f6:	2f 90       	pop	r2
    15f8:	08 95       	ret

000015fa <usart_init_rs232>:
 *
 * \retval true if the initialization was successfull
 * \retval false if the initialization failed (error in baud rate calculation)
 */
bool usart_init_rs232(USART_t *usart, const usart_rs232_options_t *opt)
{
    15fa:	0f 93       	push	r16
    15fc:	1f 93       	push	r17
    15fe:	cf 93       	push	r28
    1600:	df 93       	push	r29
    1602:	ec 01       	movw	r28, r24
    1604:	8b 01       	movw	r16, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    1606:	00 97       	sbiw	r24, 0x00	; 0
    1608:	09 f4       	brne	.+2      	; 0x160c <usart_init_rs232+0x12>
    160a:	e6 c0       	rjmp	.+460    	; 0x17d8 <usart_init_rs232+0x1de>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    160c:	80 3c       	cpi	r24, 0xC0	; 192
    160e:	91 05       	cpc	r25, r1
    1610:	21 f4       	brne	.+8      	; 0x161a <usart_init_rs232+0x20>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    1612:	60 e1       	ldi	r22, 0x10	; 16
    1614:	80 e0       	ldi	r24, 0x00	; 0
    1616:	1d d9       	rcall	.-3526   	; 0x852 <sysclk_enable_module>
    1618:	df c0       	rjmp	.+446    	; 0x17d8 <usart_init_rs232+0x1de>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    161a:	c0 38       	cpi	r28, 0x80	; 128
    161c:	81 e0       	ldi	r24, 0x01	; 1
    161e:	d8 07       	cpc	r29, r24
    1620:	21 f4       	brne	.+8      	; 0x162a <usart_init_rs232+0x30>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    1622:	62 e0       	ldi	r22, 0x02	; 2
    1624:	80 e0       	ldi	r24, 0x00	; 0
    1626:	15 d9       	rcall	.-3542   	; 0x852 <sysclk_enable_module>
    1628:	d7 c0       	rjmp	.+430    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    162a:	c1 15       	cp	r28, r1
    162c:	e1 e0       	ldi	r30, 0x01	; 1
    162e:	de 07       	cpc	r29, r30
    1630:	21 f4       	brne	.+8      	; 0x163a <usart_init_rs232+0x40>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    1632:	61 e0       	ldi	r22, 0x01	; 1
    1634:	80 e0       	ldi	r24, 0x00	; 0
    1636:	0d d9       	rcall	.-3558   	; 0x852 <sysclk_enable_module>
    1638:	cf c0       	rjmp	.+414    	; 0x17d8 <usart_init_rs232+0x1de>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    163a:	c0 38       	cpi	r28, 0x80	; 128
    163c:	f3 e0       	ldi	r31, 0x03	; 3
    163e:	df 07       	cpc	r29, r31
    1640:	21 f4       	brne	.+8      	; 0x164a <usart_init_rs232+0x50>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    1642:	61 e0       	ldi	r22, 0x01	; 1
    1644:	81 e0       	ldi	r24, 0x01	; 1
    1646:	05 d9       	rcall	.-3574   	; 0x852 <sysclk_enable_module>
    1648:	c7 c0       	rjmp	.+398    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    164a:	c0 39       	cpi	r28, 0x90	; 144
    164c:	83 e0       	ldi	r24, 0x03	; 3
    164e:	d8 07       	cpc	r29, r24
    1650:	21 f4       	brne	.+8      	; 0x165a <usart_init_rs232+0x60>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    1652:	61 e0       	ldi	r22, 0x01	; 1
    1654:	82 e0       	ldi	r24, 0x02	; 2
    1656:	fd d8       	rcall	.-3590   	; 0x852 <sysclk_enable_module>
    1658:	bf c0       	rjmp	.+382    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    165a:	c1 15       	cp	r28, r1
    165c:	e2 e0       	ldi	r30, 0x02	; 2
    165e:	de 07       	cpc	r29, r30
    1660:	21 f4       	brne	.+8      	; 0x166a <usart_init_rs232+0x70>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    1662:	62 e0       	ldi	r22, 0x02	; 2
    1664:	81 e0       	ldi	r24, 0x01	; 1
    1666:	f5 d8       	rcall	.-3606   	; 0x852 <sysclk_enable_module>
    1668:	b7 c0       	rjmp	.+366    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    166a:	c0 34       	cpi	r28, 0x40	; 64
    166c:	f2 e0       	ldi	r31, 0x02	; 2
    166e:	df 07       	cpc	r29, r31
    1670:	21 f4       	brne	.+8      	; 0x167a <usart_init_rs232+0x80>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    1672:	62 e0       	ldi	r22, 0x02	; 2
    1674:	82 e0       	ldi	r24, 0x02	; 2
    1676:	ed d8       	rcall	.-3622   	; 0x852 <sysclk_enable_module>
    1678:	af c0       	rjmp	.+350    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    167a:	c0 32       	cpi	r28, 0x20	; 32
    167c:	83 e0       	ldi	r24, 0x03	; 3
    167e:	d8 07       	cpc	r29, r24
    1680:	21 f4       	brne	.+8      	; 0x168a <usart_init_rs232+0x90>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    1682:	64 e0       	ldi	r22, 0x04	; 4
    1684:	82 e0       	ldi	r24, 0x02	; 2
    1686:	e5 d8       	rcall	.-3638   	; 0x852 <sysclk_enable_module>
    1688:	a7 c0       	rjmp	.+334    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    168a:	c1 15       	cp	r28, r1
    168c:	e8 e0       	ldi	r30, 0x08	; 8
    168e:	de 07       	cpc	r29, r30
    1690:	21 f4       	brne	.+8      	; 0x169a <usart_init_rs232+0xa0>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    1692:	61 e0       	ldi	r22, 0x01	; 1
    1694:	83 e0       	ldi	r24, 0x03	; 3
    1696:	dd d8       	rcall	.-3654   	; 0x852 <sysclk_enable_module>
    1698:	9f c0       	rjmp	.+318    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    169a:	c1 15       	cp	r28, r1
    169c:	f9 e0       	ldi	r31, 0x09	; 9
    169e:	df 07       	cpc	r29, r31
    16a0:	21 f4       	brne	.+8      	; 0x16aa <usart_init_rs232+0xb0>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    16a2:	61 e0       	ldi	r22, 0x01	; 1
    16a4:	84 e0       	ldi	r24, 0x04	; 4
    16a6:	d5 d8       	rcall	.-3670   	; 0x852 <sysclk_enable_module>
    16a8:	97 c0       	rjmp	.+302    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    16aa:	c1 15       	cp	r28, r1
    16ac:	8a e0       	ldi	r24, 0x0A	; 10
    16ae:	d8 07       	cpc	r29, r24
    16b0:	21 f4       	brne	.+8      	; 0x16ba <usart_init_rs232+0xc0>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    16b2:	61 e0       	ldi	r22, 0x01	; 1
    16b4:	85 e0       	ldi	r24, 0x05	; 5
    16b6:	cd d8       	rcall	.-3686   	; 0x852 <sysclk_enable_module>
    16b8:	8f c0       	rjmp	.+286    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    16ba:	c1 15       	cp	r28, r1
    16bc:	eb e0       	ldi	r30, 0x0B	; 11
    16be:	de 07       	cpc	r29, r30
    16c0:	21 f4       	brne	.+8      	; 0x16ca <usart_init_rs232+0xd0>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    16c2:	61 e0       	ldi	r22, 0x01	; 1
    16c4:	86 e0       	ldi	r24, 0x06	; 6
    16c6:	c5 d8       	rcall	.-3702   	; 0x852 <sysclk_enable_module>
    16c8:	87 c0       	rjmp	.+270    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    16ca:	c0 34       	cpi	r28, 0x40	; 64
    16cc:	f8 e0       	ldi	r31, 0x08	; 8
    16ce:	df 07       	cpc	r29, r31
    16d0:	21 f4       	brne	.+8      	; 0x16da <usart_init_rs232+0xe0>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    16d2:	62 e0       	ldi	r22, 0x02	; 2
    16d4:	83 e0       	ldi	r24, 0x03	; 3
    16d6:	bd d8       	rcall	.-3718   	; 0x852 <sysclk_enable_module>
    16d8:	7f c0       	rjmp	.+254    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    16da:	c0 34       	cpi	r28, 0x40	; 64
    16dc:	89 e0       	ldi	r24, 0x09	; 9
    16de:	d8 07       	cpc	r29, r24
    16e0:	21 f4       	brne	.+8      	; 0x16ea <usart_init_rs232+0xf0>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    16e2:	62 e0       	ldi	r22, 0x02	; 2
    16e4:	84 e0       	ldi	r24, 0x04	; 4
    16e6:	b5 d8       	rcall	.-3734   	; 0x852 <sysclk_enable_module>
    16e8:	77 c0       	rjmp	.+238    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    16ea:	c0 34       	cpi	r28, 0x40	; 64
    16ec:	ea e0       	ldi	r30, 0x0A	; 10
    16ee:	de 07       	cpc	r29, r30
    16f0:	21 f4       	brne	.+8      	; 0x16fa <usart_init_rs232+0x100>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    16f2:	62 e0       	ldi	r22, 0x02	; 2
    16f4:	85 e0       	ldi	r24, 0x05	; 5
    16f6:	ad d8       	rcall	.-3750   	; 0x852 <sysclk_enable_module>
    16f8:	6f c0       	rjmp	.+222    	; 0x17d8 <usart_init_rs232+0x1de>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    16fa:	c0 39       	cpi	r28, 0x90	; 144
    16fc:	f8 e0       	ldi	r31, 0x08	; 8
    16fe:	df 07       	cpc	r29, r31
    1700:	21 f4       	brne	.+8      	; 0x170a <usart_init_rs232+0x110>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    1702:	64 e0       	ldi	r22, 0x04	; 4
    1704:	83 e0       	ldi	r24, 0x03	; 3
    1706:	a5 d8       	rcall	.-3766   	; 0x852 <sysclk_enable_module>
    1708:	67 c0       	rjmp	.+206    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    170a:	c0 39       	cpi	r28, 0x90	; 144
    170c:	89 e0       	ldi	r24, 0x09	; 9
    170e:	d8 07       	cpc	r29, r24
    1710:	21 f4       	brne	.+8      	; 0x171a <usart_init_rs232+0x120>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    1712:	64 e0       	ldi	r22, 0x04	; 4
    1714:	84 e0       	ldi	r24, 0x04	; 4
    1716:	9d d8       	rcall	.-3782   	; 0x852 <sysclk_enable_module>
    1718:	5f c0       	rjmp	.+190    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    171a:	c0 39       	cpi	r28, 0x90	; 144
    171c:	ea e0       	ldi	r30, 0x0A	; 10
    171e:	de 07       	cpc	r29, r30
    1720:	21 f4       	brne	.+8      	; 0x172a <usart_init_rs232+0x130>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    1722:	64 e0       	ldi	r22, 0x04	; 4
    1724:	85 e0       	ldi	r24, 0x05	; 5
    1726:	95 d8       	rcall	.-3798   	; 0x852 <sysclk_enable_module>
    1728:	57 c0       	rjmp	.+174    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    172a:	c0 39       	cpi	r28, 0x90	; 144
    172c:	fb e0       	ldi	r31, 0x0B	; 11
    172e:	df 07       	cpc	r29, r31
    1730:	21 f4       	brne	.+8      	; 0x173a <usart_init_rs232+0x140>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    1732:	64 e0       	ldi	r22, 0x04	; 4
    1734:	86 e0       	ldi	r24, 0x06	; 6
    1736:	8d d8       	rcall	.-3814   	; 0x852 <sysclk_enable_module>
    1738:	4f c0       	rjmp	.+158    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    173a:	c0 3c       	cpi	r28, 0xC0	; 192
    173c:	88 e0       	ldi	r24, 0x08	; 8
    173e:	d8 07       	cpc	r29, r24
    1740:	21 f4       	brne	.+8      	; 0x174a <usart_init_rs232+0x150>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    1742:	68 e0       	ldi	r22, 0x08	; 8
    1744:	83 e0       	ldi	r24, 0x03	; 3
    1746:	85 d8       	rcall	.-3830   	; 0x852 <sysclk_enable_module>
    1748:	47 c0       	rjmp	.+142    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    174a:	c0 3c       	cpi	r28, 0xC0	; 192
    174c:	e9 e0       	ldi	r30, 0x09	; 9
    174e:	de 07       	cpc	r29, r30
    1750:	21 f4       	brne	.+8      	; 0x175a <usart_init_rs232+0x160>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    1752:	68 e0       	ldi	r22, 0x08	; 8
    1754:	84 e0       	ldi	r24, 0x04	; 4
    1756:	7d d8       	rcall	.-3846   	; 0x852 <sysclk_enable_module>
    1758:	3f c0       	rjmp	.+126    	; 0x17d8 <usart_init_rs232+0x1de>
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    175a:	c0 3a       	cpi	r28, 0xA0	; 160
    175c:	f8 e0       	ldi	r31, 0x08	; 8
    175e:	df 07       	cpc	r29, r31
    1760:	21 f4       	brne	.+8      	; 0x176a <usart_init_rs232+0x170>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    1762:	60 e1       	ldi	r22, 0x10	; 16
    1764:	83 e0       	ldi	r24, 0x03	; 3
    1766:	75 d8       	rcall	.-3862   	; 0x852 <sysclk_enable_module>
    1768:	37 c0       	rjmp	.+110    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    176a:	c0 3a       	cpi	r28, 0xA0	; 160
    176c:	89 e0       	ldi	r24, 0x09	; 9
    176e:	d8 07       	cpc	r29, r24
    1770:	21 f4       	brne	.+8      	; 0x177a <usart_init_rs232+0x180>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    1772:	60 e1       	ldi	r22, 0x10	; 16
    1774:	84 e0       	ldi	r24, 0x04	; 4
    1776:	6d d8       	rcall	.-3878   	; 0x852 <sysclk_enable_module>
    1778:	2f c0       	rjmp	.+94     	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    177a:	c0 3a       	cpi	r28, 0xA0	; 160
    177c:	ea e0       	ldi	r30, 0x0A	; 10
    177e:	de 07       	cpc	r29, r30
    1780:	21 f4       	brne	.+8      	; 0x178a <usart_init_rs232+0x190>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    1782:	60 e1       	ldi	r22, 0x10	; 16
    1784:	85 e0       	ldi	r24, 0x05	; 5
    1786:	65 d8       	rcall	.-3894   	; 0x852 <sysclk_enable_module>
    1788:	27 c0       	rjmp	.+78     	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    178a:	c0 3a       	cpi	r28, 0xA0	; 160
    178c:	fb e0       	ldi	r31, 0x0B	; 11
    178e:	df 07       	cpc	r29, r31
    1790:	21 f4       	brne	.+8      	; 0x179a <usart_init_rs232+0x1a0>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    1792:	60 e1       	ldi	r22, 0x10	; 16
    1794:	86 e0       	ldi	r24, 0x06	; 6
    1796:	5d d8       	rcall	.-3910   	; 0x852 <sysclk_enable_module>
    1798:	1f c0       	rjmp	.+62     	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    179a:	c0 3b       	cpi	r28, 0xB0	; 176
    179c:	88 e0       	ldi	r24, 0x08	; 8
    179e:	d8 07       	cpc	r29, r24
    17a0:	21 f4       	brne	.+8      	; 0x17aa <usart_init_rs232+0x1b0>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    17a2:	60 e2       	ldi	r22, 0x20	; 32
    17a4:	83 e0       	ldi	r24, 0x03	; 3
    17a6:	55 d8       	rcall	.-3926   	; 0x852 <sysclk_enable_module>
    17a8:	17 c0       	rjmp	.+46     	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    17aa:	c0 3b       	cpi	r28, 0xB0	; 176
    17ac:	e9 e0       	ldi	r30, 0x09	; 9
    17ae:	de 07       	cpc	r29, r30
    17b0:	21 f4       	brne	.+8      	; 0x17ba <usart_init_rs232+0x1c0>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    17b2:	60 e2       	ldi	r22, 0x20	; 32
    17b4:	84 e0       	ldi	r24, 0x04	; 4
    17b6:	4d d8       	rcall	.-3942   	; 0x852 <sysclk_enable_module>
    17b8:	0f c0       	rjmp	.+30     	; 0x17d8 <usart_init_rs232+0x1de>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    17ba:	c0 38       	cpi	r28, 0x80	; 128
    17bc:	f4 e0       	ldi	r31, 0x04	; 4
    17be:	df 07       	cpc	r29, r31
    17c0:	21 f4       	brne	.+8      	; 0x17ca <usart_init_rs232+0x1d0>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    17c2:	60 e4       	ldi	r22, 0x40	; 64
    17c4:	83 e0       	ldi	r24, 0x03	; 3
    17c6:	45 d8       	rcall	.-3958   	; 0x852 <sysclk_enable_module>
    17c8:	07 c0       	rjmp	.+14     	; 0x17d8 <usart_init_rs232+0x1de>
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    17ca:	c0 3a       	cpi	r28, 0xA0	; 160
    17cc:	84 e0       	ldi	r24, 0x04	; 4
    17ce:	d8 07       	cpc	r29, r24
    17d0:	19 f4       	brne	.+6      	; 0x17d8 <usart_init_rs232+0x1de>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    17d2:	60 e4       	ldi	r22, 0x40	; 64
    17d4:	85 e0       	ldi	r24, 0x05	; 5
    17d6:	3d d8       	rcall	.-3974   	; 0x852 <sysclk_enable_module>
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    17d8:	8d 81       	ldd	r24, Y+5	; 0x05
    17da:	8f 73       	andi	r24, 0x3F	; 63
    17dc:	8d 83       	std	Y+5, r24	; 0x05
 *  \param twoStopBits Enable two stop bit mode. Use bool type.
 */
static inline void usart_format_set(USART_t *usart, USART_CHSIZE_t charSize,
		USART_PMODE_t parityMode, bool twoStopBits)
{
	(usart)->CTRLC = (uint8_t)charSize | parityMode
    17de:	f8 01       	movw	r30, r16
    17e0:	94 81       	ldd	r25, Z+4	; 0x04
    17e2:	85 81       	ldd	r24, Z+5	; 0x05
    17e4:	89 2b       	or	r24, r25
    17e6:	96 81       	ldd	r25, Z+6	; 0x06
    17e8:	91 11       	cpse	r25, r1
    17ea:	98 e0       	ldi	r25, 0x08	; 8
    17ec:	89 2b       	or	r24, r25
    17ee:	8d 83       	std	Y+5, r24	; 0x05
	bool result;
	sysclk_enable_peripheral_clock(usart);
	usart_set_mode(usart, USART_CMODE_ASYNCHRONOUS_gc);
	usart_format_set(usart, opt->charlength, opt->paritytype,
			opt->stopbits);
	result = usart_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    17f0:	f8 01       	movw	r30, r16
    17f2:	40 81       	ld	r20, Z
    17f4:	51 81       	ldd	r21, Z+1	; 0x01
    17f6:	62 81       	ldd	r22, Z+2	; 0x02
    17f8:	73 81       	ldd	r23, Z+3	; 0x03
    17fa:	00 e8       	ldi	r16, 0x80	; 128
    17fc:	14 e8       	ldi	r17, 0x84	; 132
    17fe:	2e e1       	ldi	r18, 0x1E	; 30
    1800:	30 e0       	ldi	r19, 0x00	; 0
    1802:	ce 01       	movw	r24, r28
    1804:	e1 dd       	rcall	.-1086   	; 0x13c8 <usart_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    1806:	9c 81       	ldd	r25, Y+4	; 0x04
    1808:	98 60       	ori	r25, 0x08	; 8
    180a:	9c 83       	std	Y+4, r25	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    180c:	9c 81       	ldd	r25, Y+4	; 0x04
    180e:	90 61       	ori	r25, 0x10	; 16
    1810:	9c 83       	std	Y+4, r25	; 0x04
	usart_tx_enable(usart);
	usart_rx_enable(usart);
	
	return result;
}
    1812:	df 91       	pop	r29
    1814:	cf 91       	pop	r28
    1816:	1f 91       	pop	r17
    1818:	0f 91       	pop	r16
    181a:	08 95       	ret

0000181c <usart_spi_set_baudrate>:
 * \param usart The USART(SPI) module.
 * \param baud The baudrate.
 * \param cpu_hz The CPU frequency.
 */
void usart_spi_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    181c:	cf 92       	push	r12
    181e:	df 92       	push	r13
    1820:	ef 92       	push	r14
    1822:	ff 92       	push	r15
    1824:	0f 93       	push	r16
    1826:	1f 93       	push	r17
    1828:	cf 93       	push	r28
    182a:	df 93       	push	r29
    182c:	ec 01       	movw	r28, r24
	uint16_t bsel_value;

	/* Check if baudrate is less than the maximim limit specified in
	 * datasheet */
	if (baud < (cpu_hz / 2)) {
    182e:	d9 01       	movw	r26, r18
    1830:	c8 01       	movw	r24, r16
    1832:	b6 95       	lsr	r27
    1834:	a7 95       	ror	r26
    1836:	97 95       	ror	r25
    1838:	87 95       	ror	r24
    183a:	48 17       	cp	r20, r24
    183c:	59 07       	cpc	r21, r25
    183e:	6a 07       	cpc	r22, r26
    1840:	7b 07       	cpc	r23, r27
    1842:	78 f4       	brcc	.+30     	; 0x1862 <usart_spi_set_baudrate+0x46>
		bsel_value = (cpu_hz / (baud * 2)) - 1;
    1844:	6a 01       	movw	r12, r20
    1846:	7b 01       	movw	r14, r22
    1848:	cc 0c       	add	r12, r12
    184a:	dd 1c       	adc	r13, r13
    184c:	ee 1c       	adc	r14, r14
    184e:	ff 1c       	adc	r15, r15
    1850:	c9 01       	movw	r24, r18
    1852:	b8 01       	movw	r22, r16
    1854:	a7 01       	movw	r20, r14
    1856:	96 01       	movw	r18, r12
    1858:	0e 94 01 1c 	call	0x3802	; 0x3802 <__udivmodsi4>
    185c:	21 50       	subi	r18, 0x01	; 1
    185e:	31 09       	sbc	r19, r1
    1860:	02 c0       	rjmp	.+4      	; 0x1866 <usart_spi_set_baudrate+0x4a>
	} else {
		/* If baudrate is not within the specfication in datasheet,
		 * assign maximum baudrate possible for the current CPU frequency */
		bsel_value = 0;
    1862:	20 e0       	ldi	r18, 0x00	; 0
    1864:	30 e0       	ldi	r19, 0x00	; 0
	}

	(usart)->BAUDCTRLB = (uint8_t)((~USART_BSCALE_gm) & (bsel_value >> 8));
    1866:	83 2f       	mov	r24, r19
    1868:	8f 70       	andi	r24, 0x0F	; 15
    186a:	8f 83       	std	Y+7, r24	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)(bsel_value);
    186c:	2e 83       	std	Y+6, r18	; 0x06
}
    186e:	df 91       	pop	r29
    1870:	cf 91       	pop	r28
    1872:	1f 91       	pop	r17
    1874:	0f 91       	pop	r16
    1876:	ff 90       	pop	r15
    1878:	ef 90       	pop	r14
    187a:	df 90       	pop	r13
    187c:	cf 90       	pop	r12
    187e:	08 95       	ret

00001880 <usart_init_spi>:
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    1880:	ef 92       	push	r14
    1882:	ff 92       	push	r15
    1884:	0f 93       	push	r16
    1886:	1f 93       	push	r17
    1888:	cf 93       	push	r28
    188a:	df 93       	push	r29
    188c:	ec 01       	movw	r28, r24
    188e:	7b 01       	movw	r14, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    1890:	00 97       	sbiw	r24, 0x00	; 0
    1892:	09 f4       	brne	.+2      	; 0x1896 <usart_init_spi+0x16>
    1894:	98 c1       	rjmp	.+816    	; 0x1bc6 <usart_init_spi+0x346>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    1896:	80 3c       	cpi	r24, 0xC0	; 192
    1898:	91 05       	cpc	r25, r1
    189a:	29 f4       	brne	.+10     	; 0x18a6 <usart_init_spi+0x26>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    189c:	60 e1       	ldi	r22, 0x10	; 16
    189e:	80 e0       	ldi	r24, 0x00	; 0
    18a0:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    18a4:	90 c1       	rjmp	.+800    	; 0x1bc6 <usart_init_spi+0x346>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    18a6:	80 38       	cpi	r24, 0x80	; 128
    18a8:	91 40       	sbci	r25, 0x01	; 1
    18aa:	29 f4       	brne	.+10     	; 0x18b6 <usart_init_spi+0x36>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    18ac:	62 e0       	ldi	r22, 0x02	; 2
    18ae:	80 e0       	ldi	r24, 0x00	; 0
    18b0:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    18b4:	88 c1       	rjmp	.+784    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    18b6:	c1 15       	cp	r28, r1
    18b8:	81 e0       	ldi	r24, 0x01	; 1
    18ba:	d8 07       	cpc	r29, r24
    18bc:	29 f4       	brne	.+10     	; 0x18c8 <usart_init_spi+0x48>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    18be:	61 e0       	ldi	r22, 0x01	; 1
    18c0:	80 e0       	ldi	r24, 0x00	; 0
    18c2:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    18c6:	7f c1       	rjmp	.+766    	; 0x1bc6 <usart_init_spi+0x346>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    18c8:	c0 38       	cpi	r28, 0x80	; 128
    18ca:	e3 e0       	ldi	r30, 0x03	; 3
    18cc:	de 07       	cpc	r29, r30
    18ce:	29 f4       	brne	.+10     	; 0x18da <usart_init_spi+0x5a>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    18d0:	61 e0       	ldi	r22, 0x01	; 1
    18d2:	81 e0       	ldi	r24, 0x01	; 1
    18d4:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    18d8:	76 c1       	rjmp	.+748    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    18da:	c0 39       	cpi	r28, 0x90	; 144
    18dc:	f3 e0       	ldi	r31, 0x03	; 3
    18de:	df 07       	cpc	r29, r31
    18e0:	29 f4       	brne	.+10     	; 0x18ec <usart_init_spi+0x6c>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    18e2:	61 e0       	ldi	r22, 0x01	; 1
    18e4:	82 e0       	ldi	r24, 0x02	; 2
    18e6:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    18ea:	6d c1       	rjmp	.+730    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    18ec:	c1 15       	cp	r28, r1
    18ee:	32 e0       	ldi	r19, 0x02	; 2
    18f0:	d3 07       	cpc	r29, r19
    18f2:	29 f4       	brne	.+10     	; 0x18fe <usart_init_spi+0x7e>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    18f4:	62 e0       	ldi	r22, 0x02	; 2
    18f6:	81 e0       	ldi	r24, 0x01	; 1
    18f8:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    18fc:	64 c1       	rjmp	.+712    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    18fe:	c0 34       	cpi	r28, 0x40	; 64
    1900:	82 e0       	ldi	r24, 0x02	; 2
    1902:	d8 07       	cpc	r29, r24
    1904:	29 f4       	brne	.+10     	; 0x1910 <usart_init_spi+0x90>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    1906:	62 e0       	ldi	r22, 0x02	; 2
    1908:	82 e0       	ldi	r24, 0x02	; 2
    190a:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    190e:	5b c1       	rjmp	.+694    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    1910:	c0 32       	cpi	r28, 0x20	; 32
    1912:	e3 e0       	ldi	r30, 0x03	; 3
    1914:	de 07       	cpc	r29, r30
    1916:	29 f4       	brne	.+10     	; 0x1922 <usart_init_spi+0xa2>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    1918:	64 e0       	ldi	r22, 0x04	; 4
    191a:	82 e0       	ldi	r24, 0x02	; 2
    191c:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1920:	52 c1       	rjmp	.+676    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    1922:	c1 15       	cp	r28, r1
    1924:	f8 e0       	ldi	r31, 0x08	; 8
    1926:	df 07       	cpc	r29, r31
    1928:	29 f4       	brne	.+10     	; 0x1934 <usart_init_spi+0xb4>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    192a:	61 e0       	ldi	r22, 0x01	; 1
    192c:	83 e0       	ldi	r24, 0x03	; 3
    192e:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1932:	49 c1       	rjmp	.+658    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    1934:	c1 15       	cp	r28, r1
    1936:	39 e0       	ldi	r19, 0x09	; 9
    1938:	d3 07       	cpc	r29, r19
    193a:	29 f4       	brne	.+10     	; 0x1946 <usart_init_spi+0xc6>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    193c:	61 e0       	ldi	r22, 0x01	; 1
    193e:	84 e0       	ldi	r24, 0x04	; 4
    1940:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1944:	40 c1       	rjmp	.+640    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    1946:	c1 15       	cp	r28, r1
    1948:	8a e0       	ldi	r24, 0x0A	; 10
    194a:	d8 07       	cpc	r29, r24
    194c:	29 f4       	brne	.+10     	; 0x1958 <usart_init_spi+0xd8>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    194e:	61 e0       	ldi	r22, 0x01	; 1
    1950:	85 e0       	ldi	r24, 0x05	; 5
    1952:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1956:	37 c1       	rjmp	.+622    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    1958:	c1 15       	cp	r28, r1
    195a:	eb e0       	ldi	r30, 0x0B	; 11
    195c:	de 07       	cpc	r29, r30
    195e:	29 f4       	brne	.+10     	; 0x196a <usart_init_spi+0xea>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    1960:	61 e0       	ldi	r22, 0x01	; 1
    1962:	86 e0       	ldi	r24, 0x06	; 6
    1964:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1968:	2e c1       	rjmp	.+604    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    196a:	c0 34       	cpi	r28, 0x40	; 64
    196c:	f8 e0       	ldi	r31, 0x08	; 8
    196e:	df 07       	cpc	r29, r31
    1970:	29 f4       	brne	.+10     	; 0x197c <usart_init_spi+0xfc>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    1972:	62 e0       	ldi	r22, 0x02	; 2
    1974:	83 e0       	ldi	r24, 0x03	; 3
    1976:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    197a:	25 c1       	rjmp	.+586    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    197c:	c0 34       	cpi	r28, 0x40	; 64
    197e:	39 e0       	ldi	r19, 0x09	; 9
    1980:	d3 07       	cpc	r29, r19
    1982:	29 f4       	brne	.+10     	; 0x198e <usart_init_spi+0x10e>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    1984:	62 e0       	ldi	r22, 0x02	; 2
    1986:	84 e0       	ldi	r24, 0x04	; 4
    1988:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    198c:	1c c1       	rjmp	.+568    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    198e:	c0 34       	cpi	r28, 0x40	; 64
    1990:	8a e0       	ldi	r24, 0x0A	; 10
    1992:	d8 07       	cpc	r29, r24
    1994:	29 f4       	brne	.+10     	; 0x19a0 <usart_init_spi+0x120>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    1996:	62 e0       	ldi	r22, 0x02	; 2
    1998:	85 e0       	ldi	r24, 0x05	; 5
    199a:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    199e:	13 c1       	rjmp	.+550    	; 0x1bc6 <usart_init_spi+0x346>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    19a0:	c0 39       	cpi	r28, 0x90	; 144
    19a2:	e8 e0       	ldi	r30, 0x08	; 8
    19a4:	de 07       	cpc	r29, r30
    19a6:	29 f4       	brne	.+10     	; 0x19b2 <usart_init_spi+0x132>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    19a8:	64 e0       	ldi	r22, 0x04	; 4
    19aa:	83 e0       	ldi	r24, 0x03	; 3
    19ac:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    19b0:	0a c1       	rjmp	.+532    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    19b2:	c0 39       	cpi	r28, 0x90	; 144
    19b4:	f9 e0       	ldi	r31, 0x09	; 9
    19b6:	df 07       	cpc	r29, r31
    19b8:	29 f4       	brne	.+10     	; 0x19c4 <usart_init_spi+0x144>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    19ba:	64 e0       	ldi	r22, 0x04	; 4
    19bc:	84 e0       	ldi	r24, 0x04	; 4
    19be:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    19c2:	01 c1       	rjmp	.+514    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    19c4:	c0 39       	cpi	r28, 0x90	; 144
    19c6:	3a e0       	ldi	r19, 0x0A	; 10
    19c8:	d3 07       	cpc	r29, r19
    19ca:	29 f4       	brne	.+10     	; 0x19d6 <usart_init_spi+0x156>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    19cc:	64 e0       	ldi	r22, 0x04	; 4
    19ce:	85 e0       	ldi	r24, 0x05	; 5
    19d0:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    19d4:	f8 c0       	rjmp	.+496    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    19d6:	c0 39       	cpi	r28, 0x90	; 144
    19d8:	8b e0       	ldi	r24, 0x0B	; 11
    19da:	d8 07       	cpc	r29, r24
    19dc:	29 f4       	brne	.+10     	; 0x19e8 <usart_init_spi+0x168>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    19de:	64 e0       	ldi	r22, 0x04	; 4
    19e0:	86 e0       	ldi	r24, 0x06	; 6
    19e2:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    19e6:	ef c0       	rjmp	.+478    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    19e8:	c0 3c       	cpi	r28, 0xC0	; 192
    19ea:	e8 e0       	ldi	r30, 0x08	; 8
    19ec:	de 07       	cpc	r29, r30
    19ee:	29 f4       	brne	.+10     	; 0x19fa <usart_init_spi+0x17a>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    19f0:	68 e0       	ldi	r22, 0x08	; 8
    19f2:	83 e0       	ldi	r24, 0x03	; 3
    19f4:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    19f8:	e6 c0       	rjmp	.+460    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    19fa:	c0 3c       	cpi	r28, 0xC0	; 192
    19fc:	f9 e0       	ldi	r31, 0x09	; 9
    19fe:	df 07       	cpc	r29, r31
    1a00:	29 f4       	brne	.+10     	; 0x1a0c <usart_init_spi+0x18c>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    1a02:	68 e0       	ldi	r22, 0x08	; 8
    1a04:	84 e0       	ldi	r24, 0x04	; 4
    1a06:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1a0a:	dd c0       	rjmp	.+442    	; 0x1bc6 <usart_init_spi+0x346>
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    1a0c:	c0 3a       	cpi	r28, 0xA0	; 160
    1a0e:	38 e0       	ldi	r19, 0x08	; 8
    1a10:	d3 07       	cpc	r29, r19
    1a12:	69 f4       	brne	.+26     	; 0x1a2e <usart_init_spi+0x1ae>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    1a14:	60 e1       	ldi	r22, 0x10	; 16
    1a16:	83 e0       	ldi	r24, 0x03	; 3
    1a18:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    1a1c:	e0 ea       	ldi	r30, 0xA0	; 160
    1a1e:	f8 e0       	ldi	r31, 0x08	; 8
    1a20:	84 81       	ldd	r24, Z+4	; 0x04
    1a22:	8f 7e       	andi	r24, 0xEF	; 239
    1a24:	84 83       	std	Z+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    1a26:	f7 01       	movw	r30, r14
    1a28:	24 81       	ldd	r18, Z+4	; 0x04
    1a2a:	22 50       	subi	r18, 0x02	; 2
    1a2c:	4a c0       	rjmp	.+148    	; 0x1ac2 <usart_init_spi+0x242>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    1a2e:	c0 3a       	cpi	r28, 0xA0	; 160
    1a30:	f9 e0       	ldi	r31, 0x09	; 9
    1a32:	df 07       	cpc	r29, r31
    1a34:	29 f4       	brne	.+10     	; 0x1a40 <usart_init_spi+0x1c0>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    1a36:	60 e1       	ldi	r22, 0x10	; 16
    1a38:	84 e0       	ldi	r24, 0x04	; 4
    1a3a:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1a3e:	c3 c0       	rjmp	.+390    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    1a40:	c0 3a       	cpi	r28, 0xA0	; 160
    1a42:	3a e0       	ldi	r19, 0x0A	; 10
    1a44:	d3 07       	cpc	r29, r19
    1a46:	29 f4       	brne	.+10     	; 0x1a52 <usart_init_spi+0x1d2>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    1a48:	60 e1       	ldi	r22, 0x10	; 16
    1a4a:	85 e0       	ldi	r24, 0x05	; 5
    1a4c:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1a50:	ba c0       	rjmp	.+372    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    1a52:	c0 3a       	cpi	r28, 0xA0	; 160
    1a54:	8b e0       	ldi	r24, 0x0B	; 11
    1a56:	d8 07       	cpc	r29, r24
    1a58:	29 f4       	brne	.+10     	; 0x1a64 <usart_init_spi+0x1e4>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    1a5a:	60 e1       	ldi	r22, 0x10	; 16
    1a5c:	86 e0       	ldi	r24, 0x06	; 6
    1a5e:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1a62:	b1 c0       	rjmp	.+354    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    1a64:	c0 3b       	cpi	r28, 0xB0	; 176
    1a66:	e8 e0       	ldi	r30, 0x08	; 8
    1a68:	de 07       	cpc	r29, r30
    1a6a:	29 f4       	brne	.+10     	; 0x1a76 <usart_init_spi+0x1f6>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    1a6c:	60 e2       	ldi	r22, 0x20	; 32
    1a6e:	83 e0       	ldi	r24, 0x03	; 3
    1a70:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1a74:	a8 c0       	rjmp	.+336    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    1a76:	c0 3b       	cpi	r28, 0xB0	; 176
    1a78:	f9 e0       	ldi	r31, 0x09	; 9
    1a7a:	df 07       	cpc	r29, r31
    1a7c:	29 f4       	brne	.+10     	; 0x1a88 <usart_init_spi+0x208>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    1a7e:	60 e2       	ldi	r22, 0x20	; 32
    1a80:	84 e0       	ldi	r24, 0x04	; 4
    1a82:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1a86:	9f c0       	rjmp	.+318    	; 0x1bc6 <usart_init_spi+0x346>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    1a88:	c0 38       	cpi	r28, 0x80	; 128
    1a8a:	34 e0       	ldi	r19, 0x04	; 4
    1a8c:	d3 07       	cpc	r29, r19
    1a8e:	29 f4       	brne	.+10     	; 0x1a9a <usart_init_spi+0x21a>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    1a90:	60 e4       	ldi	r22, 0x40	; 64
    1a92:	83 e0       	ldi	r24, 0x03	; 3
    1a94:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1a98:	96 c0       	rjmp	.+300    	; 0x1bc6 <usart_init_spi+0x346>
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    1a9a:	c0 3a       	cpi	r28, 0xA0	; 160
    1a9c:	84 e0       	ldi	r24, 0x04	; 4
    1a9e:	d8 07       	cpc	r29, r24
    1aa0:	29 f4       	brne	.+10     	; 0x1aac <usart_init_spi+0x22c>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    1aa2:	60 e4       	ldi	r22, 0x40	; 64
    1aa4:	85 e0       	ldi	r24, 0x05	; 5
    1aa6:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1aaa:	8d c0       	rjmp	.+282    	; 0x1bc6 <usart_init_spi+0x346>
    1aac:	8c 81       	ldd	r24, Y+4	; 0x04
    1aae:	8f 7e       	andi	r24, 0xEF	; 239
    1ab0:	8c 83       	std	Y+4, r24	; 0x04
    1ab2:	fb 01       	movw	r30, r22
    1ab4:	24 81       	ldd	r18, Z+4	; 0x04
    1ab6:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    1ab8:	ce 01       	movw	r24, r28
    1aba:	c0 3a       	cpi	r28, 0xA0	; 160
    1abc:	f8 e0       	ldi	r31, 0x08	; 8
    1abe:	df 07       	cpc	r29, r31
    1ac0:	31 f4       	brne	.+12     	; 0x1ace <usart_init_spi+0x24e>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
    1ac2:	80 91 4e 06 	lds	r24, 0x064E	; 0x80064e <__TEXT_REGION_LENGTH__+0x70064e>
    1ac6:	84 fd       	sbrc	r24, 4
    1ac8:	86 c0       	rjmp	.+268    	; 0x1bd6 <usart_init_spi+0x356>
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
    1aca:	11 e1       	ldi	r17, 0x11	; 17
    1acc:	85 c0       	rjmp	.+266    	; 0x1bd8 <usart_init_spi+0x358>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
    1ace:	80 3b       	cpi	r24, 0xB0	; 176
    1ad0:	38 e0       	ldi	r19, 0x08	; 8
    1ad2:	93 07       	cpc	r25, r19
    1ad4:	79 f0       	breq	.+30     	; 0x1af4 <usart_init_spi+0x274>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
	}
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
    1ad6:	80 3a       	cpi	r24, 0xA0	; 160
    1ad8:	e9 e0       	ldi	r30, 0x09	; 9
    1ada:	9e 07       	cpc	r25, r30
    1adc:	31 f4       	brne	.+12     	; 0x1aea <usart_init_spi+0x26a>
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
    1ade:	30 91 6e 06 	lds	r19, 0x066E	; 0x80066e <__TEXT_REGION_LENGTH__+0x70066e>
    1ae2:	34 fd       	sbrc	r19, 4
    1ae4:	7c c0       	rjmp	.+248    	; 0x1bde <usart_init_spi+0x35e>
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
    1ae6:	19 e1       	ldi	r17, 0x19	; 25
    1ae8:	10 c0       	rjmp	.+32     	; 0x1b0a <usart_init_spi+0x28a>
		sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
    1aea:	80 3b       	cpi	r24, 0xB0	; 176
    1aec:	f9 e0       	ldi	r31, 0x09	; 9
    1aee:	9f 07       	cpc	r25, r31
    1af0:	a9 f0       	breq	.+42     	; 0x1b1c <usart_init_spi+0x29c>
    1af2:	01 c0       	rjmp	.+2      	; 0x1af6 <usart_init_spi+0x276>
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    1af4:	15 e1       	ldi	r17, 0x15	; 21
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
	}
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
    1af6:	80 3a       	cpi	r24, 0xA0	; 160
    1af8:	3a e0       	ldi	r19, 0x0A	; 10
    1afa:	93 07       	cpc	r25, r19
    1afc:	31 f4       	brne	.+12     	; 0x1b0a <usart_init_spi+0x28a>
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
    1afe:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <__TEXT_REGION_LENGTH__+0x70068e>
    1b02:	84 fd       	sbrc	r24, 4
    1b04:	6e c0       	rjmp	.+220    	; 0x1be2 <usart_init_spi+0x362>
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 1);
    1b06:	11 e2       	ldi	r17, 0x21	; 33
    1b08:	0c c0       	rjmp	.+24     	; 0x1b22 <usart_init_spi+0x2a2>
	if ((uint16_t)usart == (uint16_t)&USARTE1) {
		sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
	}
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
    1b0a:	80 3a       	cpi	r24, 0xA0	; 160
    1b0c:	9b 40       	sbci	r25, 0x0B	; 11
    1b0e:	49 f4       	brne	.+18     	; 0x1b22 <usart_init_spi+0x2a2>
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
    1b10:	80 91 ae 06 	lds	r24, 0x06AE	; 0x8006ae <__TEXT_REGION_LENGTH__+0x7006ae>
    1b14:	84 fd       	sbrc	r24, 4
    1b16:	04 c0       	rjmp	.+8      	; 0x1b20 <usart_init_spi+0x2a0>
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 1);
    1b18:	19 e2       	ldi	r17, 0x29	; 41
    1b1a:	03 c0       	rjmp	.+6      	; 0x1b22 <usart_init_spi+0x2a2>
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    1b1c:	1d e1       	ldi	r17, 0x1D	; 29
    1b1e:	01 c0       	rjmp	.+2      	; 0x1b22 <usart_init_spi+0x2a2>
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
    1b20:	1d e2       	ldi	r17, 0x2D	; 45
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
    1b22:	e1 2f       	mov	r30, r17
    1b24:	e6 95       	lsr	r30
    1b26:	e6 95       	lsr	r30
    1b28:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
    1b2a:	30 e2       	ldi	r19, 0x20	; 32
    1b2c:	e3 9f       	mul	r30, r19
    1b2e:	f0 01       	movw	r30, r0
    1b30:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    1b32:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    1b34:	17 70       	andi	r17, 0x07	; 7
    1b36:	81 e0       	ldi	r24, 0x01	; 1
    1b38:	90 e0       	ldi	r25, 0x00	; 0
    1b3a:	01 2e       	mov	r0, r17
    1b3c:	02 c0       	rjmp	.+4      	; 0x1b42 <usart_init_spi+0x2c2>
    1b3e:	88 0f       	add	r24, r24
    1b40:	99 1f       	adc	r25, r25
    1b42:	0a 94       	dec	r0
    1b44:	e2 f7       	brpl	.-8      	; 0x1b3e <usart_init_spi+0x2be>
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    1b46:	81 83       	std	Z+1, r24	; 0x01
	}
#endif

	/* Configure the USART output pin */
	ioport_set_pin_dir(sck_pin, IOPORT_DIR_OUTPUT);
	ioport_set_pin_mode(sck_pin,
    1b48:	22 30       	cpi	r18, 0x02	; 2
    1b4a:	10 f0       	brcs	.+4      	; 0x1b50 <usart_init_spi+0x2d0>
    1b4c:	40 e0       	ldi	r20, 0x00	; 0
    1b4e:	01 c0       	rjmp	.+2      	; 0x1b52 <usart_init_spi+0x2d2>
    1b50:	40 e4       	ldi	r20, 0x40	; 64
__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));
    1b52:	df 01       	movw	r26, r30
    1b54:	50 96       	adiw	r26, 0x10	; 16

__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
    1b56:	a1 0f       	add	r26, r17
    1b58:	b1 1d       	adc	r27, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1b5a:	3f b7       	in	r19, 0x3f	; 63
	cpu_irq_disable();
    1b5c:	f8 94       	cli
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));

	uint8_t flags = cpu_irq_save();

	*pin_ctrl &= PORT_ISC_gm;
    1b5e:	2c 91       	ld	r18, X
    1b60:	27 70       	andi	r18, 0x07	; 7
    1b62:	2c 93       	st	X, r18
	*pin_ctrl |= mode;
    1b64:	9c 91       	ld	r25, X
    1b66:	94 2b       	or	r25, r20
    1b68:	9c 93       	st	X, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1b6a:	3f bf       	out	0x3f, r19	; 63
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    1b6c:	85 83       	std	Z+5, r24	; 0x05
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    1b6e:	8d 81       	ldd	r24, Y+5	; 0x05
    1b70:	80 6c       	ori	r24, 0xC0	; 192
    1b72:	8d 83       	std	Y+5, r24	; 0x05
			IOPORT_MODE_TOTEM | (invert_sck? IOPORT_MODE_INVERT_PIN : 0));
	ioport_set_pin_level(sck_pin, IOPORT_PIN_LEVEL_HIGH);

	usart_set_mode(usart, USART_CMODE_MSPI_gc);

	if (opt->spimode == 1 || opt->spimode == 3) {
    1b74:	f7 01       	movw	r30, r14
    1b76:	84 81       	ldd	r24, Z+4	; 0x04
    1b78:	8d 7f       	andi	r24, 0xFD	; 253
    1b7a:	81 30       	cpi	r24, 0x01	; 1
    1b7c:	21 f4       	brne	.+8      	; 0x1b86 <usart_init_spi+0x306>
		usart->CTRLC |= USART_UCPHA_bm;
    1b7e:	8d 81       	ldd	r24, Y+5	; 0x05
    1b80:	82 60       	ori	r24, 0x02	; 2
    1b82:	8d 83       	std	Y+5, r24	; 0x05
    1b84:	03 c0       	rjmp	.+6      	; 0x1b8c <usart_init_spi+0x30c>
	} else {
		usart->CTRLC &= ~USART_UCPHA_bm;
    1b86:	8d 81       	ldd	r24, Y+5	; 0x05
    1b88:	8d 7f       	andi	r24, 0xFD	; 253
    1b8a:	8d 83       	std	Y+5, r24	; 0x05
	}
	if (opt->data_order) {
    1b8c:	f7 01       	movw	r30, r14
    1b8e:	85 81       	ldd	r24, Z+5	; 0x05
    1b90:	88 23       	and	r24, r24
    1b92:	21 f0       	breq	.+8      	; 0x1b9c <usart_init_spi+0x31c>
		(usart)->CTRLC |= USART_DORD_bm;
    1b94:	8d 81       	ldd	r24, Y+5	; 0x05
    1b96:	84 60       	ori	r24, 0x04	; 4
    1b98:	8d 83       	std	Y+5, r24	; 0x05
    1b9a:	03 c0       	rjmp	.+6      	; 0x1ba2 <usart_init_spi+0x322>
	} else {
		(usart)->CTRLC &= ~USART_DORD_bm;
    1b9c:	8d 81       	ldd	r24, Y+5	; 0x05
    1b9e:	8b 7f       	andi	r24, 0xFB	; 251
    1ba0:	8d 83       	std	Y+5, r24	; 0x05
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    1ba2:	f7 01       	movw	r30, r14
    1ba4:	40 81       	ld	r20, Z
    1ba6:	51 81       	ldd	r21, Z+1	; 0x01
    1ba8:	62 81       	ldd	r22, Z+2	; 0x02
    1baa:	73 81       	ldd	r23, Z+3	; 0x03
    1bac:	00 e8       	ldi	r16, 0x80	; 128
    1bae:	14 e8       	ldi	r17, 0x84	; 132
    1bb0:	2e e1       	ldi	r18, 0x1E	; 30
    1bb2:	30 e0       	ldi	r19, 0x00	; 0
    1bb4:	ce 01       	movw	r24, r28
    1bb6:	32 de       	rcall	.-924    	; 0x181c <usart_spi_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    1bb8:	8c 81       	ldd	r24, Y+4	; 0x04
    1bba:	88 60       	ori	r24, 0x08	; 8
    1bbc:	8c 83       	std	Y+4, r24	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    1bbe:	8c 81       	ldd	r24, Y+4	; 0x04
    1bc0:	80 61       	ori	r24, 0x10	; 16
    1bc2:	8c 83       	std	Y+4, r24	; 0x04
    1bc4:	10 c0       	rjmp	.+32     	; 0x1be6 <usart_init_spi+0x366>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    1bc6:	8c 81       	ldd	r24, Y+4	; 0x04
    1bc8:	8f 7e       	andi	r24, 0xEF	; 239
    1bca:	8c 83       	std	Y+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    1bcc:	f7 01       	movw	r30, r14
    1bce:	24 81       	ldd	r18, Z+4	; 0x04
    1bd0:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    1bd2:	ce 01       	movw	r24, r28
    1bd4:	7c cf       	rjmp	.-264    	; 0x1ace <usart_init_spi+0x24e>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    1bd6:	15 e1       	ldi	r17, 0x15	; 21
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    1bd8:	80 ea       	ldi	r24, 0xA0	; 160
    1bda:	98 e0       	ldi	r25, 0x08	; 8
    1bdc:	86 cf       	rjmp	.-244    	; 0x1aea <usart_init_spi+0x26a>
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    1bde:	1d e1       	ldi	r17, 0x1D	; 29
    1be0:	94 cf       	rjmp	.-216    	; 0x1b0a <usart_init_spi+0x28a>
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
    1be2:	15 e2       	ldi	r17, 0x25	; 37
    1be4:	9e cf       	rjmp	.-196    	; 0x1b22 <usart_init_spi+0x2a2>
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    1be6:	df 91       	pop	r29
    1be8:	cf 91       	pop	r28
    1bea:	1f 91       	pop	r17
    1bec:	0f 91       	pop	r16
    1bee:	ff 90       	pop	r15
    1bf0:	ef 90       	pop	r14
    1bf2:	08 95       	ret

00001bf4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1bf4:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bf6:	03 96       	adiw	r24, 0x03	; 3
    1bf8:	81 83       	std	Z+1, r24	; 0x01
    1bfa:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1bfc:	2f ef       	ldi	r18, 0xFF	; 255
    1bfe:	3f ef       	ldi	r19, 0xFF	; 255
    1c00:	23 83       	std	Z+3, r18	; 0x03
    1c02:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c04:	85 83       	std	Z+5, r24	; 0x05
    1c06:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c08:	87 83       	std	Z+7, r24	; 0x07
    1c0a:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1c0c:	10 82       	st	Z, r1
    1c0e:	08 95       	ret

00001c10 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1c10:	fc 01       	movw	r30, r24
    1c12:	10 86       	std	Z+8, r1	; 0x08
    1c14:	11 86       	std	Z+9, r1	; 0x09
    1c16:	08 95       	ret

00001c18 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1c18:	cf 93       	push	r28
    1c1a:	df 93       	push	r29
    1c1c:	9c 01       	movw	r18, r24
    1c1e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1c20:	dc 01       	movw	r26, r24
    1c22:	11 96       	adiw	r26, 0x01	; 1
    1c24:	cd 91       	ld	r28, X+
    1c26:	dc 91       	ld	r29, X
    1c28:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1c2a:	c2 83       	std	Z+2, r28	; 0x02
    1c2c:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1c2e:	8c 81       	ldd	r24, Y+4	; 0x04
    1c30:	9d 81       	ldd	r25, Y+5	; 0x05
    1c32:	84 83       	std	Z+4, r24	; 0x04
    1c34:	95 83       	std	Z+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1c36:	8c 81       	ldd	r24, Y+4	; 0x04
    1c38:	9d 81       	ldd	r25, Y+5	; 0x05
    1c3a:	dc 01       	movw	r26, r24
    1c3c:	12 96       	adiw	r26, 0x02	; 2
    1c3e:	6d 93       	st	X+, r22
    1c40:	7c 93       	st	X, r23
    1c42:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    1c44:	6c 83       	std	Y+4, r22	; 0x04
    1c46:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1c48:	20 87       	std	Z+8, r18	; 0x08
    1c4a:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    1c4c:	f9 01       	movw	r30, r18
    1c4e:	80 81       	ld	r24, Z
    1c50:	8f 5f       	subi	r24, 0xFF	; 255
    1c52:	80 83       	st	Z, r24
}
    1c54:	df 91       	pop	r29
    1c56:	cf 91       	pop	r28
    1c58:	08 95       	ret

00001c5a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1c5a:	cf 93       	push	r28
    1c5c:	df 93       	push	r29
    1c5e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1c60:	48 81       	ld	r20, Y
    1c62:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1c64:	4f 3f       	cpi	r20, 0xFF	; 255
    1c66:	2f ef       	ldi	r18, 0xFF	; 255
    1c68:	52 07       	cpc	r21, r18
    1c6a:	21 f4       	brne	.+8      	; 0x1c74 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1c6c:	fc 01       	movw	r30, r24
    1c6e:	a7 81       	ldd	r26, Z+7	; 0x07
    1c70:	b0 85       	ldd	r27, Z+8	; 0x08
    1c72:	0d c0       	rjmp	.+26     	; 0x1c8e <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c74:	dc 01       	movw	r26, r24
    1c76:	13 96       	adiw	r26, 0x03	; 3
    1c78:	01 c0       	rjmp	.+2      	; 0x1c7c <vListInsert+0x22>
    1c7a:	df 01       	movw	r26, r30
    1c7c:	12 96       	adiw	r26, 0x02	; 2
    1c7e:	ed 91       	ld	r30, X+
    1c80:	fc 91       	ld	r31, X
    1c82:	13 97       	sbiw	r26, 0x03	; 3
    1c84:	20 81       	ld	r18, Z
    1c86:	31 81       	ldd	r19, Z+1	; 0x01
    1c88:	42 17       	cp	r20, r18
    1c8a:	53 07       	cpc	r21, r19
    1c8c:	b0 f7       	brcc	.-20     	; 0x1c7a <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1c8e:	12 96       	adiw	r26, 0x02	; 2
    1c90:	ed 91       	ld	r30, X+
    1c92:	fc 91       	ld	r31, X
    1c94:	13 97       	sbiw	r26, 0x03	; 3
    1c96:	ea 83       	std	Y+2, r30	; 0x02
    1c98:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1c9a:	c4 83       	std	Z+4, r28	; 0x04
    1c9c:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    1c9e:	ac 83       	std	Y+4, r26	; 0x04
    1ca0:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    1ca2:	12 96       	adiw	r26, 0x02	; 2
    1ca4:	cd 93       	st	X+, r28
    1ca6:	dc 93       	st	X, r29
    1ca8:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1caa:	88 87       	std	Y+8, r24	; 0x08
    1cac:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    1cae:	fc 01       	movw	r30, r24
    1cb0:	20 81       	ld	r18, Z
    1cb2:	2f 5f       	subi	r18, 0xFF	; 255
    1cb4:	20 83       	st	Z, r18
}
    1cb6:	df 91       	pop	r29
    1cb8:	cf 91       	pop	r28
    1cba:	08 95       	ret

00001cbc <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1cbc:	cf 93       	push	r28
    1cbe:	df 93       	push	r29
    1cc0:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1cc2:	a0 85       	ldd	r26, Z+8	; 0x08
    1cc4:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1cc6:	c2 81       	ldd	r28, Z+2	; 0x02
    1cc8:	d3 81       	ldd	r29, Z+3	; 0x03
    1cca:	84 81       	ldd	r24, Z+4	; 0x04
    1ccc:	95 81       	ldd	r25, Z+5	; 0x05
    1cce:	8c 83       	std	Y+4, r24	; 0x04
    1cd0:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1cd2:	c4 81       	ldd	r28, Z+4	; 0x04
    1cd4:	d5 81       	ldd	r29, Z+5	; 0x05
    1cd6:	82 81       	ldd	r24, Z+2	; 0x02
    1cd8:	93 81       	ldd	r25, Z+3	; 0x03
    1cda:	8a 83       	std	Y+2, r24	; 0x02
    1cdc:	9b 83       	std	Y+3, r25	; 0x03

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1cde:	11 96       	adiw	r26, 0x01	; 1
    1ce0:	cd 91       	ld	r28, X+
    1ce2:	dc 91       	ld	r29, X
    1ce4:	12 97       	sbiw	r26, 0x02	; 2
    1ce6:	ce 17       	cp	r28, r30
    1ce8:	df 07       	cpc	r29, r31
    1cea:	31 f4       	brne	.+12     	; 0x1cf8 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1cec:	8c 81       	ldd	r24, Y+4	; 0x04
    1cee:	9d 81       	ldd	r25, Y+5	; 0x05
    1cf0:	11 96       	adiw	r26, 0x01	; 1
    1cf2:	8d 93       	st	X+, r24
    1cf4:	9c 93       	st	X, r25
    1cf6:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1cf8:	10 86       	std	Z+8, r1	; 0x08
    1cfa:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    1cfc:	8c 91       	ld	r24, X
    1cfe:	81 50       	subi	r24, 0x01	; 1
    1d00:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    1d02:	df 91       	pop	r29
    1d04:	cf 91       	pop	r28
    1d06:	08 95       	ret

00001d08 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1d08:	0f 93       	push	r16
    1d0a:	1f 93       	push	r17
    1d0c:	8b 01       	movw	r16, r22
uint16_t usAddress;

    /* Place a few bytes of known values on the bottom of the stack.
    This is just useful for debugging. */

    *pxTopOfStack = 0x11;
    1d0e:	71 e1       	ldi	r23, 0x11	; 17
    1d10:	fc 01       	movw	r30, r24
    1d12:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = 0x22;
    1d14:	31 97       	sbiw	r30, 0x01	; 1
    1d16:	62 e2       	ldi	r22, 0x22	; 34
    1d18:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = 0x33;
    1d1a:	31 97       	sbiw	r30, 0x01	; 1
    1d1c:	23 e3       	ldi	r18, 0x33	; 51
    1d1e:	20 83       	st	Z, r18

    /*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

    /* The start of the task code will be popped off the stack last, so place
    it on first. */
    ulAddress = ( uint32_t ) pxCode;
    1d20:	01 2e       	mov	r0, r17
    1d22:	00 0c       	add	r0, r0
    1d24:	22 0b       	sbc	r18, r18
    1d26:	33 0b       	sbc	r19, r19
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    1d28:	31 97       	sbiw	r30, 0x01	; 1
    1d2a:	00 83       	st	Z, r16
    pxTopOfStack--;

    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    1d2c:	31 97       	sbiw	r30, 0x01	; 1
    1d2e:	10 83       	st	Z, r17
    pxTopOfStack--;

#ifdef __AVR_3_BYTE_PC__
    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    1d30:	31 97       	sbiw	r30, 0x01	; 1
    1d32:	20 83       	st	Z, r18

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
    portSAVE_CONTEXT places the flags on the stack immediately after r0
    to ensure the interrupts get disabled as soon as possible, and so ensuring
    the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R0 */
    1d34:	31 97       	sbiw	r30, 0x01	; 1
    1d36:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = portFLAGS_INT_ENABLED;
    1d38:	31 97       	sbiw	r30, 0x01	; 1
    1d3a:	20 e8       	ldi	r18, 0x80	; 128
    1d3c:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Now the remaining registers.   The compiler expects R1 to be 0. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R1 */
    1d3e:	31 97       	sbiw	r30, 0x01	; 1
    1d40:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x02;   /* R2 */
    1d42:	31 97       	sbiw	r30, 0x01	; 1
    1d44:	22 e0       	ldi	r18, 0x02	; 2
    1d46:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x03;   /* R3 */
    1d48:	31 97       	sbiw	r30, 0x01	; 1
    1d4a:	23 e0       	ldi	r18, 0x03	; 3
    1d4c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x04;   /* R4 */
    1d4e:	31 97       	sbiw	r30, 0x01	; 1
    1d50:	24 e0       	ldi	r18, 0x04	; 4
    1d52:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x05;   /* R5 */
    1d54:	31 97       	sbiw	r30, 0x01	; 1
    1d56:	25 e0       	ldi	r18, 0x05	; 5
    1d58:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x06;   /* R6 */
    1d5a:	31 97       	sbiw	r30, 0x01	; 1
    1d5c:	26 e0       	ldi	r18, 0x06	; 6
    1d5e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x07;   /* R7 */
    1d60:	31 97       	sbiw	r30, 0x01	; 1
    1d62:	27 e0       	ldi	r18, 0x07	; 7
    1d64:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x08;   /* R8 */
    1d66:	31 97       	sbiw	r30, 0x01	; 1
    1d68:	28 e0       	ldi	r18, 0x08	; 8
    1d6a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x09;   /* R9 */
    1d6c:	31 97       	sbiw	r30, 0x01	; 1
    1d6e:	29 e0       	ldi	r18, 0x09	; 9
    1d70:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x10;   /* R10 */
    1d72:	31 97       	sbiw	r30, 0x01	; 1
    1d74:	20 e1       	ldi	r18, 0x10	; 16
    1d76:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x11;   /* R11 */
    1d78:	31 97       	sbiw	r30, 0x01	; 1
    1d7a:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x12;   /* R12 */
    1d7c:	31 97       	sbiw	r30, 0x01	; 1
    1d7e:	22 e1       	ldi	r18, 0x12	; 18
    1d80:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x13;   /* R13 */
    1d82:	31 97       	sbiw	r30, 0x01	; 1
    1d84:	23 e1       	ldi	r18, 0x13	; 19
    1d86:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x14;   /* R14 */
    1d88:	31 97       	sbiw	r30, 0x01	; 1
    1d8a:	24 e1       	ldi	r18, 0x14	; 20
    1d8c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x15;   /* R15 */
    1d8e:	31 97       	sbiw	r30, 0x01	; 1
    1d90:	25 e1       	ldi	r18, 0x15	; 21
    1d92:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x16;   /* R16 */
    1d94:	31 97       	sbiw	r30, 0x01	; 1
    1d96:	26 e1       	ldi	r18, 0x16	; 22
    1d98:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x17;   /* R17 */
    1d9a:	31 97       	sbiw	r30, 0x01	; 1
    1d9c:	27 e1       	ldi	r18, 0x17	; 23
    1d9e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x18;   /* R18 */
    1da0:	31 97       	sbiw	r30, 0x01	; 1
    1da2:	28 e1       	ldi	r18, 0x18	; 24
    1da4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x19;   /* R19 */
    1da6:	31 97       	sbiw	r30, 0x01	; 1
    1da8:	29 e1       	ldi	r18, 0x19	; 25
    1daa:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x20;   /* R20 */
    1dac:	31 97       	sbiw	r30, 0x01	; 1
    1dae:	20 e2       	ldi	r18, 0x20	; 32
    1db0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x21;   /* R21 */
    1db2:	31 97       	sbiw	r30, 0x01	; 1
    1db4:	21 e2       	ldi	r18, 0x21	; 33
    1db6:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x22;   /* R22 */
    1db8:	31 97       	sbiw	r30, 0x01	; 1
    1dba:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x23;   /* R23 */
    1dbc:	31 97       	sbiw	r30, 0x01	; 1
    1dbe:	23 e2       	ldi	r18, 0x23	; 35
    1dc0:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    1dc2:	31 97       	sbiw	r30, 0x01	; 1
    1dc4:	40 83       	st	Z, r20
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    1dc6:	31 97       	sbiw	r30, 0x01	; 1
    1dc8:	50 83       	st	Z, r21
    pxTopOfStack--;

    *pxTopOfStack = ( StackType_t ) 0x26;   /* R26 X */
    1dca:	31 97       	sbiw	r30, 0x01	; 1
    1dcc:	26 e2       	ldi	r18, 0x26	; 38
    1dce:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x27;   /* R27 */
    1dd0:	31 97       	sbiw	r30, 0x01	; 1
    1dd2:	27 e2       	ldi	r18, 0x27	; 39
    1dd4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x28;   /* R28 Y */
    1dd6:	31 97       	sbiw	r30, 0x01	; 1
    1dd8:	28 e2       	ldi	r18, 0x28	; 40
    1dda:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x29;   /* R29 */
    1ddc:	31 97       	sbiw	r30, 0x01	; 1
    1dde:	29 e2       	ldi	r18, 0x29	; 41
    1de0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x30;   /* R30 Z */
    1de2:	31 97       	sbiw	r30, 0x01	; 1
    1de4:	20 e3       	ldi	r18, 0x30	; 48
    1de6:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x31;   /* R31 */
    1de8:	31 97       	sbiw	r30, 0x01	; 1
    1dea:	21 e3       	ldi	r18, 0x31	; 49
    1dec:	20 83       	st	Z, r18
    pxTopOfStack--;

    /*lint +e950 +e611 +e923 */

    return pxTopOfStack;
}
    1dee:	87 97       	sbiw	r24, 0x27	; 39
    1df0:	1f 91       	pop	r17
    1df2:	0f 91       	pop	r16
    1df4:	08 95       	ret

00001df6 <xPortStartScheduler>:
 * Setup timer generate a tick interrupt.
 */
static void prvSetupTimerInterrupt(void)
{
    // disable global interrupt for a moment
    cli();
    1df6:	f8 94       	cli

    {
        //enable TC0 clock source, high resolution
        PR.PRPC &= ~(PR_TC0_bm | PR_HIRES_bm);
    1df8:	e0 e7       	ldi	r30, 0x70	; 112
    1dfa:	f0 e0       	ldi	r31, 0x00	; 0
    1dfc:	83 81       	ldd	r24, Z+3	; 0x03
    1dfe:	8a 7f       	andi	r24, 0xFA	; 250
    1e00:	83 83       	std	Z+3, r24	; 0x03

        //set period of counter
        TCC0.PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ / 1;
    1e02:	e0 e0       	ldi	r30, 0x00	; 0
    1e04:	f8 e0       	ldi	r31, 0x08	; 8
    1e06:	80 e0       	ldi	r24, 0x00	; 0
    1e08:	9a ef       	ldi	r25, 0xFA	; 250
    1e0a:	86 a3       	std	Z+38, r24	; 0x26
    1e0c:	97 a3       	std	Z+39, r25	; 0x27

        //enable interrupt and set low level
        TCC0.INTCTRLA = TC_OVFINTLVL_LO_gc;
    1e0e:	91 e0       	ldi	r25, 0x01	; 1
    1e10:	96 83       	std	Z+6, r25	; 0x06

        //enable low-level interrupt
        PMIC.CTRL |= PMIC_LOLVLEN_bm;
    1e12:	a0 ea       	ldi	r26, 0xA0	; 160
    1e14:	b0 e0       	ldi	r27, 0x00	; 0
    1e16:	12 96       	adiw	r26, 0x02	; 2
    1e18:	8c 91       	ld	r24, X
    1e1a:	12 97       	sbiw	r26, 0x02	; 2
    1e1c:	81 60       	ori	r24, 0x01	; 1
    1e1e:	12 96       	adiw	r26, 0x02	; 2
    1e20:	8c 93       	st	X, r24

        //select (start) the clock source
        TCC0.CTRLA = TC_CLKSEL_DIV1_gc;
    1e22:	90 83       	st	Z, r25

    }

    // enable global interrupt
    sei();
    1e24:	78 94       	sei
{
    /* Setup the hardware to generate the tick. */
    prvSetupTimerInterrupt();

    /* Restore the context of the first task that is going to run. */
    portRESTORE_CONTEXT();
    1e26:	a0 91 c0 22 	lds	r26, 0x22C0	; 0x8022c0 <pxCurrentTCB>
    1e2a:	b0 91 c1 22 	lds	r27, 0x22C1	; 0x8022c1 <pxCurrentTCB+0x1>
    1e2e:	0d 90       	ld	r0, X+
    1e30:	0d be       	out	0x3d, r0	; 61
    1e32:	0d 90       	ld	r0, X+
    1e34:	0e be       	out	0x3e, r0	; 62
    1e36:	ff 91       	pop	r31
    1e38:	ef 91       	pop	r30
    1e3a:	df 91       	pop	r29
    1e3c:	cf 91       	pop	r28
    1e3e:	bf 91       	pop	r27
    1e40:	af 91       	pop	r26
    1e42:	9f 91       	pop	r25
    1e44:	8f 91       	pop	r24
    1e46:	7f 91       	pop	r23
    1e48:	6f 91       	pop	r22
    1e4a:	5f 91       	pop	r21
    1e4c:	4f 91       	pop	r20
    1e4e:	3f 91       	pop	r19
    1e50:	2f 91       	pop	r18
    1e52:	1f 91       	pop	r17
    1e54:	0f 91       	pop	r16
    1e56:	ff 90       	pop	r15
    1e58:	ef 90       	pop	r14
    1e5a:	df 90       	pop	r13
    1e5c:	cf 90       	pop	r12
    1e5e:	bf 90       	pop	r11
    1e60:	af 90       	pop	r10
    1e62:	9f 90       	pop	r9
    1e64:	8f 90       	pop	r8
    1e66:	7f 90       	pop	r7
    1e68:	6f 90       	pop	r6
    1e6a:	5f 90       	pop	r5
    1e6c:	4f 90       	pop	r4
    1e6e:	3f 90       	pop	r3
    1e70:	2f 90       	pop	r2
    1e72:	1f 90       	pop	r1
    1e74:	0f 90       	pop	r0
    1e76:	0f be       	out	0x3f, r0	; 63
    1e78:	0f 90       	pop	r0

    /* Simulate a function call end as generated by the compiler.  We will now
    jump to the start of the task the context of which we have just restored. */
    asm volatile ( "ret" );
    1e7a:	08 95       	ret

    /* Should not get here. */
    return pdTRUE;
}
    1e7c:	81 e0       	ldi	r24, 0x01	; 1
    1e7e:	08 95       	ret

00001e80 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    1e80:	0f 92       	push	r0
    1e82:	0f b6       	in	r0, 0x3f	; 63
    1e84:	f8 94       	cli
    1e86:	0f 92       	push	r0
    1e88:	1f 92       	push	r1
    1e8a:	11 24       	eor	r1, r1
    1e8c:	2f 92       	push	r2
    1e8e:	3f 92       	push	r3
    1e90:	4f 92       	push	r4
    1e92:	5f 92       	push	r5
    1e94:	6f 92       	push	r6
    1e96:	7f 92       	push	r7
    1e98:	8f 92       	push	r8
    1e9a:	9f 92       	push	r9
    1e9c:	af 92       	push	r10
    1e9e:	bf 92       	push	r11
    1ea0:	cf 92       	push	r12
    1ea2:	df 92       	push	r13
    1ea4:	ef 92       	push	r14
    1ea6:	ff 92       	push	r15
    1ea8:	0f 93       	push	r16
    1eaa:	1f 93       	push	r17
    1eac:	2f 93       	push	r18
    1eae:	3f 93       	push	r19
    1eb0:	4f 93       	push	r20
    1eb2:	5f 93       	push	r21
    1eb4:	6f 93       	push	r22
    1eb6:	7f 93       	push	r23
    1eb8:	8f 93       	push	r24
    1eba:	9f 93       	push	r25
    1ebc:	af 93       	push	r26
    1ebe:	bf 93       	push	r27
    1ec0:	cf 93       	push	r28
    1ec2:	df 93       	push	r29
    1ec4:	ef 93       	push	r30
    1ec6:	ff 93       	push	r31
    1ec8:	a0 91 c0 22 	lds	r26, 0x22C0	; 0x8022c0 <pxCurrentTCB>
    1ecc:	b0 91 c1 22 	lds	r27, 0x22C1	; 0x8022c1 <pxCurrentTCB+0x1>
    1ed0:	0d b6       	in	r0, 0x3d	; 61
    1ed2:	0d 92       	st	X+, r0
    1ed4:	0e b6       	in	r0, 0x3e	; 62
    1ed6:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    1ed8:	10 d6       	rcall	.+3104   	; 0x2afa <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    1eda:	a0 91 c0 22 	lds	r26, 0x22C0	; 0x8022c0 <pxCurrentTCB>
    1ede:	b0 91 c1 22 	lds	r27, 0x22C1	; 0x8022c1 <pxCurrentTCB+0x1>
    1ee2:	0d 90       	ld	r0, X+
    1ee4:	0d be       	out	0x3d, r0	; 61
    1ee6:	0d 90       	ld	r0, X+
    1ee8:	0e be       	out	0x3e, r0	; 62
    1eea:	ff 91       	pop	r31
    1eec:	ef 91       	pop	r30
    1eee:	df 91       	pop	r29
    1ef0:	cf 91       	pop	r28
    1ef2:	bf 91       	pop	r27
    1ef4:	af 91       	pop	r26
    1ef6:	9f 91       	pop	r25
    1ef8:	8f 91       	pop	r24
    1efa:	7f 91       	pop	r23
    1efc:	6f 91       	pop	r22
    1efe:	5f 91       	pop	r21
    1f00:	4f 91       	pop	r20
    1f02:	3f 91       	pop	r19
    1f04:	2f 91       	pop	r18
    1f06:	1f 91       	pop	r17
    1f08:	0f 91       	pop	r16
    1f0a:	ff 90       	pop	r15
    1f0c:	ef 90       	pop	r14
    1f0e:	df 90       	pop	r13
    1f10:	cf 90       	pop	r12
    1f12:	bf 90       	pop	r11
    1f14:	af 90       	pop	r10
    1f16:	9f 90       	pop	r9
    1f18:	8f 90       	pop	r8
    1f1a:	7f 90       	pop	r7
    1f1c:	6f 90       	pop	r6
    1f1e:	5f 90       	pop	r5
    1f20:	4f 90       	pop	r4
    1f22:	3f 90       	pop	r3
    1f24:	2f 90       	pop	r2
    1f26:	1f 90       	pop	r1
    1f28:	0f 90       	pop	r0
    1f2a:	0f be       	out	0x3f, r0	; 63
    1f2c:	0f 90       	pop	r0

    asm volatile ( "ret" );
    1f2e:	08 95       	ret

00001f30 <__vector_14>:
         * Context switch function used by the tick.  This must be identical to
         * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
         * difference from vPortYield() is the tick count is incremented as the
         * call comes from the tick ISR.
         */
        portSAVE_CONTEXT();
    1f30:	0f 92       	push	r0
    1f32:	0f b6       	in	r0, 0x3f	; 63
    1f34:	f8 94       	cli
    1f36:	0f 92       	push	r0
    1f38:	1f 92       	push	r1
    1f3a:	11 24       	eor	r1, r1
    1f3c:	2f 92       	push	r2
    1f3e:	3f 92       	push	r3
    1f40:	4f 92       	push	r4
    1f42:	5f 92       	push	r5
    1f44:	6f 92       	push	r6
    1f46:	7f 92       	push	r7
    1f48:	8f 92       	push	r8
    1f4a:	9f 92       	push	r9
    1f4c:	af 92       	push	r10
    1f4e:	bf 92       	push	r11
    1f50:	cf 92       	push	r12
    1f52:	df 92       	push	r13
    1f54:	ef 92       	push	r14
    1f56:	ff 92       	push	r15
    1f58:	0f 93       	push	r16
    1f5a:	1f 93       	push	r17
    1f5c:	2f 93       	push	r18
    1f5e:	3f 93       	push	r19
    1f60:	4f 93       	push	r20
    1f62:	5f 93       	push	r21
    1f64:	6f 93       	push	r22
    1f66:	7f 93       	push	r23
    1f68:	8f 93       	push	r24
    1f6a:	9f 93       	push	r25
    1f6c:	af 93       	push	r26
    1f6e:	bf 93       	push	r27
    1f70:	cf 93       	push	r28
    1f72:	df 93       	push	r29
    1f74:	ef 93       	push	r30
    1f76:	ff 93       	push	r31
    1f78:	a0 91 c0 22 	lds	r26, 0x22C0	; 0x8022c0 <pxCurrentTCB>
    1f7c:	b0 91 c1 22 	lds	r27, 0x22C1	; 0x8022c1 <pxCurrentTCB+0x1>
    1f80:	0d b6       	in	r0, 0x3d	; 61
    1f82:	0d 92       	st	X+, r0
    1f84:	0e b6       	in	r0, 0x3e	; 62
    1f86:	0d 92       	st	X+, r0
        if( xTaskIncrementTick() != pdFALSE )
    1f88:	4d d4       	rcall	.+2202   	; 0x2824 <xTaskIncrementTick>
    1f8a:	81 11       	cpse	r24, r1
        {
            vTaskSwitchContext();
    1f8c:	b6 d5       	rcall	.+2924   	; 0x2afa <vTaskSwitchContext>
        }
        portRESTORE_CONTEXT();
    1f8e:	a0 91 c0 22 	lds	r26, 0x22C0	; 0x8022c0 <pxCurrentTCB>
    1f92:	b0 91 c1 22 	lds	r27, 0x22C1	; 0x8022c1 <pxCurrentTCB+0x1>
    1f96:	0d 90       	ld	r0, X+
    1f98:	0d be       	out	0x3d, r0	; 61
    1f9a:	0d 90       	ld	r0, X+
    1f9c:	0e be       	out	0x3e, r0	; 62
    1f9e:	ff 91       	pop	r31
    1fa0:	ef 91       	pop	r30
    1fa2:	df 91       	pop	r29
    1fa4:	cf 91       	pop	r28
    1fa6:	bf 91       	pop	r27
    1fa8:	af 91       	pop	r26
    1faa:	9f 91       	pop	r25
    1fac:	8f 91       	pop	r24
    1fae:	7f 91       	pop	r23
    1fb0:	6f 91       	pop	r22
    1fb2:	5f 91       	pop	r21
    1fb4:	4f 91       	pop	r20
    1fb6:	3f 91       	pop	r19
    1fb8:	2f 91       	pop	r18
    1fba:	1f 91       	pop	r17
    1fbc:	0f 91       	pop	r16
    1fbe:	ff 90       	pop	r15
    1fc0:	ef 90       	pop	r14
    1fc2:	df 90       	pop	r13
    1fc4:	cf 90       	pop	r12
    1fc6:	bf 90       	pop	r11
    1fc8:	af 90       	pop	r10
    1fca:	9f 90       	pop	r9
    1fcc:	8f 90       	pop	r8
    1fce:	7f 90       	pop	r7
    1fd0:	6f 90       	pop	r6
    1fd2:	5f 90       	pop	r5
    1fd4:	4f 90       	pop	r4
    1fd6:	3f 90       	pop	r3
    1fd8:	2f 90       	pop	r2
    1fda:	1f 90       	pop	r1
    1fdc:	0f 90       	pop	r0
    1fde:	0f be       	out	0x3f, r0	; 63
    1fe0:	0f 90       	pop	r0

        asm volatile ( "reti" );
    1fe2:	18 95       	reti

00001fe4 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1fe4:	cf 93       	push	r28
    1fe6:	df 93       	push	r29
    1fe8:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
    1fea:	0c d4       	rcall	.+2072   	; 0x2804 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
    1fec:	ce 01       	movw	r24, r28
    1fee:	0e 94 2b 1c 	call	0x3856	; 0x3856 <malloc>
    1ff2:	ec 01       	movw	r28, r24
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1ff4:	ea d4       	rcall	.+2516   	; 0x29ca <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1ff6:	ce 01       	movw	r24, r28
    1ff8:	df 91       	pop	r29
    1ffa:	cf 91       	pop	r28
    1ffc:	08 95       	ret

00001ffe <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1ffe:	cf 93       	push	r28
    2000:	df 93       	push	r29
	if( pv )
    2002:	00 97       	sbiw	r24, 0x00	; 0
    2004:	31 f0       	breq	.+12     	; 0x2012 <vPortFree+0x14>
    2006:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
    2008:	fd d3       	rcall	.+2042   	; 0x2804 <vTaskSuspendAll>
		{
			free( pv );
    200a:	ce 01       	movw	r24, r28
    200c:	0e 94 c0 1c 	call	0x3980	; 0x3980 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
    2010:	dc d4       	rcall	.+2488   	; 0x29ca <xTaskResumeAll>
	}
}
    2012:	df 91       	pop	r29
    2014:	cf 91       	pop	r28
    2016:	08 95       	ret

00002018 <prvCopyDataToQueue>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2018:	1f 93       	push	r17
    201a:	cf 93       	push	r28
    201c:	df 93       	push	r29
    201e:	ec 01       	movw	r28, r24
    2020:	14 2f       	mov	r17, r20
    2022:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2024:	88 23       	and	r24, r24
    2026:	e9 f1       	breq	.+122    	; 0x20a2 <prvCopyDataToQueue+0x8a>
    2028:	41 11       	cpse	r20, r1
    202a:	17 c0       	rjmp	.+46     	; 0x205a <prvCopyDataToQueue+0x42>
    202c:	48 2f       	mov	r20, r24
    202e:	50 e0       	ldi	r21, 0x00	; 0
    2030:	8c 81       	ldd	r24, Y+4	; 0x04
    2032:	9d 81       	ldd	r25, Y+5	; 0x05
    2034:	0e 94 58 1d 	call	0x3ab0	; 0x3ab0 <memcpy>
    2038:	2c 8d       	ldd	r18, Y+28	; 0x1c
    203a:	8c 81       	ldd	r24, Y+4	; 0x04
    203c:	9d 81       	ldd	r25, Y+5	; 0x05
    203e:	82 0f       	add	r24, r18
    2040:	91 1d       	adc	r25, r1
    2042:	8c 83       	std	Y+4, r24	; 0x04
    2044:	9d 83       	std	Y+5, r25	; 0x05
    2046:	2a 81       	ldd	r18, Y+2	; 0x02
    2048:	3b 81       	ldd	r19, Y+3	; 0x03
    204a:	82 17       	cp	r24, r18
    204c:	93 07       	cpc	r25, r19
    204e:	48 f1       	brcs	.+82     	; 0x20a2 <prvCopyDataToQueue+0x8a>
    2050:	88 81       	ld	r24, Y
    2052:	99 81       	ldd	r25, Y+1	; 0x01
    2054:	8c 83       	std	Y+4, r24	; 0x04
    2056:	9d 83       	std	Y+5, r25	; 0x05
    2058:	24 c0       	rjmp	.+72     	; 0x20a2 <prvCopyDataToQueue+0x8a>
    205a:	48 2f       	mov	r20, r24
    205c:	50 e0       	ldi	r21, 0x00	; 0
    205e:	8e 81       	ldd	r24, Y+6	; 0x06
    2060:	9f 81       	ldd	r25, Y+7	; 0x07
    2062:	0e 94 58 1d 	call	0x3ab0	; 0x3ab0 <memcpy>
    2066:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2068:	90 e0       	ldi	r25, 0x00	; 0
    206a:	91 95       	neg	r25
    206c:	81 95       	neg	r24
    206e:	91 09       	sbc	r25, r1
    2070:	2e 81       	ldd	r18, Y+6	; 0x06
    2072:	3f 81       	ldd	r19, Y+7	; 0x07
    2074:	28 0f       	add	r18, r24
    2076:	39 1f       	adc	r19, r25
    2078:	2e 83       	std	Y+6, r18	; 0x06
    207a:	3f 83       	std	Y+7, r19	; 0x07
    207c:	48 81       	ld	r20, Y
    207e:	59 81       	ldd	r21, Y+1	; 0x01
    2080:	24 17       	cp	r18, r20
    2082:	35 07       	cpc	r19, r21
    2084:	30 f4       	brcc	.+12     	; 0x2092 <prvCopyDataToQueue+0x7a>
    2086:	2a 81       	ldd	r18, Y+2	; 0x02
    2088:	3b 81       	ldd	r19, Y+3	; 0x03
    208a:	82 0f       	add	r24, r18
    208c:	93 1f       	adc	r25, r19
    208e:	8e 83       	std	Y+6, r24	; 0x06
    2090:	9f 83       	std	Y+7, r25	; 0x07
    2092:	12 30       	cpi	r17, 0x02	; 2
    2094:	31 f4       	brne	.+12     	; 0x20a2 <prvCopyDataToQueue+0x8a>
    2096:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2098:	88 23       	and	r24, r24
    209a:	19 f0       	breq	.+6      	; 0x20a2 <prvCopyDataToQueue+0x8a>
    209c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    209e:	81 50       	subi	r24, 0x01	; 1
    20a0:	8a 8f       	std	Y+26, r24	; 0x1a
    20a2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    20a4:	8f 5f       	subi	r24, 0xFF	; 255
    20a6:	8a 8f       	std	Y+26, r24	; 0x1a
    20a8:	80 e0       	ldi	r24, 0x00	; 0
    20aa:	df 91       	pop	r29
    20ac:	cf 91       	pop	r28
    20ae:	1f 91       	pop	r17
    20b0:	08 95       	ret

000020b2 <prvCopyDataFromQueue>:
    20b2:	fc 01       	movw	r30, r24
    20b4:	44 8d       	ldd	r20, Z+28	; 0x1c
    20b6:	44 23       	and	r20, r20
    20b8:	a9 f0       	breq	.+42     	; 0x20e4 <prvCopyDataFromQueue+0x32>
    20ba:	50 e0       	ldi	r21, 0x00	; 0
    20bc:	26 81       	ldd	r18, Z+6	; 0x06
    20be:	37 81       	ldd	r19, Z+7	; 0x07
    20c0:	24 0f       	add	r18, r20
    20c2:	35 1f       	adc	r19, r21
    20c4:	26 83       	std	Z+6, r18	; 0x06
    20c6:	37 83       	std	Z+7, r19	; 0x07
    20c8:	82 81       	ldd	r24, Z+2	; 0x02
    20ca:	93 81       	ldd	r25, Z+3	; 0x03
    20cc:	28 17       	cp	r18, r24
    20ce:	39 07       	cpc	r19, r25
    20d0:	20 f0       	brcs	.+8      	; 0x20da <prvCopyDataFromQueue+0x28>
    20d2:	80 81       	ld	r24, Z
    20d4:	91 81       	ldd	r25, Z+1	; 0x01
    20d6:	86 83       	std	Z+6, r24	; 0x06
    20d8:	97 83       	std	Z+7, r25	; 0x07
    20da:	cb 01       	movw	r24, r22
    20dc:	66 81       	ldd	r22, Z+6	; 0x06
    20de:	77 81       	ldd	r23, Z+7	; 0x07
    20e0:	0c 94 58 1d 	jmp	0x3ab0	; 0x3ab0 <memcpy>
    20e4:	08 95       	ret

000020e6 <prvUnlockQueue>:
    20e6:	0f 93       	push	r16
    20e8:	1f 93       	push	r17
    20ea:	cf 93       	push	r28
    20ec:	df 93       	push	r29
    20ee:	ec 01       	movw	r28, r24
    20f0:	0f b6       	in	r0, 0x3f	; 63
    20f2:	f8 94       	cli
    20f4:	0f 92       	push	r0
    20f6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    20f8:	18 16       	cp	r1, r24
    20fa:	ac f4       	brge	.+42     	; 0x2126 <prvUnlockQueue+0x40>
    20fc:	89 89       	ldd	r24, Y+17	; 0x11
    20fe:	81 11       	cpse	r24, r1
    2100:	05 c0       	rjmp	.+10     	; 0x210c <prvUnlockQueue+0x26>
    2102:	11 c0       	rjmp	.+34     	; 0x2126 <prvUnlockQueue+0x40>
    2104:	99 89       	ldd	r25, Y+17	; 0x11
    2106:	91 11       	cpse	r25, r1
    2108:	04 c0       	rjmp	.+8      	; 0x2112 <prvUnlockQueue+0x2c>
    210a:	0d c0       	rjmp	.+26     	; 0x2126 <prvUnlockQueue+0x40>
    210c:	8e 01       	movw	r16, r28
    210e:	0f 5e       	subi	r16, 0xEF	; 239
    2110:	1f 4f       	sbci	r17, 0xFF	; 255
    2112:	c8 01       	movw	r24, r16
    2114:	96 d5       	rcall	.+2860   	; 0x2c42 <xTaskRemoveFromEventList>
    2116:	81 11       	cpse	r24, r1
    2118:	16 d6       	rcall	.+3116   	; 0x2d46 <vTaskMissedYield>
    211a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    211c:	91 50       	subi	r25, 0x01	; 1
    211e:	9e 8f       	std	Y+30, r25	; 0x1e
    2120:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2122:	19 16       	cp	r1, r25
    2124:	7c f3       	brlt	.-34     	; 0x2104 <prvUnlockQueue+0x1e>
    2126:	8f ef       	ldi	r24, 0xFF	; 255
    2128:	8e 8f       	std	Y+30, r24	; 0x1e
    212a:	0f 90       	pop	r0
    212c:	0f be       	out	0x3f, r0	; 63
    212e:	0f b6       	in	r0, 0x3f	; 63
    2130:	f8 94       	cli
    2132:	0f 92       	push	r0
    2134:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2136:	18 16       	cp	r1, r24
    2138:	ac f4       	brge	.+42     	; 0x2164 <prvUnlockQueue+0x7e>
    213a:	88 85       	ldd	r24, Y+8	; 0x08
    213c:	81 11       	cpse	r24, r1
    213e:	05 c0       	rjmp	.+10     	; 0x214a <prvUnlockQueue+0x64>
    2140:	11 c0       	rjmp	.+34     	; 0x2164 <prvUnlockQueue+0x7e>
    2142:	98 85       	ldd	r25, Y+8	; 0x08
    2144:	91 11       	cpse	r25, r1
    2146:	04 c0       	rjmp	.+8      	; 0x2150 <prvUnlockQueue+0x6a>
    2148:	0d c0       	rjmp	.+26     	; 0x2164 <prvUnlockQueue+0x7e>
    214a:	8e 01       	movw	r16, r28
    214c:	08 5f       	subi	r16, 0xF8	; 248
    214e:	1f 4f       	sbci	r17, 0xFF	; 255
    2150:	c8 01       	movw	r24, r16
    2152:	77 d5       	rcall	.+2798   	; 0x2c42 <xTaskRemoveFromEventList>
    2154:	81 11       	cpse	r24, r1
    2156:	f7 d5       	rcall	.+3054   	; 0x2d46 <vTaskMissedYield>
    2158:	9d 8d       	ldd	r25, Y+29	; 0x1d
    215a:	91 50       	subi	r25, 0x01	; 1
    215c:	9d 8f       	std	Y+29, r25	; 0x1d
    215e:	9d 8d       	ldd	r25, Y+29	; 0x1d
    2160:	19 16       	cp	r1, r25
    2162:	7c f3       	brlt	.-34     	; 0x2142 <prvUnlockQueue+0x5c>
    2164:	8f ef       	ldi	r24, 0xFF	; 255
    2166:	8d 8f       	std	Y+29, r24	; 0x1d
    2168:	0f 90       	pop	r0
    216a:	0f be       	out	0x3f, r0	; 63
    216c:	df 91       	pop	r29
    216e:	cf 91       	pop	r28
    2170:	1f 91       	pop	r17
    2172:	0f 91       	pop	r16
    2174:	08 95       	ret

00002176 <xQueueGenericReset>:
    2176:	cf 93       	push	r28
    2178:	df 93       	push	r29
    217a:	ec 01       	movw	r28, r24
    217c:	0f b6       	in	r0, 0x3f	; 63
    217e:	f8 94       	cli
    2180:	0f 92       	push	r0
    2182:	48 81       	ld	r20, Y
    2184:	59 81       	ldd	r21, Y+1	; 0x01
    2186:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2188:	30 e0       	ldi	r19, 0x00	; 0
    218a:	7b 8d       	ldd	r23, Y+27	; 0x1b
    218c:	72 9f       	mul	r23, r18
    218e:	c0 01       	movw	r24, r0
    2190:	73 9f       	mul	r23, r19
    2192:	90 0d       	add	r25, r0
    2194:	11 24       	eor	r1, r1
    2196:	fa 01       	movw	r30, r20
    2198:	e8 0f       	add	r30, r24
    219a:	f9 1f       	adc	r31, r25
    219c:	ea 83       	std	Y+2, r30	; 0x02
    219e:	fb 83       	std	Y+3, r31	; 0x03
    21a0:	1a 8e       	std	Y+26, r1	; 0x1a
    21a2:	4c 83       	std	Y+4, r20	; 0x04
    21a4:	5d 83       	std	Y+5, r21	; 0x05
    21a6:	82 1b       	sub	r24, r18
    21a8:	93 0b       	sbc	r25, r19
    21aa:	84 0f       	add	r24, r20
    21ac:	95 1f       	adc	r25, r21
    21ae:	8e 83       	std	Y+6, r24	; 0x06
    21b0:	9f 83       	std	Y+7, r25	; 0x07
    21b2:	8f ef       	ldi	r24, 0xFF	; 255
    21b4:	8d 8f       	std	Y+29, r24	; 0x1d
    21b6:	8e 8f       	std	Y+30, r24	; 0x1e
    21b8:	61 11       	cpse	r22, r1
    21ba:	0a c0       	rjmp	.+20     	; 0x21d0 <xQueueGenericReset+0x5a>
    21bc:	88 85       	ldd	r24, Y+8	; 0x08
    21be:	88 23       	and	r24, r24
    21c0:	69 f0       	breq	.+26     	; 0x21dc <xQueueGenericReset+0x66>
    21c2:	ce 01       	movw	r24, r28
    21c4:	08 96       	adiw	r24, 0x08	; 8
    21c6:	3d d5       	rcall	.+2682   	; 0x2c42 <xTaskRemoveFromEventList>
    21c8:	81 30       	cpi	r24, 0x01	; 1
    21ca:	41 f4       	brne	.+16     	; 0x21dc <xQueueGenericReset+0x66>
    21cc:	59 de       	rcall	.-846    	; 0x1e80 <vPortYield>
    21ce:	06 c0       	rjmp	.+12     	; 0x21dc <xQueueGenericReset+0x66>
    21d0:	ce 01       	movw	r24, r28
    21d2:	08 96       	adiw	r24, 0x08	; 8
    21d4:	0f dd       	rcall	.-1506   	; 0x1bf4 <vListInitialise>
    21d6:	ce 01       	movw	r24, r28
    21d8:	41 96       	adiw	r24, 0x11	; 17
    21da:	0c dd       	rcall	.-1512   	; 0x1bf4 <vListInitialise>
    21dc:	0f 90       	pop	r0
    21de:	0f be       	out	0x3f, r0	; 63
    21e0:	81 e0       	ldi	r24, 0x01	; 1
    21e2:	df 91       	pop	r29
    21e4:	cf 91       	pop	r28
    21e6:	08 95       	ret

000021e8 <xQueueGenericCreate>:
    21e8:	0f 93       	push	r16
    21ea:	1f 93       	push	r17
    21ec:	cf 93       	push	r28
    21ee:	df 93       	push	r29
    21f0:	08 2f       	mov	r16, r24
    21f2:	16 2f       	mov	r17, r22
    21f4:	66 23       	and	r22, r22
    21f6:	a9 f0       	breq	.+42     	; 0x2222 <xQueueGenericCreate+0x3a>
    21f8:	86 9f       	mul	r24, r22
    21fa:	c0 01       	movw	r24, r0
    21fc:	11 24       	eor	r1, r1
    21fe:	80 96       	adiw	r24, 0x20	; 32
    2200:	f1 de       	rcall	.-542    	; 0x1fe4 <pvPortMalloc>
    2202:	ec 01       	movw	r28, r24
    2204:	00 97       	sbiw	r24, 0x00	; 0
    2206:	21 f4       	brne	.+8      	; 0x2210 <xQueueGenericCreate+0x28>
    2208:	12 c0       	rjmp	.+36     	; 0x222e <xQueueGenericCreate+0x46>
    220a:	c8 83       	st	Y, r28
    220c:	d9 83       	std	Y+1, r29	; 0x01
    220e:	03 c0       	rjmp	.+6      	; 0x2216 <xQueueGenericCreate+0x2e>
    2210:	4f 96       	adiw	r24, 0x1f	; 31
    2212:	88 83       	st	Y, r24
    2214:	99 83       	std	Y+1, r25	; 0x01
    2216:	0b 8f       	std	Y+27, r16	; 0x1b
    2218:	1c 8f       	std	Y+28, r17	; 0x1c
    221a:	61 e0       	ldi	r22, 0x01	; 1
    221c:	ce 01       	movw	r24, r28
    221e:	ab df       	rcall	.-170    	; 0x2176 <xQueueGenericReset>
    2220:	06 c0       	rjmp	.+12     	; 0x222e <xQueueGenericCreate+0x46>
    2222:	8f e1       	ldi	r24, 0x1F	; 31
    2224:	90 e0       	ldi	r25, 0x00	; 0
    2226:	de de       	rcall	.-580    	; 0x1fe4 <pvPortMalloc>
    2228:	ec 01       	movw	r28, r24
    222a:	89 2b       	or	r24, r25
    222c:	71 f7       	brne	.-36     	; 0x220a <xQueueGenericCreate+0x22>
    222e:	ce 01       	movw	r24, r28
    2230:	df 91       	pop	r29
    2232:	cf 91       	pop	r28
    2234:	1f 91       	pop	r17
    2236:	0f 91       	pop	r16
    2238:	08 95       	ret

0000223a <xQueueGenericSend>:
    223a:	af 92       	push	r10
    223c:	bf 92       	push	r11
    223e:	cf 92       	push	r12
    2240:	df 92       	push	r13
    2242:	ef 92       	push	r14
    2244:	ff 92       	push	r15
    2246:	0f 93       	push	r16
    2248:	1f 93       	push	r17
    224a:	cf 93       	push	r28
    224c:	df 93       	push	r29
    224e:	cd b7       	in	r28, 0x3d	; 61
    2250:	de b7       	in	r29, 0x3e	; 62
    2252:	25 97       	sbiw	r28, 0x05	; 5
    2254:	cd bf       	out	0x3d, r28	; 61
    2256:	de bf       	out	0x3e, r29	; 62
    2258:	8c 01       	movw	r16, r24
    225a:	6b 01       	movw	r12, r22
    225c:	4c 83       	std	Y+4, r20	; 0x04
    225e:	5d 83       	std	Y+5, r21	; 0x05
    2260:	a2 2e       	mov	r10, r18
    2262:	b1 2c       	mov	r11, r1
    2264:	7c 01       	movw	r14, r24
    2266:	88 e0       	ldi	r24, 0x08	; 8
    2268:	e8 0e       	add	r14, r24
    226a:	f1 1c       	adc	r15, r1
    226c:	0f b6       	in	r0, 0x3f	; 63
    226e:	f8 94       	cli
    2270:	0f 92       	push	r0
    2272:	f8 01       	movw	r30, r16
    2274:	32 8d       	ldd	r19, Z+26	; 0x1a
    2276:	93 8d       	ldd	r25, Z+27	; 0x1b
    2278:	39 17       	cp	r19, r25
    227a:	18 f0       	brcs	.+6      	; 0x2282 <xQueueGenericSend+0x48>
    227c:	f2 e0       	ldi	r31, 0x02	; 2
    227e:	af 12       	cpse	r10, r31
    2280:	15 c0       	rjmp	.+42     	; 0x22ac <xQueueGenericSend+0x72>
    2282:	4a 2d       	mov	r20, r10
    2284:	b6 01       	movw	r22, r12
    2286:	c8 01       	movw	r24, r16
    2288:	c7 de       	rcall	.-626    	; 0x2018 <prvCopyDataToQueue>
    228a:	f8 01       	movw	r30, r16
    228c:	91 89       	ldd	r25, Z+17	; 0x11
    228e:	99 23       	and	r25, r25
    2290:	39 f0       	breq	.+14     	; 0x22a0 <xQueueGenericSend+0x66>
    2292:	c8 01       	movw	r24, r16
    2294:	41 96       	adiw	r24, 0x11	; 17
    2296:	d5 d4       	rcall	.+2474   	; 0x2c42 <xTaskRemoveFromEventList>
    2298:	81 30       	cpi	r24, 0x01	; 1
    229a:	21 f4       	brne	.+8      	; 0x22a4 <xQueueGenericSend+0x6a>
    229c:	f1 dd       	rcall	.-1054   	; 0x1e80 <vPortYield>
    229e:	02 c0       	rjmp	.+4      	; 0x22a4 <xQueueGenericSend+0x6a>
    22a0:	81 11       	cpse	r24, r1
    22a2:	ee dd       	rcall	.-1060   	; 0x1e80 <vPortYield>
    22a4:	0f 90       	pop	r0
    22a6:	0f be       	out	0x3f, r0	; 63
    22a8:	81 e0       	ldi	r24, 0x01	; 1
    22aa:	46 c0       	rjmp	.+140    	; 0x2338 <xQueueGenericSend+0xfe>
    22ac:	ec 81       	ldd	r30, Y+4	; 0x04
    22ae:	fd 81       	ldd	r31, Y+5	; 0x05
    22b0:	ef 2b       	or	r30, r31
    22b2:	21 f4       	brne	.+8      	; 0x22bc <xQueueGenericSend+0x82>
    22b4:	0f 90       	pop	r0
    22b6:	0f be       	out	0x3f, r0	; 63
    22b8:	80 e0       	ldi	r24, 0x00	; 0
    22ba:	3e c0       	rjmp	.+124    	; 0x2338 <xQueueGenericSend+0xfe>
    22bc:	b1 10       	cpse	r11, r1
    22be:	05 c0       	rjmp	.+10     	; 0x22ca <xQueueGenericSend+0x90>
    22c0:	ce 01       	movw	r24, r28
    22c2:	01 96       	adiw	r24, 0x01	; 1
    22c4:	04 d5       	rcall	.+2568   	; 0x2cce <vTaskSetTimeOutState>
    22c6:	bb 24       	eor	r11, r11
    22c8:	b3 94       	inc	r11
    22ca:	0f 90       	pop	r0
    22cc:	0f be       	out	0x3f, r0	; 63
    22ce:	9a d2       	rcall	.+1332   	; 0x2804 <vTaskSuspendAll>
    22d0:	0f b6       	in	r0, 0x3f	; 63
    22d2:	f8 94       	cli
    22d4:	0f 92       	push	r0
    22d6:	f8 01       	movw	r30, r16
    22d8:	85 8d       	ldd	r24, Z+29	; 0x1d
    22da:	8f 3f       	cpi	r24, 0xFF	; 255
    22dc:	09 f4       	brne	.+2      	; 0x22e0 <xQueueGenericSend+0xa6>
    22de:	15 8e       	std	Z+29, r1	; 0x1d
    22e0:	f8 01       	movw	r30, r16
    22e2:	86 8d       	ldd	r24, Z+30	; 0x1e
    22e4:	8f 3f       	cpi	r24, 0xFF	; 255
    22e6:	09 f4       	brne	.+2      	; 0x22ea <xQueueGenericSend+0xb0>
    22e8:	16 8e       	std	Z+30, r1	; 0x1e
    22ea:	0f 90       	pop	r0
    22ec:	0f be       	out	0x3f, r0	; 63
    22ee:	be 01       	movw	r22, r28
    22f0:	6c 5f       	subi	r22, 0xFC	; 252
    22f2:	7f 4f       	sbci	r23, 0xFF	; 255
    22f4:	ce 01       	movw	r24, r28
    22f6:	01 96       	adiw	r24, 0x01	; 1
    22f8:	f5 d4       	rcall	.+2538   	; 0x2ce4 <xTaskCheckForTimeOut>
    22fa:	81 11       	cpse	r24, r1
    22fc:	19 c0       	rjmp	.+50     	; 0x2330 <xQueueGenericSend+0xf6>
    22fe:	0f b6       	in	r0, 0x3f	; 63
    2300:	f8 94       	cli
    2302:	0f 92       	push	r0
    2304:	f8 01       	movw	r30, r16
    2306:	92 8d       	ldd	r25, Z+26	; 0x1a
    2308:	0f 90       	pop	r0
    230a:	0f be       	out	0x3f, r0	; 63
    230c:	83 8d       	ldd	r24, Z+27	; 0x1b
    230e:	98 13       	cpse	r25, r24
    2310:	0b c0       	rjmp	.+22     	; 0x2328 <xQueueGenericSend+0xee>
    2312:	6c 81       	ldd	r22, Y+4	; 0x04
    2314:	7d 81       	ldd	r23, Y+5	; 0x05
    2316:	c7 01       	movw	r24, r14
    2318:	5d d4       	rcall	.+2234   	; 0x2bd4 <vTaskPlaceOnEventList>
    231a:	c8 01       	movw	r24, r16
    231c:	e4 de       	rcall	.-568    	; 0x20e6 <prvUnlockQueue>
    231e:	55 d3       	rcall	.+1706   	; 0x29ca <xTaskResumeAll>
    2320:	81 11       	cpse	r24, r1
    2322:	a4 cf       	rjmp	.-184    	; 0x226c <xQueueGenericSend+0x32>
    2324:	ad dd       	rcall	.-1190   	; 0x1e80 <vPortYield>
    2326:	a2 cf       	rjmp	.-188    	; 0x226c <xQueueGenericSend+0x32>
    2328:	c8 01       	movw	r24, r16
    232a:	dd de       	rcall	.-582    	; 0x20e6 <prvUnlockQueue>
    232c:	4e d3       	rcall	.+1692   	; 0x29ca <xTaskResumeAll>
    232e:	9e cf       	rjmp	.-196    	; 0x226c <xQueueGenericSend+0x32>
    2330:	c8 01       	movw	r24, r16
    2332:	d9 de       	rcall	.-590    	; 0x20e6 <prvUnlockQueue>
    2334:	4a d3       	rcall	.+1684   	; 0x29ca <xTaskResumeAll>
    2336:	80 e0       	ldi	r24, 0x00	; 0
    2338:	25 96       	adiw	r28, 0x05	; 5
    233a:	cd bf       	out	0x3d, r28	; 61
    233c:	de bf       	out	0x3e, r29	; 62
    233e:	df 91       	pop	r29
    2340:	cf 91       	pop	r28
    2342:	1f 91       	pop	r17
    2344:	0f 91       	pop	r16
    2346:	ff 90       	pop	r15
    2348:	ef 90       	pop	r14
    234a:	df 90       	pop	r13
    234c:	cf 90       	pop	r12
    234e:	bf 90       	pop	r11
    2350:	af 90       	pop	r10
    2352:	08 95       	ret

00002354 <xQueueGenericSendFromISR>:
    2354:	0f 93       	push	r16
    2356:	1f 93       	push	r17
    2358:	cf 93       	push	r28
    235a:	df 93       	push	r29
    235c:	fa 01       	movw	r30, r20
    235e:	dc 01       	movw	r26, r24
    2360:	5a 96       	adiw	r26, 0x1a	; 26
    2362:	5c 91       	ld	r21, X
    2364:	5a 97       	sbiw	r26, 0x1a	; 26
    2366:	5b 96       	adiw	r26, 0x1b	; 27
    2368:	3c 91       	ld	r19, X
    236a:	53 17       	cp	r21, r19
    236c:	10 f0       	brcs	.+4      	; 0x2372 <xQueueGenericSendFromISR+0x1e>
    236e:	22 30       	cpi	r18, 0x02	; 2
    2370:	d9 f4       	brne	.+54     	; 0x23a8 <xQueueGenericSendFromISR+0x54>
    2372:	42 2f       	mov	r20, r18
    2374:	8f 01       	movw	r16, r30
    2376:	ec 01       	movw	r28, r24
    2378:	4f de       	rcall	.-866    	; 0x2018 <prvCopyDataToQueue>
    237a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    237c:	8f 3f       	cpi	r24, 0xFF	; 255
    237e:	79 f4       	brne	.+30     	; 0x239e <xQueueGenericSendFromISR+0x4a>
    2380:	89 89       	ldd	r24, Y+17	; 0x11
    2382:	88 23       	and	r24, r24
    2384:	99 f0       	breq	.+38     	; 0x23ac <xQueueGenericSendFromISR+0x58>
    2386:	ce 01       	movw	r24, r28
    2388:	41 96       	adiw	r24, 0x11	; 17
    238a:	5b d4       	rcall	.+2230   	; 0x2c42 <xTaskRemoveFromEventList>
    238c:	88 23       	and	r24, r24
    238e:	81 f0       	breq	.+32     	; 0x23b0 <xQueueGenericSendFromISR+0x5c>
    2390:	01 15       	cp	r16, r1
    2392:	11 05       	cpc	r17, r1
    2394:	79 f0       	breq	.+30     	; 0x23b4 <xQueueGenericSendFromISR+0x60>
    2396:	81 e0       	ldi	r24, 0x01	; 1
    2398:	f8 01       	movw	r30, r16
    239a:	80 83       	st	Z, r24
    239c:	0c c0       	rjmp	.+24     	; 0x23b6 <xQueueGenericSendFromISR+0x62>
    239e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    23a0:	8f 5f       	subi	r24, 0xFF	; 255
    23a2:	8e 8f       	std	Y+30, r24	; 0x1e
    23a4:	81 e0       	ldi	r24, 0x01	; 1
    23a6:	07 c0       	rjmp	.+14     	; 0x23b6 <xQueueGenericSendFromISR+0x62>
    23a8:	80 e0       	ldi	r24, 0x00	; 0
    23aa:	05 c0       	rjmp	.+10     	; 0x23b6 <xQueueGenericSendFromISR+0x62>
    23ac:	81 e0       	ldi	r24, 0x01	; 1
    23ae:	03 c0       	rjmp	.+6      	; 0x23b6 <xQueueGenericSendFromISR+0x62>
    23b0:	81 e0       	ldi	r24, 0x01	; 1
    23b2:	01 c0       	rjmp	.+2      	; 0x23b6 <xQueueGenericSendFromISR+0x62>
    23b4:	81 e0       	ldi	r24, 0x01	; 1
    23b6:	df 91       	pop	r29
    23b8:	cf 91       	pop	r28
    23ba:	1f 91       	pop	r17
    23bc:	0f 91       	pop	r16
    23be:	08 95       	ret

000023c0 <xQueueGenericReceive>:
    23c0:	af 92       	push	r10
    23c2:	bf 92       	push	r11
    23c4:	cf 92       	push	r12
    23c6:	df 92       	push	r13
    23c8:	ef 92       	push	r14
    23ca:	ff 92       	push	r15
    23cc:	0f 93       	push	r16
    23ce:	1f 93       	push	r17
    23d0:	cf 93       	push	r28
    23d2:	df 93       	push	r29
    23d4:	cd b7       	in	r28, 0x3d	; 61
    23d6:	de b7       	in	r29, 0x3e	; 62
    23d8:	25 97       	sbiw	r28, 0x05	; 5
    23da:	cd bf       	out	0x3d, r28	; 61
    23dc:	de bf       	out	0x3e, r29	; 62
    23de:	8c 01       	movw	r16, r24
    23e0:	6b 01       	movw	r12, r22
    23e2:	4c 83       	std	Y+4, r20	; 0x04
    23e4:	5d 83       	std	Y+5, r21	; 0x05
    23e6:	a2 2e       	mov	r10, r18
    23e8:	b1 2c       	mov	r11, r1
    23ea:	7c 01       	movw	r14, r24
    23ec:	81 e1       	ldi	r24, 0x11	; 17
    23ee:	e8 0e       	add	r14, r24
    23f0:	f1 1c       	adc	r15, r1
    23f2:	0f b6       	in	r0, 0x3f	; 63
    23f4:	f8 94       	cli
    23f6:	0f 92       	push	r0
    23f8:	f8 01       	movw	r30, r16
    23fa:	92 8d       	ldd	r25, Z+26	; 0x1a
    23fc:	99 23       	and	r25, r25
    23fe:	21 f1       	breq	.+72     	; 0x2448 <xQueueGenericReceive+0x88>
    2400:	e6 80       	ldd	r14, Z+6	; 0x06
    2402:	f7 80       	ldd	r15, Z+7	; 0x07
    2404:	b6 01       	movw	r22, r12
    2406:	c8 01       	movw	r24, r16
    2408:	54 de       	rcall	.-856    	; 0x20b2 <prvCopyDataFromQueue>
    240a:	a1 10       	cpse	r10, r1
    240c:	0e c0       	rjmp	.+28     	; 0x242a <xQueueGenericReceive+0x6a>
    240e:	f8 01       	movw	r30, r16
    2410:	82 8d       	ldd	r24, Z+26	; 0x1a
    2412:	81 50       	subi	r24, 0x01	; 1
    2414:	82 8f       	std	Z+26, r24	; 0x1a
    2416:	80 85       	ldd	r24, Z+8	; 0x08
    2418:	88 23       	and	r24, r24
    241a:	91 f0       	breq	.+36     	; 0x2440 <xQueueGenericReceive+0x80>
    241c:	c8 01       	movw	r24, r16
    241e:	08 96       	adiw	r24, 0x08	; 8
    2420:	10 d4       	rcall	.+2080   	; 0x2c42 <xTaskRemoveFromEventList>
    2422:	81 30       	cpi	r24, 0x01	; 1
    2424:	69 f4       	brne	.+26     	; 0x2440 <xQueueGenericReceive+0x80>
    2426:	2c dd       	rcall	.-1448   	; 0x1e80 <vPortYield>
    2428:	0b c0       	rjmp	.+22     	; 0x2440 <xQueueGenericReceive+0x80>
    242a:	f8 01       	movw	r30, r16
    242c:	e6 82       	std	Z+6, r14	; 0x06
    242e:	f7 82       	std	Z+7, r15	; 0x07
    2430:	81 89       	ldd	r24, Z+17	; 0x11
    2432:	88 23       	and	r24, r24
    2434:	29 f0       	breq	.+10     	; 0x2440 <xQueueGenericReceive+0x80>
    2436:	c8 01       	movw	r24, r16
    2438:	41 96       	adiw	r24, 0x11	; 17
    243a:	03 d4       	rcall	.+2054   	; 0x2c42 <xTaskRemoveFromEventList>
    243c:	81 11       	cpse	r24, r1
    243e:	20 dd       	rcall	.-1472   	; 0x1e80 <vPortYield>
    2440:	0f 90       	pop	r0
    2442:	0f be       	out	0x3f, r0	; 63
    2444:	81 e0       	ldi	r24, 0x01	; 1
    2446:	45 c0       	rjmp	.+138    	; 0x24d2 <xQueueGenericReceive+0x112>
    2448:	4c 81       	ldd	r20, Y+4	; 0x04
    244a:	5d 81       	ldd	r21, Y+5	; 0x05
    244c:	45 2b       	or	r20, r21
    244e:	21 f4       	brne	.+8      	; 0x2458 <xQueueGenericReceive+0x98>
    2450:	0f 90       	pop	r0
    2452:	0f be       	out	0x3f, r0	; 63
    2454:	80 e0       	ldi	r24, 0x00	; 0
    2456:	3d c0       	rjmp	.+122    	; 0x24d2 <xQueueGenericReceive+0x112>
    2458:	b1 10       	cpse	r11, r1
    245a:	05 c0       	rjmp	.+10     	; 0x2466 <xQueueGenericReceive+0xa6>
    245c:	ce 01       	movw	r24, r28
    245e:	01 96       	adiw	r24, 0x01	; 1
    2460:	36 d4       	rcall	.+2156   	; 0x2cce <vTaskSetTimeOutState>
    2462:	bb 24       	eor	r11, r11
    2464:	b3 94       	inc	r11
    2466:	0f 90       	pop	r0
    2468:	0f be       	out	0x3f, r0	; 63
    246a:	cc d1       	rcall	.+920    	; 0x2804 <vTaskSuspendAll>
    246c:	0f b6       	in	r0, 0x3f	; 63
    246e:	f8 94       	cli
    2470:	0f 92       	push	r0
    2472:	f8 01       	movw	r30, r16
    2474:	85 8d       	ldd	r24, Z+29	; 0x1d
    2476:	8f 3f       	cpi	r24, 0xFF	; 255
    2478:	09 f4       	brne	.+2      	; 0x247c <xQueueGenericReceive+0xbc>
    247a:	15 8e       	std	Z+29, r1	; 0x1d
    247c:	f8 01       	movw	r30, r16
    247e:	96 8d       	ldd	r25, Z+30	; 0x1e
    2480:	9f 3f       	cpi	r25, 0xFF	; 255
    2482:	09 f4       	brne	.+2      	; 0x2486 <xQueueGenericReceive+0xc6>
    2484:	16 8e       	std	Z+30, r1	; 0x1e
    2486:	0f 90       	pop	r0
    2488:	0f be       	out	0x3f, r0	; 63
    248a:	be 01       	movw	r22, r28
    248c:	6c 5f       	subi	r22, 0xFC	; 252
    248e:	7f 4f       	sbci	r23, 0xFF	; 255
    2490:	ce 01       	movw	r24, r28
    2492:	01 96       	adiw	r24, 0x01	; 1
    2494:	27 d4       	rcall	.+2126   	; 0x2ce4 <xTaskCheckForTimeOut>
    2496:	81 11       	cpse	r24, r1
    2498:	18 c0       	rjmp	.+48     	; 0x24ca <xQueueGenericReceive+0x10a>
    249a:	0f b6       	in	r0, 0x3f	; 63
    249c:	f8 94       	cli
    249e:	0f 92       	push	r0
    24a0:	f8 01       	movw	r30, r16
    24a2:	82 8d       	ldd	r24, Z+26	; 0x1a
    24a4:	0f 90       	pop	r0
    24a6:	0f be       	out	0x3f, r0	; 63
    24a8:	81 11       	cpse	r24, r1
    24aa:	0b c0       	rjmp	.+22     	; 0x24c2 <xQueueGenericReceive+0x102>
    24ac:	6c 81       	ldd	r22, Y+4	; 0x04
    24ae:	7d 81       	ldd	r23, Y+5	; 0x05
    24b0:	c7 01       	movw	r24, r14
    24b2:	90 d3       	rcall	.+1824   	; 0x2bd4 <vTaskPlaceOnEventList>
    24b4:	c8 01       	movw	r24, r16
    24b6:	17 de       	rcall	.-978    	; 0x20e6 <prvUnlockQueue>
    24b8:	88 d2       	rcall	.+1296   	; 0x29ca <xTaskResumeAll>
    24ba:	81 11       	cpse	r24, r1
    24bc:	9a cf       	rjmp	.-204    	; 0x23f2 <xQueueGenericReceive+0x32>
    24be:	e0 dc       	rcall	.-1600   	; 0x1e80 <vPortYield>
    24c0:	98 cf       	rjmp	.-208    	; 0x23f2 <xQueueGenericReceive+0x32>
    24c2:	c8 01       	movw	r24, r16
    24c4:	10 de       	rcall	.-992    	; 0x20e6 <prvUnlockQueue>
    24c6:	81 d2       	rcall	.+1282   	; 0x29ca <xTaskResumeAll>
    24c8:	94 cf       	rjmp	.-216    	; 0x23f2 <xQueueGenericReceive+0x32>
    24ca:	c8 01       	movw	r24, r16
    24cc:	0c de       	rcall	.-1000   	; 0x20e6 <prvUnlockQueue>
    24ce:	7d d2       	rcall	.+1274   	; 0x29ca <xTaskResumeAll>
    24d0:	80 e0       	ldi	r24, 0x00	; 0
    24d2:	25 96       	adiw	r28, 0x05	; 5
    24d4:	cd bf       	out	0x3d, r28	; 61
    24d6:	de bf       	out	0x3e, r29	; 62
    24d8:	df 91       	pop	r29
    24da:	cf 91       	pop	r28
    24dc:	1f 91       	pop	r17
    24de:	0f 91       	pop	r16
    24e0:	ff 90       	pop	r15
    24e2:	ef 90       	pop	r14
    24e4:	df 90       	pop	r13
    24e6:	cf 90       	pop	r12
    24e8:	bf 90       	pop	r11
    24ea:	af 90       	pop	r10
    24ec:	08 95       	ret

000024ee <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    24ee:	cf 93       	push	r28
    24f0:	df 93       	push	r29
    24f2:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    24f4:	0f b6       	in	r0, 0x3f	; 63
    24f6:	f8 94       	cli
    24f8:	0f 92       	push	r0
    24fa:	8d 8d       	ldd	r24, Y+29	; 0x1d
    24fc:	8f 3f       	cpi	r24, 0xFF	; 255
    24fe:	09 f4       	brne	.+2      	; 0x2502 <vQueueWaitForMessageRestricted+0x14>
    2500:	1d 8e       	std	Y+29, r1	; 0x1d
    2502:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2504:	8f 3f       	cpi	r24, 0xFF	; 255
    2506:	09 f4       	brne	.+2      	; 0x250a <vQueueWaitForMessageRestricted+0x1c>
    2508:	1e 8e       	std	Y+30, r1	; 0x1e
    250a:	0f 90       	pop	r0
    250c:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    250e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2510:	81 11       	cpse	r24, r1
    2512:	03 c0       	rjmp	.+6      	; 0x251a <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    2514:	ce 01       	movw	r24, r28
    2516:	41 96       	adiw	r24, 0x11	; 17
    2518:	78 d3       	rcall	.+1776   	; 0x2c0a <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    251a:	ce 01       	movw	r24, r28
    251c:	e4 dd       	rcall	.-1080   	; 0x20e6 <prvUnlockQueue>
	}
    251e:	df 91       	pop	r29
    2520:	cf 91       	pop	r28
    2522:	08 95       	ret

00002524 <prvIdleTask>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    2524:	c3 e9       	ldi	r28, 0x93	; 147
    2526:	d2 e2       	ldi	r29, 0x22	; 34
    2528:	88 81       	ld	r24, Y
    252a:	82 30       	cpi	r24, 0x02	; 2
    252c:	f0 f3       	brcs	.-4      	; 0x252a <prvIdleTask+0x6>
    252e:	a8 dc       	rcall	.-1712   	; 0x1e80 <vPortYield>
    2530:	fb cf       	rjmp	.-10     	; 0x2528 <prvIdleTask+0x4>

00002532 <prvAddCurrentTaskToDelayedList>:
    2532:	cf 93       	push	r28
    2534:	df 93       	push	r29
    2536:	ec 01       	movw	r28, r24
    2538:	e0 91 c0 22 	lds	r30, 0x22C0	; 0x8022c0 <pxCurrentTCB>
    253c:	f0 91 c1 22 	lds	r31, 0x22C1	; 0x8022c1 <pxCurrentTCB+0x1>
    2540:	82 83       	std	Z+2, r24	; 0x02
    2542:	93 83       	std	Z+3, r25	; 0x03
    2544:	80 91 71 22 	lds	r24, 0x2271	; 0x802271 <xTickCount>
    2548:	90 91 72 22 	lds	r25, 0x2272	; 0x802272 <xTickCount+0x1>
    254c:	c8 17       	cp	r28, r24
    254e:	d9 07       	cpc	r29, r25
    2550:	60 f4       	brcc	.+24     	; 0x256a <prvAddCurrentTaskToDelayedList+0x38>
    2552:	60 91 c0 22 	lds	r22, 0x22C0	; 0x8022c0 <pxCurrentTCB>
    2556:	70 91 c1 22 	lds	r23, 0x22C1	; 0x8022c1 <pxCurrentTCB+0x1>
    255a:	80 91 7d 22 	lds	r24, 0x227D	; 0x80227d <pxOverflowDelayedTaskList>
    255e:	90 91 7e 22 	lds	r25, 0x227E	; 0x80227e <pxOverflowDelayedTaskList+0x1>
    2562:	6e 5f       	subi	r22, 0xFE	; 254
    2564:	7f 4f       	sbci	r23, 0xFF	; 255
    2566:	79 db       	rcall	.-2318   	; 0x1c5a <vListInsert>
    2568:	16 c0       	rjmp	.+44     	; 0x2596 <prvAddCurrentTaskToDelayedList+0x64>
    256a:	60 91 c0 22 	lds	r22, 0x22C0	; 0x8022c0 <pxCurrentTCB>
    256e:	70 91 c1 22 	lds	r23, 0x22C1	; 0x8022c1 <pxCurrentTCB+0x1>
    2572:	80 91 7f 22 	lds	r24, 0x227F	; 0x80227f <pxDelayedTaskList>
    2576:	90 91 80 22 	lds	r25, 0x2280	; 0x802280 <pxDelayedTaskList+0x1>
    257a:	6e 5f       	subi	r22, 0xFE	; 254
    257c:	7f 4f       	sbci	r23, 0xFF	; 255
    257e:	6d db       	rcall	.-2342   	; 0x1c5a <vListInsert>
    2580:	80 91 69 22 	lds	r24, 0x2269	; 0x802269 <xNextTaskUnblockTime>
    2584:	90 91 6a 22 	lds	r25, 0x226A	; 0x80226a <xNextTaskUnblockTime+0x1>
    2588:	c8 17       	cp	r28, r24
    258a:	d9 07       	cpc	r29, r25
    258c:	20 f4       	brcc	.+8      	; 0x2596 <prvAddCurrentTaskToDelayedList+0x64>
    258e:	c0 93 69 22 	sts	0x2269, r28	; 0x802269 <xNextTaskUnblockTime>
    2592:	d0 93 6a 22 	sts	0x226A, r29	; 0x80226a <xNextTaskUnblockTime+0x1>
    2596:	df 91       	pop	r29
    2598:	cf 91       	pop	r28
    259a:	08 95       	ret

0000259c <xTaskGenericCreate>:
    259c:	4f 92       	push	r4
    259e:	5f 92       	push	r5
    25a0:	6f 92       	push	r6
    25a2:	7f 92       	push	r7
    25a4:	8f 92       	push	r8
    25a6:	9f 92       	push	r9
    25a8:	af 92       	push	r10
    25aa:	bf 92       	push	r11
    25ac:	cf 92       	push	r12
    25ae:	df 92       	push	r13
    25b0:	ef 92       	push	r14
    25b2:	ff 92       	push	r15
    25b4:	0f 93       	push	r16
    25b6:	1f 93       	push	r17
    25b8:	cf 93       	push	r28
    25ba:	df 93       	push	r29
    25bc:	4c 01       	movw	r8, r24
    25be:	eb 01       	movw	r28, r22
    25c0:	5a 01       	movw	r10, r20
    25c2:	29 01       	movw	r4, r18
    25c4:	c1 14       	cp	r12, r1
    25c6:	d1 04       	cpc	r13, r1
    25c8:	31 f4       	brne	.+12     	; 0x25d6 <xTaskGenericCreate+0x3a>
    25ca:	ca 01       	movw	r24, r20
    25cc:	0b dd       	rcall	.-1514   	; 0x1fe4 <pvPortMalloc>
    25ce:	6c 01       	movw	r12, r24
    25d0:	89 2b       	or	r24, r25
    25d2:	09 f4       	brne	.+2      	; 0x25d6 <xTaskGenericCreate+0x3a>
    25d4:	d2 c0       	rjmp	.+420    	; 0x277a <xTaskGenericCreate+0x1de>
    25d6:	86 e2       	ldi	r24, 0x26	; 38
    25d8:	90 e0       	ldi	r25, 0x00	; 0
    25da:	04 dd       	rcall	.-1528   	; 0x1fe4 <pvPortMalloc>
    25dc:	3c 01       	movw	r6, r24
    25de:	00 97       	sbiw	r24, 0x00	; 0
    25e0:	79 f0       	breq	.+30     	; 0x2600 <xTaskGenericCreate+0x64>
    25e2:	fc 01       	movw	r30, r24
    25e4:	c7 8a       	std	Z+23, r12	; 0x17
    25e6:	d0 8e       	std	Z+24, r13	; 0x18
    25e8:	f1 e0       	ldi	r31, 0x01	; 1
    25ea:	af 1a       	sub	r10, r31
    25ec:	b1 08       	sbc	r11, r1
    25ee:	ca 0c       	add	r12, r10
    25f0:	db 1c       	adc	r13, r11
    25f2:	88 81       	ld	r24, Y
    25f4:	f3 01       	movw	r30, r6
    25f6:	81 8f       	std	Z+25, r24	; 0x19
    25f8:	88 81       	ld	r24, Y
    25fa:	81 11       	cpse	r24, r1
    25fc:	04 c0       	rjmp	.+8      	; 0x2606 <xTaskGenericCreate+0x6a>
    25fe:	13 c0       	rjmp	.+38     	; 0x2626 <xTaskGenericCreate+0x8a>
    2600:	c6 01       	movw	r24, r12
    2602:	fd dc       	rcall	.-1542   	; 0x1ffe <vPortFree>
    2604:	ba c0       	rjmp	.+372    	; 0x277a <xTaskGenericCreate+0x1de>
    2606:	d3 01       	movw	r26, r6
    2608:	5a 96       	adiw	r26, 0x1a	; 26
    260a:	fe 01       	movw	r30, r28
    260c:	31 96       	adiw	r30, 0x01	; 1
    260e:	9e 01       	movw	r18, r28
    2610:	28 5f       	subi	r18, 0xF8	; 248
    2612:	3f 4f       	sbci	r19, 0xFF	; 255
    2614:	ef 01       	movw	r28, r30
    2616:	81 91       	ld	r24, Z+
    2618:	8d 93       	st	X+, r24
    261a:	88 81       	ld	r24, Y
    261c:	88 23       	and	r24, r24
    261e:	19 f0       	breq	.+6      	; 0x2626 <xTaskGenericCreate+0x8a>
    2620:	e2 17       	cp	r30, r18
    2622:	f3 07       	cpc	r31, r19
    2624:	b9 f7       	brne	.-18     	; 0x2614 <xTaskGenericCreate+0x78>
    2626:	f3 01       	movw	r30, r6
    2628:	10 a2       	std	Z+32, r1	; 0x20
    262a:	10 2f       	mov	r17, r16
    262c:	05 30       	cpi	r16, 0x05	; 5
    262e:	08 f0       	brcs	.+2      	; 0x2632 <xTaskGenericCreate+0x96>
    2630:	14 e0       	ldi	r17, 0x04	; 4
    2632:	f3 01       	movw	r30, r6
    2634:	16 8b       	std	Z+22, r17	; 0x16
    2636:	e3 01       	movw	r28, r6
    2638:	22 96       	adiw	r28, 0x02	; 2
    263a:	ce 01       	movw	r24, r28
    263c:	e9 da       	rcall	.-2606   	; 0x1c10 <vListInitialiseItem>
    263e:	c3 01       	movw	r24, r6
    2640:	0c 96       	adiw	r24, 0x0c	; 12
    2642:	e6 da       	rcall	.-2612   	; 0x1c10 <vListInitialiseItem>
    2644:	f3 01       	movw	r30, r6
    2646:	60 86       	std	Z+8, r6	; 0x08
    2648:	71 86       	std	Z+9, r7	; 0x09
    264a:	85 e0       	ldi	r24, 0x05	; 5
    264c:	90 e0       	ldi	r25, 0x00	; 0
    264e:	81 1b       	sub	r24, r17
    2650:	91 09       	sbc	r25, r1
    2652:	84 87       	std	Z+12, r24	; 0x0c
    2654:	95 87       	std	Z+13, r25	; 0x0d
    2656:	62 8a       	std	Z+18, r6	; 0x12
    2658:	73 8a       	std	Z+19, r7	; 0x13
    265a:	11 a2       	std	Z+33, r1	; 0x21
    265c:	12 a2       	std	Z+34, r1	; 0x22
    265e:	13 a2       	std	Z+35, r1	; 0x23
    2660:	14 a2       	std	Z+36, r1	; 0x24
    2662:	15 a2       	std	Z+37, r1	; 0x25
    2664:	a2 01       	movw	r20, r4
    2666:	b4 01       	movw	r22, r8
    2668:	c6 01       	movw	r24, r12
    266a:	4e db       	rcall	.-2404   	; 0x1d08 <pxPortInitialiseStack>
    266c:	f3 01       	movw	r30, r6
    266e:	80 83       	st	Z, r24
    2670:	91 83       	std	Z+1, r25	; 0x01
    2672:	e1 14       	cp	r14, r1
    2674:	f1 04       	cpc	r15, r1
    2676:	19 f0       	breq	.+6      	; 0x267e <xTaskGenericCreate+0xe2>
    2678:	f7 01       	movw	r30, r14
    267a:	60 82       	st	Z, r6
    267c:	71 82       	std	Z+1, r7	; 0x01
    267e:	0f b6       	in	r0, 0x3f	; 63
    2680:	f8 94       	cli
    2682:	0f 92       	push	r0
    2684:	80 91 73 22 	lds	r24, 0x2273	; 0x802273 <uxCurrentNumberOfTasks>
    2688:	8f 5f       	subi	r24, 0xFF	; 255
    268a:	80 93 73 22 	sts	0x2273, r24	; 0x802273 <uxCurrentNumberOfTasks>
    268e:	80 91 c0 22 	lds	r24, 0x22C0	; 0x8022c0 <pxCurrentTCB>
    2692:	90 91 c1 22 	lds	r25, 0x22C1	; 0x8022c1 <pxCurrentTCB+0x1>
    2696:	89 2b       	or	r24, r25
    2698:	91 f5       	brne	.+100    	; 0x26fe <xTaskGenericCreate+0x162>
    269a:	60 92 c0 22 	sts	0x22C0, r6	; 0x8022c0 <pxCurrentTCB>
    269e:	70 92 c1 22 	sts	0x22C1, r7	; 0x8022c1 <pxCurrentTCB+0x1>
    26a2:	80 91 73 22 	lds	r24, 0x2273	; 0x802273 <uxCurrentNumberOfTasks>
    26a6:	81 30       	cpi	r24, 0x01	; 1
    26a8:	c9 f5       	brne	.+114    	; 0x271c <xTaskGenericCreate+0x180>
    26aa:	0f 2e       	mov	r0, r31
    26ac:	f3 e9       	ldi	r31, 0x93	; 147
    26ae:	ef 2e       	mov	r14, r31
    26b0:	f2 e2       	ldi	r31, 0x22	; 34
    26b2:	ff 2e       	mov	r15, r31
    26b4:	f0 2d       	mov	r31, r0
    26b6:	0f 2e       	mov	r0, r31
    26b8:	f0 ec       	ldi	r31, 0xC0	; 192
    26ba:	cf 2e       	mov	r12, r31
    26bc:	f2 e2       	ldi	r31, 0x22	; 34
    26be:	df 2e       	mov	r13, r31
    26c0:	f0 2d       	mov	r31, r0
    26c2:	c7 01       	movw	r24, r14
    26c4:	97 da       	rcall	.-2770   	; 0x1bf4 <vListInitialise>
    26c6:	f9 e0       	ldi	r31, 0x09	; 9
    26c8:	ef 0e       	add	r14, r31
    26ca:	f1 1c       	adc	r15, r1
    26cc:	ec 14       	cp	r14, r12
    26ce:	fd 04       	cpc	r15, r13
    26d0:	c1 f7       	brne	.-16     	; 0x26c2 <xTaskGenericCreate+0x126>
    26d2:	8a e8       	ldi	r24, 0x8A	; 138
    26d4:	92 e2       	ldi	r25, 0x22	; 34
    26d6:	8e da       	rcall	.-2788   	; 0x1bf4 <vListInitialise>
    26d8:	81 e8       	ldi	r24, 0x81	; 129
    26da:	92 e2       	ldi	r25, 0x22	; 34
    26dc:	8b da       	rcall	.-2794   	; 0x1bf4 <vListInitialise>
    26de:	84 e7       	ldi	r24, 0x74	; 116
    26e0:	92 e2       	ldi	r25, 0x22	; 34
    26e2:	88 da       	rcall	.-2800   	; 0x1bf4 <vListInitialise>
    26e4:	8a e8       	ldi	r24, 0x8A	; 138
    26e6:	92 e2       	ldi	r25, 0x22	; 34
    26e8:	80 93 7f 22 	sts	0x227F, r24	; 0x80227f <pxDelayedTaskList>
    26ec:	90 93 80 22 	sts	0x2280, r25	; 0x802280 <pxDelayedTaskList+0x1>
    26f0:	81 e8       	ldi	r24, 0x81	; 129
    26f2:	92 e2       	ldi	r25, 0x22	; 34
    26f4:	80 93 7d 22 	sts	0x227D, r24	; 0x80227d <pxOverflowDelayedTaskList>
    26f8:	90 93 7e 22 	sts	0x227E, r25	; 0x80227e <pxOverflowDelayedTaskList+0x1>
    26fc:	0f c0       	rjmp	.+30     	; 0x271c <xTaskGenericCreate+0x180>
    26fe:	80 91 6f 22 	lds	r24, 0x226F	; 0x80226f <xSchedulerRunning>
    2702:	81 11       	cpse	r24, r1
    2704:	0b c0       	rjmp	.+22     	; 0x271c <xTaskGenericCreate+0x180>
    2706:	e0 91 c0 22 	lds	r30, 0x22C0	; 0x8022c0 <pxCurrentTCB>
    270a:	f0 91 c1 22 	lds	r31, 0x22C1	; 0x8022c1 <pxCurrentTCB+0x1>
    270e:	86 89       	ldd	r24, Z+22	; 0x16
    2710:	08 17       	cp	r16, r24
    2712:	20 f0       	brcs	.+8      	; 0x271c <xTaskGenericCreate+0x180>
    2714:	60 92 c0 22 	sts	0x22C0, r6	; 0x8022c0 <pxCurrentTCB>
    2718:	70 92 c1 22 	sts	0x22C1, r7	; 0x8022c1 <pxCurrentTCB+0x1>
    271c:	80 91 6b 22 	lds	r24, 0x226B	; 0x80226b <uxTaskNumber>
    2720:	8f 5f       	subi	r24, 0xFF	; 255
    2722:	80 93 6b 22 	sts	0x226B, r24	; 0x80226b <uxTaskNumber>
    2726:	f3 01       	movw	r30, r6
    2728:	86 89       	ldd	r24, Z+22	; 0x16
    272a:	90 91 70 22 	lds	r25, 0x2270	; 0x802270 <uxTopReadyPriority>
    272e:	98 17       	cp	r25, r24
    2730:	10 f4       	brcc	.+4      	; 0x2736 <xTaskGenericCreate+0x19a>
    2732:	80 93 70 22 	sts	0x2270, r24	; 0x802270 <uxTopReadyPriority>
    2736:	90 e0       	ldi	r25, 0x00	; 0
    2738:	9c 01       	movw	r18, r24
    273a:	22 0f       	add	r18, r18
    273c:	33 1f       	adc	r19, r19
    273e:	22 0f       	add	r18, r18
    2740:	33 1f       	adc	r19, r19
    2742:	22 0f       	add	r18, r18
    2744:	33 1f       	adc	r19, r19
    2746:	82 0f       	add	r24, r18
    2748:	93 1f       	adc	r25, r19
    274a:	be 01       	movw	r22, r28
    274c:	8d 56       	subi	r24, 0x6D	; 109
    274e:	9d 4d       	sbci	r25, 0xDD	; 221
    2750:	63 da       	rcall	.-2874   	; 0x1c18 <vListInsertEnd>
    2752:	0f 90       	pop	r0
    2754:	0f be       	out	0x3f, r0	; 63
    2756:	80 91 6f 22 	lds	r24, 0x226F	; 0x80226f <xSchedulerRunning>
    275a:	88 23       	and	r24, r24
    275c:	51 f0       	breq	.+20     	; 0x2772 <xTaskGenericCreate+0x1d6>
    275e:	e0 91 c0 22 	lds	r30, 0x22C0	; 0x8022c0 <pxCurrentTCB>
    2762:	f0 91 c1 22 	lds	r31, 0x22C1	; 0x8022c1 <pxCurrentTCB+0x1>
    2766:	86 89       	ldd	r24, Z+22	; 0x16
    2768:	80 17       	cp	r24, r16
    276a:	28 f4       	brcc	.+10     	; 0x2776 <xTaskGenericCreate+0x1da>
    276c:	89 db       	rcall	.-2286   	; 0x1e80 <vPortYield>
    276e:	81 e0       	ldi	r24, 0x01	; 1
    2770:	05 c0       	rjmp	.+10     	; 0x277c <xTaskGenericCreate+0x1e0>
    2772:	81 e0       	ldi	r24, 0x01	; 1
    2774:	03 c0       	rjmp	.+6      	; 0x277c <xTaskGenericCreate+0x1e0>
    2776:	81 e0       	ldi	r24, 0x01	; 1
    2778:	01 c0       	rjmp	.+2      	; 0x277c <xTaskGenericCreate+0x1e0>
    277a:	8f ef       	ldi	r24, 0xFF	; 255
    277c:	df 91       	pop	r29
    277e:	cf 91       	pop	r28
    2780:	1f 91       	pop	r17
    2782:	0f 91       	pop	r16
    2784:	ff 90       	pop	r15
    2786:	ef 90       	pop	r14
    2788:	df 90       	pop	r13
    278a:	cf 90       	pop	r12
    278c:	bf 90       	pop	r11
    278e:	af 90       	pop	r10
    2790:	9f 90       	pop	r9
    2792:	8f 90       	pop	r8
    2794:	7f 90       	pop	r7
    2796:	6f 90       	pop	r6
    2798:	5f 90       	pop	r5
    279a:	4f 90       	pop	r4
    279c:	08 95       	ret

0000279e <vTaskStartScheduler>:
    279e:	af 92       	push	r10
    27a0:	bf 92       	push	r11
    27a2:	cf 92       	push	r12
    27a4:	df 92       	push	r13
    27a6:	ef 92       	push	r14
    27a8:	ff 92       	push	r15
    27aa:	0f 93       	push	r16
    27ac:	a1 2c       	mov	r10, r1
    27ae:	b1 2c       	mov	r11, r1
    27b0:	c1 2c       	mov	r12, r1
    27b2:	d1 2c       	mov	r13, r1
    27b4:	e1 2c       	mov	r14, r1
    27b6:	f1 2c       	mov	r15, r1
    27b8:	00 e0       	ldi	r16, 0x00	; 0
    27ba:	20 e0       	ldi	r18, 0x00	; 0
    27bc:	30 e0       	ldi	r19, 0x00	; 0
    27be:	45 e5       	ldi	r20, 0x55	; 85
    27c0:	50 e0       	ldi	r21, 0x00	; 0
    27c2:	64 e1       	ldi	r22, 0x14	; 20
    27c4:	70 e2       	ldi	r23, 0x20	; 32
    27c6:	82 e9       	ldi	r24, 0x92	; 146
    27c8:	92 e1       	ldi	r25, 0x12	; 18
    27ca:	e8 de       	rcall	.-560    	; 0x259c <xTaskGenericCreate>
    27cc:	81 30       	cpi	r24, 0x01	; 1
    27ce:	91 f4       	brne	.+36     	; 0x27f4 <vTaskStartScheduler+0x56>
    27d0:	23 d3       	rcall	.+1606   	; 0x2e18 <xTimerCreateTimerTask>
    27d2:	81 30       	cpi	r24, 0x01	; 1
    27d4:	79 f4       	brne	.+30     	; 0x27f4 <vTaskStartScheduler+0x56>
    27d6:	f8 94       	cli
    27d8:	8f ef       	ldi	r24, 0xFF	; 255
    27da:	9f ef       	ldi	r25, 0xFF	; 255
    27dc:	80 93 69 22 	sts	0x2269, r24	; 0x802269 <xNextTaskUnblockTime>
    27e0:	90 93 6a 22 	sts	0x226A, r25	; 0x80226a <xNextTaskUnblockTime+0x1>
    27e4:	81 e0       	ldi	r24, 0x01	; 1
    27e6:	80 93 6f 22 	sts	0x226F, r24	; 0x80226f <xSchedulerRunning>
    27ea:	10 92 71 22 	sts	0x2271, r1	; 0x802271 <xTickCount>
    27ee:	10 92 72 22 	sts	0x2272, r1	; 0x802272 <xTickCount+0x1>
    27f2:	01 db       	rcall	.-2558   	; 0x1df6 <xPortStartScheduler>
    27f4:	0f 91       	pop	r16
    27f6:	ff 90       	pop	r15
    27f8:	ef 90       	pop	r14
    27fa:	df 90       	pop	r13
    27fc:	cf 90       	pop	r12
    27fe:	bf 90       	pop	r11
    2800:	af 90       	pop	r10
    2802:	08 95       	ret

00002804 <vTaskSuspendAll>:
    2804:	80 91 68 22 	lds	r24, 0x2268	; 0x802268 <uxSchedulerSuspended>
    2808:	8f 5f       	subi	r24, 0xFF	; 255
    280a:	80 93 68 22 	sts	0x2268, r24	; 0x802268 <uxSchedulerSuspended>
    280e:	08 95       	ret

00002810 <xTaskGetTickCount>:
    2810:	0f b6       	in	r0, 0x3f	; 63
    2812:	f8 94       	cli
    2814:	0f 92       	push	r0
    2816:	80 91 71 22 	lds	r24, 0x2271	; 0x802271 <xTickCount>
    281a:	90 91 72 22 	lds	r25, 0x2272	; 0x802272 <xTickCount+0x1>
    281e:	0f 90       	pop	r0
    2820:	0f be       	out	0x3f, r0	; 63
    2822:	08 95       	ret

00002824 <xTaskIncrementTick>:
    2824:	df 92       	push	r13
    2826:	ef 92       	push	r14
    2828:	ff 92       	push	r15
    282a:	0f 93       	push	r16
    282c:	1f 93       	push	r17
    282e:	cf 93       	push	r28
    2830:	df 93       	push	r29
    2832:	80 91 68 22 	lds	r24, 0x2268	; 0x802268 <uxSchedulerSuspended>
    2836:	81 11       	cpse	r24, r1
    2838:	b3 c0       	rjmp	.+358    	; 0x29a0 <xTaskIncrementTick+0x17c>
    283a:	80 91 71 22 	lds	r24, 0x2271	; 0x802271 <xTickCount>
    283e:	90 91 72 22 	lds	r25, 0x2272	; 0x802272 <xTickCount+0x1>
    2842:	01 96       	adiw	r24, 0x01	; 1
    2844:	80 93 71 22 	sts	0x2271, r24	; 0x802271 <xTickCount>
    2848:	90 93 72 22 	sts	0x2272, r25	; 0x802272 <xTickCount+0x1>
    284c:	e0 90 71 22 	lds	r14, 0x2271	; 0x802271 <xTickCount>
    2850:	f0 90 72 22 	lds	r15, 0x2272	; 0x802272 <xTickCount+0x1>
    2854:	e1 14       	cp	r14, r1
    2856:	f1 04       	cpc	r15, r1
    2858:	99 f5       	brne	.+102    	; 0x28c0 <xTaskIncrementTick+0x9c>
    285a:	80 91 7f 22 	lds	r24, 0x227F	; 0x80227f <pxDelayedTaskList>
    285e:	90 91 80 22 	lds	r25, 0x2280	; 0x802280 <pxDelayedTaskList+0x1>
    2862:	20 91 7d 22 	lds	r18, 0x227D	; 0x80227d <pxOverflowDelayedTaskList>
    2866:	30 91 7e 22 	lds	r19, 0x227E	; 0x80227e <pxOverflowDelayedTaskList+0x1>
    286a:	20 93 7f 22 	sts	0x227F, r18	; 0x80227f <pxDelayedTaskList>
    286e:	30 93 80 22 	sts	0x2280, r19	; 0x802280 <pxDelayedTaskList+0x1>
    2872:	80 93 7d 22 	sts	0x227D, r24	; 0x80227d <pxOverflowDelayedTaskList>
    2876:	90 93 7e 22 	sts	0x227E, r25	; 0x80227e <pxOverflowDelayedTaskList+0x1>
    287a:	80 91 6c 22 	lds	r24, 0x226C	; 0x80226c <xNumOfOverflows>
    287e:	8f 5f       	subi	r24, 0xFF	; 255
    2880:	80 93 6c 22 	sts	0x226C, r24	; 0x80226c <xNumOfOverflows>
    2884:	e0 91 7f 22 	lds	r30, 0x227F	; 0x80227f <pxDelayedTaskList>
    2888:	f0 91 80 22 	lds	r31, 0x2280	; 0x802280 <pxDelayedTaskList+0x1>
    288c:	80 81       	ld	r24, Z
    288e:	81 11       	cpse	r24, r1
    2890:	07 c0       	rjmp	.+14     	; 0x28a0 <xTaskIncrementTick+0x7c>
    2892:	8f ef       	ldi	r24, 0xFF	; 255
    2894:	9f ef       	ldi	r25, 0xFF	; 255
    2896:	80 93 69 22 	sts	0x2269, r24	; 0x802269 <xNextTaskUnblockTime>
    289a:	90 93 6a 22 	sts	0x226A, r25	; 0x80226a <xNextTaskUnblockTime+0x1>
    289e:	10 c0       	rjmp	.+32     	; 0x28c0 <xTaskIncrementTick+0x9c>
    28a0:	e0 91 7f 22 	lds	r30, 0x227F	; 0x80227f <pxDelayedTaskList>
    28a4:	f0 91 80 22 	lds	r31, 0x2280	; 0x802280 <pxDelayedTaskList+0x1>
    28a8:	05 80       	ldd	r0, Z+5	; 0x05
    28aa:	f6 81       	ldd	r31, Z+6	; 0x06
    28ac:	e0 2d       	mov	r30, r0
    28ae:	06 80       	ldd	r0, Z+6	; 0x06
    28b0:	f7 81       	ldd	r31, Z+7	; 0x07
    28b2:	e0 2d       	mov	r30, r0
    28b4:	82 81       	ldd	r24, Z+2	; 0x02
    28b6:	93 81       	ldd	r25, Z+3	; 0x03
    28b8:	80 93 69 22 	sts	0x2269, r24	; 0x802269 <xNextTaskUnblockTime>
    28bc:	90 93 6a 22 	sts	0x226A, r25	; 0x80226a <xNextTaskUnblockTime+0x1>
    28c0:	80 91 69 22 	lds	r24, 0x2269	; 0x802269 <xNextTaskUnblockTime>
    28c4:	90 91 6a 22 	lds	r25, 0x226A	; 0x80226a <xNextTaskUnblockTime+0x1>
    28c8:	e8 16       	cp	r14, r24
    28ca:	f9 06       	cpc	r15, r25
    28cc:	10 f4       	brcc	.+4      	; 0x28d2 <xTaskIncrementTick+0xae>
    28ce:	d1 2c       	mov	r13, r1
    28d0:	4f c0       	rjmp	.+158    	; 0x2970 <xTaskIncrementTick+0x14c>
    28d2:	d1 2c       	mov	r13, r1
    28d4:	e0 91 7f 22 	lds	r30, 0x227F	; 0x80227f <pxDelayedTaskList>
    28d8:	f0 91 80 22 	lds	r31, 0x2280	; 0x802280 <pxDelayedTaskList+0x1>
    28dc:	90 81       	ld	r25, Z
    28de:	91 11       	cpse	r25, r1
    28e0:	07 c0       	rjmp	.+14     	; 0x28f0 <xTaskIncrementTick+0xcc>
    28e2:	8f ef       	ldi	r24, 0xFF	; 255
    28e4:	9f ef       	ldi	r25, 0xFF	; 255
    28e6:	80 93 69 22 	sts	0x2269, r24	; 0x802269 <xNextTaskUnblockTime>
    28ea:	90 93 6a 22 	sts	0x226A, r25	; 0x80226a <xNextTaskUnblockTime+0x1>
    28ee:	40 c0       	rjmp	.+128    	; 0x2970 <xTaskIncrementTick+0x14c>
    28f0:	e0 91 7f 22 	lds	r30, 0x227F	; 0x80227f <pxDelayedTaskList>
    28f4:	f0 91 80 22 	lds	r31, 0x2280	; 0x802280 <pxDelayedTaskList+0x1>
    28f8:	05 80       	ldd	r0, Z+5	; 0x05
    28fa:	f6 81       	ldd	r31, Z+6	; 0x06
    28fc:	e0 2d       	mov	r30, r0
    28fe:	c6 81       	ldd	r28, Z+6	; 0x06
    2900:	d7 81       	ldd	r29, Z+7	; 0x07
    2902:	2a 81       	ldd	r18, Y+2	; 0x02
    2904:	3b 81       	ldd	r19, Y+3	; 0x03
    2906:	e2 16       	cp	r14, r18
    2908:	f3 06       	cpc	r15, r19
    290a:	28 f4       	brcc	.+10     	; 0x2916 <xTaskIncrementTick+0xf2>
    290c:	20 93 69 22 	sts	0x2269, r18	; 0x802269 <xNextTaskUnblockTime>
    2910:	30 93 6a 22 	sts	0x226A, r19	; 0x80226a <xNextTaskUnblockTime+0x1>
    2914:	2d c0       	rjmp	.+90     	; 0x2970 <xTaskIncrementTick+0x14c>
    2916:	8e 01       	movw	r16, r28
    2918:	0e 5f       	subi	r16, 0xFE	; 254
    291a:	1f 4f       	sbci	r17, 0xFF	; 255
    291c:	c8 01       	movw	r24, r16
    291e:	ce d9       	rcall	.-3172   	; 0x1cbc <uxListRemove>
    2920:	8c 89       	ldd	r24, Y+20	; 0x14
    2922:	9d 89       	ldd	r25, Y+21	; 0x15
    2924:	89 2b       	or	r24, r25
    2926:	19 f0       	breq	.+6      	; 0x292e <xTaskIncrementTick+0x10a>
    2928:	ce 01       	movw	r24, r28
    292a:	0c 96       	adiw	r24, 0x0c	; 12
    292c:	c7 d9       	rcall	.-3186   	; 0x1cbc <uxListRemove>
    292e:	2e 89       	ldd	r18, Y+22	; 0x16
    2930:	80 91 70 22 	lds	r24, 0x2270	; 0x802270 <uxTopReadyPriority>
    2934:	82 17       	cp	r24, r18
    2936:	10 f4       	brcc	.+4      	; 0x293c <xTaskIncrementTick+0x118>
    2938:	20 93 70 22 	sts	0x2270, r18	; 0x802270 <uxTopReadyPriority>
    293c:	30 e0       	ldi	r19, 0x00	; 0
    293e:	c9 01       	movw	r24, r18
    2940:	88 0f       	add	r24, r24
    2942:	99 1f       	adc	r25, r25
    2944:	88 0f       	add	r24, r24
    2946:	99 1f       	adc	r25, r25
    2948:	88 0f       	add	r24, r24
    294a:	99 1f       	adc	r25, r25
    294c:	82 0f       	add	r24, r18
    294e:	93 1f       	adc	r25, r19
    2950:	b8 01       	movw	r22, r16
    2952:	8d 56       	subi	r24, 0x6D	; 109
    2954:	9d 4d       	sbci	r25, 0xDD	; 221
    2956:	60 d9       	rcall	.-3392   	; 0x1c18 <vListInsertEnd>
    2958:	e0 91 c0 22 	lds	r30, 0x22C0	; 0x8022c0 <pxCurrentTCB>
    295c:	f0 91 c1 22 	lds	r31, 0x22C1	; 0x8022c1 <pxCurrentTCB+0x1>
    2960:	9e 89       	ldd	r25, Y+22	; 0x16
    2962:	86 89       	ldd	r24, Z+22	; 0x16
    2964:	98 17       	cp	r25, r24
    2966:	08 f4       	brcc	.+2      	; 0x296a <xTaskIncrementTick+0x146>
    2968:	b5 cf       	rjmp	.-150    	; 0x28d4 <xTaskIncrementTick+0xb0>
    296a:	dd 24       	eor	r13, r13
    296c:	d3 94       	inc	r13
    296e:	b2 cf       	rjmp	.-156    	; 0x28d4 <xTaskIncrementTick+0xb0>
    2970:	e0 91 c0 22 	lds	r30, 0x22C0	; 0x8022c0 <pxCurrentTCB>
    2974:	f0 91 c1 22 	lds	r31, 0x22C1	; 0x8022c1 <pxCurrentTCB+0x1>
    2978:	86 89       	ldd	r24, Z+22	; 0x16
    297a:	90 e0       	ldi	r25, 0x00	; 0
    297c:	fc 01       	movw	r30, r24
    297e:	ee 0f       	add	r30, r30
    2980:	ff 1f       	adc	r31, r31
    2982:	ee 0f       	add	r30, r30
    2984:	ff 1f       	adc	r31, r31
    2986:	ee 0f       	add	r30, r30
    2988:	ff 1f       	adc	r31, r31
    298a:	8e 0f       	add	r24, r30
    298c:	9f 1f       	adc	r25, r31
    298e:	fc 01       	movw	r30, r24
    2990:	ed 56       	subi	r30, 0x6D	; 109
    2992:	fd 4d       	sbci	r31, 0xDD	; 221
    2994:	80 81       	ld	r24, Z
    2996:	82 30       	cpi	r24, 0x02	; 2
    2998:	48 f0       	brcs	.+18     	; 0x29ac <xTaskIncrementTick+0x188>
    299a:	dd 24       	eor	r13, r13
    299c:	d3 94       	inc	r13
    299e:	06 c0       	rjmp	.+12     	; 0x29ac <xTaskIncrementTick+0x188>
    29a0:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <uxPendedTicks>
    29a4:	8f 5f       	subi	r24, 0xFF	; 255
    29a6:	80 93 6e 22 	sts	0x226E, r24	; 0x80226e <uxPendedTicks>
    29aa:	d1 2c       	mov	r13, r1
    29ac:	80 91 6d 22 	lds	r24, 0x226D	; 0x80226d <xYieldPending>
    29b0:	88 23       	and	r24, r24
    29b2:	11 f0       	breq	.+4      	; 0x29b8 <xTaskIncrementTick+0x194>
    29b4:	dd 24       	eor	r13, r13
    29b6:	d3 94       	inc	r13
    29b8:	8d 2d       	mov	r24, r13
    29ba:	df 91       	pop	r29
    29bc:	cf 91       	pop	r28
    29be:	1f 91       	pop	r17
    29c0:	0f 91       	pop	r16
    29c2:	ff 90       	pop	r15
    29c4:	ef 90       	pop	r14
    29c6:	df 90       	pop	r13
    29c8:	08 95       	ret

000029ca <xTaskResumeAll>:
    29ca:	df 92       	push	r13
    29cc:	ef 92       	push	r14
    29ce:	ff 92       	push	r15
    29d0:	0f 93       	push	r16
    29d2:	1f 93       	push	r17
    29d4:	cf 93       	push	r28
    29d6:	df 93       	push	r29
    29d8:	0f b6       	in	r0, 0x3f	; 63
    29da:	f8 94       	cli
    29dc:	0f 92       	push	r0
    29de:	80 91 68 22 	lds	r24, 0x2268	; 0x802268 <uxSchedulerSuspended>
    29e2:	81 50       	subi	r24, 0x01	; 1
    29e4:	80 93 68 22 	sts	0x2268, r24	; 0x802268 <uxSchedulerSuspended>
    29e8:	80 91 68 22 	lds	r24, 0x2268	; 0x802268 <uxSchedulerSuspended>
    29ec:	81 11       	cpse	r24, r1
    29ee:	5d c0       	rjmp	.+186    	; 0x2aaa <xTaskResumeAll+0xe0>
    29f0:	80 91 73 22 	lds	r24, 0x2273	; 0x802273 <uxCurrentNumberOfTasks>
    29f4:	81 11       	cpse	r24, r1
    29f6:	30 c0       	rjmp	.+96     	; 0x2a58 <xTaskResumeAll+0x8e>
    29f8:	5b c0       	rjmp	.+182    	; 0x2ab0 <xTaskResumeAll+0xe6>
    29fa:	d7 01       	movw	r26, r14
    29fc:	15 96       	adiw	r26, 0x05	; 5
    29fe:	ed 91       	ld	r30, X+
    2a00:	fc 91       	ld	r31, X
    2a02:	16 97       	sbiw	r26, 0x06	; 6
    2a04:	c6 81       	ldd	r28, Z+6	; 0x06
    2a06:	d7 81       	ldd	r29, Z+7	; 0x07
    2a08:	ce 01       	movw	r24, r28
    2a0a:	0c 96       	adiw	r24, 0x0c	; 12
    2a0c:	57 d9       	rcall	.-3410   	; 0x1cbc <uxListRemove>
    2a0e:	8e 01       	movw	r16, r28
    2a10:	0e 5f       	subi	r16, 0xFE	; 254
    2a12:	1f 4f       	sbci	r17, 0xFF	; 255
    2a14:	c8 01       	movw	r24, r16
    2a16:	52 d9       	rcall	.-3420   	; 0x1cbc <uxListRemove>
    2a18:	2e 89       	ldd	r18, Y+22	; 0x16
    2a1a:	80 91 70 22 	lds	r24, 0x2270	; 0x802270 <uxTopReadyPriority>
    2a1e:	82 17       	cp	r24, r18
    2a20:	10 f4       	brcc	.+4      	; 0x2a26 <xTaskResumeAll+0x5c>
    2a22:	20 93 70 22 	sts	0x2270, r18	; 0x802270 <uxTopReadyPriority>
    2a26:	30 e0       	ldi	r19, 0x00	; 0
    2a28:	c9 01       	movw	r24, r18
    2a2a:	88 0f       	add	r24, r24
    2a2c:	99 1f       	adc	r25, r25
    2a2e:	88 0f       	add	r24, r24
    2a30:	99 1f       	adc	r25, r25
    2a32:	88 0f       	add	r24, r24
    2a34:	99 1f       	adc	r25, r25
    2a36:	82 0f       	add	r24, r18
    2a38:	93 1f       	adc	r25, r19
    2a3a:	b8 01       	movw	r22, r16
    2a3c:	8d 56       	subi	r24, 0x6D	; 109
    2a3e:	9d 4d       	sbci	r25, 0xDD	; 221
    2a40:	eb d8       	rcall	.-3626   	; 0x1c18 <vListInsertEnd>
    2a42:	e0 91 c0 22 	lds	r30, 0x22C0	; 0x8022c0 <pxCurrentTCB>
    2a46:	f0 91 c1 22 	lds	r31, 0x22C1	; 0x8022c1 <pxCurrentTCB+0x1>
    2a4a:	9e 89       	ldd	r25, Y+22	; 0x16
    2a4c:	86 89       	ldd	r24, Z+22	; 0x16
    2a4e:	98 17       	cp	r25, r24
    2a50:	58 f0       	brcs	.+22     	; 0x2a68 <xTaskResumeAll+0x9e>
    2a52:	d0 92 6d 22 	sts	0x226D, r13	; 0x80226d <xYieldPending>
    2a56:	08 c0       	rjmp	.+16     	; 0x2a68 <xTaskResumeAll+0x9e>
    2a58:	0f 2e       	mov	r0, r31
    2a5a:	f4 e7       	ldi	r31, 0x74	; 116
    2a5c:	ef 2e       	mov	r14, r31
    2a5e:	f2 e2       	ldi	r31, 0x22	; 34
    2a60:	ff 2e       	mov	r15, r31
    2a62:	f0 2d       	mov	r31, r0
    2a64:	dd 24       	eor	r13, r13
    2a66:	d3 94       	inc	r13
    2a68:	f7 01       	movw	r30, r14
    2a6a:	80 81       	ld	r24, Z
    2a6c:	81 11       	cpse	r24, r1
    2a6e:	c5 cf       	rjmp	.-118    	; 0x29fa <xTaskResumeAll+0x30>
    2a70:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <uxPendedTicks>
    2a74:	88 23       	and	r24, r24
    2a76:	91 f0       	breq	.+36     	; 0x2a9c <xTaskResumeAll+0xd2>
    2a78:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <uxPendedTicks>
    2a7c:	88 23       	and	r24, r24
    2a7e:	71 f0       	breq	.+28     	; 0x2a9c <xTaskResumeAll+0xd2>
    2a80:	c1 e0       	ldi	r28, 0x01	; 1
    2a82:	d0 de       	rcall	.-608    	; 0x2824 <xTaskIncrementTick>
    2a84:	81 11       	cpse	r24, r1
    2a86:	c0 93 6d 22 	sts	0x226D, r28	; 0x80226d <xYieldPending>
    2a8a:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <uxPendedTicks>
    2a8e:	81 50       	subi	r24, 0x01	; 1
    2a90:	80 93 6e 22 	sts	0x226E, r24	; 0x80226e <uxPendedTicks>
    2a94:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <uxPendedTicks>
    2a98:	81 11       	cpse	r24, r1
    2a9a:	f3 cf       	rjmp	.-26     	; 0x2a82 <xTaskResumeAll+0xb8>
    2a9c:	80 91 6d 22 	lds	r24, 0x226D	; 0x80226d <xYieldPending>
    2aa0:	81 30       	cpi	r24, 0x01	; 1
    2aa2:	29 f4       	brne	.+10     	; 0x2aae <xTaskResumeAll+0xe4>
    2aa4:	ed d9       	rcall	.-3110   	; 0x1e80 <vPortYield>
    2aa6:	81 e0       	ldi	r24, 0x01	; 1
    2aa8:	03 c0       	rjmp	.+6      	; 0x2ab0 <xTaskResumeAll+0xe6>
    2aaa:	80 e0       	ldi	r24, 0x00	; 0
    2aac:	01 c0       	rjmp	.+2      	; 0x2ab0 <xTaskResumeAll+0xe6>
    2aae:	80 e0       	ldi	r24, 0x00	; 0
    2ab0:	0f 90       	pop	r0
    2ab2:	0f be       	out	0x3f, r0	; 63
    2ab4:	df 91       	pop	r29
    2ab6:	cf 91       	pop	r28
    2ab8:	1f 91       	pop	r17
    2aba:	0f 91       	pop	r16
    2abc:	ff 90       	pop	r15
    2abe:	ef 90       	pop	r14
    2ac0:	df 90       	pop	r13
    2ac2:	08 95       	ret

00002ac4 <vTaskDelay>:
    2ac4:	cf 93       	push	r28
    2ac6:	df 93       	push	r29
    2ac8:	ec 01       	movw	r28, r24
    2aca:	89 2b       	or	r24, r25
    2acc:	91 f0       	breq	.+36     	; 0x2af2 <vTaskDelay+0x2e>
    2ace:	9a de       	rcall	.-716    	; 0x2804 <vTaskSuspendAll>
    2ad0:	80 91 71 22 	lds	r24, 0x2271	; 0x802271 <xTickCount>
    2ad4:	90 91 72 22 	lds	r25, 0x2272	; 0x802272 <xTickCount+0x1>
    2ad8:	c8 0f       	add	r28, r24
    2ada:	d9 1f       	adc	r29, r25
    2adc:	80 91 c0 22 	lds	r24, 0x22C0	; 0x8022c0 <pxCurrentTCB>
    2ae0:	90 91 c1 22 	lds	r25, 0x22C1	; 0x8022c1 <pxCurrentTCB+0x1>
    2ae4:	02 96       	adiw	r24, 0x02	; 2
    2ae6:	ea d8       	rcall	.-3628   	; 0x1cbc <uxListRemove>
    2ae8:	ce 01       	movw	r24, r28
    2aea:	23 dd       	rcall	.-1466   	; 0x2532 <prvAddCurrentTaskToDelayedList>
    2aec:	6e df       	rcall	.-292    	; 0x29ca <xTaskResumeAll>
    2aee:	81 11       	cpse	r24, r1
    2af0:	01 c0       	rjmp	.+2      	; 0x2af4 <vTaskDelay+0x30>
    2af2:	c6 d9       	rcall	.-3188   	; 0x1e80 <vPortYield>
    2af4:	df 91       	pop	r29
    2af6:	cf 91       	pop	r28
    2af8:	08 95       	ret

00002afa <vTaskSwitchContext>:
    2afa:	80 91 68 22 	lds	r24, 0x2268	; 0x802268 <uxSchedulerSuspended>
    2afe:	88 23       	and	r24, r24
    2b00:	21 f0       	breq	.+8      	; 0x2b0a <vTaskSwitchContext+0x10>
    2b02:	81 e0       	ldi	r24, 0x01	; 1
    2b04:	80 93 6d 22 	sts	0x226D, r24	; 0x80226d <xYieldPending>
    2b08:	08 95       	ret
    2b0a:	10 92 6d 22 	sts	0x226D, r1	; 0x80226d <xYieldPending>
    2b0e:	80 91 70 22 	lds	r24, 0x2270	; 0x802270 <uxTopReadyPriority>
    2b12:	90 e0       	ldi	r25, 0x00	; 0
    2b14:	fc 01       	movw	r30, r24
    2b16:	ee 0f       	add	r30, r30
    2b18:	ff 1f       	adc	r31, r31
    2b1a:	ee 0f       	add	r30, r30
    2b1c:	ff 1f       	adc	r31, r31
    2b1e:	ee 0f       	add	r30, r30
    2b20:	ff 1f       	adc	r31, r31
    2b22:	8e 0f       	add	r24, r30
    2b24:	9f 1f       	adc	r25, r31
    2b26:	fc 01       	movw	r30, r24
    2b28:	ed 56       	subi	r30, 0x6D	; 109
    2b2a:	fd 4d       	sbci	r31, 0xDD	; 221
    2b2c:	80 81       	ld	r24, Z
    2b2e:	81 11       	cpse	r24, r1
    2b30:	17 c0       	rjmp	.+46     	; 0x2b60 <vTaskSwitchContext+0x66>
    2b32:	80 91 70 22 	lds	r24, 0x2270	; 0x802270 <uxTopReadyPriority>
    2b36:	81 50       	subi	r24, 0x01	; 1
    2b38:	80 93 70 22 	sts	0x2270, r24	; 0x802270 <uxTopReadyPriority>
    2b3c:	80 91 70 22 	lds	r24, 0x2270	; 0x802270 <uxTopReadyPriority>
    2b40:	90 e0       	ldi	r25, 0x00	; 0
    2b42:	fc 01       	movw	r30, r24
    2b44:	ee 0f       	add	r30, r30
    2b46:	ff 1f       	adc	r31, r31
    2b48:	ee 0f       	add	r30, r30
    2b4a:	ff 1f       	adc	r31, r31
    2b4c:	ee 0f       	add	r30, r30
    2b4e:	ff 1f       	adc	r31, r31
    2b50:	8e 0f       	add	r24, r30
    2b52:	9f 1f       	adc	r25, r31
    2b54:	fc 01       	movw	r30, r24
    2b56:	ed 56       	subi	r30, 0x6D	; 109
    2b58:	fd 4d       	sbci	r31, 0xDD	; 221
    2b5a:	80 81       	ld	r24, Z
    2b5c:	88 23       	and	r24, r24
    2b5e:	49 f3       	breq	.-46     	; 0x2b32 <vTaskSwitchContext+0x38>
    2b60:	80 91 70 22 	lds	r24, 0x2270	; 0x802270 <uxTopReadyPriority>
    2b64:	90 e0       	ldi	r25, 0x00	; 0
    2b66:	9c 01       	movw	r18, r24
    2b68:	22 0f       	add	r18, r18
    2b6a:	33 1f       	adc	r19, r19
    2b6c:	22 0f       	add	r18, r18
    2b6e:	33 1f       	adc	r19, r19
    2b70:	22 0f       	add	r18, r18
    2b72:	33 1f       	adc	r19, r19
    2b74:	28 0f       	add	r18, r24
    2b76:	39 1f       	adc	r19, r25
    2b78:	d9 01       	movw	r26, r18
    2b7a:	ad 56       	subi	r26, 0x6D	; 109
    2b7c:	bd 4d       	sbci	r27, 0xDD	; 221
    2b7e:	11 96       	adiw	r26, 0x01	; 1
    2b80:	ed 91       	ld	r30, X+
    2b82:	fc 91       	ld	r31, X
    2b84:	12 97       	sbiw	r26, 0x02	; 2
    2b86:	02 80       	ldd	r0, Z+2	; 0x02
    2b88:	f3 81       	ldd	r31, Z+3	; 0x03
    2b8a:	e0 2d       	mov	r30, r0
    2b8c:	11 96       	adiw	r26, 0x01	; 1
    2b8e:	ed 93       	st	X+, r30
    2b90:	fc 93       	st	X, r31
    2b92:	12 97       	sbiw	r26, 0x02	; 2
    2b94:	2a 56       	subi	r18, 0x6A	; 106
    2b96:	3d 4d       	sbci	r19, 0xDD	; 221
    2b98:	e2 17       	cp	r30, r18
    2b9a:	f3 07       	cpc	r31, r19
    2b9c:	29 f4       	brne	.+10     	; 0x2ba8 <vTaskSwitchContext+0xae>
    2b9e:	22 81       	ldd	r18, Z+2	; 0x02
    2ba0:	33 81       	ldd	r19, Z+3	; 0x03
    2ba2:	fd 01       	movw	r30, r26
    2ba4:	21 83       	std	Z+1, r18	; 0x01
    2ba6:	32 83       	std	Z+2, r19	; 0x02
    2ba8:	fc 01       	movw	r30, r24
    2baa:	ee 0f       	add	r30, r30
    2bac:	ff 1f       	adc	r31, r31
    2bae:	ee 0f       	add	r30, r30
    2bb0:	ff 1f       	adc	r31, r31
    2bb2:	ee 0f       	add	r30, r30
    2bb4:	ff 1f       	adc	r31, r31
    2bb6:	8e 0f       	add	r24, r30
    2bb8:	9f 1f       	adc	r25, r31
    2bba:	fc 01       	movw	r30, r24
    2bbc:	ed 56       	subi	r30, 0x6D	; 109
    2bbe:	fd 4d       	sbci	r31, 0xDD	; 221
    2bc0:	01 80       	ldd	r0, Z+1	; 0x01
    2bc2:	f2 81       	ldd	r31, Z+2	; 0x02
    2bc4:	e0 2d       	mov	r30, r0
    2bc6:	86 81       	ldd	r24, Z+6	; 0x06
    2bc8:	97 81       	ldd	r25, Z+7	; 0x07
    2bca:	80 93 c0 22 	sts	0x22C0, r24	; 0x8022c0 <pxCurrentTCB>
    2bce:	90 93 c1 22 	sts	0x22C1, r25	; 0x8022c1 <pxCurrentTCB+0x1>
    2bd2:	08 95       	ret

00002bd4 <vTaskPlaceOnEventList>:
    2bd4:	cf 93       	push	r28
    2bd6:	df 93       	push	r29
    2bd8:	eb 01       	movw	r28, r22
    2bda:	20 91 c0 22 	lds	r18, 0x22C0	; 0x8022c0 <pxCurrentTCB>
    2bde:	30 91 c1 22 	lds	r19, 0x22C1	; 0x8022c1 <pxCurrentTCB+0x1>
    2be2:	b9 01       	movw	r22, r18
    2be4:	64 5f       	subi	r22, 0xF4	; 244
    2be6:	7f 4f       	sbci	r23, 0xFF	; 255
    2be8:	38 d8       	rcall	.-3984   	; 0x1c5a <vListInsert>
    2bea:	80 91 c0 22 	lds	r24, 0x22C0	; 0x8022c0 <pxCurrentTCB>
    2bee:	90 91 c1 22 	lds	r25, 0x22C1	; 0x8022c1 <pxCurrentTCB+0x1>
    2bf2:	02 96       	adiw	r24, 0x02	; 2
    2bf4:	63 d8       	rcall	.-3898   	; 0x1cbc <uxListRemove>
    2bf6:	80 91 71 22 	lds	r24, 0x2271	; 0x802271 <xTickCount>
    2bfa:	90 91 72 22 	lds	r25, 0x2272	; 0x802272 <xTickCount+0x1>
    2bfe:	8c 0f       	add	r24, r28
    2c00:	9d 1f       	adc	r25, r29
    2c02:	97 dc       	rcall	.-1746   	; 0x2532 <prvAddCurrentTaskToDelayedList>
    2c04:	df 91       	pop	r29
    2c06:	cf 91       	pop	r28
    2c08:	08 95       	ret

00002c0a <vTaskPlaceOnEventListRestricted>:
    2c0a:	cf 93       	push	r28
    2c0c:	df 93       	push	r29
    2c0e:	eb 01       	movw	r28, r22
    2c10:	20 91 c0 22 	lds	r18, 0x22C0	; 0x8022c0 <pxCurrentTCB>
    2c14:	30 91 c1 22 	lds	r19, 0x22C1	; 0x8022c1 <pxCurrentTCB+0x1>
    2c18:	b9 01       	movw	r22, r18
    2c1a:	64 5f       	subi	r22, 0xF4	; 244
    2c1c:	7f 4f       	sbci	r23, 0xFF	; 255
    2c1e:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <vListInsertEnd>
    2c22:	80 91 c0 22 	lds	r24, 0x22C0	; 0x8022c0 <pxCurrentTCB>
    2c26:	90 91 c1 22 	lds	r25, 0x22C1	; 0x8022c1 <pxCurrentTCB+0x1>
    2c2a:	02 96       	adiw	r24, 0x02	; 2
    2c2c:	47 d8       	rcall	.-3954   	; 0x1cbc <uxListRemove>
    2c2e:	80 91 71 22 	lds	r24, 0x2271	; 0x802271 <xTickCount>
    2c32:	90 91 72 22 	lds	r25, 0x2272	; 0x802272 <xTickCount+0x1>
    2c36:	8c 0f       	add	r24, r28
    2c38:	9d 1f       	adc	r25, r29
    2c3a:	7b dc       	rcall	.-1802   	; 0x2532 <prvAddCurrentTaskToDelayedList>
    2c3c:	df 91       	pop	r29
    2c3e:	cf 91       	pop	r28
    2c40:	08 95       	ret

00002c42 <xTaskRemoveFromEventList>:
    2c42:	0f 93       	push	r16
    2c44:	1f 93       	push	r17
    2c46:	cf 93       	push	r28
    2c48:	df 93       	push	r29
    2c4a:	dc 01       	movw	r26, r24
    2c4c:	15 96       	adiw	r26, 0x05	; 5
    2c4e:	ed 91       	ld	r30, X+
    2c50:	fc 91       	ld	r31, X
    2c52:	16 97       	sbiw	r26, 0x06	; 6
    2c54:	c6 81       	ldd	r28, Z+6	; 0x06
    2c56:	d7 81       	ldd	r29, Z+7	; 0x07
    2c58:	8e 01       	movw	r16, r28
    2c5a:	04 5f       	subi	r16, 0xF4	; 244
    2c5c:	1f 4f       	sbci	r17, 0xFF	; 255
    2c5e:	c8 01       	movw	r24, r16
    2c60:	2d d8       	rcall	.-4006   	; 0x1cbc <uxListRemove>
    2c62:	80 91 68 22 	lds	r24, 0x2268	; 0x802268 <uxSchedulerSuspended>
    2c66:	81 11       	cpse	r24, r1
    2c68:	1b c0       	rjmp	.+54     	; 0x2ca0 <xTaskRemoveFromEventList+0x5e>
    2c6a:	0a 50       	subi	r16, 0x0A	; 10
    2c6c:	11 09       	sbc	r17, r1
    2c6e:	c8 01       	movw	r24, r16
    2c70:	25 d8       	rcall	.-4022   	; 0x1cbc <uxListRemove>
    2c72:	2e 89       	ldd	r18, Y+22	; 0x16
    2c74:	80 91 70 22 	lds	r24, 0x2270	; 0x802270 <uxTopReadyPriority>
    2c78:	82 17       	cp	r24, r18
    2c7a:	10 f4       	brcc	.+4      	; 0x2c80 <xTaskRemoveFromEventList+0x3e>
    2c7c:	20 93 70 22 	sts	0x2270, r18	; 0x802270 <uxTopReadyPriority>
    2c80:	30 e0       	ldi	r19, 0x00	; 0
    2c82:	c9 01       	movw	r24, r18
    2c84:	88 0f       	add	r24, r24
    2c86:	99 1f       	adc	r25, r25
    2c88:	88 0f       	add	r24, r24
    2c8a:	99 1f       	adc	r25, r25
    2c8c:	88 0f       	add	r24, r24
    2c8e:	99 1f       	adc	r25, r25
    2c90:	82 0f       	add	r24, r18
    2c92:	93 1f       	adc	r25, r19
    2c94:	b8 01       	movw	r22, r16
    2c96:	8d 56       	subi	r24, 0x6D	; 109
    2c98:	9d 4d       	sbci	r25, 0xDD	; 221
    2c9a:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <vListInsertEnd>
    2c9e:	05 c0       	rjmp	.+10     	; 0x2caa <xTaskRemoveFromEventList+0x68>
    2ca0:	b8 01       	movw	r22, r16
    2ca2:	84 e7       	ldi	r24, 0x74	; 116
    2ca4:	92 e2       	ldi	r25, 0x22	; 34
    2ca6:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <vListInsertEnd>
    2caa:	e0 91 c0 22 	lds	r30, 0x22C0	; 0x8022c0 <pxCurrentTCB>
    2cae:	f0 91 c1 22 	lds	r31, 0x22C1	; 0x8022c1 <pxCurrentTCB+0x1>
    2cb2:	9e 89       	ldd	r25, Y+22	; 0x16
    2cb4:	86 89       	ldd	r24, Z+22	; 0x16
    2cb6:	89 17       	cp	r24, r25
    2cb8:	20 f4       	brcc	.+8      	; 0x2cc2 <xTaskRemoveFromEventList+0x80>
    2cba:	81 e0       	ldi	r24, 0x01	; 1
    2cbc:	80 93 6d 22 	sts	0x226D, r24	; 0x80226d <xYieldPending>
    2cc0:	01 c0       	rjmp	.+2      	; 0x2cc4 <xTaskRemoveFromEventList+0x82>
    2cc2:	80 e0       	ldi	r24, 0x00	; 0
    2cc4:	df 91       	pop	r29
    2cc6:	cf 91       	pop	r28
    2cc8:	1f 91       	pop	r17
    2cca:	0f 91       	pop	r16
    2ccc:	08 95       	ret

00002cce <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2cce:	20 91 6c 22 	lds	r18, 0x226C	; 0x80226c <xNumOfOverflows>
    2cd2:	fc 01       	movw	r30, r24
    2cd4:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2cd6:	20 91 71 22 	lds	r18, 0x2271	; 0x802271 <xTickCount>
    2cda:	30 91 72 22 	lds	r19, 0x2272	; 0x802272 <xTickCount+0x1>
    2cde:	21 83       	std	Z+1, r18	; 0x01
    2ce0:	32 83       	std	Z+2, r19	; 0x02
    2ce2:	08 95       	ret

00002ce4 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    2ce4:	cf 93       	push	r28
    2ce6:	df 93       	push	r29
    2ce8:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2cea:	0f b6       	in	r0, 0x3f	; 63
    2cec:	f8 94       	cli
    2cee:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    2cf0:	20 91 71 22 	lds	r18, 0x2271	; 0x802271 <xTickCount>
    2cf4:	30 91 72 22 	lds	r19, 0x2272	; 0x802272 <xTickCount+0x1>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    2cf8:	80 91 6c 22 	lds	r24, 0x226C	; 0x80226c <xNumOfOverflows>
    2cfc:	90 81       	ld	r25, Z
    2cfe:	98 17       	cp	r25, r24
    2d00:	29 f0       	breq	.+10     	; 0x2d0c <xTaskCheckForTimeOut+0x28>
    2d02:	81 81       	ldd	r24, Z+1	; 0x01
    2d04:	92 81       	ldd	r25, Z+2	; 0x02
    2d06:	28 17       	cp	r18, r24
    2d08:	39 07       	cpc	r19, r25
    2d0a:	a8 f4       	brcc	.+42     	; 0x2d36 <xTaskCheckForTimeOut+0x52>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    2d0c:	a1 81       	ldd	r26, Z+1	; 0x01
    2d0e:	b2 81       	ldd	r27, Z+2	; 0x02
    2d10:	eb 01       	movw	r28, r22
    2d12:	48 81       	ld	r20, Y
    2d14:	59 81       	ldd	r21, Y+1	; 0x01
    2d16:	c9 01       	movw	r24, r18
    2d18:	8a 1b       	sub	r24, r26
    2d1a:	9b 0b       	sbc	r25, r27
    2d1c:	84 17       	cp	r24, r20
    2d1e:	95 07       	cpc	r25, r21
    2d20:	60 f4       	brcc	.+24     	; 0x2d3a <xTaskCheckForTimeOut+0x56>
    2d22:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    2d24:	a2 1b       	sub	r26, r18
    2d26:	b3 0b       	sbc	r27, r19
    2d28:	4a 0f       	add	r20, r26
    2d2a:	5b 1f       	adc	r21, r27
    2d2c:	48 83       	st	Y, r20
    2d2e:	59 83       	std	Y+1, r21	; 0x01
			vTaskSetTimeOutState( pxTimeOut );
    2d30:	ce df       	rcall	.-100    	; 0x2cce <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2d32:	80 e0       	ldi	r24, 0x00	; 0
    2d34:	03 c0       	rjmp	.+6      	; 0x2d3c <xTaskCheckForTimeOut+0x58>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2d36:	81 e0       	ldi	r24, 0x01	; 1
    2d38:	01 c0       	rjmp	.+2      	; 0x2d3c <xTaskCheckForTimeOut+0x58>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2d3a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2d3c:	0f 90       	pop	r0
    2d3e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2d40:	df 91       	pop	r29
    2d42:	cf 91       	pop	r28
    2d44:	08 95       	ret

00002d46 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    2d46:	81 e0       	ldi	r24, 0x01	; 1
    2d48:	80 93 6d 22 	sts	0x226D, r24	; 0x80226d <xYieldPending>
    2d4c:	08 95       	ret

00002d4e <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    2d4e:	80 91 6f 22 	lds	r24, 0x226F	; 0x80226f <xSchedulerRunning>
    2d52:	88 23       	and	r24, r24
    2d54:	31 f0       	breq	.+12     	; 0x2d62 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2d56:	80 91 68 22 	lds	r24, 0x2268	; 0x802268 <uxSchedulerSuspended>
    2d5a:	88 23       	and	r24, r24
    2d5c:	21 f0       	breq	.+8      	; 0x2d66 <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    2d5e:	80 e0       	ldi	r24, 0x00	; 0
    2d60:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    2d62:	81 e0       	ldi	r24, 0x01	; 1
    2d64:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    2d66:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    2d68:	08 95       	ret

00002d6a <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    2d6a:	fc 01       	movw	r30, r24
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    2d6c:	62 83       	std	Z+2, r22	; 0x02
    2d6e:	73 83       	std	Z+3, r23	; 0x03
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2d70:	80 87       	std	Z+8, r24	; 0x08
    2d72:	91 87       	std	Z+9, r25	; 0x09

	if( xNextExpiryTime <= xTimeNow )
    2d74:	46 17       	cp	r20, r22
    2d76:	57 07       	cpc	r21, r23
    2d78:	90 f0       	brcs	.+36     	; 0x2d9e <prvInsertTimerInActiveList+0x34>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
    2d7a:	42 1b       	sub	r20, r18
    2d7c:	53 0b       	sbc	r21, r19
    2d7e:	84 85       	ldd	r24, Z+12	; 0x0c
    2d80:	95 85       	ldd	r25, Z+13	; 0x0d
    2d82:	48 17       	cp	r20, r24
    2d84:	59 07       	cpc	r21, r25
    2d86:	e0 f4       	brcc	.+56     	; 0x2dc0 <prvInsertTimerInActiveList+0x56>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    2d88:	bf 01       	movw	r22, r30
    2d8a:	6e 5f       	subi	r22, 0xFE	; 254
    2d8c:	7f 4f       	sbci	r23, 0xFF	; 255
    2d8e:	80 91 c6 22 	lds	r24, 0x22C6	; 0x8022c6 <pxOverflowTimerList>
    2d92:	90 91 c7 22 	lds	r25, 0x22C7	; 0x8022c7 <pxOverflowTimerList+0x1>
    2d96:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    2d9a:	80 e0       	ldi	r24, 0x00	; 0
    2d9c:	08 95       	ret
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    2d9e:	42 17       	cp	r20, r18
    2da0:	53 07       	cpc	r21, r19
    2da2:	18 f4       	brcc	.+6      	; 0x2daa <prvInsertTimerInActiveList+0x40>
    2da4:	62 17       	cp	r22, r18
    2da6:	73 07       	cpc	r23, r19
    2da8:	68 f4       	brcc	.+26     	; 0x2dc4 <prvInsertTimerInActiveList+0x5a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2daa:	bf 01       	movw	r22, r30
    2dac:	6e 5f       	subi	r22, 0xFE	; 254
    2dae:	7f 4f       	sbci	r23, 0xFF	; 255
    2db0:	80 91 c8 22 	lds	r24, 0x22C8	; 0x8022c8 <pxCurrentTimerList>
    2db4:	90 91 c9 22 	lds	r25, 0x22C9	; 0x8022c9 <pxCurrentTimerList+0x1>
    2db8:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    2dbc:	80 e0       	ldi	r24, 0x00	; 0
    2dbe:	08 95       	ret
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    2dc0:	81 e0       	ldi	r24, 0x01	; 1
    2dc2:	08 95       	ret
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    2dc4:	81 e0       	ldi	r24, 0x01	; 1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
    2dc6:	08 95       	ret

00002dc8 <prvCheckForValidListAndQueue>:
static void prvCheckForValidListAndQueue( void )
{
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    2dc8:	0f b6       	in	r0, 0x3f	; 63
    2dca:	f8 94       	cli
    2dcc:	0f 92       	push	r0
	{
		if( xTimerQueue == NULL )
    2dce:	80 91 c4 22 	lds	r24, 0x22C4	; 0x8022c4 <xTimerQueue>
    2dd2:	90 91 c5 22 	lds	r25, 0x22C5	; 0x8022c5 <xTimerQueue+0x1>
    2dd6:	89 2b       	or	r24, r25
    2dd8:	e1 f4       	brne	.+56     	; 0x2e12 <prvCheckForValidListAndQueue+0x4a>
		{
			vListInitialise( &xActiveTimerList1 );
    2dda:	83 ed       	ldi	r24, 0xD3	; 211
    2ddc:	92 e2       	ldi	r25, 0x22	; 34
    2dde:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
    2de2:	8a ec       	ldi	r24, 0xCA	; 202
    2de4:	92 e2       	ldi	r25, 0x22	; 34
    2de6:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
    2dea:	83 ed       	ldi	r24, 0xD3	; 211
    2dec:	92 e2       	ldi	r25, 0x22	; 34
    2dee:	80 93 c8 22 	sts	0x22C8, r24	; 0x8022c8 <pxCurrentTimerList>
    2df2:	90 93 c9 22 	sts	0x22C9, r25	; 0x8022c9 <pxCurrentTimerList+0x1>
			pxOverflowTimerList = &xActiveTimerList2;
    2df6:	8a ec       	ldi	r24, 0xCA	; 202
    2df8:	92 e2       	ldi	r25, 0x22	; 34
    2dfa:	80 93 c6 22 	sts	0x22C6, r24	; 0x8022c6 <pxOverflowTimerList>
    2dfe:	90 93 c7 22 	sts	0x22C7, r25	; 0x8022c7 <pxOverflowTimerList+0x1>
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    2e02:	40 e0       	ldi	r20, 0x00	; 0
    2e04:	65 e0       	ldi	r22, 0x05	; 5
    2e06:	8a e0       	ldi	r24, 0x0A	; 10
    2e08:	ef d9       	rcall	.-3106   	; 0x21e8 <xQueueGenericCreate>
    2e0a:	80 93 c4 22 	sts	0x22C4, r24	; 0x8022c4 <xTimerQueue>
    2e0e:	90 93 c5 22 	sts	0x22C5, r25	; 0x8022c5 <xTimerQueue+0x1>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    2e12:	0f 90       	pop	r0
    2e14:	0f be       	out	0x3f, r0	; 63
    2e16:	08 95       	ret

00002e18 <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
    2e18:	af 92       	push	r10
    2e1a:	bf 92       	push	r11
    2e1c:	cf 92       	push	r12
    2e1e:	df 92       	push	r13
    2e20:	ef 92       	push	r14
    2e22:	ff 92       	push	r15
    2e24:	0f 93       	push	r16

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
    2e26:	d0 df       	rcall	.-96     	; 0x2dc8 <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
    2e28:	80 91 c4 22 	lds	r24, 0x22C4	; 0x8022c4 <xTimerQueue>
    2e2c:	90 91 c5 22 	lds	r25, 0x22C5	; 0x8022c5 <xTimerQueue+0x1>
    2e30:	89 2b       	or	r24, r25
    2e32:	89 f0       	breq	.+34     	; 0x2e56 <xTimerCreateTimerTask+0x3e>
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
    2e34:	a1 2c       	mov	r10, r1
    2e36:	b1 2c       	mov	r11, r1
    2e38:	c1 2c       	mov	r12, r1
    2e3a:	d1 2c       	mov	r13, r1
    2e3c:	e1 2c       	mov	r14, r1
    2e3e:	f1 2c       	mov	r15, r1
    2e40:	03 e0       	ldi	r16, 0x03	; 3
    2e42:	20 e0       	ldi	r18, 0x00	; 0
    2e44:	30 e0       	ldi	r19, 0x00	; 0
    2e46:	45 e5       	ldi	r20, 0x55	; 85
    2e48:	50 e0       	ldi	r21, 0x00	; 0
    2e4a:	69 e1       	ldi	r22, 0x19	; 25
    2e4c:	70 e2       	ldi	r23, 0x20	; 32
    2e4e:	8a e1       	ldi	r24, 0x1A	; 26
    2e50:	98 e1       	ldi	r25, 0x18	; 24
    2e52:	a4 db       	rcall	.-2232   	; 0x259c <xTaskGenericCreate>
    2e54:	01 c0       	rjmp	.+2      	; 0x2e58 <xTimerCreateTimerTask+0x40>

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
BaseType_t xReturn = pdFAIL;
    2e56:	80 e0       	ldi	r24, 0x00	; 0
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
	return xReturn;
}
    2e58:	0f 91       	pop	r16
    2e5a:	ff 90       	pop	r15
    2e5c:	ef 90       	pop	r14
    2e5e:	df 90       	pop	r13
    2e60:	cf 90       	pop	r12
    2e62:	bf 90       	pop	r11
    2e64:	af 90       	pop	r10
    2e66:	08 95       	ret

00002e68 <xTimerCreate>:
/*-----------------------------------------------------------*/

TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    2e68:	8f 92       	push	r8
    2e6a:	9f 92       	push	r9
    2e6c:	bf 92       	push	r11
    2e6e:	cf 92       	push	r12
    2e70:	df 92       	push	r13
    2e72:	ef 92       	push	r14
    2e74:	ff 92       	push	r15
    2e76:	0f 93       	push	r16
    2e78:	1f 93       	push	r17
    2e7a:	cf 93       	push	r28
    2e7c:	df 93       	push	r29
Timer_t *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
    2e7e:	61 15       	cp	r22, r1
    2e80:	71 05       	cpc	r23, r1
    2e82:	c9 f0       	breq	.+50     	; 0x2eb6 <xTimerCreate+0x4e>
    2e84:	69 01       	movw	r12, r18
    2e86:	b4 2e       	mov	r11, r20
    2e88:	7b 01       	movw	r14, r22
    2e8a:	4c 01       	movw	r8, r24
	{
		pxNewTimer = NULL;
	}
	else
	{
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
    2e8c:	83 e1       	ldi	r24, 0x13	; 19
    2e8e:	90 e0       	ldi	r25, 0x00	; 0
    2e90:	a9 d8       	rcall	.-3758   	; 0x1fe4 <pvPortMalloc>
    2e92:	ec 01       	movw	r28, r24
		if( pxNewTimer != NULL )
    2e94:	89 2b       	or	r24, r25
    2e96:	89 f0       	breq	.+34     	; 0x2eba <xTimerCreate+0x52>
		{
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();
    2e98:	97 df       	rcall	.-210    	; 0x2dc8 <prvCheckForValidListAndQueue>

			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
    2e9a:	88 82       	st	Y, r8
    2e9c:	99 82       	std	Y+1, r9	; 0x01
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    2e9e:	ec 86       	std	Y+12, r14	; 0x0c
    2ea0:	fd 86       	std	Y+13, r15	; 0x0d
			pxNewTimer->uxAutoReload = uxAutoReload;
    2ea2:	be 86       	std	Y+14, r11	; 0x0e
			pxNewTimer->pvTimerID = pvTimerID;
    2ea4:	cf 86       	std	Y+15, r12	; 0x0f
    2ea6:	d8 8a       	std	Y+16, r13	; 0x10
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    2ea8:	09 8b       	std	Y+17, r16	; 0x11
    2eaa:	1a 8b       	std	Y+18, r17	; 0x12
			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    2eac:	ce 01       	movw	r24, r28
    2eae:	02 96       	adiw	r24, 0x02	; 2
    2eb0:	0e 94 08 0e 	call	0x1c10	; 0x1c10 <vListInitialiseItem>
    2eb4:	02 c0       	rjmp	.+4      	; 0x2eba <xTimerCreate+0x52>
Timer_t *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
	{
		pxNewTimer = NULL;
    2eb6:	c0 e0       	ldi	r28, 0x00	; 0
    2eb8:	d0 e0       	ldi	r29, 0x00	; 0

	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	return ( TimerHandle_t ) pxNewTimer;
}
    2eba:	ce 01       	movw	r24, r28
    2ebc:	df 91       	pop	r29
    2ebe:	cf 91       	pop	r28
    2ec0:	1f 91       	pop	r17
    2ec2:	0f 91       	pop	r16
    2ec4:	ff 90       	pop	r15
    2ec6:	ef 90       	pop	r14
    2ec8:	df 90       	pop	r13
    2eca:	cf 90       	pop	r12
    2ecc:	bf 90       	pop	r11
    2ece:	9f 90       	pop	r9
    2ed0:	8f 90       	pop	r8
    2ed2:	08 95       	ret

00002ed4 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    2ed4:	0f 93       	push	r16
    2ed6:	1f 93       	push	r17
    2ed8:	cf 93       	push	r28
    2eda:	df 93       	push	r29
    2edc:	cd b7       	in	r28, 0x3d	; 61
    2ede:	de b7       	in	r29, 0x3e	; 62
    2ee0:	25 97       	sbiw	r28, 0x05	; 5
    2ee2:	cd bf       	out	0x3d, r28	; 61
    2ee4:	de bf       	out	0x3e, r29	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    2ee6:	e0 91 c4 22 	lds	r30, 0x22C4	; 0x8022c4 <xTimerQueue>
    2eea:	f0 91 c5 22 	lds	r31, 0x22C5	; 0x8022c5 <xTimerQueue+0x1>
    2eee:	30 97       	sbiw	r30, 0x00	; 0
    2ef0:	51 f1       	breq	.+84     	; 0x2f46 <xTimerGenericCommand+0x72>
    2ef2:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    2ef4:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    2ef6:	4a 83       	std	Y+2, r20	; 0x02
    2ef8:	5b 83       	std	Y+3, r21	; 0x03
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    2efa:	8c 83       	std	Y+4, r24	; 0x04
    2efc:	9d 83       	std	Y+5, r25	; 0x05

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    2efe:	66 30       	cpi	r22, 0x06	; 6
    2f00:	d4 f4       	brge	.+52     	; 0x2f36 <xTimerGenericCommand+0x62>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    2f02:	25 df       	rcall	.-438    	; 0x2d4e <xTaskGetSchedulerState>
    2f04:	82 30       	cpi	r24, 0x02	; 2
    2f06:	59 f4       	brne	.+22     	; 0x2f1e <xTimerGenericCommand+0x4a>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    2f08:	20 e0       	ldi	r18, 0x00	; 0
    2f0a:	a8 01       	movw	r20, r16
    2f0c:	be 01       	movw	r22, r28
    2f0e:	6f 5f       	subi	r22, 0xFF	; 255
    2f10:	7f 4f       	sbci	r23, 0xFF	; 255
    2f12:	80 91 c4 22 	lds	r24, 0x22C4	; 0x8022c4 <xTimerQueue>
    2f16:	90 91 c5 22 	lds	r25, 0x22C5	; 0x8022c5 <xTimerQueue+0x1>
    2f1a:	8f d9       	rcall	.-3298   	; 0x223a <xQueueGenericSend>
    2f1c:	15 c0       	rjmp	.+42     	; 0x2f48 <xTimerGenericCommand+0x74>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    2f1e:	20 e0       	ldi	r18, 0x00	; 0
    2f20:	40 e0       	ldi	r20, 0x00	; 0
    2f22:	50 e0       	ldi	r21, 0x00	; 0
    2f24:	be 01       	movw	r22, r28
    2f26:	6f 5f       	subi	r22, 0xFF	; 255
    2f28:	7f 4f       	sbci	r23, 0xFF	; 255
    2f2a:	80 91 c4 22 	lds	r24, 0x22C4	; 0x8022c4 <xTimerQueue>
    2f2e:	90 91 c5 22 	lds	r25, 0x22C5	; 0x8022c5 <xTimerQueue+0x1>
    2f32:	83 d9       	rcall	.-3322   	; 0x223a <xQueueGenericSend>
    2f34:	09 c0       	rjmp	.+18     	; 0x2f48 <xTimerGenericCommand+0x74>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    2f36:	20 e0       	ldi	r18, 0x00	; 0
    2f38:	ad 01       	movw	r20, r26
    2f3a:	be 01       	movw	r22, r28
    2f3c:	6f 5f       	subi	r22, 0xFF	; 255
    2f3e:	7f 4f       	sbci	r23, 0xFF	; 255
    2f40:	cf 01       	movw	r24, r30
    2f42:	08 da       	rcall	.-3056   	; 0x2354 <xQueueGenericSendFromISR>
    2f44:	01 c0       	rjmp	.+2      	; 0x2f48 <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    2f46:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    2f48:	25 96       	adiw	r28, 0x05	; 5
    2f4a:	cd bf       	out	0x3d, r28	; 61
    2f4c:	de bf       	out	0x3e, r29	; 62
    2f4e:	df 91       	pop	r29
    2f50:	cf 91       	pop	r28
    2f52:	1f 91       	pop	r17
    2f54:	0f 91       	pop	r16
    2f56:	08 95       	ret

00002f58 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    2f58:	af 92       	push	r10
    2f5a:	bf 92       	push	r11
    2f5c:	cf 92       	push	r12
    2f5e:	df 92       	push	r13
    2f60:	ef 92       	push	r14
    2f62:	ff 92       	push	r15
    2f64:	0f 93       	push	r16
    2f66:	1f 93       	push	r17
    2f68:	cf 93       	push	r28
    2f6a:	df 93       	push	r29
    2f6c:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    2f6e:	50 dc       	rcall	.-1888   	; 0x2810 <xTaskGetTickCount>
    2f70:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    2f72:	80 91 c2 22 	lds	r24, 0x22C2	; 0x8022c2 <xLastTime.4281>
    2f76:	90 91 c3 22 	lds	r25, 0x22C3	; 0x8022c3 <xLastTime.4281+0x1>
    2f7a:	e8 16       	cp	r14, r24
    2f7c:	f9 06       	cpc	r15, r25
    2f7e:	08 f0       	brcs	.+2      	; 0x2f82 <prvSampleTimeNow+0x2a>
    2f80:	47 c0       	rjmp	.+142    	; 0x3010 <prvSampleTimeNow+0xb8>
    2f82:	2f c0       	rjmp	.+94     	; 0x2fe2 <prvSampleTimeNow+0x8a>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2f84:	05 80       	ldd	r0, Z+5	; 0x05
    2f86:	f6 81       	ldd	r31, Z+6	; 0x06
    2f88:	e0 2d       	mov	r30, r0
    2f8a:	a0 80       	ld	r10, Z
    2f8c:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    2f8e:	c6 81       	ldd	r28, Z+6	; 0x06
    2f90:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2f92:	8e 01       	movw	r16, r28
    2f94:	0e 5f       	subi	r16, 0xFE	; 254
    2f96:	1f 4f       	sbci	r17, 0xFF	; 255
    2f98:	c8 01       	movw	r24, r16
    2f9a:	0e 94 5e 0e 	call	0x1cbc	; 0x1cbc <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2f9e:	e9 89       	ldd	r30, Y+17	; 0x11
    2fa0:	fa 89       	ldd	r31, Y+18	; 0x12
    2fa2:	ce 01       	movw	r24, r28
    2fa4:	19 95       	eicall

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2fa6:	8e 85       	ldd	r24, Y+14	; 0x0e
    2fa8:	81 30       	cpi	r24, 0x01	; 1
    2faa:	d9 f4       	brne	.+54     	; 0x2fe2 <prvSampleTimeNow+0x8a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    2fac:	8c 85       	ldd	r24, Y+12	; 0x0c
    2fae:	9d 85       	ldd	r25, Y+13	; 0x0d
    2fb0:	8a 0d       	add	r24, r10
    2fb2:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    2fb4:	a8 16       	cp	r10, r24
    2fb6:	b9 06       	cpc	r11, r25
    2fb8:	60 f4       	brcc	.+24     	; 0x2fd2 <prvSampleTimeNow+0x7a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    2fba:	8a 83       	std	Y+2, r24	; 0x02
    2fbc:	9b 83       	std	Y+3, r25	; 0x03
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2fbe:	c8 87       	std	Y+8, r28	; 0x08
    2fc0:	d9 87       	std	Y+9, r29	; 0x09
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2fc2:	b8 01       	movw	r22, r16
    2fc4:	80 91 c8 22 	lds	r24, 0x22C8	; 0x8022c8 <pxCurrentTimerList>
    2fc8:	90 91 c9 22 	lds	r25, 0x22C9	; 0x8022c9 <pxCurrentTimerList+0x1>
    2fcc:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <vListInsert>
    2fd0:	08 c0       	rjmp	.+16     	; 0x2fe2 <prvSampleTimeNow+0x8a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2fd2:	00 e0       	ldi	r16, 0x00	; 0
    2fd4:	10 e0       	ldi	r17, 0x00	; 0
    2fd6:	20 e0       	ldi	r18, 0x00	; 0
    2fd8:	30 e0       	ldi	r19, 0x00	; 0
    2fda:	a5 01       	movw	r20, r10
    2fdc:	60 e0       	ldi	r22, 0x00	; 0
    2fde:	ce 01       	movw	r24, r28
    2fe0:	79 df       	rcall	.-270    	; 0x2ed4 <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2fe2:	e0 91 c8 22 	lds	r30, 0x22C8	; 0x8022c8 <pxCurrentTimerList>
    2fe6:	f0 91 c9 22 	lds	r31, 0x22C9	; 0x8022c9 <pxCurrentTimerList+0x1>
    2fea:	90 81       	ld	r25, Z
    2fec:	91 11       	cpse	r25, r1
    2fee:	ca cf       	rjmp	.-108    	; 0x2f84 <prvSampleTimeNow+0x2c>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    2ff0:	80 91 c6 22 	lds	r24, 0x22C6	; 0x8022c6 <pxOverflowTimerList>
    2ff4:	90 91 c7 22 	lds	r25, 0x22C7	; 0x8022c7 <pxOverflowTimerList+0x1>
    2ff8:	80 93 c8 22 	sts	0x22C8, r24	; 0x8022c8 <pxCurrentTimerList>
    2ffc:	90 93 c9 22 	sts	0x22C9, r25	; 0x8022c9 <pxCurrentTimerList+0x1>
	pxOverflowTimerList = pxTemp;
    3000:	e0 93 c6 22 	sts	0x22C6, r30	; 0x8022c6 <pxOverflowTimerList>
    3004:	f0 93 c7 22 	sts	0x22C7, r31	; 0x8022c7 <pxOverflowTimerList+0x1>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    3008:	81 e0       	ldi	r24, 0x01	; 1
    300a:	f6 01       	movw	r30, r12
    300c:	80 83       	st	Z, r24
    300e:	02 c0       	rjmp	.+4      	; 0x3014 <prvSampleTimeNow+0xbc>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    3010:	f6 01       	movw	r30, r12
    3012:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    3014:	e0 92 c2 22 	sts	0x22C2, r14	; 0x8022c2 <xLastTime.4281>
    3018:	f0 92 c3 22 	sts	0x22C3, r15	; 0x8022c3 <xLastTime.4281+0x1>

	return xTimeNow;
}
    301c:	c7 01       	movw	r24, r14
    301e:	df 91       	pop	r29
    3020:	cf 91       	pop	r28
    3022:	1f 91       	pop	r17
    3024:	0f 91       	pop	r16
    3026:	ff 90       	pop	r15
    3028:	ef 90       	pop	r14
    302a:	df 90       	pop	r13
    302c:	cf 90       	pop	r12
    302e:	bf 90       	pop	r11
    3030:	af 90       	pop	r10
    3032:	08 95       	ret

00003034 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    3034:	cf 93       	push	r28
    3036:	df 93       	push	r29
    3038:	00 d0       	rcall	.+0      	; 0x303a <prvTimerTask+0x6>
    303a:	00 d0       	rcall	.+0      	; 0x303c <prvTimerTask+0x8>
    303c:	cd b7       	in	r28, 0x3d	; 61
    303e:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3040:	ce 01       	movw	r24, r28
    3042:	01 96       	adiw	r24, 0x01	; 1
    3044:	5c 01       	movw	r10, r24
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    3046:	e8 2e       	mov	r14, r24
    3048:	fb 2c       	mov	r15, r11
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    304a:	e0 91 c8 22 	lds	r30, 0x22C8	; 0x8022c8 <pxCurrentTimerList>
    304e:	f0 91 c9 22 	lds	r31, 0x22C9	; 0x8022c9 <pxCurrentTimerList+0x1>
	if( *pxListWasEmpty == pdFALSE )
    3052:	80 81       	ld	r24, Z
    3054:	88 23       	and	r24, r24
    3056:	69 f0       	breq	.+26     	; 0x3072 <prvTimerTask+0x3e>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    3058:	05 80       	ldd	r0, Z+5	; 0x05
    305a:	f6 81       	ldd	r31, Z+6	; 0x06
    305c:	e0 2d       	mov	r30, r0
    305e:	c0 80       	ld	r12, Z
    3060:	d1 80       	ldd	r13, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    3062:	d0 db       	rcall	.-2144   	; 0x2804 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3064:	c5 01       	movw	r24, r10
    3066:	78 df       	rcall	.-272    	; 0x2f58 <prvSampleTimeNow>
    3068:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    306a:	89 81       	ldd	r24, Y+1	; 0x01
    306c:	88 23       	and	r24, r24
    306e:	49 f0       	breq	.+18     	; 0x3082 <prvTimerTask+0x4e>
    3070:	56 c0       	rjmp	.+172    	; 0x311e <prvTimerTask+0xea>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    3072:	c8 db       	rcall	.-2160   	; 0x2804 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3074:	c5 01       	movw	r24, r10
    3076:	70 df       	rcall	.-288    	; 0x2f58 <prvSampleTimeNow>
    3078:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    307a:	89 81       	ldd	r24, Y+1	; 0x01
    307c:	88 23       	and	r24, r24
    307e:	a9 f1       	breq	.+106    	; 0x30ea <prvTimerTask+0xb6>
    3080:	4e c0       	rjmp	.+156    	; 0x311e <prvTimerTask+0xea>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    3082:	0c 15       	cp	r16, r12
    3084:	1d 05       	cpc	r17, r13
    3086:	08 f4       	brcc	.+2      	; 0x308a <prvTimerTask+0x56>
    3088:	3b c0       	rjmp	.+118    	; 0x3100 <prvTimerTask+0xcc>
			{
				( void ) xTaskResumeAll();
    308a:	9f dc       	rcall	.-1730   	; 0x29ca <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    308c:	e0 91 c8 22 	lds	r30, 0x22C8	; 0x8022c8 <pxCurrentTimerList>
    3090:	f0 91 c9 22 	lds	r31, 0x22C9	; 0x8022c9 <pxCurrentTimerList+0x1>
    3094:	05 80       	ldd	r0, Z+5	; 0x05
    3096:	f6 81       	ldd	r31, Z+6	; 0x06
    3098:	e0 2d       	mov	r30, r0
    309a:	86 80       	ldd	r8, Z+6	; 0x06
    309c:	97 80       	ldd	r9, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    309e:	c4 01       	movw	r24, r8
    30a0:	02 96       	adiw	r24, 0x02	; 2
    30a2:	0e 94 5e 0e 	call	0x1cbc	; 0x1cbc <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    30a6:	d4 01       	movw	r26, r8
    30a8:	1e 96       	adiw	r26, 0x0e	; 14
    30aa:	8c 91       	ld	r24, X
    30ac:	1e 97       	sbiw	r26, 0x0e	; 14
    30ae:	81 30       	cpi	r24, 0x01	; 1
    30b0:	a1 f4       	brne	.+40     	; 0x30da <prvTimerTask+0xa6>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
    30b2:	1c 96       	adiw	r26, 0x0c	; 12
    30b4:	6d 91       	ld	r22, X+
    30b6:	7c 91       	ld	r23, X
    30b8:	1d 97       	sbiw	r26, 0x0d	; 13
    30ba:	6c 0d       	add	r22, r12
    30bc:	7d 1d       	adc	r23, r13
    30be:	96 01       	movw	r18, r12
    30c0:	a8 01       	movw	r20, r16
    30c2:	c4 01       	movw	r24, r8
    30c4:	52 de       	rcall	.-860    	; 0x2d6a <prvInsertTimerInActiveList>
    30c6:	81 30       	cpi	r24, 0x01	; 1
    30c8:	41 f4       	brne	.+16     	; 0x30da <prvTimerTask+0xa6>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    30ca:	00 e0       	ldi	r16, 0x00	; 0
    30cc:	10 e0       	ldi	r17, 0x00	; 0
    30ce:	20 e0       	ldi	r18, 0x00	; 0
    30d0:	30 e0       	ldi	r19, 0x00	; 0
    30d2:	a6 01       	movw	r20, r12
    30d4:	60 e0       	ldi	r22, 0x00	; 0
    30d6:	c4 01       	movw	r24, r8
    30d8:	fd de       	rcall	.-518    	; 0x2ed4 <xTimerGenericCommand>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    30da:	d4 01       	movw	r26, r8
    30dc:	51 96       	adiw	r26, 0x11	; 17
    30de:	ed 91       	ld	r30, X+
    30e0:	fc 91       	ld	r31, X
    30e2:	52 97       	sbiw	r26, 0x12	; 18
    30e4:	c4 01       	movw	r24, r8
    30e6:	19 95       	eicall
    30e8:	75 c0       	rjmp	.+234    	; 0x31d4 <prvTimerTask+0x1a0>
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    30ea:	e0 91 c6 22 	lds	r30, 0x22C6	; 0x8022c6 <pxOverflowTimerList>
    30ee:	f0 91 c7 22 	lds	r31, 0x22C7	; 0x8022c7 <pxOverflowTimerList+0x1>
    30f2:	41 e0       	ldi	r20, 0x01	; 1
    30f4:	80 81       	ld	r24, Z
    30f6:	81 11       	cpse	r24, r1
    30f8:	40 e0       	ldi	r20, 0x00	; 0
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    30fa:	c1 2c       	mov	r12, r1
    30fc:	d1 2c       	mov	r13, r1
    30fe:	01 c0       	rjmp	.+2      	; 0x3102 <prvTimerTask+0xce>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    3100:	40 e0       	ldi	r20, 0x00	; 0
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    3102:	b6 01       	movw	r22, r12
    3104:	60 1b       	sub	r22, r16
    3106:	71 0b       	sbc	r23, r17
    3108:	80 91 c4 22 	lds	r24, 0x22C4	; 0x8022c4 <xTimerQueue>
    310c:	90 91 c5 22 	lds	r25, 0x22C5	; 0x8022c5 <xTimerQueue+0x1>
    3110:	ee d9       	rcall	.-3108   	; 0x24ee <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    3112:	5b dc       	rcall	.-1866   	; 0x29ca <xTaskResumeAll>
    3114:	81 11       	cpse	r24, r1
    3116:	5e c0       	rjmp	.+188    	; 0x31d4 <prvTimerTask+0x1a0>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    3118:	0e 94 40 0f 	call	0x1e80	; 0x1e80 <vPortYield>
    311c:	5b c0       	rjmp	.+182    	; 0x31d4 <prvTimerTask+0x1a0>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    311e:	55 dc       	rcall	.-1878   	; 0x29ca <xTaskResumeAll>
    3120:	59 c0       	rjmp	.+178    	; 0x31d4 <prvTimerTask+0x1a0>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    3122:	99 81       	ldd	r25, Y+1	; 0x01
    3124:	99 23       	and	r25, r25
    3126:	0c f4       	brge	.+2      	; 0x312a <prvTimerTask+0xf6>
    3128:	55 c0       	rjmp	.+170    	; 0x31d4 <prvTimerTask+0x1a0>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    312a:	cc 80       	ldd	r12, Y+4	; 0x04
    312c:	dd 80       	ldd	r13, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    312e:	f6 01       	movw	r30, r12
    3130:	82 85       	ldd	r24, Z+10	; 0x0a
    3132:	93 85       	ldd	r25, Z+11	; 0x0b
    3134:	89 2b       	or	r24, r25
    3136:	21 f0       	breq	.+8      	; 0x3140 <prvTimerTask+0x10c>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3138:	c6 01       	movw	r24, r12
    313a:	02 96       	adiw	r24, 0x02	; 2
    313c:	0e 94 5e 0e 	call	0x1cbc	; 0x1cbc <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3140:	ce 01       	movw	r24, r28
    3142:	06 96       	adiw	r24, 0x06	; 6
    3144:	09 df       	rcall	.-494    	; 0x2f58 <prvSampleTimeNow>
    3146:	ac 01       	movw	r20, r24

			switch( xMessage.xMessageID )
    3148:	09 81       	ldd	r16, Y+1	; 0x01
    314a:	00 2e       	mov	r0, r16
    314c:	00 0c       	add	r0, r0
    314e:	11 0b       	sbc	r17, r17
    3150:	22 0b       	sbc	r18, r18
    3152:	33 0b       	sbc	r19, r19
    3154:	0a 30       	cpi	r16, 0x0A	; 10
    3156:	11 05       	cpc	r17, r1
    3158:	08 f0       	brcs	.+2      	; 0x315c <prvTimerTask+0x128>
    315a:	3c c0       	rjmp	.+120    	; 0x31d4 <prvTimerTask+0x1a0>
    315c:	f8 01       	movw	r30, r16
    315e:	88 27       	eor	r24, r24
    3160:	e2 50       	subi	r30, 0x02	; 2
    3162:	ff 4f       	sbci	r31, 0xFF	; 255
    3164:	8f 4f       	sbci	r24, 0xFF	; 255
    3166:	6f c3       	rjmp	.+1758   	; 0x3846 <__tablejump2__>
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
    3168:	2a 81       	ldd	r18, Y+2	; 0x02
    316a:	3b 81       	ldd	r19, Y+3	; 0x03
    316c:	d6 01       	movw	r26, r12
    316e:	1c 96       	adiw	r26, 0x0c	; 12
    3170:	6d 91       	ld	r22, X+
    3172:	7c 91       	ld	r23, X
    3174:	1d 97       	sbiw	r26, 0x0d	; 13
    3176:	62 0f       	add	r22, r18
    3178:	73 1f       	adc	r23, r19
    317a:	c6 01       	movw	r24, r12
    317c:	f6 dd       	rcall	.-1044   	; 0x2d6a <prvInsertTimerInActiveList>
    317e:	81 30       	cpi	r24, 0x01	; 1
    3180:	49 f5       	brne	.+82     	; 0x31d4 <prvTimerTask+0x1a0>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3182:	d6 01       	movw	r26, r12
    3184:	51 96       	adiw	r26, 0x11	; 17
    3186:	ed 91       	ld	r30, X+
    3188:	fc 91       	ld	r31, X
    318a:	52 97       	sbiw	r26, 0x12	; 18
    318c:	c6 01       	movw	r24, r12
    318e:	19 95       	eicall
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    3190:	f6 01       	movw	r30, r12
    3192:	86 85       	ldd	r24, Z+14	; 0x0e
    3194:	81 30       	cpi	r24, 0x01	; 1
    3196:	f1 f4       	brne	.+60     	; 0x31d4 <prvTimerTask+0x1a0>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    3198:	44 85       	ldd	r20, Z+12	; 0x0c
    319a:	55 85       	ldd	r21, Z+13	; 0x0d
    319c:	8a 81       	ldd	r24, Y+2	; 0x02
    319e:	9b 81       	ldd	r25, Y+3	; 0x03
    31a0:	48 0f       	add	r20, r24
    31a2:	59 1f       	adc	r21, r25
    31a4:	00 e0       	ldi	r16, 0x00	; 0
    31a6:	10 e0       	ldi	r17, 0x00	; 0
    31a8:	20 e0       	ldi	r18, 0x00	; 0
    31aa:	30 e0       	ldi	r19, 0x00	; 0
    31ac:	60 e0       	ldi	r22, 0x00	; 0
    31ae:	c6 01       	movw	r24, r12
    31b0:	91 de       	rcall	.-734    	; 0x2ed4 <xTimerGenericCommand>
    31b2:	10 c0       	rjmp	.+32     	; 0x31d4 <prvTimerTask+0x1a0>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    31b4:	6a 81       	ldd	r22, Y+2	; 0x02
    31b6:	7b 81       	ldd	r23, Y+3	; 0x03
    31b8:	d6 01       	movw	r26, r12
    31ba:	1c 96       	adiw	r26, 0x0c	; 12
    31bc:	6d 93       	st	X+, r22
    31be:	7c 93       	st	X, r23
    31c0:	1d 97       	sbiw	r26, 0x0d	; 13
					longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot be
					zero the next expiry time can only be in the future, meaning
					(unlike for the xTimerStart() case above) there is no fail case
					that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    31c2:	64 0f       	add	r22, r20
    31c4:	75 1f       	adc	r23, r21
    31c6:	9a 01       	movw	r18, r20
    31c8:	c6 01       	movw	r24, r12
    31ca:	cf dd       	rcall	.-1122   	; 0x2d6a <prvInsertTimerInActiveList>
    31cc:	03 c0       	rjmp	.+6      	; 0x31d4 <prvTimerTask+0x1a0>
					break;

				case tmrCOMMAND_DELETE :
					/* The timer has already been removed from the active list,
					just free up the memory. */
					vPortFree( pxTimer );
    31ce:	c6 01       	movw	r24, r12
    31d0:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <vPortFree>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    31d4:	20 e0       	ldi	r18, 0x00	; 0
    31d6:	40 e0       	ldi	r20, 0x00	; 0
    31d8:	50 e0       	ldi	r21, 0x00	; 0
    31da:	6e 2d       	mov	r22, r14
    31dc:	7f 2d       	mov	r23, r15
    31de:	80 91 c4 22 	lds	r24, 0x22C4	; 0x8022c4 <xTimerQueue>
    31e2:	90 91 c5 22 	lds	r25, 0x22C5	; 0x8022c5 <xTimerQueue+0x1>
    31e6:	ec d8       	rcall	.-3624   	; 0x23c0 <xQueueGenericReceive>
    31e8:	81 11       	cpse	r24, r1
    31ea:	9b cf       	rjmp	.-202    	; 0x3122 <prvTimerTask+0xee>
    31ec:	2e cf       	rjmp	.-420    	; 0x304a <prvTimerTask+0x16>

000031ee <ioport_configure_port_pin>:
#include "ioport_compat.h"

#if defined(IOPORT_XMEGA_COMPAT)
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
    31ee:	cf 93       	push	r28
    31f0:	df 93       	push	r29
    31f2:	fc 01       	movw	r30, r24
    31f4:	70 96       	adiw	r30, 0x10	; 16
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    31f6:	20 e0       	ldi	r18, 0x00	; 0
    31f8:	30 e0       	ldi	r19, 0x00	; 0
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
    31fa:	c6 2f       	mov	r28, r22
    31fc:	d0 e0       	ldi	r29, 0x00	; 0
    31fe:	de 01       	movw	r26, r28
    3200:	02 2e       	mov	r0, r18
    3202:	02 c0       	rjmp	.+4      	; 0x3208 <ioport_configure_port_pin+0x1a>
    3204:	b5 95       	asr	r27
    3206:	a7 95       	ror	r26
    3208:	0a 94       	dec	r0
    320a:	e2 f7       	brpl	.-8      	; 0x3204 <ioport_configure_port_pin+0x16>
    320c:	a0 fd       	sbrc	r26, 0
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    320e:	50 83       	st	Z, r21
    3210:	2f 5f       	subi	r18, 0xFF	; 255
    3212:	3f 4f       	sbci	r19, 0xFF	; 255
    3214:	31 96       	adiw	r30, 0x01	; 1
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
    3216:	28 30       	cpi	r18, 0x08	; 8
    3218:	31 05       	cpc	r19, r1
    321a:	89 f7       	brne	.-30     	; 0x31fe <ioport_configure_port_pin+0x10>
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
		}
	}
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
    321c:	40 ff       	sbrs	r20, 0
    321e:	0a c0       	rjmp	.+20     	; 0x3234 <ioport_configure_port_pin+0x46>
		if (flags & IOPORT_INIT_HIGH) {
    3220:	41 ff       	sbrs	r20, 1
    3222:	03 c0       	rjmp	.+6      	; 0x322a <ioport_configure_port_pin+0x3c>
			*((uint8_t *)port + PORT_OUTSET) = pin_mask;
    3224:	fc 01       	movw	r30, r24
    3226:	65 83       	std	Z+5, r22	; 0x05
    3228:	02 c0       	rjmp	.+4      	; 0x322e <ioport_configure_port_pin+0x40>
		} else {
			*((uint8_t *)port + PORT_OUTCLR) = pin_mask;
    322a:	fc 01       	movw	r30, r24
    322c:	66 83       	std	Z+6, r22	; 0x06
		}

		*((uint8_t *)port + PORT_DIRSET) = pin_mask;
    322e:	fc 01       	movw	r30, r24
    3230:	61 83       	std	Z+1, r22	; 0x01
    3232:	02 c0       	rjmp	.+4      	; 0x3238 <ioport_configure_port_pin+0x4a>
	} else {
		*((uint8_t *)port + PORT_DIRCLR) = pin_mask;
    3234:	fc 01       	movw	r30, r24
    3236:	62 83       	std	Z+2, r22	; 0x02
	}
}
    3238:	df 91       	pop	r29
    323a:	cf 91       	pop	r28
    323c:	08 95       	ret

0000323e <board_init>:
 * \param flags Bitmask of flags specifying additional configuration
 * parameters.
 */
static inline void ioport_configure_pin(port_pin_t pin, port_pin_flags_t flags)
{
	ioport_configure_port_pin(arch_ioport_pin_to_base(pin),
    323e:	43 e0       	ldi	r20, 0x03	; 3
    3240:	50 e0       	ldi	r21, 0x00	; 0
    3242:	61 e0       	ldi	r22, 0x01	; 1
    3244:	80 ee       	ldi	r24, 0xE0	; 224
    3246:	97 e0       	ldi	r25, 0x07	; 7
    3248:	d2 df       	rcall	.-92     	; 0x31ee <ioport_configure_port_pin>
    324a:	43 e0       	ldi	r20, 0x03	; 3
    324c:	50 e0       	ldi	r21, 0x00	; 0
    324e:	62 e0       	ldi	r22, 0x02	; 2
    3250:	80 ee       	ldi	r24, 0xE0	; 224
    3252:	97 e0       	ldi	r25, 0x07	; 7
    3254:	cc df       	rcall	.-104    	; 0x31ee <ioport_configure_port_pin>
    3256:	43 e0       	ldi	r20, 0x03	; 3
    3258:	50 e0       	ldi	r21, 0x00	; 0
    325a:	60 e1       	ldi	r22, 0x10	; 16
    325c:	80 e6       	ldi	r24, 0x60	; 96
    325e:	96 e0       	ldi	r25, 0x06	; 6
    3260:	c6 df       	rcall	.-116    	; 0x31ee <ioport_configure_port_pin>
    3262:	41 e0       	ldi	r20, 0x01	; 1
    3264:	50 e4       	ldi	r21, 0x40	; 64
    3266:	60 e2       	ldi	r22, 0x20	; 32
    3268:	80 e6       	ldi	r24, 0x60	; 96
    326a:	96 e0       	ldi	r25, 0x06	; 6
    326c:	c0 df       	rcall	.-128    	; 0x31ee <ioport_configure_port_pin>
    326e:	40 e0       	ldi	r20, 0x00	; 0
    3270:	5b e1       	ldi	r21, 0x1B	; 27
    3272:	60 e2       	ldi	r22, 0x20	; 32
    3274:	80 e8       	ldi	r24, 0x80	; 128
    3276:	96 e0       	ldi	r25, 0x06	; 6
    3278:	ba df       	rcall	.-140    	; 0x31ee <ioport_configure_port_pin>
    327a:	40 e0       	ldi	r20, 0x00	; 0
    327c:	5b e1       	ldi	r21, 0x1B	; 27
    327e:	62 e0       	ldi	r22, 0x02	; 2
    3280:	80 ea       	ldi	r24, 0xA0	; 160
    3282:	96 e0       	ldi	r25, 0x06	; 6
    3284:	b4 df       	rcall	.-152    	; 0x31ee <ioport_configure_port_pin>
    3286:	40 e0       	ldi	r20, 0x00	; 0
    3288:	5b e1       	ldi	r21, 0x1B	; 27
    328a:	64 e0       	ldi	r22, 0x04	; 4
    328c:	80 ea       	ldi	r24, 0xA0	; 160
    328e:	96 e0       	ldi	r25, 0x06	; 6
    3290:	ae df       	rcall	.-164    	; 0x31ee <ioport_configure_port_pin>
    3292:	43 e0       	ldi	r20, 0x03	; 3
    3294:	50 e0       	ldi	r21, 0x00	; 0
    3296:	62 e0       	ldi	r22, 0x02	; 2
    3298:	80 e6       	ldi	r24, 0x60	; 96
    329a:	96 e0       	ldi	r25, 0x06	; 6
    329c:	a8 df       	rcall	.-176    	; 0x31ee <ioport_configure_port_pin>
    329e:	43 e0       	ldi	r20, 0x03	; 3
    32a0:	50 e0       	ldi	r21, 0x00	; 0
    32a2:	68 e0       	ldi	r22, 0x08	; 8
    32a4:	80 e6       	ldi	r24, 0x60	; 96
    32a6:	96 e0       	ldi	r25, 0x06	; 6
    32a8:	a2 df       	rcall	.-188    	; 0x31ee <ioport_configure_port_pin>
    32aa:	43 e0       	ldi	r20, 0x03	; 3
    32ac:	50 e0       	ldi	r21, 0x00	; 0
    32ae:	68 e0       	ldi	r22, 0x08	; 8
    32b0:	80 ea       	ldi	r24, 0xA0	; 160
    32b2:	96 e0       	ldi	r25, 0x06	; 6
    32b4:	9c df       	rcall	.-200    	; 0x31ee <ioport_configure_port_pin>
    32b6:	43 e0       	ldi	r20, 0x03	; 3
    32b8:	50 e0       	ldi	r21, 0x00	; 0
    32ba:	61 e0       	ldi	r22, 0x01	; 1
    32bc:	80 e6       	ldi	r24, 0x60	; 96
    32be:	96 e0       	ldi	r25, 0x06	; 6
    32c0:	96 df       	rcall	.-212    	; 0x31ee <ioport_configure_port_pin>
    32c2:	43 e0       	ldi	r20, 0x03	; 3
    32c4:	50 e0       	ldi	r21, 0x00	; 0
    32c6:	68 e0       	ldi	r22, 0x08	; 8
    32c8:	80 e0       	ldi	r24, 0x00	; 0
    32ca:	96 e0       	ldi	r25, 0x06	; 6
    32cc:	90 df       	rcall	.-224    	; 0x31ee <ioport_configure_port_pin>
    32ce:	41 e0       	ldi	r20, 0x01	; 1
    32d0:	50 e0       	ldi	r21, 0x00	; 0
    32d2:	60 e1       	ldi	r22, 0x10	; 16
    32d4:	80 e8       	ldi	r24, 0x80	; 128
    32d6:	96 e0       	ldi	r25, 0x06	; 6
    32d8:	8a df       	rcall	.-236    	; 0x31ee <ioport_configure_port_pin>
    32da:	43 e0       	ldi	r20, 0x03	; 3
    32dc:	50 e0       	ldi	r21, 0x00	; 0
    32de:	62 e0       	ldi	r22, 0x02	; 2
    32e0:	80 e6       	ldi	r24, 0x60	; 96
    32e2:	96 e0       	ldi	r25, 0x06	; 6
    32e4:	84 df       	rcall	.-248    	; 0x31ee <ioport_configure_port_pin>
    32e6:	43 e0       	ldi	r20, 0x03	; 3
    32e8:	50 e0       	ldi	r21, 0x00	; 0
    32ea:	68 e0       	ldi	r22, 0x08	; 8
    32ec:	80 e6       	ldi	r24, 0x60	; 96
    32ee:	96 e0       	ldi	r25, 0x06	; 6
    32f0:	7e df       	rcall	.-260    	; 0x31ee <ioport_configure_port_pin>
    32f2:	40 e0       	ldi	r20, 0x00	; 0
    32f4:	50 e0       	ldi	r21, 0x00	; 0
    32f6:	64 e0       	ldi	r22, 0x04	; 4
    32f8:	80 e6       	ldi	r24, 0x60	; 96
    32fa:	96 e0       	ldi	r25, 0x06	; 6
    32fc:	78 df       	rcall	.-272    	; 0x31ee <ioport_configure_port_pin>
    32fe:	43 e0       	ldi	r20, 0x03	; 3
    3300:	50 e0       	ldi	r21, 0x00	; 0
    3302:	60 e1       	ldi	r22, 0x10	; 16
    3304:	80 ea       	ldi	r24, 0xA0	; 160
    3306:	96 e0       	ldi	r25, 0x06	; 6
    3308:	72 df       	rcall	.-284    	; 0x31ee <ioport_configure_port_pin>
    330a:	40 e0       	ldi	r20, 0x00	; 0
    330c:	50 e0       	ldi	r21, 0x00	; 0
    330e:	61 e0       	ldi	r22, 0x01	; 1
    3310:	80 e0       	ldi	r24, 0x00	; 0
    3312:	96 e0       	ldi	r25, 0x06	; 6
    3314:	6c df       	rcall	.-296    	; 0x31ee <ioport_configure_port_pin>
    3316:	40 e0       	ldi	r20, 0x00	; 0
    3318:	50 e0       	ldi	r21, 0x00	; 0
    331a:	64 e0       	ldi	r22, 0x04	; 4
    331c:	80 e0       	ldi	r24, 0x00	; 0
    331e:	96 e0       	ldi	r25, 0x06	; 6
    3320:	66 df       	rcall	.-308    	; 0x31ee <ioport_configure_port_pin>
    3322:	40 e0       	ldi	r20, 0x00	; 0
    3324:	50 e0       	ldi	r21, 0x00	; 0
    3326:	62 e0       	ldi	r22, 0x02	; 2
    3328:	80 e2       	ldi	r24, 0x20	; 32
    332a:	96 e0       	ldi	r25, 0x06	; 6
    332c:	60 df       	rcall	.-320    	; 0x31ee <ioport_configure_port_pin>
    332e:	43 e0       	ldi	r20, 0x03	; 3
    3330:	50 e0       	ldi	r21, 0x00	; 0
    3332:	68 e0       	ldi	r22, 0x08	; 8
    3334:	80 e4       	ldi	r24, 0x40	; 64
    3336:	96 e0       	ldi	r25, 0x06	; 6
    3338:	5a df       	rcall	.-332    	; 0x31ee <ioport_configure_port_pin>
    333a:	40 e0       	ldi	r20, 0x00	; 0
    333c:	50 e0       	ldi	r21, 0x00	; 0
    333e:	64 e0       	ldi	r22, 0x04	; 4
    3340:	80 e4       	ldi	r24, 0x40	; 64
    3342:	96 e0       	ldi	r25, 0x06	; 6
    3344:	54 df       	rcall	.-344    	; 0x31ee <ioport_configure_port_pin>
    3346:	43 e0       	ldi	r20, 0x03	; 3
    3348:	50 e0       	ldi	r21, 0x00	; 0
    334a:	68 e0       	ldi	r22, 0x08	; 8
    334c:	80 e6       	ldi	r24, 0x60	; 96
    334e:	96 e0       	ldi	r25, 0x06	; 6
    3350:	4e df       	rcall	.-356    	; 0x31ee <ioport_configure_port_pin>
    3352:	40 e0       	ldi	r20, 0x00	; 0
    3354:	50 e0       	ldi	r21, 0x00	; 0
    3356:	64 e0       	ldi	r22, 0x04	; 4
    3358:	80 e6       	ldi	r24, 0x60	; 96
    335a:	96 e0       	ldi	r25, 0x06	; 6
    335c:	48 df       	rcall	.-368    	; 0x31ee <ioport_configure_port_pin>
    335e:	43 e0       	ldi	r20, 0x03	; 3
    3360:	50 e0       	ldi	r21, 0x00	; 0
    3362:	68 e0       	ldi	r22, 0x08	; 8
    3364:	80 e8       	ldi	r24, 0x80	; 128
    3366:	96 e0       	ldi	r25, 0x06	; 6
    3368:	42 df       	rcall	.-380    	; 0x31ee <ioport_configure_port_pin>
    336a:	40 e0       	ldi	r20, 0x00	; 0
    336c:	50 e0       	ldi	r21, 0x00	; 0
    336e:	64 e0       	ldi	r22, 0x04	; 4
    3370:	80 e8       	ldi	r24, 0x80	; 128
    3372:	96 e0       	ldi	r25, 0x06	; 6
    3374:	3c cf       	rjmp	.-392    	; 0x31ee <ioport_configure_port_pin>
    3376:	08 95       	ret

00003378 <vTimerCallback>:
	while(1){
		char inp = usart_getchar(USART_SERIAL_EXAMPLE);
		if(inp=='\n') break;
		else reads[i++] = inp;
	}
}
    3378:	80 91 dc 22 	lds	r24, 0x22DC	; 0x8022dc <increment>
    337c:	90 91 dd 22 	lds	r25, 0x22DD	; 0x8022dd <increment+0x1>
    3380:	a0 91 de 22 	lds	r26, 0x22DE	; 0x8022de <increment+0x2>
    3384:	b0 91 df 22 	lds	r27, 0x22DF	; 0x8022df <increment+0x3>
    3388:	01 96       	adiw	r24, 0x01	; 1
    338a:	a1 1d       	adc	r26, r1
    338c:	b1 1d       	adc	r27, r1
    338e:	80 93 dc 22 	sts	0x22DC, r24	; 0x8022dc <increment>
    3392:	90 93 dd 22 	sts	0x22DD, r25	; 0x8022dd <increment+0x1>
    3396:	a0 93 de 22 	sts	0x22DE, r26	; 0x8022de <increment+0x2>
    339a:	b0 93 df 22 	sts	0x22DF, r27	; 0x8022df <increment+0x3>
    339e:	08 95       	ret

000033a0 <resetAll>:
    33a0:	00 e8       	ldi	r16, 0x80	; 128
    33a2:	16 e0       	ldi	r17, 0x06	; 6
    33a4:	c0 ee       	ldi	r28, 0xE0	; 224
    33a6:	d7 e0       	ldi	r29, 0x07	; 7
    33a8:	bb 24       	eor	r11, r11
    33aa:	b3 94       	inc	r11
    33ac:	68 94       	set
    33ae:	ee 24       	eor	r14, r14
    33b0:	e1 f8       	bld	r14, 1
    33b2:	0f 2e       	mov	r0, r31
    33b4:	f0 e6       	ldi	r31, 0x60	; 96
    33b6:	cf 2e       	mov	r12, r31
    33b8:	f6 e0       	ldi	r31, 0x06	; 6
    33ba:	df 2e       	mov	r13, r31
    33bc:	f0 2d       	mov	r31, r0
    33be:	68 94       	set
    33c0:	ff 24       	eor	r15, r15
    33c2:	f4 f8       	bld	r15, 4
    33c4:	f8 01       	movw	r30, r16
    33c6:	80 85       	ldd	r24, Z+8	; 0x08
    33c8:	85 fd       	sbrc	r24, 5
    33ca:	14 c0       	rjmp	.+40     	; 0x33f4 <resetAll+0x54>
    33cc:	bd 82       	std	Y+5, r11	; 0x05
    33ce:	ed 82       	std	Y+5, r14	; 0x05
    33d0:	f6 01       	movw	r30, r12
    33d2:	f5 82       	std	Z+5, r15	; 0x05
    33d4:	10 92 e2 22 	sts	0x22E2, r1	; 0x8022e2 <pingtest>
    33d8:	10 92 e3 22 	sts	0x22E3, r1	; 0x8022e3 <pingtest+0x1>
    33dc:	10 92 e6 22 	sts	0x22E6, r1	; 0x8022e6 <servotest>
    33e0:	10 92 e7 22 	sts	0x22E7, r1	; 0x8022e7 <servotest+0x1>
    33e4:	10 92 e8 22 	sts	0x22E8, r1	; 0x8022e8 <potensiotest>
    33e8:	10 92 e9 22 	sts	0x22E9, r1	; 0x8022e9 <potensiotest+0x1>
    33ec:	10 92 e4 22 	sts	0x22E4, r1	; 0x8022e4 <qtouchtest>
    33f0:	10 92 e5 22 	sts	0x22E5, r1	; 0x8022e5 <qtouchtest+0x1>
    33f4:	85 e0       	ldi	r24, 0x05	; 5
    33f6:	90 e0       	ldi	r25, 0x00	; 0
    33f8:	65 db       	rcall	.-2358   	; 0x2ac4 <vTaskDelay>
    33fa:	e4 cf       	rjmp	.-56     	; 0x33c4 <resetAll+0x24>

000033fc <testQtouch>:
    33fc:	0f 2e       	mov	r0, r31
    33fe:	f0 ea       	ldi	r31, 0xA0	; 160
    3400:	ef 2e       	mov	r14, r31
    3402:	f6 e0       	ldi	r31, 0x06	; 6
    3404:	ff 2e       	mov	r15, r31
    3406:	f0 2d       	mov	r31, r0
    3408:	00 ee       	ldi	r16, 0xE0	; 224
    340a:	17 e0       	ldi	r17, 0x07	; 7
    340c:	c2 e0       	ldi	r28, 0x02	; 2
    340e:	cc 24       	eor	r12, r12
    3410:	c3 94       	inc	r12
    3412:	d1 2c       	mov	r13, r1
    3414:	f7 01       	movw	r30, r14
    3416:	80 85       	ldd	r24, Z+8	; 0x08
    3418:	88 23       	and	r24, r24
    341a:	3c f4       	brge	.+14     	; 0x342a <testQtouch+0x2e>
    341c:	f8 01       	movw	r30, r16
    341e:	c6 83       	std	Z+6, r28	; 0x06
    3420:	c0 92 e4 22 	sts	0x22E4, r12	; 0x8022e4 <qtouchtest>
    3424:	d0 92 e5 22 	sts	0x22E5, r13	; 0x8022e5 <qtouchtest+0x1>
    3428:	06 c0       	rjmp	.+12     	; 0x3436 <testQtouch+0x3a>
    342a:	f8 01       	movw	r30, r16
    342c:	c5 83       	std	Z+5, r28	; 0x05
    342e:	10 92 e4 22 	sts	0x22E4, r1	; 0x8022e4 <qtouchtest>
    3432:	10 92 e5 22 	sts	0x22E5, r1	; 0x8022e5 <qtouchtest+0x1>
    3436:	82 e3       	ldi	r24, 0x32	; 50
    3438:	90 e0       	ldi	r25, 0x00	; 0
    343a:	44 db       	rcall	.-2424   	; 0x2ac4 <vTaskDelay>
    343c:	eb cf       	rjmp	.-42     	; 0x3414 <testQtouch+0x18>

0000343e <testPotentio>:
    343e:	c0 e0       	ldi	r28, 0x00	; 0
    3440:	d2 e0       	ldi	r29, 0x02	; 2
    3442:	cc 24       	eor	r12, r12
    3444:	c3 94       	inc	r12
    3446:	00 e6       	ldi	r16, 0x60	; 96
    3448:	16 e0       	ldi	r17, 0x06	; 6
    344a:	68 94       	set
    344c:	dd 24       	eor	r13, r13
    344e:	d4 f8       	bld	r13, 4
    3450:	ee 24       	eor	r14, r14
    3452:	e3 94       	inc	r14
    3454:	f1 2c       	mov	r15, r1
    3456:	ce 01       	movw	r24, r28
    3458:	0e 94 46 07 	call	0xe8c	; 0xe8c <adc_enable>
    345c:	9f b7       	in	r25, 0x3f	; 63
    345e:	f8 94       	cli
    3460:	88 81       	ld	r24, Y
    3462:	84 60       	ori	r24, 0x04	; 4
    3464:	88 83       	st	Y, r24
    3466:	9f bf       	out	0x3f, r25	; 63
    3468:	9e 81       	ldd	r25, Y+6	; 0x06
    346a:	90 ff       	sbrs	r25, 0
    346c:	fd cf       	rjmp	.-6      	; 0x3468 <testPotentio+0x2a>
    346e:	ce 82       	std	Y+6, r12	; 0x06
    3470:	8c a1       	ldd	r24, Y+36	; 0x24
    3472:	9d a1       	ldd	r25, Y+37	; 0x25
    3474:	80 93 ea 22 	sts	0x22EA, r24	; 0x8022ea <result>
    3478:	90 93 eb 22 	sts	0x22EB, r25	; 0x8022eb <result+0x1>
    347c:	81 3d       	cpi	r24, 0xD1	; 209
    347e:	97 40       	sbci	r25, 0x07	; 7
    3480:	38 f4       	brcc	.+14     	; 0x3490 <testPotentio+0x52>
    3482:	f8 01       	movw	r30, r16
    3484:	d6 82       	std	Z+6, r13	; 0x06
    3486:	e0 92 e8 22 	sts	0x22E8, r14	; 0x8022e8 <potensiotest>
    348a:	f0 92 e9 22 	sts	0x22E9, r15	; 0x8022e9 <potensiotest+0x1>
    348e:	06 c0       	rjmp	.+12     	; 0x349c <testPotentio+0x5e>
    3490:	f8 01       	movw	r30, r16
    3492:	d5 82       	std	Z+5, r13	; 0x05
    3494:	10 92 e8 22 	sts	0x22E8, r1	; 0x8022e8 <potensiotest>
    3498:	10 92 e9 22 	sts	0x22E9, r1	; 0x8022e9 <potensiotest+0x1>
    349c:	85 e0       	ldi	r24, 0x05	; 5
    349e:	90 e0       	ldi	r25, 0x00	; 0
    34a0:	11 db       	rcall	.-2526   	; 0x2ac4 <vTaskDelay>
    34a2:	d9 cf       	rjmp	.-78     	; 0x3456 <testPotentio+0x18>

000034a4 <PWM_Init>:
    34a4:	e0 e4       	ldi	r30, 0x40	; 64
    34a6:	f6 e0       	ldi	r31, 0x06	; 6
    34a8:	80 81       	ld	r24, Z
    34aa:	81 60       	ori	r24, 0x01	; 1
    34ac:	80 83       	st	Z, r24
    34ae:	e0 e0       	ldi	r30, 0x00	; 0
    34b0:	f8 e0       	ldi	r31, 0x08	; 8
    34b2:	85 e0       	ldi	r24, 0x05	; 5
    34b4:	80 83       	st	Z, r24
    34b6:	86 e1       	ldi	r24, 0x16	; 22
    34b8:	81 83       	std	Z+1, r24	; 0x01
    34ba:	88 ee       	ldi	r24, 0xE8	; 232
    34bc:	93 e0       	ldi	r25, 0x03	; 3
    34be:	86 a3       	std	Z+38, r24	; 0x26
    34c0:	97 a3       	std	Z+39, r25	; 0x27
    34c2:	87 e7       	ldi	r24, 0x77	; 119
    34c4:	91 e0       	ldi	r25, 0x01	; 1
    34c6:	80 a7       	std	Z+40, r24	; 0x28
    34c8:	91 a7       	std	Z+41, r25	; 0x29
    34ca:	08 95       	ret

000034cc <testServo>:
    34cc:	eb df       	rcall	.-42     	; 0x34a4 <PWM_Init>
    34ce:	c0 ea       	ldi	r28, 0xA0	; 160
    34d0:	d6 e0       	ldi	r29, 0x06	; 6
    34d2:	00 e0       	ldi	r16, 0x00	; 0
    34d4:	18 e0       	ldi	r17, 0x08	; 8
    34d6:	0f 2e       	mov	r0, r31
    34d8:	f7 e7       	ldi	r31, 0x77	; 119
    34da:	8f 2e       	mov	r8, r31
    34dc:	99 24       	eor	r9, r9
    34de:	93 94       	inc	r9
    34e0:	f0 2d       	mov	r31, r0
    34e2:	cc 24       	eor	r12, r12
    34e4:	c3 94       	inc	r12
    34e6:	d1 2c       	mov	r13, r1
    34e8:	0f 2e       	mov	r0, r31
    34ea:	f0 ee       	ldi	r31, 0xE0	; 224
    34ec:	ef 2e       	mov	r14, r31
    34ee:	f7 e0       	ldi	r31, 0x07	; 7
    34f0:	ff 2e       	mov	r15, r31
    34f2:	f0 2d       	mov	r31, r0
    34f4:	77 24       	eor	r7, r7
    34f6:	73 94       	inc	r7
    34f8:	0f 2e       	mov	r0, r31
    34fa:	f6 e9       	ldi	r31, 0x96	; 150
    34fc:	af 2e       	mov	r10, r31
    34fe:	b1 2c       	mov	r11, r1
    3500:	f0 2d       	mov	r31, r0
    3502:	88 85       	ldd	r24, Y+8	; 0x08
    3504:	81 fd       	sbrc	r24, 1
    3506:	0a c0       	rjmp	.+20     	; 0x351c <testServo+0x50>
    3508:	f8 01       	movw	r30, r16
    350a:	a0 a6       	std	Z+40, r10	; 0x28
    350c:	b1 a6       	std	Z+41, r11	; 0x29
    350e:	f7 01       	movw	r30, r14
    3510:	76 82       	std	Z+6, r7	; 0x06
    3512:	c0 92 e6 22 	sts	0x22E6, r12	; 0x8022e6 <servotest>
    3516:	d0 92 e7 22 	sts	0x22E7, r13	; 0x8022e7 <servotest+0x1>
    351a:	10 c0       	rjmp	.+32     	; 0x353c <testServo+0x70>
    351c:	88 85       	ldd	r24, Y+8	; 0x08
    351e:	82 fd       	sbrc	r24, 2
    3520:	0a c0       	rjmp	.+20     	; 0x3536 <testServo+0x6a>
    3522:	f8 01       	movw	r30, r16
    3524:	c0 a6       	std	Z+40, r12	; 0x28
    3526:	d1 a6       	std	Z+41, r13	; 0x29
    3528:	f7 01       	movw	r30, r14
    352a:	75 82       	std	Z+5, r7	; 0x05
    352c:	10 92 e6 22 	sts	0x22E6, r1	; 0x8022e6 <servotest>
    3530:	10 92 e7 22 	sts	0x22E7, r1	; 0x8022e7 <servotest+0x1>
    3534:	03 c0       	rjmp	.+6      	; 0x353c <testServo+0x70>
    3536:	f8 01       	movw	r30, r16
    3538:	80 a6       	std	Z+40, r8	; 0x28
    353a:	91 a6       	std	Z+41, r9	; 0x29
    353c:	85 e0       	ldi	r24, 0x05	; 5
    353e:	90 e0       	ldi	r25, 0x00	; 0
    3540:	c1 da       	rcall	.-2686   	; 0x2ac4 <vTaskDelay>
    3542:	df cf       	rjmp	.-66     	; 0x3502 <testServo+0x36>

00003544 <setUpSerial>:
    3544:	10 92 a7 08 	sts	0x08A7, r1	; 0x8008a7 <__TEXT_REGION_LENGTH__+0x7008a7>
    3548:	8c e0       	ldi	r24, 0x0C	; 12
    354a:	80 93 a6 08 	sts	0x08A6, r24	; 0x8008a6 <__TEXT_REGION_LENGTH__+0x7008a6>
    354e:	10 92 a3 08 	sts	0x08A3, r1	; 0x8008a3 <__TEXT_REGION_LENGTH__+0x7008a3>
    3552:	83 e0       	ldi	r24, 0x03	; 3
    3554:	80 93 a5 08 	sts	0x08A5, r24	; 0x8008a5 <__TEXT_REGION_LENGTH__+0x7008a5>
    3558:	88 e1       	ldi	r24, 0x18	; 24
    355a:	80 93 a4 08 	sts	0x08A4, r24	; 0x8008a4 <__TEXT_REGION_LENGTH__+0x7008a4>
    355e:	08 95       	ret

00003560 <sendString>:
    3560:	cf 93       	push	r28
    3562:	df 93       	push	r29
    3564:	fc 01       	movw	r30, r24
    3566:	60 81       	ld	r22, Z
    3568:	66 23       	and	r22, r22
    356a:	49 f0       	breq	.+18     	; 0x357e <sendString+0x1e>
    356c:	ec 01       	movw	r28, r24
    356e:	21 96       	adiw	r28, 0x01	; 1
    3570:	80 ea       	ldi	r24, 0xA0	; 160
    3572:	98 e0       	ldi	r25, 0x08	; 8
    3574:	0e 94 dc 09 	call	0x13b8	; 0x13b8 <usart_putchar>
    3578:	69 91       	ld	r22, Y+
    357a:	61 11       	cpse	r22, r1
    357c:	f9 cf       	rjmp	.-14     	; 0x3570 <sendString+0x10>
    357e:	df 91       	pop	r29
    3580:	cf 91       	pop	r28
    3582:	08 95       	ret

00003584 <testLCD>:
    3584:	80 e1       	ldi	r24, 0x10	; 16
    3586:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
    358a:	0f 2e       	mov	r0, r31
    358c:	f1 e2       	ldi	r31, 0x21	; 33
    358e:	8f 2e       	mov	r8, r31
    3590:	f0 e2       	ldi	r31, 0x20	; 32
    3592:	9f 2e       	mov	r9, r31
    3594:	f0 2d       	mov	r31, r0
    3596:	19 ec       	ldi	r17, 0xC9	; 201
    3598:	cc ee       	ldi	r28, 0xEC	; 236
    359a:	d2 e2       	ldi	r29, 0x22	; 34
    359c:	0f 2e       	mov	r0, r31
    359e:	f0 e3       	ldi	r31, 0x30	; 48
    35a0:	af 2e       	mov	r10, r31
    35a2:	f0 e2       	ldi	r31, 0x20	; 32
    35a4:	bf 2e       	mov	r11, r31
    35a6:	f0 2d       	mov	r31, r0
    35a8:	0f 2e       	mov	r0, r31
    35aa:	fd e3       	ldi	r31, 0x3D	; 61
    35ac:	cf 2e       	mov	r12, r31
    35ae:	f0 e2       	ldi	r31, 0x20	; 32
    35b0:	df 2e       	mov	r13, r31
    35b2:	f0 2d       	mov	r31, r0
    35b4:	0f 2e       	mov	r0, r31
    35b6:	f9 e4       	ldi	r31, 0x49	; 73
    35b8:	ef 2e       	mov	r14, r31
    35ba:	f0 e2       	ldi	r31, 0x20	; 32
    35bc:	ff 2e       	mov	r15, r31
    35be:	f0 2d       	mov	r31, r0
    35c0:	80 91 eb 22 	lds	r24, 0x22EB	; 0x8022eb <result+0x1>
    35c4:	8f 93       	push	r24
    35c6:	80 91 ea 22 	lds	r24, 0x22EA	; 0x8022ea <result>
    35ca:	8f 93       	push	r24
    35cc:	9f 92       	push	r9
    35ce:	8f 92       	push	r8
    35d0:	1f 92       	push	r1
    35d2:	1f 93       	push	r17
    35d4:	df 93       	push	r29
    35d6:	cf 93       	push	r28
    35d8:	74 d2       	rcall	.+1256   	; 0x3ac2 <snprintf>
    35da:	26 e0       	ldi	r18, 0x06	; 6
    35dc:	30 e2       	ldi	r19, 0x20	; 32
    35de:	40 e0       	ldi	r20, 0x00	; 0
    35e0:	60 e0       	ldi	r22, 0x00	; 0
    35e2:	ce 01       	movw	r24, r28
    35e4:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <gfx_mono_draw_string>
    35e8:	80 91 e5 22 	lds	r24, 0x22E5	; 0x8022e5 <qtouchtest+0x1>
    35ec:	8f 93       	push	r24
    35ee:	80 91 e4 22 	lds	r24, 0x22E4	; 0x8022e4 <qtouchtest>
    35f2:	8f 93       	push	r24
    35f4:	bf 92       	push	r11
    35f6:	af 92       	push	r10
    35f8:	1f 92       	push	r1
    35fa:	1f 93       	push	r17
    35fc:	df 93       	push	r29
    35fe:	cf 93       	push	r28
    3600:	60 d2       	rcall	.+1216   	; 0x3ac2 <snprintf>
    3602:	26 e0       	ldi	r18, 0x06	; 6
    3604:	30 e2       	ldi	r19, 0x20	; 32
    3606:	48 e0       	ldi	r20, 0x08	; 8
    3608:	60 e0       	ldi	r22, 0x00	; 0
    360a:	ce 01       	movw	r24, r28
    360c:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <gfx_mono_draw_string>
    3610:	80 91 e7 22 	lds	r24, 0x22E7	; 0x8022e7 <servotest+0x1>
    3614:	8f 93       	push	r24
    3616:	80 91 e6 22 	lds	r24, 0x22E6	; 0x8022e6 <servotest>
    361a:	8f 93       	push	r24
    361c:	df 92       	push	r13
    361e:	cf 92       	push	r12
    3620:	1f 92       	push	r1
    3622:	1f 93       	push	r17
    3624:	df 93       	push	r29
    3626:	cf 93       	push	r28
    3628:	4c d2       	rcall	.+1176   	; 0x3ac2 <snprintf>
    362a:	26 e0       	ldi	r18, 0x06	; 6
    362c:	30 e2       	ldi	r19, 0x20	; 32
    362e:	40 e1       	ldi	r20, 0x10	; 16
    3630:	60 e0       	ldi	r22, 0x00	; 0
    3632:	ce 01       	movw	r24, r28
    3634:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <gfx_mono_draw_string>
    3638:	80 91 e1 22 	lds	r24, 0x22E1	; 0x8022e1 <heap+0x1>
    363c:	8f 93       	push	r24
    363e:	80 91 e0 22 	lds	r24, 0x22E0	; 0x8022e0 <heap>
    3642:	8f 93       	push	r24
    3644:	80 91 e5 22 	lds	r24, 0x22E5	; 0x8022e5 <qtouchtest+0x1>
    3648:	8f 93       	push	r24
    364a:	80 91 e4 22 	lds	r24, 0x22E4	; 0x8022e4 <qtouchtest>
    364e:	8f 93       	push	r24
    3650:	80 91 e7 22 	lds	r24, 0x22E7	; 0x8022e7 <servotest+0x1>
    3654:	8f 93       	push	r24
    3656:	80 91 e6 22 	lds	r24, 0x22E6	; 0x8022e6 <servotest>
    365a:	8f 93       	push	r24
    365c:	80 91 eb 22 	lds	r24, 0x22EB	; 0x8022eb <result+0x1>
    3660:	8f 93       	push	r24
    3662:	80 91 ea 22 	lds	r24, 0x22EA	; 0x8022ea <result>
    3666:	8f 93       	push	r24
    3668:	ff 92       	push	r15
    366a:	ef 92       	push	r14
    366c:	1f 92       	push	r1
    366e:	1f 93       	push	r17
    3670:	df 93       	push	r29
    3672:	cf 93       	push	r28
    3674:	26 d2       	rcall	.+1100   	; 0x3ac2 <snprintf>
    3676:	8d b7       	in	r24, 0x3d	; 61
    3678:	9e b7       	in	r25, 0x3e	; 62
    367a:	86 96       	adiw	r24, 0x26	; 38
    367c:	8d bf       	out	0x3d, r24	; 61
    367e:	9e bf       	out	0x3e, r25	; 62
    3680:	26 e0       	ldi	r18, 0x06	; 6
    3682:	30 e2       	ldi	r19, 0x20	; 32
    3684:	48 e1       	ldi	r20, 0x18	; 24
    3686:	60 e0       	ldi	r22, 0x00	; 0
    3688:	ce 01       	movw	r24, r28
    368a:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <gfx_mono_draw_string>
    368e:	ce 01       	movw	r24, r28
    3690:	67 df       	rcall	.-306    	; 0x3560 <sendString>
    3692:	82 e0       	ldi	r24, 0x02	; 2
    3694:	90 e0       	ldi	r25, 0x00	; 0
    3696:	16 da       	rcall	.-3028   	; 0x2ac4 <vTaskDelay>
    3698:	93 cf       	rjmp	.-218    	; 0x35c0 <testLCD+0x3c>

0000369a <main>:

int main (void)
{
    369a:	8f 92       	push	r8
    369c:	9f 92       	push	r9
    369e:	af 92       	push	r10
    36a0:	bf 92       	push	r11
    36a2:	cf 92       	push	r12
    36a4:	df 92       	push	r13
    36a6:	ef 92       	push	r14
    36a8:	ff 92       	push	r15
    36aa:	0f 93       	push	r16
    36ac:	1f 93       	push	r17
    36ae:	cf 93       	push	r28
    36b0:	df 93       	push	r29
    36b2:	cd b7       	in	r28, 0x3d	; 61
    36b4:	de b7       	in	r29, 0x3e	; 62
    36b6:	2b 97       	sbiw	r28, 0x0b	; 11
    36b8:	cd bf       	out	0x3d, r28	; 61
    36ba:	de bf       	out	0x3e, r29	; 62
	// Insert system clock initialization code here (sysclk_init()).

	
	board_init();
    36bc:	c0 dd       	rcall	.-1152   	; 0x323e <board_init>
 * Enables all interrupt levels, with vectors located in the application section
 * and fixed priority scheduling.
 */
static inline void pmic_init(void)
{
	PMIC.CTRL = PMIC_LVL_LOW | PMIC_LVL_MEDIUM |
    36be:	87 e0       	ldi	r24, 0x07	; 7
    36c0:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
static void adc_init(void)
{
	struct adc_config adc_conf;
	struct adc_channel_config adcch_conf;

	adc_read_configuration(&MY_ADC, &adc_conf);
    36c4:	be 01       	movw	r22, r28
    36c6:	6f 5f       	subi	r22, 0xFF	; 255
    36c8:	7f 4f       	sbci	r23, 0xFF	; 255
    36ca:	80 e0       	ldi	r24, 0x00	; 0
    36cc:	92 e0       	ldi	r25, 0x02	; 2
    36ce:	0e 94 3d 09 	call	0x127a	; 0x127a <adc_read_configuration>
	adcch_read_configuration(&MY_ADC, MY_ADC_CH, &adcch_conf);
    36d2:	ae 01       	movw	r20, r28
    36d4:	48 5f       	subi	r20, 0xF8	; 248
    36d6:	5f 4f       	sbci	r21, 0xFF	; 255
    36d8:	61 e0       	ldi	r22, 0x01	; 1
    36da:	80 e0       	ldi	r24, 0x00	; 0
    36dc:	92 e0       	ldi	r25, 0x02	; 2
    36de:	0e 94 99 09 	call	0x1332	; 0x1332 <adcch_read_configuration>
static inline void adc_set_conversion_parameters(struct adc_config *conf,
		enum adc_sign sign, enum adc_resolution res,
		enum adc_reference ref)
{
	/* Preserve all but conversion and resolution config. */
	conf->ctrlb &= ~(ADC_CONMODE_bm | ADC_RESOLUTION_gm);
    36e2:	9a 81       	ldd	r25, Y+2	; 0x02
	conf->ctrlb |= (uint8_t)res | (uint8_t)sign;

	conf->refctrl &= ~ADC_REFSEL_gm;
    36e4:	8b 81       	ldd	r24, Y+3	; 0x03
    36e6:	8f 78       	andi	r24, 0x8F	; 143
	conf->refctrl |= ref;
    36e8:	80 61       	ori	r24, 0x10	; 16
    36ea:	8b 83       	std	Y+3, r24	; 0x03
	Assert(base_ev_ch <= 3);
#endif

	switch (trig) {
	case ADC_TRIG_MANUAL:
		conf->ctrlb &= ~ADC_FREERUN_bm;
    36ec:	89 2f       	mov	r24, r25
    36ee:	81 7e       	andi	r24, 0xE1	; 225
    36f0:	8a 83       	std	Y+2, r24	; 0x02
		conf->evctrl = ADC_EVACT_NONE_gc;
    36f2:	1c 82       	std	Y+4, r1	; 0x04
		psc = ADC_PRESCALER_DIV256_gc;
	} else {
		psc = ADC_PRESCALER_DIV512_gc;
	}

	conf->prescaler = psc;
    36f4:	82 e0       	ldi	r24, 0x02	; 2
    36f6:	8d 83       	std	Y+5, r24	; 0x05
				ADC_CH_MUXPOS_gp;
	} else if (neg == ADCCH_NEG_NONE) {
		/* Configure for single-ended measurement. */
		Assert(gain == 1);

		ch_conf->ctrl = ADC_CH_INPUTMODE_SINGLEENDED_gc;
    36f8:	81 e0       	ldi	r24, 0x01	; 1
    36fa:	88 87       	std	Y+8, r24	; 0x08
		ch_conf->muxctrl = pos << ADC_CH_MUXPOS_gp;
    36fc:	80 e4       	ldi	r24, 0x40	; 64
    36fe:	89 87       	std	Y+9, r24	; 0x09
	adc_set_conversion_trigger(&adc_conf, ADC_TRIG_MANUAL, 1, 0);
	adc_set_clock_rate(&adc_conf, 200000UL);

	adcch_set_input(&adcch_conf, J2_PIN0, ADCCH_NEG_NONE, 1);

	adc_write_configuration(&MY_ADC, &adc_conf);
    3700:	be 01       	movw	r22, r28
    3702:	6f 5f       	subi	r22, 0xFF	; 255
    3704:	7f 4f       	sbci	r23, 0xFF	; 255
    3706:	80 e0       	ldi	r24, 0x00	; 0
    3708:	92 e0       	ldi	r25, 0x02	; 2
    370a:	0e 94 ed 08 	call	0x11da	; 0x11da <adc_write_configuration>
	adcch_write_configuration(&MY_ADC, MY_ADC_CH, &adcch_conf);
    370e:	ae 01       	movw	r20, r28
    3710:	48 5f       	subi	r20, 0xF8	; 248
    3712:	5f 4f       	sbci	r21, 0xFF	; 255
    3714:	61 e0       	ldi	r22, 0x01	; 1
    3716:	80 e0       	ldi	r24, 0x00	; 0
    3718:	92 e0       	ldi	r25, 0x02	; 2
    371a:	0e 94 60 09 	call	0x12c0	; 0x12c0 <adcch_write_configuration>
	
	board_init();
	
	pmic_init();
	adc_init();
	gfx_mono_init();
    371e:	0e 94 e7 04 	call	0x9ce	; 0x9ce <gfx_mono_st7565r_init>
    3722:	80 e1       	ldi	r24, 0x10	; 16
    3724:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
	ioport_set_pin_level(LCD_BACKLIGHT_ENABLE_PIN, 1);
	PORTC_OUTSET = PIN3_bm; // PC3 as TX
    3728:	88 e0       	ldi	r24, 0x08	; 8
    372a:	80 93 45 06 	sts	0x0645, r24	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>
	PORTC_DIRSET = PIN3_bm; //TX pin as output
    372e:	80 93 41 06 	sts	0x0641, r24	; 0x800641 <__TEXT_REGION_LENGTH__+0x700641>
	setUpSerial();
    3732:	08 df       	rcall	.-496    	; 0x3544 <setUpSerial>
		.baudrate = USART_SERIAL_EXAMPLE_BAUDRATE,
		.charlength = USART_SERIAL_CHAR_LENGTH,
		.paritytype = USART_SERIAL_PARITY,
		.stopbits = USART_SERIAL_STOP_BIT
	};
	usart_init_rs232(USART_SERIAL_EXAMPLE, &USART_SERIAL_OPTIONS);
    3734:	6d e0       	ldi	r22, 0x0D	; 13
    3736:	70 e2       	ldi	r23, 0x20	; 32
    3738:	80 ea       	ldi	r24, 0xA0	; 160
    373a:	98 e0       	ldi	r25, 0x08	; 8
    373c:	0e 94 fd 0a 	call	0x15fa	; 0x15fa <usart_init_rs232>
	
	TimerHandle_t timerPing = xTimerCreate("tPing", 2/portTICK_PERIOD_MS, pdTRUE, (void *) 0, vTimerCallback);
    3740:	0c eb       	ldi	r16, 0xBC	; 188
    3742:	19 e1       	ldi	r17, 0x19	; 25
    3744:	20 e0       	ldi	r18, 0x00	; 0
    3746:	30 e0       	ldi	r19, 0x00	; 0
    3748:	41 e0       	ldi	r20, 0x01	; 1
    374a:	61 e0       	ldi	r22, 0x01	; 1
    374c:	70 e0       	ldi	r23, 0x00	; 0
    374e:	8e e5       	ldi	r24, 0x5E	; 94
    3750:	90 e2       	ldi	r25, 0x20	; 32
    3752:	8a db       	rcall	.-2284   	; 0x2e68 <xTimerCreate>
    3754:	4c 01       	movw	r8, r24
	
	xTaskCreate(testPotentio,"",500,NULL,1,NULL);
    3756:	a1 2c       	mov	r10, r1
    3758:	b1 2c       	mov	r11, r1
    375a:	c1 2c       	mov	r12, r1
    375c:	d1 2c       	mov	r13, r1
    375e:	e1 2c       	mov	r14, r1
    3760:	f1 2c       	mov	r15, r1
    3762:	01 e0       	ldi	r16, 0x01	; 1
    3764:	20 e0       	ldi	r18, 0x00	; 0
    3766:	30 e0       	ldi	r19, 0x00	; 0
    3768:	44 ef       	ldi	r20, 0xF4	; 244
    376a:	51 e0       	ldi	r21, 0x01	; 1
    376c:	6d e5       	ldi	r22, 0x5D	; 93
    376e:	70 e2       	ldi	r23, 0x20	; 32
    3770:	8f e1       	ldi	r24, 0x1F	; 31
    3772:	9a e1       	ldi	r25, 0x1A	; 26
    3774:	0e 94 ce 12 	call	0x259c	; 0x259c <xTaskGenericCreate>
	xTaskCreate(testServo,"",500,NULL,1,NULL);
    3778:	20 e0       	ldi	r18, 0x00	; 0
    377a:	30 e0       	ldi	r19, 0x00	; 0
    377c:	44 ef       	ldi	r20, 0xF4	; 244
    377e:	51 e0       	ldi	r21, 0x01	; 1
    3780:	6d e5       	ldi	r22, 0x5D	; 93
    3782:	70 e2       	ldi	r23, 0x20	; 32
    3784:	86 e6       	ldi	r24, 0x66	; 102
    3786:	9a e1       	ldi	r25, 0x1A	; 26
    3788:	0e 94 ce 12 	call	0x259c	; 0x259c <xTaskGenericCreate>
	xTaskCreate(testQtouch,"",500,NULL,1,NULL);
    378c:	20 e0       	ldi	r18, 0x00	; 0
    378e:	30 e0       	ldi	r19, 0x00	; 0
    3790:	44 ef       	ldi	r20, 0xF4	; 244
    3792:	51 e0       	ldi	r21, 0x01	; 1
    3794:	6d e5       	ldi	r22, 0x5D	; 93
    3796:	70 e2       	ldi	r23, 0x20	; 32
    3798:	8e ef       	ldi	r24, 0xFE	; 254
    379a:	99 e1       	ldi	r25, 0x19	; 25
    379c:	0e 94 ce 12 	call	0x259c	; 0x259c <xTaskGenericCreate>
	//xTaskCreate(testUsart,"",500,NULL,1,NULL);
	//xTaskCreate(testHeap,"",500,NULL,1,NULL);
	xTaskCreate(testLCD,"",500,NULL,1,NULL);
    37a0:	20 e0       	ldi	r18, 0x00	; 0
    37a2:	30 e0       	ldi	r19, 0x00	; 0
    37a4:	44 ef       	ldi	r20, 0xF4	; 244
    37a6:	51 e0       	ldi	r21, 0x01	; 1
    37a8:	6d e5       	ldi	r22, 0x5D	; 93
    37aa:	70 e2       	ldi	r23, 0x20	; 32
    37ac:	82 ec       	ldi	r24, 0xC2	; 194
    37ae:	9a e1       	ldi	r25, 0x1A	; 26
    37b0:	0e 94 ce 12 	call	0x259c	; 0x259c <xTaskGenericCreate>
	xTaskCreate(resetAll,"",500,NULL,1,NULL);
    37b4:	20 e0       	ldi	r18, 0x00	; 0
    37b6:	30 e0       	ldi	r19, 0x00	; 0
    37b8:	44 ef       	ldi	r20, 0xF4	; 244
    37ba:	51 e0       	ldi	r21, 0x01	; 1
    37bc:	6d e5       	ldi	r22, 0x5D	; 93
    37be:	70 e2       	ldi	r23, 0x20	; 32
    37c0:	80 ed       	ldi	r24, 0xD0	; 208
    37c2:	99 e1       	ldi	r25, 0x19	; 25
    37c4:	0e 94 ce 12 	call	0x259c	; 0x259c <xTaskGenericCreate>
		
	xTimerStart(timerPing, 0);
    37c8:	23 d8       	rcall	.-4026   	; 0x2810 <xTaskGetTickCount>
    37ca:	00 e0       	ldi	r16, 0x00	; 0
    37cc:	10 e0       	ldi	r17, 0x00	; 0
    37ce:	20 e0       	ldi	r18, 0x00	; 0
    37d0:	30 e0       	ldi	r19, 0x00	; 0
    37d2:	ac 01       	movw	r20, r24
    37d4:	61 e0       	ldi	r22, 0x01	; 1
    37d6:	c4 01       	movw	r24, r8
    37d8:	7d db       	rcall	.-2310   	; 0x2ed4 <xTimerGenericCommand>
	
	vTaskStartScheduler();
    37da:	0e 94 cf 13 	call	0x279e	; 0x279e <vTaskStartScheduler>

	// Insert application code here, after the board has been initialized.
}
    37de:	80 e0       	ldi	r24, 0x00	; 0
    37e0:	90 e0       	ldi	r25, 0x00	; 0
    37e2:	2b 96       	adiw	r28, 0x0b	; 11
    37e4:	cd bf       	out	0x3d, r28	; 61
    37e6:	de bf       	out	0x3e, r29	; 62
    37e8:	df 91       	pop	r29
    37ea:	cf 91       	pop	r28
    37ec:	1f 91       	pop	r17
    37ee:	0f 91       	pop	r16
    37f0:	ff 90       	pop	r15
    37f2:	ef 90       	pop	r14
    37f4:	df 90       	pop	r13
    37f6:	cf 90       	pop	r12
    37f8:	bf 90       	pop	r11
    37fa:	af 90       	pop	r10
    37fc:	9f 90       	pop	r9
    37fe:	8f 90       	pop	r8
    3800:	08 95       	ret

00003802 <__udivmodsi4>:
    3802:	a1 e2       	ldi	r26, 0x21	; 33
    3804:	1a 2e       	mov	r1, r26
    3806:	aa 1b       	sub	r26, r26
    3808:	bb 1b       	sub	r27, r27
    380a:	fd 01       	movw	r30, r26
    380c:	0d c0       	rjmp	.+26     	; 0x3828 <__udivmodsi4_ep>

0000380e <__udivmodsi4_loop>:
    380e:	aa 1f       	adc	r26, r26
    3810:	bb 1f       	adc	r27, r27
    3812:	ee 1f       	adc	r30, r30
    3814:	ff 1f       	adc	r31, r31
    3816:	a2 17       	cp	r26, r18
    3818:	b3 07       	cpc	r27, r19
    381a:	e4 07       	cpc	r30, r20
    381c:	f5 07       	cpc	r31, r21
    381e:	20 f0       	brcs	.+8      	; 0x3828 <__udivmodsi4_ep>
    3820:	a2 1b       	sub	r26, r18
    3822:	b3 0b       	sbc	r27, r19
    3824:	e4 0b       	sbc	r30, r20
    3826:	f5 0b       	sbc	r31, r21

00003828 <__udivmodsi4_ep>:
    3828:	66 1f       	adc	r22, r22
    382a:	77 1f       	adc	r23, r23
    382c:	88 1f       	adc	r24, r24
    382e:	99 1f       	adc	r25, r25
    3830:	1a 94       	dec	r1
    3832:	69 f7       	brne	.-38     	; 0x380e <__udivmodsi4_loop>
    3834:	60 95       	com	r22
    3836:	70 95       	com	r23
    3838:	80 95       	com	r24
    383a:	90 95       	com	r25
    383c:	9b 01       	movw	r18, r22
    383e:	ac 01       	movw	r20, r24
    3840:	bd 01       	movw	r22, r26
    3842:	cf 01       	movw	r24, r30
    3844:	08 95       	ret

00003846 <__tablejump2__>:
    3846:	ee 0f       	add	r30, r30
    3848:	ff 1f       	adc	r31, r31
    384a:	88 1f       	adc	r24, r24
    384c:	8b bf       	out	0x3b, r24	; 59
    384e:	07 90       	elpm	r0, Z+
    3850:	f6 91       	elpm	r31, Z
    3852:	e0 2d       	mov	r30, r0
    3854:	19 94       	eijmp

00003856 <malloc>:
    3856:	cf 93       	push	r28
    3858:	df 93       	push	r29
    385a:	82 30       	cpi	r24, 0x02	; 2
    385c:	91 05       	cpc	r25, r1
    385e:	10 f4       	brcc	.+4      	; 0x3864 <malloc+0xe>
    3860:	82 e0       	ldi	r24, 0x02	; 2
    3862:	90 e0       	ldi	r25, 0x00	; 0
    3864:	e0 91 c1 23 	lds	r30, 0x23C1	; 0x8023c1 <__flp>
    3868:	f0 91 c2 23 	lds	r31, 0x23C2	; 0x8023c2 <__flp+0x1>
    386c:	20 e0       	ldi	r18, 0x00	; 0
    386e:	30 e0       	ldi	r19, 0x00	; 0
    3870:	c0 e0       	ldi	r28, 0x00	; 0
    3872:	d0 e0       	ldi	r29, 0x00	; 0
    3874:	30 97       	sbiw	r30, 0x00	; 0
    3876:	11 f1       	breq	.+68     	; 0x38bc <malloc+0x66>
    3878:	40 81       	ld	r20, Z
    387a:	51 81       	ldd	r21, Z+1	; 0x01
    387c:	48 17       	cp	r20, r24
    387e:	59 07       	cpc	r21, r25
    3880:	c0 f0       	brcs	.+48     	; 0x38b2 <malloc+0x5c>
    3882:	48 17       	cp	r20, r24
    3884:	59 07       	cpc	r21, r25
    3886:	61 f4       	brne	.+24     	; 0x38a0 <malloc+0x4a>
    3888:	82 81       	ldd	r24, Z+2	; 0x02
    388a:	93 81       	ldd	r25, Z+3	; 0x03
    388c:	20 97       	sbiw	r28, 0x00	; 0
    388e:	19 f0       	breq	.+6      	; 0x3896 <malloc+0x40>
    3890:	8a 83       	std	Y+2, r24	; 0x02
    3892:	9b 83       	std	Y+3, r25	; 0x03
    3894:	2b c0       	rjmp	.+86     	; 0x38ec <malloc+0x96>
    3896:	80 93 c1 23 	sts	0x23C1, r24	; 0x8023c1 <__flp>
    389a:	90 93 c2 23 	sts	0x23C2, r25	; 0x8023c2 <__flp+0x1>
    389e:	26 c0       	rjmp	.+76     	; 0x38ec <malloc+0x96>
    38a0:	21 15       	cp	r18, r1
    38a2:	31 05       	cpc	r19, r1
    38a4:	19 f0       	breq	.+6      	; 0x38ac <malloc+0x56>
    38a6:	42 17       	cp	r20, r18
    38a8:	53 07       	cpc	r21, r19
    38aa:	18 f4       	brcc	.+6      	; 0x38b2 <malloc+0x5c>
    38ac:	9a 01       	movw	r18, r20
    38ae:	be 01       	movw	r22, r28
    38b0:	df 01       	movw	r26, r30
    38b2:	ef 01       	movw	r28, r30
    38b4:	02 80       	ldd	r0, Z+2	; 0x02
    38b6:	f3 81       	ldd	r31, Z+3	; 0x03
    38b8:	e0 2d       	mov	r30, r0
    38ba:	dc cf       	rjmp	.-72     	; 0x3874 <malloc+0x1e>
    38bc:	21 15       	cp	r18, r1
    38be:	31 05       	cpc	r19, r1
    38c0:	09 f1       	breq	.+66     	; 0x3904 <malloc+0xae>
    38c2:	28 1b       	sub	r18, r24
    38c4:	39 0b       	sbc	r19, r25
    38c6:	24 30       	cpi	r18, 0x04	; 4
    38c8:	31 05       	cpc	r19, r1
    38ca:	90 f4       	brcc	.+36     	; 0x38f0 <malloc+0x9a>
    38cc:	12 96       	adiw	r26, 0x02	; 2
    38ce:	8d 91       	ld	r24, X+
    38d0:	9c 91       	ld	r25, X
    38d2:	13 97       	sbiw	r26, 0x03	; 3
    38d4:	61 15       	cp	r22, r1
    38d6:	71 05       	cpc	r23, r1
    38d8:	21 f0       	breq	.+8      	; 0x38e2 <malloc+0x8c>
    38da:	fb 01       	movw	r30, r22
    38dc:	82 83       	std	Z+2, r24	; 0x02
    38de:	93 83       	std	Z+3, r25	; 0x03
    38e0:	04 c0       	rjmp	.+8      	; 0x38ea <malloc+0x94>
    38e2:	80 93 c1 23 	sts	0x23C1, r24	; 0x8023c1 <__flp>
    38e6:	90 93 c2 23 	sts	0x23C2, r25	; 0x8023c2 <__flp+0x1>
    38ea:	fd 01       	movw	r30, r26
    38ec:	32 96       	adiw	r30, 0x02	; 2
    38ee:	44 c0       	rjmp	.+136    	; 0x3978 <malloc+0x122>
    38f0:	fd 01       	movw	r30, r26
    38f2:	e2 0f       	add	r30, r18
    38f4:	f3 1f       	adc	r31, r19
    38f6:	81 93       	st	Z+, r24
    38f8:	91 93       	st	Z+, r25
    38fa:	22 50       	subi	r18, 0x02	; 2
    38fc:	31 09       	sbc	r19, r1
    38fe:	2d 93       	st	X+, r18
    3900:	3c 93       	st	X, r19
    3902:	3a c0       	rjmp	.+116    	; 0x3978 <malloc+0x122>
    3904:	20 91 bf 23 	lds	r18, 0x23BF	; 0x8023bf <__brkval>
    3908:	30 91 c0 23 	lds	r19, 0x23C0	; 0x8023c0 <__brkval+0x1>
    390c:	23 2b       	or	r18, r19
    390e:	41 f4       	brne	.+16     	; 0x3920 <malloc+0xca>
    3910:	20 91 02 20 	lds	r18, 0x2002	; 0x802002 <__malloc_heap_start>
    3914:	30 91 03 20 	lds	r19, 0x2003	; 0x802003 <__malloc_heap_start+0x1>
    3918:	20 93 bf 23 	sts	0x23BF, r18	; 0x8023bf <__brkval>
    391c:	30 93 c0 23 	sts	0x23C0, r19	; 0x8023c0 <__brkval+0x1>
    3920:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    3924:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    3928:	21 15       	cp	r18, r1
    392a:	31 05       	cpc	r19, r1
    392c:	41 f4       	brne	.+16     	; 0x393e <malloc+0xe8>
    392e:	2d b7       	in	r18, 0x3d	; 61
    3930:	3e b7       	in	r19, 0x3e	; 62
    3932:	40 91 04 20 	lds	r20, 0x2004	; 0x802004 <__malloc_margin>
    3936:	50 91 05 20 	lds	r21, 0x2005	; 0x802005 <__malloc_margin+0x1>
    393a:	24 1b       	sub	r18, r20
    393c:	35 0b       	sbc	r19, r21
    393e:	e0 91 bf 23 	lds	r30, 0x23BF	; 0x8023bf <__brkval>
    3942:	f0 91 c0 23 	lds	r31, 0x23C0	; 0x8023c0 <__brkval+0x1>
    3946:	e2 17       	cp	r30, r18
    3948:	f3 07       	cpc	r31, r19
    394a:	a0 f4       	brcc	.+40     	; 0x3974 <malloc+0x11e>
    394c:	2e 1b       	sub	r18, r30
    394e:	3f 0b       	sbc	r19, r31
    3950:	28 17       	cp	r18, r24
    3952:	39 07       	cpc	r19, r25
    3954:	78 f0       	brcs	.+30     	; 0x3974 <malloc+0x11e>
    3956:	ac 01       	movw	r20, r24
    3958:	4e 5f       	subi	r20, 0xFE	; 254
    395a:	5f 4f       	sbci	r21, 0xFF	; 255
    395c:	24 17       	cp	r18, r20
    395e:	35 07       	cpc	r19, r21
    3960:	48 f0       	brcs	.+18     	; 0x3974 <malloc+0x11e>
    3962:	4e 0f       	add	r20, r30
    3964:	5f 1f       	adc	r21, r31
    3966:	40 93 bf 23 	sts	0x23BF, r20	; 0x8023bf <__brkval>
    396a:	50 93 c0 23 	sts	0x23C0, r21	; 0x8023c0 <__brkval+0x1>
    396e:	81 93       	st	Z+, r24
    3970:	91 93       	st	Z+, r25
    3972:	02 c0       	rjmp	.+4      	; 0x3978 <malloc+0x122>
    3974:	e0 e0       	ldi	r30, 0x00	; 0
    3976:	f0 e0       	ldi	r31, 0x00	; 0
    3978:	cf 01       	movw	r24, r30
    397a:	df 91       	pop	r29
    397c:	cf 91       	pop	r28
    397e:	08 95       	ret

00003980 <free>:
    3980:	0f 93       	push	r16
    3982:	1f 93       	push	r17
    3984:	cf 93       	push	r28
    3986:	df 93       	push	r29
    3988:	00 97       	sbiw	r24, 0x00	; 0
    398a:	09 f4       	brne	.+2      	; 0x398e <free+0xe>
    398c:	8c c0       	rjmp	.+280    	; 0x3aa6 <free+0x126>
    398e:	fc 01       	movw	r30, r24
    3990:	32 97       	sbiw	r30, 0x02	; 2
    3992:	12 82       	std	Z+2, r1	; 0x02
    3994:	13 82       	std	Z+3, r1	; 0x03
    3996:	00 91 c1 23 	lds	r16, 0x23C1	; 0x8023c1 <__flp>
    399a:	10 91 c2 23 	lds	r17, 0x23C2	; 0x8023c2 <__flp+0x1>
    399e:	01 15       	cp	r16, r1
    39a0:	11 05       	cpc	r17, r1
    39a2:	81 f4       	brne	.+32     	; 0x39c4 <free+0x44>
    39a4:	20 81       	ld	r18, Z
    39a6:	31 81       	ldd	r19, Z+1	; 0x01
    39a8:	82 0f       	add	r24, r18
    39aa:	93 1f       	adc	r25, r19
    39ac:	20 91 bf 23 	lds	r18, 0x23BF	; 0x8023bf <__brkval>
    39b0:	30 91 c0 23 	lds	r19, 0x23C0	; 0x8023c0 <__brkval+0x1>
    39b4:	28 17       	cp	r18, r24
    39b6:	39 07       	cpc	r19, r25
    39b8:	79 f5       	brne	.+94     	; 0x3a18 <free+0x98>
    39ba:	e0 93 bf 23 	sts	0x23BF, r30	; 0x8023bf <__brkval>
    39be:	f0 93 c0 23 	sts	0x23C0, r31	; 0x8023c0 <__brkval+0x1>
    39c2:	71 c0       	rjmp	.+226    	; 0x3aa6 <free+0x126>
    39c4:	d8 01       	movw	r26, r16
    39c6:	40 e0       	ldi	r20, 0x00	; 0
    39c8:	50 e0       	ldi	r21, 0x00	; 0
    39ca:	ae 17       	cp	r26, r30
    39cc:	bf 07       	cpc	r27, r31
    39ce:	50 f4       	brcc	.+20     	; 0x39e4 <free+0x64>
    39d0:	12 96       	adiw	r26, 0x02	; 2
    39d2:	2d 91       	ld	r18, X+
    39d4:	3c 91       	ld	r19, X
    39d6:	13 97       	sbiw	r26, 0x03	; 3
    39d8:	ad 01       	movw	r20, r26
    39da:	21 15       	cp	r18, r1
    39dc:	31 05       	cpc	r19, r1
    39de:	09 f1       	breq	.+66     	; 0x3a22 <free+0xa2>
    39e0:	d9 01       	movw	r26, r18
    39e2:	f3 cf       	rjmp	.-26     	; 0x39ca <free+0x4a>
    39e4:	9d 01       	movw	r18, r26
    39e6:	da 01       	movw	r26, r20
    39e8:	22 83       	std	Z+2, r18	; 0x02
    39ea:	33 83       	std	Z+3, r19	; 0x03
    39ec:	60 81       	ld	r22, Z
    39ee:	71 81       	ldd	r23, Z+1	; 0x01
    39f0:	86 0f       	add	r24, r22
    39f2:	97 1f       	adc	r25, r23
    39f4:	82 17       	cp	r24, r18
    39f6:	93 07       	cpc	r25, r19
    39f8:	69 f4       	brne	.+26     	; 0x3a14 <free+0x94>
    39fa:	ec 01       	movw	r28, r24
    39fc:	28 81       	ld	r18, Y
    39fe:	39 81       	ldd	r19, Y+1	; 0x01
    3a00:	26 0f       	add	r18, r22
    3a02:	37 1f       	adc	r19, r23
    3a04:	2e 5f       	subi	r18, 0xFE	; 254
    3a06:	3f 4f       	sbci	r19, 0xFF	; 255
    3a08:	20 83       	st	Z, r18
    3a0a:	31 83       	std	Z+1, r19	; 0x01
    3a0c:	8a 81       	ldd	r24, Y+2	; 0x02
    3a0e:	9b 81       	ldd	r25, Y+3	; 0x03
    3a10:	82 83       	std	Z+2, r24	; 0x02
    3a12:	93 83       	std	Z+3, r25	; 0x03
    3a14:	45 2b       	or	r20, r21
    3a16:	29 f4       	brne	.+10     	; 0x3a22 <free+0xa2>
    3a18:	e0 93 c1 23 	sts	0x23C1, r30	; 0x8023c1 <__flp>
    3a1c:	f0 93 c2 23 	sts	0x23C2, r31	; 0x8023c2 <__flp+0x1>
    3a20:	42 c0       	rjmp	.+132    	; 0x3aa6 <free+0x126>
    3a22:	12 96       	adiw	r26, 0x02	; 2
    3a24:	ed 93       	st	X+, r30
    3a26:	fc 93       	st	X, r31
    3a28:	13 97       	sbiw	r26, 0x03	; 3
    3a2a:	ed 01       	movw	r28, r26
    3a2c:	49 91       	ld	r20, Y+
    3a2e:	59 91       	ld	r21, Y+
    3a30:	9e 01       	movw	r18, r28
    3a32:	24 0f       	add	r18, r20
    3a34:	35 1f       	adc	r19, r21
    3a36:	e2 17       	cp	r30, r18
    3a38:	f3 07       	cpc	r31, r19
    3a3a:	71 f4       	brne	.+28     	; 0x3a58 <free+0xd8>
    3a3c:	80 81       	ld	r24, Z
    3a3e:	91 81       	ldd	r25, Z+1	; 0x01
    3a40:	84 0f       	add	r24, r20
    3a42:	95 1f       	adc	r25, r21
    3a44:	02 96       	adiw	r24, 0x02	; 2
    3a46:	8d 93       	st	X+, r24
    3a48:	9c 93       	st	X, r25
    3a4a:	11 97       	sbiw	r26, 0x01	; 1
    3a4c:	82 81       	ldd	r24, Z+2	; 0x02
    3a4e:	93 81       	ldd	r25, Z+3	; 0x03
    3a50:	12 96       	adiw	r26, 0x02	; 2
    3a52:	8d 93       	st	X+, r24
    3a54:	9c 93       	st	X, r25
    3a56:	13 97       	sbiw	r26, 0x03	; 3
    3a58:	e0 e0       	ldi	r30, 0x00	; 0
    3a5a:	f0 e0       	ldi	r31, 0x00	; 0
    3a5c:	d8 01       	movw	r26, r16
    3a5e:	12 96       	adiw	r26, 0x02	; 2
    3a60:	8d 91       	ld	r24, X+
    3a62:	9c 91       	ld	r25, X
    3a64:	13 97       	sbiw	r26, 0x03	; 3
    3a66:	00 97       	sbiw	r24, 0x00	; 0
    3a68:	19 f0       	breq	.+6      	; 0x3a70 <free+0xf0>
    3a6a:	f8 01       	movw	r30, r16
    3a6c:	8c 01       	movw	r16, r24
    3a6e:	f6 cf       	rjmp	.-20     	; 0x3a5c <free+0xdc>
    3a70:	8d 91       	ld	r24, X+
    3a72:	9c 91       	ld	r25, X
    3a74:	98 01       	movw	r18, r16
    3a76:	2e 5f       	subi	r18, 0xFE	; 254
    3a78:	3f 4f       	sbci	r19, 0xFF	; 255
    3a7a:	82 0f       	add	r24, r18
    3a7c:	93 1f       	adc	r25, r19
    3a7e:	20 91 bf 23 	lds	r18, 0x23BF	; 0x8023bf <__brkval>
    3a82:	30 91 c0 23 	lds	r19, 0x23C0	; 0x8023c0 <__brkval+0x1>
    3a86:	28 17       	cp	r18, r24
    3a88:	39 07       	cpc	r19, r25
    3a8a:	69 f4       	brne	.+26     	; 0x3aa6 <free+0x126>
    3a8c:	30 97       	sbiw	r30, 0x00	; 0
    3a8e:	29 f4       	brne	.+10     	; 0x3a9a <free+0x11a>
    3a90:	10 92 c1 23 	sts	0x23C1, r1	; 0x8023c1 <__flp>
    3a94:	10 92 c2 23 	sts	0x23C2, r1	; 0x8023c2 <__flp+0x1>
    3a98:	02 c0       	rjmp	.+4      	; 0x3a9e <free+0x11e>
    3a9a:	12 82       	std	Z+2, r1	; 0x02
    3a9c:	13 82       	std	Z+3, r1	; 0x03
    3a9e:	00 93 bf 23 	sts	0x23BF, r16	; 0x8023bf <__brkval>
    3aa2:	10 93 c0 23 	sts	0x23C0, r17	; 0x8023c0 <__brkval+0x1>
    3aa6:	df 91       	pop	r29
    3aa8:	cf 91       	pop	r28
    3aaa:	1f 91       	pop	r17
    3aac:	0f 91       	pop	r16
    3aae:	08 95       	ret

00003ab0 <memcpy>:
    3ab0:	fb 01       	movw	r30, r22
    3ab2:	dc 01       	movw	r26, r24
    3ab4:	02 c0       	rjmp	.+4      	; 0x3aba <memcpy+0xa>
    3ab6:	01 90       	ld	r0, Z+
    3ab8:	0d 92       	st	X+, r0
    3aba:	41 50       	subi	r20, 0x01	; 1
    3abc:	50 40       	sbci	r21, 0x00	; 0
    3abe:	d8 f7       	brcc	.-10     	; 0x3ab6 <memcpy+0x6>
    3ac0:	08 95       	ret

00003ac2 <snprintf>:
    3ac2:	0f 93       	push	r16
    3ac4:	1f 93       	push	r17
    3ac6:	cf 93       	push	r28
    3ac8:	df 93       	push	r29
    3aca:	cd b7       	in	r28, 0x3d	; 61
    3acc:	de b7       	in	r29, 0x3e	; 62
    3ace:	2e 97       	sbiw	r28, 0x0e	; 14
    3ad0:	cd bf       	out	0x3d, r28	; 61
    3ad2:	de bf       	out	0x3e, r29	; 62
    3ad4:	0e 89       	ldd	r16, Y+22	; 0x16
    3ad6:	1f 89       	ldd	r17, Y+23	; 0x17
    3ad8:	88 8d       	ldd	r24, Y+24	; 0x18
    3ada:	99 8d       	ldd	r25, Y+25	; 0x19
    3adc:	26 e0       	ldi	r18, 0x06	; 6
    3ade:	2c 83       	std	Y+4, r18	; 0x04
    3ae0:	09 83       	std	Y+1, r16	; 0x01
    3ae2:	1a 83       	std	Y+2, r17	; 0x02
    3ae4:	97 ff       	sbrs	r25, 7
    3ae6:	02 c0       	rjmp	.+4      	; 0x3aec <snprintf+0x2a>
    3ae8:	80 e0       	ldi	r24, 0x00	; 0
    3aea:	90 e8       	ldi	r25, 0x80	; 128
    3aec:	01 97       	sbiw	r24, 0x01	; 1
    3aee:	8d 83       	std	Y+5, r24	; 0x05
    3af0:	9e 83       	std	Y+6, r25	; 0x06
    3af2:	ae 01       	movw	r20, r28
    3af4:	44 5e       	subi	r20, 0xE4	; 228
    3af6:	5f 4f       	sbci	r21, 0xFF	; 255
    3af8:	6a 8d       	ldd	r22, Y+26	; 0x1a
    3afa:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3afc:	ce 01       	movw	r24, r28
    3afe:	01 96       	adiw	r24, 0x01	; 1
    3b00:	16 d0       	rcall	.+44     	; 0x3b2e <vfprintf>
    3b02:	4d 81       	ldd	r20, Y+5	; 0x05
    3b04:	5e 81       	ldd	r21, Y+6	; 0x06
    3b06:	57 fd       	sbrc	r21, 7
    3b08:	0a c0       	rjmp	.+20     	; 0x3b1e <snprintf+0x5c>
    3b0a:	2f 81       	ldd	r18, Y+7	; 0x07
    3b0c:	38 85       	ldd	r19, Y+8	; 0x08
    3b0e:	42 17       	cp	r20, r18
    3b10:	53 07       	cpc	r21, r19
    3b12:	0c f4       	brge	.+2      	; 0x3b16 <snprintf+0x54>
    3b14:	9a 01       	movw	r18, r20
    3b16:	f8 01       	movw	r30, r16
    3b18:	e2 0f       	add	r30, r18
    3b1a:	f3 1f       	adc	r31, r19
    3b1c:	10 82       	st	Z, r1
    3b1e:	2e 96       	adiw	r28, 0x0e	; 14
    3b20:	cd bf       	out	0x3d, r28	; 61
    3b22:	de bf       	out	0x3e, r29	; 62
    3b24:	df 91       	pop	r29
    3b26:	cf 91       	pop	r28
    3b28:	1f 91       	pop	r17
    3b2a:	0f 91       	pop	r16
    3b2c:	08 95       	ret

00003b2e <vfprintf>:
    3b2e:	2f 92       	push	r2
    3b30:	3f 92       	push	r3
    3b32:	4f 92       	push	r4
    3b34:	5f 92       	push	r5
    3b36:	6f 92       	push	r6
    3b38:	7f 92       	push	r7
    3b3a:	8f 92       	push	r8
    3b3c:	9f 92       	push	r9
    3b3e:	af 92       	push	r10
    3b40:	bf 92       	push	r11
    3b42:	cf 92       	push	r12
    3b44:	df 92       	push	r13
    3b46:	ef 92       	push	r14
    3b48:	ff 92       	push	r15
    3b4a:	0f 93       	push	r16
    3b4c:	1f 93       	push	r17
    3b4e:	cf 93       	push	r28
    3b50:	df 93       	push	r29
    3b52:	cd b7       	in	r28, 0x3d	; 61
    3b54:	de b7       	in	r29, 0x3e	; 62
    3b56:	2c 97       	sbiw	r28, 0x0c	; 12
    3b58:	cd bf       	out	0x3d, r28	; 61
    3b5a:	de bf       	out	0x3e, r29	; 62
    3b5c:	7c 01       	movw	r14, r24
    3b5e:	6b 01       	movw	r12, r22
    3b60:	8a 01       	movw	r16, r20
    3b62:	fc 01       	movw	r30, r24
    3b64:	16 82       	std	Z+6, r1	; 0x06
    3b66:	17 82       	std	Z+7, r1	; 0x07
    3b68:	83 81       	ldd	r24, Z+3	; 0x03
    3b6a:	81 ff       	sbrs	r24, 1
    3b6c:	b0 c1       	rjmp	.+864    	; 0x3ece <vfprintf+0x3a0>
    3b6e:	ce 01       	movw	r24, r28
    3b70:	01 96       	adiw	r24, 0x01	; 1
    3b72:	4c 01       	movw	r8, r24
    3b74:	f7 01       	movw	r30, r14
    3b76:	93 81       	ldd	r25, Z+3	; 0x03
    3b78:	f6 01       	movw	r30, r12
    3b7a:	93 fd       	sbrc	r25, 3
    3b7c:	85 91       	lpm	r24, Z+
    3b7e:	93 ff       	sbrs	r25, 3
    3b80:	81 91       	ld	r24, Z+
    3b82:	6f 01       	movw	r12, r30
    3b84:	88 23       	and	r24, r24
    3b86:	09 f4       	brne	.+2      	; 0x3b8a <vfprintf+0x5c>
    3b88:	9e c1       	rjmp	.+828    	; 0x3ec6 <vfprintf+0x398>
    3b8a:	85 32       	cpi	r24, 0x25	; 37
    3b8c:	39 f4       	brne	.+14     	; 0x3b9c <vfprintf+0x6e>
    3b8e:	93 fd       	sbrc	r25, 3
    3b90:	85 91       	lpm	r24, Z+
    3b92:	93 ff       	sbrs	r25, 3
    3b94:	81 91       	ld	r24, Z+
    3b96:	6f 01       	movw	r12, r30
    3b98:	85 32       	cpi	r24, 0x25	; 37
    3b9a:	21 f4       	brne	.+8      	; 0x3ba4 <vfprintf+0x76>
    3b9c:	b7 01       	movw	r22, r14
    3b9e:	90 e0       	ldi	r25, 0x00	; 0
    3ba0:	c4 d1       	rcall	.+904    	; 0x3f2a <fputc>
    3ba2:	e8 cf       	rjmp	.-48     	; 0x3b74 <vfprintf+0x46>
    3ba4:	51 2c       	mov	r5, r1
    3ba6:	31 2c       	mov	r3, r1
    3ba8:	20 e0       	ldi	r18, 0x00	; 0
    3baa:	20 32       	cpi	r18, 0x20	; 32
    3bac:	a0 f4       	brcc	.+40     	; 0x3bd6 <vfprintf+0xa8>
    3bae:	8b 32       	cpi	r24, 0x2B	; 43
    3bb0:	69 f0       	breq	.+26     	; 0x3bcc <vfprintf+0x9e>
    3bb2:	30 f4       	brcc	.+12     	; 0x3bc0 <vfprintf+0x92>
    3bb4:	80 32       	cpi	r24, 0x20	; 32
    3bb6:	59 f0       	breq	.+22     	; 0x3bce <vfprintf+0xa0>
    3bb8:	83 32       	cpi	r24, 0x23	; 35
    3bba:	69 f4       	brne	.+26     	; 0x3bd6 <vfprintf+0xa8>
    3bbc:	20 61       	ori	r18, 0x10	; 16
    3bbe:	2c c0       	rjmp	.+88     	; 0x3c18 <vfprintf+0xea>
    3bc0:	8d 32       	cpi	r24, 0x2D	; 45
    3bc2:	39 f0       	breq	.+14     	; 0x3bd2 <vfprintf+0xa4>
    3bc4:	80 33       	cpi	r24, 0x30	; 48
    3bc6:	39 f4       	brne	.+14     	; 0x3bd6 <vfprintf+0xa8>
    3bc8:	21 60       	ori	r18, 0x01	; 1
    3bca:	26 c0       	rjmp	.+76     	; 0x3c18 <vfprintf+0xea>
    3bcc:	22 60       	ori	r18, 0x02	; 2
    3bce:	24 60       	ori	r18, 0x04	; 4
    3bd0:	23 c0       	rjmp	.+70     	; 0x3c18 <vfprintf+0xea>
    3bd2:	28 60       	ori	r18, 0x08	; 8
    3bd4:	21 c0       	rjmp	.+66     	; 0x3c18 <vfprintf+0xea>
    3bd6:	27 fd       	sbrc	r18, 7
    3bd8:	27 c0       	rjmp	.+78     	; 0x3c28 <vfprintf+0xfa>
    3bda:	30 ed       	ldi	r19, 0xD0	; 208
    3bdc:	38 0f       	add	r19, r24
    3bde:	3a 30       	cpi	r19, 0x0A	; 10
    3be0:	78 f4       	brcc	.+30     	; 0x3c00 <vfprintf+0xd2>
    3be2:	26 ff       	sbrs	r18, 6
    3be4:	06 c0       	rjmp	.+12     	; 0x3bf2 <vfprintf+0xc4>
    3be6:	fa e0       	ldi	r31, 0x0A	; 10
    3be8:	5f 9e       	mul	r5, r31
    3bea:	30 0d       	add	r19, r0
    3bec:	11 24       	eor	r1, r1
    3bee:	53 2e       	mov	r5, r19
    3bf0:	13 c0       	rjmp	.+38     	; 0x3c18 <vfprintf+0xea>
    3bf2:	8a e0       	ldi	r24, 0x0A	; 10
    3bf4:	38 9e       	mul	r3, r24
    3bf6:	30 0d       	add	r19, r0
    3bf8:	11 24       	eor	r1, r1
    3bfa:	33 2e       	mov	r3, r19
    3bfc:	20 62       	ori	r18, 0x20	; 32
    3bfe:	0c c0       	rjmp	.+24     	; 0x3c18 <vfprintf+0xea>
    3c00:	8e 32       	cpi	r24, 0x2E	; 46
    3c02:	21 f4       	brne	.+8      	; 0x3c0c <vfprintf+0xde>
    3c04:	26 fd       	sbrc	r18, 6
    3c06:	5f c1       	rjmp	.+702    	; 0x3ec6 <vfprintf+0x398>
    3c08:	20 64       	ori	r18, 0x40	; 64
    3c0a:	06 c0       	rjmp	.+12     	; 0x3c18 <vfprintf+0xea>
    3c0c:	8c 36       	cpi	r24, 0x6C	; 108
    3c0e:	11 f4       	brne	.+4      	; 0x3c14 <vfprintf+0xe6>
    3c10:	20 68       	ori	r18, 0x80	; 128
    3c12:	02 c0       	rjmp	.+4      	; 0x3c18 <vfprintf+0xea>
    3c14:	88 36       	cpi	r24, 0x68	; 104
    3c16:	41 f4       	brne	.+16     	; 0x3c28 <vfprintf+0xfa>
    3c18:	f6 01       	movw	r30, r12
    3c1a:	93 fd       	sbrc	r25, 3
    3c1c:	85 91       	lpm	r24, Z+
    3c1e:	93 ff       	sbrs	r25, 3
    3c20:	81 91       	ld	r24, Z+
    3c22:	6f 01       	movw	r12, r30
    3c24:	81 11       	cpse	r24, r1
    3c26:	c1 cf       	rjmp	.-126    	; 0x3baa <vfprintf+0x7c>
    3c28:	98 2f       	mov	r25, r24
    3c2a:	9f 7d       	andi	r25, 0xDF	; 223
    3c2c:	95 54       	subi	r25, 0x45	; 69
    3c2e:	93 30       	cpi	r25, 0x03	; 3
    3c30:	28 f4       	brcc	.+10     	; 0x3c3c <vfprintf+0x10e>
    3c32:	0c 5f       	subi	r16, 0xFC	; 252
    3c34:	1f 4f       	sbci	r17, 0xFF	; 255
    3c36:	ff e3       	ldi	r31, 0x3F	; 63
    3c38:	f9 83       	std	Y+1, r31	; 0x01
    3c3a:	0d c0       	rjmp	.+26     	; 0x3c56 <vfprintf+0x128>
    3c3c:	83 36       	cpi	r24, 0x63	; 99
    3c3e:	31 f0       	breq	.+12     	; 0x3c4c <vfprintf+0x11e>
    3c40:	83 37       	cpi	r24, 0x73	; 115
    3c42:	71 f0       	breq	.+28     	; 0x3c60 <vfprintf+0x132>
    3c44:	83 35       	cpi	r24, 0x53	; 83
    3c46:	09 f0       	breq	.+2      	; 0x3c4a <vfprintf+0x11c>
    3c48:	57 c0       	rjmp	.+174    	; 0x3cf8 <vfprintf+0x1ca>
    3c4a:	21 c0       	rjmp	.+66     	; 0x3c8e <vfprintf+0x160>
    3c4c:	f8 01       	movw	r30, r16
    3c4e:	80 81       	ld	r24, Z
    3c50:	89 83       	std	Y+1, r24	; 0x01
    3c52:	0e 5f       	subi	r16, 0xFE	; 254
    3c54:	1f 4f       	sbci	r17, 0xFF	; 255
    3c56:	44 24       	eor	r4, r4
    3c58:	43 94       	inc	r4
    3c5a:	51 2c       	mov	r5, r1
    3c5c:	54 01       	movw	r10, r8
    3c5e:	14 c0       	rjmp	.+40     	; 0x3c88 <vfprintf+0x15a>
    3c60:	38 01       	movw	r6, r16
    3c62:	f2 e0       	ldi	r31, 0x02	; 2
    3c64:	6f 0e       	add	r6, r31
    3c66:	71 1c       	adc	r7, r1
    3c68:	f8 01       	movw	r30, r16
    3c6a:	a0 80       	ld	r10, Z
    3c6c:	b1 80       	ldd	r11, Z+1	; 0x01
    3c6e:	26 ff       	sbrs	r18, 6
    3c70:	03 c0       	rjmp	.+6      	; 0x3c78 <vfprintf+0x14a>
    3c72:	65 2d       	mov	r22, r5
    3c74:	70 e0       	ldi	r23, 0x00	; 0
    3c76:	02 c0       	rjmp	.+4      	; 0x3c7c <vfprintf+0x14e>
    3c78:	6f ef       	ldi	r22, 0xFF	; 255
    3c7a:	7f ef       	ldi	r23, 0xFF	; 255
    3c7c:	c5 01       	movw	r24, r10
    3c7e:	2c 87       	std	Y+12, r18	; 0x0c
    3c80:	49 d1       	rcall	.+658    	; 0x3f14 <strnlen>
    3c82:	2c 01       	movw	r4, r24
    3c84:	83 01       	movw	r16, r6
    3c86:	2c 85       	ldd	r18, Y+12	; 0x0c
    3c88:	2f 77       	andi	r18, 0x7F	; 127
    3c8a:	22 2e       	mov	r2, r18
    3c8c:	16 c0       	rjmp	.+44     	; 0x3cba <vfprintf+0x18c>
    3c8e:	38 01       	movw	r6, r16
    3c90:	f2 e0       	ldi	r31, 0x02	; 2
    3c92:	6f 0e       	add	r6, r31
    3c94:	71 1c       	adc	r7, r1
    3c96:	f8 01       	movw	r30, r16
    3c98:	a0 80       	ld	r10, Z
    3c9a:	b1 80       	ldd	r11, Z+1	; 0x01
    3c9c:	26 ff       	sbrs	r18, 6
    3c9e:	03 c0       	rjmp	.+6      	; 0x3ca6 <vfprintf+0x178>
    3ca0:	65 2d       	mov	r22, r5
    3ca2:	70 e0       	ldi	r23, 0x00	; 0
    3ca4:	02 c0       	rjmp	.+4      	; 0x3caa <vfprintf+0x17c>
    3ca6:	6f ef       	ldi	r22, 0xFF	; 255
    3ca8:	7f ef       	ldi	r23, 0xFF	; 255
    3caa:	c5 01       	movw	r24, r10
    3cac:	2c 87       	std	Y+12, r18	; 0x0c
    3cae:	27 d1       	rcall	.+590    	; 0x3efe <strnlen_P>
    3cb0:	2c 01       	movw	r4, r24
    3cb2:	2c 85       	ldd	r18, Y+12	; 0x0c
    3cb4:	20 68       	ori	r18, 0x80	; 128
    3cb6:	22 2e       	mov	r2, r18
    3cb8:	83 01       	movw	r16, r6
    3cba:	23 fc       	sbrc	r2, 3
    3cbc:	19 c0       	rjmp	.+50     	; 0x3cf0 <vfprintf+0x1c2>
    3cbe:	83 2d       	mov	r24, r3
    3cc0:	90 e0       	ldi	r25, 0x00	; 0
    3cc2:	48 16       	cp	r4, r24
    3cc4:	59 06       	cpc	r5, r25
    3cc6:	a0 f4       	brcc	.+40     	; 0x3cf0 <vfprintf+0x1c2>
    3cc8:	b7 01       	movw	r22, r14
    3cca:	80 e2       	ldi	r24, 0x20	; 32
    3ccc:	90 e0       	ldi	r25, 0x00	; 0
    3cce:	2d d1       	rcall	.+602    	; 0x3f2a <fputc>
    3cd0:	3a 94       	dec	r3
    3cd2:	f5 cf       	rjmp	.-22     	; 0x3cbe <vfprintf+0x190>
    3cd4:	f5 01       	movw	r30, r10
    3cd6:	27 fc       	sbrc	r2, 7
    3cd8:	85 91       	lpm	r24, Z+
    3cda:	27 fe       	sbrs	r2, 7
    3cdc:	81 91       	ld	r24, Z+
    3cde:	5f 01       	movw	r10, r30
    3ce0:	b7 01       	movw	r22, r14
    3ce2:	90 e0       	ldi	r25, 0x00	; 0
    3ce4:	22 d1       	rcall	.+580    	; 0x3f2a <fputc>
    3ce6:	31 10       	cpse	r3, r1
    3ce8:	3a 94       	dec	r3
    3cea:	f1 e0       	ldi	r31, 0x01	; 1
    3cec:	4f 1a       	sub	r4, r31
    3cee:	51 08       	sbc	r5, r1
    3cf0:	41 14       	cp	r4, r1
    3cf2:	51 04       	cpc	r5, r1
    3cf4:	79 f7       	brne	.-34     	; 0x3cd4 <vfprintf+0x1a6>
    3cf6:	de c0       	rjmp	.+444    	; 0x3eb4 <vfprintf+0x386>
    3cf8:	84 36       	cpi	r24, 0x64	; 100
    3cfa:	11 f0       	breq	.+4      	; 0x3d00 <vfprintf+0x1d2>
    3cfc:	89 36       	cpi	r24, 0x69	; 105
    3cfe:	31 f5       	brne	.+76     	; 0x3d4c <vfprintf+0x21e>
    3d00:	f8 01       	movw	r30, r16
    3d02:	27 ff       	sbrs	r18, 7
    3d04:	07 c0       	rjmp	.+14     	; 0x3d14 <vfprintf+0x1e6>
    3d06:	60 81       	ld	r22, Z
    3d08:	71 81       	ldd	r23, Z+1	; 0x01
    3d0a:	82 81       	ldd	r24, Z+2	; 0x02
    3d0c:	93 81       	ldd	r25, Z+3	; 0x03
    3d0e:	0c 5f       	subi	r16, 0xFC	; 252
    3d10:	1f 4f       	sbci	r17, 0xFF	; 255
    3d12:	08 c0       	rjmp	.+16     	; 0x3d24 <vfprintf+0x1f6>
    3d14:	60 81       	ld	r22, Z
    3d16:	71 81       	ldd	r23, Z+1	; 0x01
    3d18:	07 2e       	mov	r0, r23
    3d1a:	00 0c       	add	r0, r0
    3d1c:	88 0b       	sbc	r24, r24
    3d1e:	99 0b       	sbc	r25, r25
    3d20:	0e 5f       	subi	r16, 0xFE	; 254
    3d22:	1f 4f       	sbci	r17, 0xFF	; 255
    3d24:	2f 76       	andi	r18, 0x6F	; 111
    3d26:	72 2e       	mov	r7, r18
    3d28:	97 ff       	sbrs	r25, 7
    3d2a:	09 c0       	rjmp	.+18     	; 0x3d3e <vfprintf+0x210>
    3d2c:	90 95       	com	r25
    3d2e:	80 95       	com	r24
    3d30:	70 95       	com	r23
    3d32:	61 95       	neg	r22
    3d34:	7f 4f       	sbci	r23, 0xFF	; 255
    3d36:	8f 4f       	sbci	r24, 0xFF	; 255
    3d38:	9f 4f       	sbci	r25, 0xFF	; 255
    3d3a:	20 68       	ori	r18, 0x80	; 128
    3d3c:	72 2e       	mov	r7, r18
    3d3e:	2a e0       	ldi	r18, 0x0A	; 10
    3d40:	30 e0       	ldi	r19, 0x00	; 0
    3d42:	a4 01       	movw	r20, r8
    3d44:	2a d1       	rcall	.+596    	; 0x3f9a <__ultoa_invert>
    3d46:	a8 2e       	mov	r10, r24
    3d48:	a8 18       	sub	r10, r8
    3d4a:	43 c0       	rjmp	.+134    	; 0x3dd2 <vfprintf+0x2a4>
    3d4c:	85 37       	cpi	r24, 0x75	; 117
    3d4e:	29 f4       	brne	.+10     	; 0x3d5a <vfprintf+0x22c>
    3d50:	2f 7e       	andi	r18, 0xEF	; 239
    3d52:	b2 2e       	mov	r11, r18
    3d54:	2a e0       	ldi	r18, 0x0A	; 10
    3d56:	30 e0       	ldi	r19, 0x00	; 0
    3d58:	25 c0       	rjmp	.+74     	; 0x3da4 <vfprintf+0x276>
    3d5a:	f2 2f       	mov	r31, r18
    3d5c:	f9 7f       	andi	r31, 0xF9	; 249
    3d5e:	bf 2e       	mov	r11, r31
    3d60:	8f 36       	cpi	r24, 0x6F	; 111
    3d62:	c1 f0       	breq	.+48     	; 0x3d94 <vfprintf+0x266>
    3d64:	18 f4       	brcc	.+6      	; 0x3d6c <vfprintf+0x23e>
    3d66:	88 35       	cpi	r24, 0x58	; 88
    3d68:	79 f0       	breq	.+30     	; 0x3d88 <vfprintf+0x25a>
    3d6a:	ad c0       	rjmp	.+346    	; 0x3ec6 <vfprintf+0x398>
    3d6c:	80 37       	cpi	r24, 0x70	; 112
    3d6e:	19 f0       	breq	.+6      	; 0x3d76 <vfprintf+0x248>
    3d70:	88 37       	cpi	r24, 0x78	; 120
    3d72:	21 f0       	breq	.+8      	; 0x3d7c <vfprintf+0x24e>
    3d74:	a8 c0       	rjmp	.+336    	; 0x3ec6 <vfprintf+0x398>
    3d76:	2f 2f       	mov	r18, r31
    3d78:	20 61       	ori	r18, 0x10	; 16
    3d7a:	b2 2e       	mov	r11, r18
    3d7c:	b4 fe       	sbrs	r11, 4
    3d7e:	0d c0       	rjmp	.+26     	; 0x3d9a <vfprintf+0x26c>
    3d80:	8b 2d       	mov	r24, r11
    3d82:	84 60       	ori	r24, 0x04	; 4
    3d84:	b8 2e       	mov	r11, r24
    3d86:	09 c0       	rjmp	.+18     	; 0x3d9a <vfprintf+0x26c>
    3d88:	24 ff       	sbrs	r18, 4
    3d8a:	0a c0       	rjmp	.+20     	; 0x3da0 <vfprintf+0x272>
    3d8c:	9f 2f       	mov	r25, r31
    3d8e:	96 60       	ori	r25, 0x06	; 6
    3d90:	b9 2e       	mov	r11, r25
    3d92:	06 c0       	rjmp	.+12     	; 0x3da0 <vfprintf+0x272>
    3d94:	28 e0       	ldi	r18, 0x08	; 8
    3d96:	30 e0       	ldi	r19, 0x00	; 0
    3d98:	05 c0       	rjmp	.+10     	; 0x3da4 <vfprintf+0x276>
    3d9a:	20 e1       	ldi	r18, 0x10	; 16
    3d9c:	30 e0       	ldi	r19, 0x00	; 0
    3d9e:	02 c0       	rjmp	.+4      	; 0x3da4 <vfprintf+0x276>
    3da0:	20 e1       	ldi	r18, 0x10	; 16
    3da2:	32 e0       	ldi	r19, 0x02	; 2
    3da4:	f8 01       	movw	r30, r16
    3da6:	b7 fe       	sbrs	r11, 7
    3da8:	07 c0       	rjmp	.+14     	; 0x3db8 <vfprintf+0x28a>
    3daa:	60 81       	ld	r22, Z
    3dac:	71 81       	ldd	r23, Z+1	; 0x01
    3dae:	82 81       	ldd	r24, Z+2	; 0x02
    3db0:	93 81       	ldd	r25, Z+3	; 0x03
    3db2:	0c 5f       	subi	r16, 0xFC	; 252
    3db4:	1f 4f       	sbci	r17, 0xFF	; 255
    3db6:	06 c0       	rjmp	.+12     	; 0x3dc4 <vfprintf+0x296>
    3db8:	60 81       	ld	r22, Z
    3dba:	71 81       	ldd	r23, Z+1	; 0x01
    3dbc:	80 e0       	ldi	r24, 0x00	; 0
    3dbe:	90 e0       	ldi	r25, 0x00	; 0
    3dc0:	0e 5f       	subi	r16, 0xFE	; 254
    3dc2:	1f 4f       	sbci	r17, 0xFF	; 255
    3dc4:	a4 01       	movw	r20, r8
    3dc6:	e9 d0       	rcall	.+466    	; 0x3f9a <__ultoa_invert>
    3dc8:	a8 2e       	mov	r10, r24
    3dca:	a8 18       	sub	r10, r8
    3dcc:	fb 2d       	mov	r31, r11
    3dce:	ff 77       	andi	r31, 0x7F	; 127
    3dd0:	7f 2e       	mov	r7, r31
    3dd2:	76 fe       	sbrs	r7, 6
    3dd4:	0b c0       	rjmp	.+22     	; 0x3dec <vfprintf+0x2be>
    3dd6:	37 2d       	mov	r19, r7
    3dd8:	3e 7f       	andi	r19, 0xFE	; 254
    3dda:	a5 14       	cp	r10, r5
    3ddc:	50 f4       	brcc	.+20     	; 0x3df2 <vfprintf+0x2c4>
    3dde:	74 fe       	sbrs	r7, 4
    3de0:	0a c0       	rjmp	.+20     	; 0x3df6 <vfprintf+0x2c8>
    3de2:	72 fc       	sbrc	r7, 2
    3de4:	08 c0       	rjmp	.+16     	; 0x3df6 <vfprintf+0x2c8>
    3de6:	37 2d       	mov	r19, r7
    3de8:	3e 7e       	andi	r19, 0xEE	; 238
    3dea:	05 c0       	rjmp	.+10     	; 0x3df6 <vfprintf+0x2c8>
    3dec:	ba 2c       	mov	r11, r10
    3dee:	37 2d       	mov	r19, r7
    3df0:	03 c0       	rjmp	.+6      	; 0x3df8 <vfprintf+0x2ca>
    3df2:	ba 2c       	mov	r11, r10
    3df4:	01 c0       	rjmp	.+2      	; 0x3df8 <vfprintf+0x2ca>
    3df6:	b5 2c       	mov	r11, r5
    3df8:	34 ff       	sbrs	r19, 4
    3dfa:	0d c0       	rjmp	.+26     	; 0x3e16 <vfprintf+0x2e8>
    3dfc:	fe 01       	movw	r30, r28
    3dfe:	ea 0d       	add	r30, r10
    3e00:	f1 1d       	adc	r31, r1
    3e02:	80 81       	ld	r24, Z
    3e04:	80 33       	cpi	r24, 0x30	; 48
    3e06:	11 f4       	brne	.+4      	; 0x3e0c <vfprintf+0x2de>
    3e08:	39 7e       	andi	r19, 0xE9	; 233
    3e0a:	09 c0       	rjmp	.+18     	; 0x3e1e <vfprintf+0x2f0>
    3e0c:	32 ff       	sbrs	r19, 2
    3e0e:	06 c0       	rjmp	.+12     	; 0x3e1c <vfprintf+0x2ee>
    3e10:	b3 94       	inc	r11
    3e12:	b3 94       	inc	r11
    3e14:	04 c0       	rjmp	.+8      	; 0x3e1e <vfprintf+0x2f0>
    3e16:	83 2f       	mov	r24, r19
    3e18:	86 78       	andi	r24, 0x86	; 134
    3e1a:	09 f0       	breq	.+2      	; 0x3e1e <vfprintf+0x2f0>
    3e1c:	b3 94       	inc	r11
    3e1e:	33 fd       	sbrc	r19, 3
    3e20:	12 c0       	rjmp	.+36     	; 0x3e46 <vfprintf+0x318>
    3e22:	30 ff       	sbrs	r19, 0
    3e24:	06 c0       	rjmp	.+12     	; 0x3e32 <vfprintf+0x304>
    3e26:	5a 2c       	mov	r5, r10
    3e28:	b3 14       	cp	r11, r3
    3e2a:	18 f4       	brcc	.+6      	; 0x3e32 <vfprintf+0x304>
    3e2c:	53 0c       	add	r5, r3
    3e2e:	5b 18       	sub	r5, r11
    3e30:	b3 2c       	mov	r11, r3
    3e32:	b3 14       	cp	r11, r3
    3e34:	60 f4       	brcc	.+24     	; 0x3e4e <vfprintf+0x320>
    3e36:	b7 01       	movw	r22, r14
    3e38:	80 e2       	ldi	r24, 0x20	; 32
    3e3a:	90 e0       	ldi	r25, 0x00	; 0
    3e3c:	3c 87       	std	Y+12, r19	; 0x0c
    3e3e:	75 d0       	rcall	.+234    	; 0x3f2a <fputc>
    3e40:	b3 94       	inc	r11
    3e42:	3c 85       	ldd	r19, Y+12	; 0x0c
    3e44:	f6 cf       	rjmp	.-20     	; 0x3e32 <vfprintf+0x304>
    3e46:	b3 14       	cp	r11, r3
    3e48:	10 f4       	brcc	.+4      	; 0x3e4e <vfprintf+0x320>
    3e4a:	3b 18       	sub	r3, r11
    3e4c:	01 c0       	rjmp	.+2      	; 0x3e50 <vfprintf+0x322>
    3e4e:	31 2c       	mov	r3, r1
    3e50:	34 ff       	sbrs	r19, 4
    3e52:	11 c0       	rjmp	.+34     	; 0x3e76 <vfprintf+0x348>
    3e54:	b7 01       	movw	r22, r14
    3e56:	80 e3       	ldi	r24, 0x30	; 48
    3e58:	90 e0       	ldi	r25, 0x00	; 0
    3e5a:	3c 87       	std	Y+12, r19	; 0x0c
    3e5c:	66 d0       	rcall	.+204    	; 0x3f2a <fputc>
    3e5e:	3c 85       	ldd	r19, Y+12	; 0x0c
    3e60:	32 ff       	sbrs	r19, 2
    3e62:	16 c0       	rjmp	.+44     	; 0x3e90 <vfprintf+0x362>
    3e64:	31 fd       	sbrc	r19, 1
    3e66:	03 c0       	rjmp	.+6      	; 0x3e6e <vfprintf+0x340>
    3e68:	88 e7       	ldi	r24, 0x78	; 120
    3e6a:	90 e0       	ldi	r25, 0x00	; 0
    3e6c:	02 c0       	rjmp	.+4      	; 0x3e72 <vfprintf+0x344>
    3e6e:	88 e5       	ldi	r24, 0x58	; 88
    3e70:	90 e0       	ldi	r25, 0x00	; 0
    3e72:	b7 01       	movw	r22, r14
    3e74:	0c c0       	rjmp	.+24     	; 0x3e8e <vfprintf+0x360>
    3e76:	83 2f       	mov	r24, r19
    3e78:	86 78       	andi	r24, 0x86	; 134
    3e7a:	51 f0       	breq	.+20     	; 0x3e90 <vfprintf+0x362>
    3e7c:	31 ff       	sbrs	r19, 1
    3e7e:	02 c0       	rjmp	.+4      	; 0x3e84 <vfprintf+0x356>
    3e80:	8b e2       	ldi	r24, 0x2B	; 43
    3e82:	01 c0       	rjmp	.+2      	; 0x3e86 <vfprintf+0x358>
    3e84:	80 e2       	ldi	r24, 0x20	; 32
    3e86:	37 fd       	sbrc	r19, 7
    3e88:	8d e2       	ldi	r24, 0x2D	; 45
    3e8a:	b7 01       	movw	r22, r14
    3e8c:	90 e0       	ldi	r25, 0x00	; 0
    3e8e:	4d d0       	rcall	.+154    	; 0x3f2a <fputc>
    3e90:	a5 14       	cp	r10, r5
    3e92:	30 f4       	brcc	.+12     	; 0x3ea0 <vfprintf+0x372>
    3e94:	b7 01       	movw	r22, r14
    3e96:	80 e3       	ldi	r24, 0x30	; 48
    3e98:	90 e0       	ldi	r25, 0x00	; 0
    3e9a:	47 d0       	rcall	.+142    	; 0x3f2a <fputc>
    3e9c:	5a 94       	dec	r5
    3e9e:	f8 cf       	rjmp	.-16     	; 0x3e90 <vfprintf+0x362>
    3ea0:	aa 94       	dec	r10
    3ea2:	f4 01       	movw	r30, r8
    3ea4:	ea 0d       	add	r30, r10
    3ea6:	f1 1d       	adc	r31, r1
    3ea8:	80 81       	ld	r24, Z
    3eaa:	b7 01       	movw	r22, r14
    3eac:	90 e0       	ldi	r25, 0x00	; 0
    3eae:	3d d0       	rcall	.+122    	; 0x3f2a <fputc>
    3eb0:	a1 10       	cpse	r10, r1
    3eb2:	f6 cf       	rjmp	.-20     	; 0x3ea0 <vfprintf+0x372>
    3eb4:	33 20       	and	r3, r3
    3eb6:	09 f4       	brne	.+2      	; 0x3eba <vfprintf+0x38c>
    3eb8:	5d ce       	rjmp	.-838    	; 0x3b74 <vfprintf+0x46>
    3eba:	b7 01       	movw	r22, r14
    3ebc:	80 e2       	ldi	r24, 0x20	; 32
    3ebe:	90 e0       	ldi	r25, 0x00	; 0
    3ec0:	34 d0       	rcall	.+104    	; 0x3f2a <fputc>
    3ec2:	3a 94       	dec	r3
    3ec4:	f7 cf       	rjmp	.-18     	; 0x3eb4 <vfprintf+0x386>
    3ec6:	f7 01       	movw	r30, r14
    3ec8:	86 81       	ldd	r24, Z+6	; 0x06
    3eca:	97 81       	ldd	r25, Z+7	; 0x07
    3ecc:	02 c0       	rjmp	.+4      	; 0x3ed2 <vfprintf+0x3a4>
    3ece:	8f ef       	ldi	r24, 0xFF	; 255
    3ed0:	9f ef       	ldi	r25, 0xFF	; 255
    3ed2:	2c 96       	adiw	r28, 0x0c	; 12
    3ed4:	cd bf       	out	0x3d, r28	; 61
    3ed6:	de bf       	out	0x3e, r29	; 62
    3ed8:	df 91       	pop	r29
    3eda:	cf 91       	pop	r28
    3edc:	1f 91       	pop	r17
    3ede:	0f 91       	pop	r16
    3ee0:	ff 90       	pop	r15
    3ee2:	ef 90       	pop	r14
    3ee4:	df 90       	pop	r13
    3ee6:	cf 90       	pop	r12
    3ee8:	bf 90       	pop	r11
    3eea:	af 90       	pop	r10
    3eec:	9f 90       	pop	r9
    3eee:	8f 90       	pop	r8
    3ef0:	7f 90       	pop	r7
    3ef2:	6f 90       	pop	r6
    3ef4:	5f 90       	pop	r5
    3ef6:	4f 90       	pop	r4
    3ef8:	3f 90       	pop	r3
    3efa:	2f 90       	pop	r2
    3efc:	08 95       	ret

00003efe <strnlen_P>:
    3efe:	fc 01       	movw	r30, r24
    3f00:	05 90       	lpm	r0, Z+
    3f02:	61 50       	subi	r22, 0x01	; 1
    3f04:	70 40       	sbci	r23, 0x00	; 0
    3f06:	01 10       	cpse	r0, r1
    3f08:	d8 f7       	brcc	.-10     	; 0x3f00 <strnlen_P+0x2>
    3f0a:	80 95       	com	r24
    3f0c:	90 95       	com	r25
    3f0e:	8e 0f       	add	r24, r30
    3f10:	9f 1f       	adc	r25, r31
    3f12:	08 95       	ret

00003f14 <strnlen>:
    3f14:	fc 01       	movw	r30, r24
    3f16:	61 50       	subi	r22, 0x01	; 1
    3f18:	70 40       	sbci	r23, 0x00	; 0
    3f1a:	01 90       	ld	r0, Z+
    3f1c:	01 10       	cpse	r0, r1
    3f1e:	d8 f7       	brcc	.-10     	; 0x3f16 <strnlen+0x2>
    3f20:	80 95       	com	r24
    3f22:	90 95       	com	r25
    3f24:	8e 0f       	add	r24, r30
    3f26:	9f 1f       	adc	r25, r31
    3f28:	08 95       	ret

00003f2a <fputc>:
    3f2a:	0f 93       	push	r16
    3f2c:	1f 93       	push	r17
    3f2e:	cf 93       	push	r28
    3f30:	df 93       	push	r29
    3f32:	fb 01       	movw	r30, r22
    3f34:	23 81       	ldd	r18, Z+3	; 0x03
    3f36:	21 fd       	sbrc	r18, 1
    3f38:	03 c0       	rjmp	.+6      	; 0x3f40 <fputc+0x16>
    3f3a:	8f ef       	ldi	r24, 0xFF	; 255
    3f3c:	9f ef       	ldi	r25, 0xFF	; 255
    3f3e:	28 c0       	rjmp	.+80     	; 0x3f90 <fputc+0x66>
    3f40:	22 ff       	sbrs	r18, 2
    3f42:	16 c0       	rjmp	.+44     	; 0x3f70 <fputc+0x46>
    3f44:	46 81       	ldd	r20, Z+6	; 0x06
    3f46:	57 81       	ldd	r21, Z+7	; 0x07
    3f48:	24 81       	ldd	r18, Z+4	; 0x04
    3f4a:	35 81       	ldd	r19, Z+5	; 0x05
    3f4c:	42 17       	cp	r20, r18
    3f4e:	53 07       	cpc	r21, r19
    3f50:	44 f4       	brge	.+16     	; 0x3f62 <fputc+0x38>
    3f52:	a0 81       	ld	r26, Z
    3f54:	b1 81       	ldd	r27, Z+1	; 0x01
    3f56:	9d 01       	movw	r18, r26
    3f58:	2f 5f       	subi	r18, 0xFF	; 255
    3f5a:	3f 4f       	sbci	r19, 0xFF	; 255
    3f5c:	20 83       	st	Z, r18
    3f5e:	31 83       	std	Z+1, r19	; 0x01
    3f60:	8c 93       	st	X, r24
    3f62:	26 81       	ldd	r18, Z+6	; 0x06
    3f64:	37 81       	ldd	r19, Z+7	; 0x07
    3f66:	2f 5f       	subi	r18, 0xFF	; 255
    3f68:	3f 4f       	sbci	r19, 0xFF	; 255
    3f6a:	26 83       	std	Z+6, r18	; 0x06
    3f6c:	37 83       	std	Z+7, r19	; 0x07
    3f6e:	10 c0       	rjmp	.+32     	; 0x3f90 <fputc+0x66>
    3f70:	eb 01       	movw	r28, r22
    3f72:	09 2f       	mov	r16, r25
    3f74:	18 2f       	mov	r17, r24
    3f76:	00 84       	ldd	r0, Z+8	; 0x08
    3f78:	f1 85       	ldd	r31, Z+9	; 0x09
    3f7a:	e0 2d       	mov	r30, r0
    3f7c:	19 95       	eicall
    3f7e:	89 2b       	or	r24, r25
    3f80:	e1 f6       	brne	.-72     	; 0x3f3a <fputc+0x10>
    3f82:	8e 81       	ldd	r24, Y+6	; 0x06
    3f84:	9f 81       	ldd	r25, Y+7	; 0x07
    3f86:	01 96       	adiw	r24, 0x01	; 1
    3f88:	8e 83       	std	Y+6, r24	; 0x06
    3f8a:	9f 83       	std	Y+7, r25	; 0x07
    3f8c:	81 2f       	mov	r24, r17
    3f8e:	90 2f       	mov	r25, r16
    3f90:	df 91       	pop	r29
    3f92:	cf 91       	pop	r28
    3f94:	1f 91       	pop	r17
    3f96:	0f 91       	pop	r16
    3f98:	08 95       	ret

00003f9a <__ultoa_invert>:
    3f9a:	fa 01       	movw	r30, r20
    3f9c:	aa 27       	eor	r26, r26
    3f9e:	28 30       	cpi	r18, 0x08	; 8
    3fa0:	51 f1       	breq	.+84     	; 0x3ff6 <__ultoa_invert+0x5c>
    3fa2:	20 31       	cpi	r18, 0x10	; 16
    3fa4:	81 f1       	breq	.+96     	; 0x4006 <__ultoa_invert+0x6c>
    3fa6:	e8 94       	clt
    3fa8:	6f 93       	push	r22
    3faa:	6e 7f       	andi	r22, 0xFE	; 254
    3fac:	6e 5f       	subi	r22, 0xFE	; 254
    3fae:	7f 4f       	sbci	r23, 0xFF	; 255
    3fb0:	8f 4f       	sbci	r24, 0xFF	; 255
    3fb2:	9f 4f       	sbci	r25, 0xFF	; 255
    3fb4:	af 4f       	sbci	r26, 0xFF	; 255
    3fb6:	b1 e0       	ldi	r27, 0x01	; 1
    3fb8:	3e d0       	rcall	.+124    	; 0x4036 <__ultoa_invert+0x9c>
    3fba:	b4 e0       	ldi	r27, 0x04	; 4
    3fbc:	3c d0       	rcall	.+120    	; 0x4036 <__ultoa_invert+0x9c>
    3fbe:	67 0f       	add	r22, r23
    3fc0:	78 1f       	adc	r23, r24
    3fc2:	89 1f       	adc	r24, r25
    3fc4:	9a 1f       	adc	r25, r26
    3fc6:	a1 1d       	adc	r26, r1
    3fc8:	68 0f       	add	r22, r24
    3fca:	79 1f       	adc	r23, r25
    3fcc:	8a 1f       	adc	r24, r26
    3fce:	91 1d       	adc	r25, r1
    3fd0:	a1 1d       	adc	r26, r1
    3fd2:	6a 0f       	add	r22, r26
    3fd4:	71 1d       	adc	r23, r1
    3fd6:	81 1d       	adc	r24, r1
    3fd8:	91 1d       	adc	r25, r1
    3fda:	a1 1d       	adc	r26, r1
    3fdc:	20 d0       	rcall	.+64     	; 0x401e <__ultoa_invert+0x84>
    3fde:	09 f4       	brne	.+2      	; 0x3fe2 <__ultoa_invert+0x48>
    3fe0:	68 94       	set
    3fe2:	3f 91       	pop	r19
    3fe4:	2a e0       	ldi	r18, 0x0A	; 10
    3fe6:	26 9f       	mul	r18, r22
    3fe8:	11 24       	eor	r1, r1
    3fea:	30 19       	sub	r19, r0
    3fec:	30 5d       	subi	r19, 0xD0	; 208
    3fee:	31 93       	st	Z+, r19
    3ff0:	de f6       	brtc	.-74     	; 0x3fa8 <__ultoa_invert+0xe>
    3ff2:	cf 01       	movw	r24, r30
    3ff4:	08 95       	ret
    3ff6:	46 2f       	mov	r20, r22
    3ff8:	47 70       	andi	r20, 0x07	; 7
    3ffa:	40 5d       	subi	r20, 0xD0	; 208
    3ffc:	41 93       	st	Z+, r20
    3ffe:	b3 e0       	ldi	r27, 0x03	; 3
    4000:	0f d0       	rcall	.+30     	; 0x4020 <__ultoa_invert+0x86>
    4002:	c9 f7       	brne	.-14     	; 0x3ff6 <__ultoa_invert+0x5c>
    4004:	f6 cf       	rjmp	.-20     	; 0x3ff2 <__ultoa_invert+0x58>
    4006:	46 2f       	mov	r20, r22
    4008:	4f 70       	andi	r20, 0x0F	; 15
    400a:	40 5d       	subi	r20, 0xD0	; 208
    400c:	4a 33       	cpi	r20, 0x3A	; 58
    400e:	18 f0       	brcs	.+6      	; 0x4016 <__ultoa_invert+0x7c>
    4010:	49 5d       	subi	r20, 0xD9	; 217
    4012:	31 fd       	sbrc	r19, 1
    4014:	40 52       	subi	r20, 0x20	; 32
    4016:	41 93       	st	Z+, r20
    4018:	02 d0       	rcall	.+4      	; 0x401e <__ultoa_invert+0x84>
    401a:	a9 f7       	brne	.-22     	; 0x4006 <__ultoa_invert+0x6c>
    401c:	ea cf       	rjmp	.-44     	; 0x3ff2 <__ultoa_invert+0x58>
    401e:	b4 e0       	ldi	r27, 0x04	; 4
    4020:	a6 95       	lsr	r26
    4022:	97 95       	ror	r25
    4024:	87 95       	ror	r24
    4026:	77 95       	ror	r23
    4028:	67 95       	ror	r22
    402a:	ba 95       	dec	r27
    402c:	c9 f7       	brne	.-14     	; 0x4020 <__ultoa_invert+0x86>
    402e:	00 97       	sbiw	r24, 0x00	; 0
    4030:	61 05       	cpc	r22, r1
    4032:	71 05       	cpc	r23, r1
    4034:	08 95       	ret
    4036:	9b 01       	movw	r18, r22
    4038:	ac 01       	movw	r20, r24
    403a:	0a 2e       	mov	r0, r26
    403c:	06 94       	lsr	r0
    403e:	57 95       	ror	r21
    4040:	47 95       	ror	r20
    4042:	37 95       	ror	r19
    4044:	27 95       	ror	r18
    4046:	ba 95       	dec	r27
    4048:	c9 f7       	brne	.-14     	; 0x403c <__ultoa_invert+0xa2>
    404a:	62 0f       	add	r22, r18
    404c:	73 1f       	adc	r23, r19
    404e:	84 1f       	adc	r24, r20
    4050:	95 1f       	adc	r25, r21
    4052:	a0 1d       	adc	r26, r0
    4054:	08 95       	ret

00004056 <_exit>:
    4056:	f8 94       	cli

00004058 <__stop_program>:
    4058:	ff cf       	rjmp	.-2      	; 0x4058 <__stop_program>


Praktikum_5_Template_6_2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004286  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000001f2  00802000  00004286  0000431a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00003ecc  008021f2  008021f2  0000450c  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  0000450c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000044  00000000  00000000  00004568  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000710  00000000  00000000  000045b0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00012741  00000000  00000000  00004cc0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003250  00000000  00000000  00017401  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000b198  00000000  00000000  0001a651  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000183c  00000000  00000000  000257ec  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000358c5  00000000  00000000  00027028  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00009de2  00000000  00000000  0005c8ed  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000008b8  00000000  00000000  000666d0  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000c88e  00000000  00000000  00066f88  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	50 c2       	rjmp	.+1184   	; 0x4a2 <__ctors_end>
       2:	00 00       	nop
       4:	6f c2       	rjmp	.+1246   	; 0x4e4 <__bad_interrupt>
       6:	00 00       	nop
       8:	6d c2       	rjmp	.+1242   	; 0x4e4 <__bad_interrupt>
       a:	00 00       	nop
       c:	6b c2       	rjmp	.+1238   	; 0x4e4 <__bad_interrupt>
       e:	00 00       	nop
      10:	69 c2       	rjmp	.+1234   	; 0x4e4 <__bad_interrupt>
      12:	00 00       	nop
      14:	67 c2       	rjmp	.+1230   	; 0x4e4 <__bad_interrupt>
      16:	00 00       	nop
      18:	65 c2       	rjmp	.+1226   	; 0x4e4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	63 c2       	rjmp	.+1222   	; 0x4e4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	61 c2       	rjmp	.+1218   	; 0x4e4 <__bad_interrupt>
      22:	00 00       	nop
      24:	5f c2       	rjmp	.+1214   	; 0x4e4 <__bad_interrupt>
      26:	00 00       	nop
      28:	5d c2       	rjmp	.+1210   	; 0x4e4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5b c2       	rjmp	.+1206   	; 0x4e4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	59 c2       	rjmp	.+1202   	; 0x4e4 <__bad_interrupt>
      32:	00 00       	nop
      34:	57 c2       	rjmp	.+1198   	; 0x4e4 <__bad_interrupt>
      36:	00 00       	nop
      38:	0c 94 98 0f 	jmp	0x1f30	; 0x1f30 <__vector_14>
      3c:	53 c2       	rjmp	.+1190   	; 0x4e4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	51 c2       	rjmp	.+1186   	; 0x4e4 <__bad_interrupt>
      42:	00 00       	nop
      44:	4f c2       	rjmp	.+1182   	; 0x4e4 <__bad_interrupt>
      46:	00 00       	nop
      48:	4d c2       	rjmp	.+1178   	; 0x4e4 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	4b c2       	rjmp	.+1174   	; 0x4e4 <__bad_interrupt>
      4e:	00 00       	nop
      50:	49 c2       	rjmp	.+1170   	; 0x4e4 <__bad_interrupt>
      52:	00 00       	nop
      54:	47 c2       	rjmp	.+1166   	; 0x4e4 <__bad_interrupt>
      56:	00 00       	nop
      58:	45 c2       	rjmp	.+1162   	; 0x4e4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	43 c2       	rjmp	.+1158   	; 0x4e4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	41 c2       	rjmp	.+1154   	; 0x4e4 <__bad_interrupt>
      62:	00 00       	nop
      64:	3f c2       	rjmp	.+1150   	; 0x4e4 <__bad_interrupt>
      66:	00 00       	nop
      68:	3d c2       	rjmp	.+1146   	; 0x4e4 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3b c2       	rjmp	.+1142   	; 0x4e4 <__bad_interrupt>
      6e:	00 00       	nop
      70:	39 c2       	rjmp	.+1138   	; 0x4e4 <__bad_interrupt>
      72:	00 00       	nop
      74:	37 c2       	rjmp	.+1134   	; 0x4e4 <__bad_interrupt>
      76:	00 00       	nop
      78:	35 c2       	rjmp	.+1130   	; 0x4e4 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	33 c2       	rjmp	.+1126   	; 0x4e4 <__bad_interrupt>
      7e:	00 00       	nop
      80:	31 c2       	rjmp	.+1122   	; 0x4e4 <__bad_interrupt>
      82:	00 00       	nop
      84:	2f c2       	rjmp	.+1118   	; 0x4e4 <__bad_interrupt>
      86:	00 00       	nop
      88:	2d c2       	rjmp	.+1114   	; 0x4e4 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	2b c2       	rjmp	.+1110   	; 0x4e4 <__bad_interrupt>
      8e:	00 00       	nop
      90:	29 c2       	rjmp	.+1106   	; 0x4e4 <__bad_interrupt>
      92:	00 00       	nop
      94:	27 c2       	rjmp	.+1102   	; 0x4e4 <__bad_interrupt>
      96:	00 00       	nop
      98:	25 c2       	rjmp	.+1098   	; 0x4e4 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	d6 c7       	rjmp	.+4012   	; 0x104a <__vector_39>
      9e:	00 00       	nop
      a0:	0c 94 57 08 	jmp	0x10ae	; 0x10ae <__vector_40>
      a4:	0c 94 89 08 	jmp	0x1112	; 0x1112 <__vector_41>
      a8:	0c 94 bb 08 	jmp	0x1176	; 0x1176 <__vector_42>
      ac:	1b c2       	rjmp	.+1078   	; 0x4e4 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	19 c2       	rjmp	.+1074   	; 0x4e4 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	17 c2       	rjmp	.+1070   	; 0x4e4 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	15 c2       	rjmp	.+1066   	; 0x4e4 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	13 c2       	rjmp	.+1062   	; 0x4e4 <__bad_interrupt>
      be:	00 00       	nop
      c0:	11 c2       	rjmp	.+1058   	; 0x4e4 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	0f c2       	rjmp	.+1054   	; 0x4e4 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	0d c2       	rjmp	.+1050   	; 0x4e4 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0b c2       	rjmp	.+1046   	; 0x4e4 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	09 c2       	rjmp	.+1042   	; 0x4e4 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	07 c2       	rjmp	.+1038   	; 0x4e4 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	05 c2       	rjmp	.+1034   	; 0x4e4 <__bad_interrupt>
      da:	00 00       	nop
      dc:	03 c2       	rjmp	.+1030   	; 0x4e4 <__bad_interrupt>
      de:	00 00       	nop
      e0:	01 c2       	rjmp	.+1026   	; 0x4e4 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	ff c1       	rjmp	.+1022   	; 0x4e4 <__bad_interrupt>
      e6:	00 00       	nop
      e8:	fd c1       	rjmp	.+1018   	; 0x4e4 <__bad_interrupt>
      ea:	00 00       	nop
      ec:	fb c1       	rjmp	.+1014   	; 0x4e4 <__bad_interrupt>
      ee:	00 00       	nop
      f0:	f9 c1       	rjmp	.+1010   	; 0x4e4 <__bad_interrupt>
      f2:	00 00       	nop
      f4:	f7 c1       	rjmp	.+1006   	; 0x4e4 <__bad_interrupt>
      f6:	00 00       	nop
      f8:	f5 c1       	rjmp	.+1002   	; 0x4e4 <__bad_interrupt>
      fa:	00 00       	nop
      fc:	f3 c1       	rjmp	.+998    	; 0x4e4 <__bad_interrupt>
      fe:	00 00       	nop
     100:	f1 c1       	rjmp	.+994    	; 0x4e4 <__bad_interrupt>
     102:	00 00       	nop
     104:	ef c1       	rjmp	.+990    	; 0x4e4 <__bad_interrupt>
     106:	00 00       	nop
     108:	ed c1       	rjmp	.+986    	; 0x4e4 <__bad_interrupt>
     10a:	00 00       	nop
     10c:	eb c1       	rjmp	.+982    	; 0x4e4 <__bad_interrupt>
     10e:	00 00       	nop
     110:	e9 c1       	rjmp	.+978    	; 0x4e4 <__bad_interrupt>
     112:	00 00       	nop
     114:	e7 c1       	rjmp	.+974    	; 0x4e4 <__bad_interrupt>
     116:	00 00       	nop
     118:	e5 c1       	rjmp	.+970    	; 0x4e4 <__bad_interrupt>
     11a:	00 00       	nop
     11c:	ce c6       	rjmp	.+3484   	; 0xeba <__vector_71>
     11e:	00 00       	nop
     120:	fe c6       	rjmp	.+3580   	; 0xf1e <__vector_72>
     122:	00 00       	nop
     124:	2e c7       	rjmp	.+3676   	; 0xf82 <__vector_73>
     126:	00 00       	nop
     128:	5e c7       	rjmp	.+3772   	; 0xfe6 <__vector_74>
     12a:	00 00       	nop
     12c:	db c1       	rjmp	.+950    	; 0x4e4 <__bad_interrupt>
     12e:	00 00       	nop
     130:	d9 c1       	rjmp	.+946    	; 0x4e4 <__bad_interrupt>
     132:	00 00       	nop
     134:	d7 c1       	rjmp	.+942    	; 0x4e4 <__bad_interrupt>
     136:	00 00       	nop
     138:	d5 c1       	rjmp	.+938    	; 0x4e4 <__bad_interrupt>
     13a:	00 00       	nop
     13c:	d3 c1       	rjmp	.+934    	; 0x4e4 <__bad_interrupt>
     13e:	00 00       	nop
     140:	d1 c1       	rjmp	.+930    	; 0x4e4 <__bad_interrupt>
     142:	00 00       	nop
     144:	cf c1       	rjmp	.+926    	; 0x4e4 <__bad_interrupt>
     146:	00 00       	nop
     148:	cd c1       	rjmp	.+922    	; 0x4e4 <__bad_interrupt>
     14a:	00 00       	nop
     14c:	cb c1       	rjmp	.+918    	; 0x4e4 <__bad_interrupt>
     14e:	00 00       	nop
     150:	c9 c1       	rjmp	.+914    	; 0x4e4 <__bad_interrupt>
     152:	00 00       	nop
     154:	c7 c1       	rjmp	.+910    	; 0x4e4 <__bad_interrupt>
     156:	00 00       	nop
     158:	c5 c1       	rjmp	.+906    	; 0x4e4 <__bad_interrupt>
     15a:	00 00       	nop
     15c:	c3 c1       	rjmp	.+902    	; 0x4e4 <__bad_interrupt>
     15e:	00 00       	nop
     160:	c1 c1       	rjmp	.+898    	; 0x4e4 <__bad_interrupt>
     162:	00 00       	nop
     164:	bf c1       	rjmp	.+894    	; 0x4e4 <__bad_interrupt>
     166:	00 00       	nop
     168:	bd c1       	rjmp	.+890    	; 0x4e4 <__bad_interrupt>
     16a:	00 00       	nop
     16c:	bb c1       	rjmp	.+886    	; 0x4e4 <__bad_interrupt>
     16e:	00 00       	nop
     170:	b9 c1       	rjmp	.+882    	; 0x4e4 <__bad_interrupt>
     172:	00 00       	nop
     174:	b7 c1       	rjmp	.+878    	; 0x4e4 <__bad_interrupt>
     176:	00 00       	nop
     178:	b5 c1       	rjmp	.+874    	; 0x4e4 <__bad_interrupt>
     17a:	00 00       	nop
     17c:	b3 c1       	rjmp	.+870    	; 0x4e4 <__bad_interrupt>
     17e:	00 00       	nop
     180:	b1 c1       	rjmp	.+866    	; 0x4e4 <__bad_interrupt>
     182:	00 00       	nop
     184:	af c1       	rjmp	.+862    	; 0x4e4 <__bad_interrupt>
     186:	00 00       	nop
     188:	ad c1       	rjmp	.+858    	; 0x4e4 <__bad_interrupt>
     18a:	00 00       	nop
     18c:	ab c1       	rjmp	.+854    	; 0x4e4 <__bad_interrupt>
     18e:	00 00       	nop
     190:	a9 c1       	rjmp	.+850    	; 0x4e4 <__bad_interrupt>
     192:	00 00       	nop
     194:	a7 c1       	rjmp	.+846    	; 0x4e4 <__bad_interrupt>
     196:	00 00       	nop
     198:	a5 c1       	rjmp	.+842    	; 0x4e4 <__bad_interrupt>
     19a:	00 00       	nop
     19c:	a3 c1       	rjmp	.+838    	; 0x4e4 <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	a1 c1       	rjmp	.+834    	; 0x4e4 <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	9f c1       	rjmp	.+830    	; 0x4e4 <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	9d c1       	rjmp	.+826    	; 0x4e4 <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	9b c1       	rjmp	.+822    	; 0x4e4 <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	99 c1       	rjmp	.+818    	; 0x4e4 <__bad_interrupt>
     1b2:	00 00       	nop
     1b4:	97 c1       	rjmp	.+814    	; 0x4e4 <__bad_interrupt>
     1b6:	00 00       	nop
     1b8:	95 c1       	rjmp	.+810    	; 0x4e4 <__bad_interrupt>
     1ba:	00 00       	nop
     1bc:	93 c1       	rjmp	.+806    	; 0x4e4 <__bad_interrupt>
     1be:	00 00       	nop
     1c0:	91 c1       	rjmp	.+802    	; 0x4e4 <__bad_interrupt>
     1c2:	00 00       	nop
     1c4:	8f c1       	rjmp	.+798    	; 0x4e4 <__bad_interrupt>
     1c6:	00 00       	nop
     1c8:	8d c1       	rjmp	.+794    	; 0x4e4 <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	8b c1       	rjmp	.+790    	; 0x4e4 <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	89 c1       	rjmp	.+786    	; 0x4e4 <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	87 c1       	rjmp	.+782    	; 0x4e4 <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	85 c1       	rjmp	.+778    	; 0x4e4 <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	83 c1       	rjmp	.+774    	; 0x4e4 <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	81 c1       	rjmp	.+770    	; 0x4e4 <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	7f c1       	rjmp	.+766    	; 0x4e4 <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	7d c1       	rjmp	.+762    	; 0x4e4 <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	7b c1       	rjmp	.+758    	; 0x4e4 <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	79 c1       	rjmp	.+754    	; 0x4e4 <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	77 c1       	rjmp	.+750    	; 0x4e4 <__bad_interrupt>
     1f6:	00 00       	nop
     1f8:	75 c1       	rjmp	.+746    	; 0x4e4 <__bad_interrupt>
     1fa:	00 00       	nop
     1fc:	de 19       	sub	r29, r14
     1fe:	de 19       	sub	r29, r14
     200:	de 19       	sub	r29, r14
     202:	14 1a       	sub	r1, r20
     204:	04 1a       	sub	r0, r20
     206:	11 1a       	sub	r1, r17
     208:	de 19       	sub	r29, r14
     20a:	de 19       	sub	r29, r14
     20c:	14 1a       	sub	r1, r20
     20e:	04 1a       	sub	r0, r20

00000210 <__trampolines_end>:
     210:	00 00       	nop
     212:	00 00       	nop
     214:	00 00       	nop
     216:	00 20       	and	r0, r0
     218:	20 20       	and	r2, r0
     21a:	20 20       	and	r2, r0
     21c:	00 20       	and	r0, r0
     21e:	50 50       	subi	r21, 0x00	; 0
     220:	50 00       	.word	0x0050	; ????
     222:	00 00       	nop
     224:	00 50       	subi	r16, 0x00	; 0
     226:	50 f8       	bld	r5, 0
     228:	50 f8       	bld	r5, 0
     22a:	50 50       	subi	r21, 0x00	; 0
     22c:	20 78       	andi	r18, 0x80	; 128
     22e:	a0 70       	andi	r26, 0x00	; 0
     230:	28 f0       	brcs	.+10     	; 0x23c <__trampolines_end+0x2c>
     232:	20 c0       	rjmp	.+64     	; 0x274 <__trampolines_end+0x64>
     234:	c8 10       	cpse	r12, r8
     236:	20 40       	sbci	r18, 0x00	; 0
     238:	98 18       	sub	r9, r8
     23a:	60 90 a0 40 	lds	r6, 0x40A0	; 0x8040a0 <ucHeap+0x1c9e>
     23e:	a8 90       	.word	0x90a8	; ????
     240:	68 60       	ori	r22, 0x08	; 8
     242:	20 40       	sbci	r18, 0x00	; 0
     244:	00 00       	nop
     246:	00 00       	nop
     248:	10 20       	and	r1, r0
     24a:	40 40       	sbci	r20, 0x00	; 0
     24c:	40 20       	and	r4, r0
     24e:	10 40       	sbci	r17, 0x00	; 0
     250:	20 10       	cpse	r2, r0
     252:	10 10       	cpse	r1, r0
     254:	20 40       	sbci	r18, 0x00	; 0
     256:	00 50       	subi	r16, 0x00	; 0
     258:	20 f8       	bld	r2, 0
     25a:	20 50       	subi	r18, 0x00	; 0
     25c:	00 00       	nop
     25e:	20 20       	and	r2, r0
     260:	f8 20       	and	r15, r8
     262:	20 00       	.word	0x0020	; ????
     264:	00 00       	nop
     266:	00 00       	nop
     268:	60 20       	and	r6, r0
     26a:	40 00       	.word	0x0040	; ????
     26c:	00 00       	nop
     26e:	f8 00       	.word	0x00f8	; ????
     270:	00 00       	nop
     272:	00 00       	nop
     274:	00 00       	nop
     276:	00 60       	ori	r16, 0x00	; 0
     278:	60 00       	.word	0x0060	; ????
     27a:	08 10       	cpse	r0, r8
     27c:	20 40       	sbci	r18, 0x00	; 0
     27e:	80 00       	.word	0x0080	; ????
     280:	70 88       	ldd	r7, Z+16	; 0x10
     282:	98 a8       	ldd	r9, Y+48	; 0x30
     284:	c8 88       	ldd	r12, Y+16	; 0x10
     286:	70 20       	and	r7, r0
     288:	60 20       	and	r6, r0
     28a:	20 20       	and	r2, r0
     28c:	20 70       	andi	r18, 0x00	; 0
     28e:	70 88       	ldd	r7, Z+16	; 0x10
     290:	08 10       	cpse	r0, r8
     292:	20 40       	sbci	r18, 0x00	; 0
     294:	f8 f8       	.word	0xf8f8	; ????
     296:	10 20       	and	r1, r0
     298:	10 08       	sbc	r1, r0
     29a:	88 70       	andi	r24, 0x08	; 8
     29c:	10 30       	cpi	r17, 0x00	; 0
     29e:	50 90 f8 10 	lds	r5, 0x10F8	; 0x8010f8 <__TEXT_REGION_LENGTH__+0x7010f8>
     2a2:	10 f8       	bld	r1, 0
     2a4:	80 f0       	brcs	.+32     	; 0x2c6 <__trampolines_end+0xb6>
     2a6:	08 08       	sbc	r0, r8
     2a8:	88 70       	andi	r24, 0x08	; 8
     2aa:	30 40       	sbci	r19, 0x00	; 0
     2ac:	80 f0       	brcs	.+32     	; 0x2ce <__trampolines_end+0xbe>
     2ae:	88 88       	ldd	r8, Y+16	; 0x10
     2b0:	70 f8       	bld	r7, 0
     2b2:	08 10       	cpse	r0, r8
     2b4:	20 40       	sbci	r18, 0x00	; 0
     2b6:	40 40       	sbci	r20, 0x00	; 0
     2b8:	70 88       	ldd	r7, Z+16	; 0x10
     2ba:	88 70       	andi	r24, 0x08	; 8
     2bc:	88 88       	ldd	r8, Y+16	; 0x10
     2be:	70 70       	andi	r23, 0x00	; 0
     2c0:	88 88       	ldd	r8, Y+16	; 0x10
     2c2:	78 08       	sbc	r7, r8
     2c4:	10 60       	ori	r17, 0x00	; 0
     2c6:	00 60       	ori	r16, 0x00	; 0
     2c8:	60 00       	.word	0x0060	; ????
     2ca:	60 60       	ori	r22, 0x00	; 0
     2cc:	00 00       	nop
     2ce:	60 60       	ori	r22, 0x00	; 0
     2d0:	00 60       	ori	r16, 0x00	; 0
     2d2:	20 40       	sbci	r18, 0x00	; 0
     2d4:	08 10       	cpse	r0, r8
     2d6:	20 40       	sbci	r18, 0x00	; 0
     2d8:	20 10       	cpse	r2, r0
     2da:	08 00       	.word	0x0008	; ????
     2dc:	00 f8       	bld	r0, 0
     2de:	00 f8       	bld	r0, 0
     2e0:	00 00       	nop
     2e2:	80 40       	sbci	r24, 0x00	; 0
     2e4:	20 10       	cpse	r2, r0
     2e6:	20 40       	sbci	r18, 0x00	; 0
     2e8:	80 70       	andi	r24, 0x00	; 0
     2ea:	88 08       	sbc	r8, r8
     2ec:	10 20       	and	r1, r0
     2ee:	00 20       	and	r0, r0
     2f0:	70 88       	ldd	r7, Z+16	; 0x10
     2f2:	08 68       	ori	r16, 0x88	; 136
     2f4:	a8 a8       	ldd	r10, Y+48	; 0x30
     2f6:	70 70       	andi	r23, 0x00	; 0
     2f8:	88 88       	ldd	r8, Y+16	; 0x10
     2fa:	88 f8       	.word	0xf888	; ????
     2fc:	88 88       	ldd	r8, Y+16	; 0x10
     2fe:	f0 88       	ldd	r15, Z+16	; 0x10
     300:	88 f0       	brcs	.+34     	; 0x324 <__trampolines_end+0x114>
     302:	88 88       	ldd	r8, Y+16	; 0x10
     304:	f0 70       	andi	r31, 0x00	; 0
     306:	88 80       	ld	r8, Y
     308:	80 80       	ld	r8, Z
     30a:	88 70       	andi	r24, 0x08	; 8
     30c:	e0 90 88 88 	lds	r14, 0x8888	; 0x808888 <__bss_end+0x27ca>
     310:	88 90       	.word	0x9088	; ????
     312:	e0 f8       	bld	r14, 0
     314:	80 80       	ld	r8, Z
     316:	f0 80       	ld	r15, Z
     318:	80 f8       	bld	r8, 0
     31a:	f8 80       	ld	r15, Y
     31c:	80 e0       	ldi	r24, 0x00	; 0
     31e:	80 80       	ld	r8, Z
     320:	80 70       	andi	r24, 0x00	; 0
     322:	88 80       	ld	r8, Y
     324:	80 98       	cbi	0x10, 0	; 16
     326:	88 70       	andi	r24, 0x08	; 8
     328:	88 88       	ldd	r8, Y+16	; 0x10
     32a:	88 f8       	.word	0xf888	; ????
     32c:	88 88       	ldd	r8, Y+16	; 0x10
     32e:	88 70       	andi	r24, 0x08	; 8
     330:	20 20       	and	r2, r0
     332:	20 20       	and	r2, r0
     334:	20 70       	andi	r18, 0x00	; 0
     336:	38 10       	cpse	r3, r8
     338:	10 10       	cpse	r1, r0
     33a:	10 90 60 88 	lds	r1, 0x8860	; 0x808860 <__bss_end+0x27a2>
     33e:	90 a0       	ldd	r9, Z+32	; 0x20
     340:	c0 a0       	ldd	r12, Z+32	; 0x20
     342:	90 88       	ldd	r9, Z+16	; 0x10
     344:	80 80       	ld	r8, Z
     346:	80 80       	ld	r8, Z
     348:	80 80       	ld	r8, Z
     34a:	f8 88       	ldd	r15, Y+16	; 0x10
     34c:	d8 a8       	ldd	r13, Y+48	; 0x30
     34e:	88 88       	ldd	r8, Y+16	; 0x10
     350:	88 88       	ldd	r8, Y+16	; 0x10
     352:	88 88       	ldd	r8, Y+16	; 0x10
     354:	c8 a8       	ldd	r12, Y+48	; 0x30
     356:	98 88       	ldd	r9, Y+16	; 0x10
     358:	88 70       	andi	r24, 0x08	; 8
     35a:	88 88       	ldd	r8, Y+16	; 0x10
     35c:	88 88       	ldd	r8, Y+16	; 0x10
     35e:	88 70       	andi	r24, 0x08	; 8
     360:	f0 88       	ldd	r15, Z+16	; 0x10
     362:	88 f0       	brcs	.+34     	; 0x386 <__trampolines_end+0x176>
     364:	80 80       	ld	r8, Z
     366:	80 70       	andi	r24, 0x00	; 0
     368:	88 88       	ldd	r8, Y+16	; 0x10
     36a:	88 a8       	ldd	r8, Y+48	; 0x30
     36c:	90 68       	ori	r25, 0x80	; 128
     36e:	f0 88       	ldd	r15, Z+16	; 0x10
     370:	88 f0       	brcs	.+34     	; 0x394 <__trampolines_end+0x184>
     372:	a0 90 88 78 	lds	r10, 0x7888	; 0x807888 <__bss_end+0x17ca>
     376:	80 80       	ld	r8, Z
     378:	70 08       	sbc	r7, r0
     37a:	08 f0       	brcs	.+2      	; 0x37e <__trampolines_end+0x16e>
     37c:	f8 20       	and	r15, r8
     37e:	20 20       	and	r2, r0
     380:	20 20       	and	r2, r0
     382:	20 88       	ldd	r2, Z+16	; 0x10
     384:	88 88       	ldd	r8, Y+16	; 0x10
     386:	88 88       	ldd	r8, Y+16	; 0x10
     388:	88 70       	andi	r24, 0x08	; 8
     38a:	88 88       	ldd	r8, Y+16	; 0x10
     38c:	88 88       	ldd	r8, Y+16	; 0x10
     38e:	88 50       	subi	r24, 0x08	; 8
     390:	20 88       	ldd	r2, Z+16	; 0x10
     392:	88 88       	ldd	r8, Y+16	; 0x10
     394:	a8 a8       	ldd	r10, Y+48	; 0x30
     396:	d8 88       	ldd	r13, Y+16	; 0x10
     398:	88 88       	ldd	r8, Y+16	; 0x10
     39a:	50 20       	and	r5, r0
     39c:	50 88       	ldd	r5, Z+16	; 0x10
     39e:	88 88       	ldd	r8, Y+16	; 0x10
     3a0:	88 50       	subi	r24, 0x08	; 8
     3a2:	20 20       	and	r2, r0
     3a4:	20 20       	and	r2, r0
     3a6:	f8 08       	sbc	r15, r8
     3a8:	10 20       	and	r1, r0
     3aa:	40 80       	ld	r4, Z
     3ac:	f8 38       	cpi	r31, 0x88	; 136
     3ae:	20 20       	and	r2, r0
     3b0:	20 20       	and	r2, r0
     3b2:	20 38       	cpi	r18, 0x80	; 128
     3b4:	00 80       	ld	r0, Z
     3b6:	40 20       	and	r4, r0
     3b8:	10 08       	sbc	r1, r0
     3ba:	00 e0       	ldi	r16, 0x00	; 0
     3bc:	20 20       	and	r2, r0
     3be:	20 20       	and	r2, r0
     3c0:	20 e0       	ldi	r18, 0x00	; 0
     3c2:	20 50       	subi	r18, 0x00	; 0
     3c4:	88 00       	.word	0x0088	; ????
	...
     3ce:	00 f8       	bld	r0, 0
     3d0:	40 20       	and	r4, r0
     3d2:	10 00       	.word	0x0010	; ????
     3d4:	00 00       	nop
     3d6:	00 00       	nop
     3d8:	00 70       	andi	r16, 0x00	; 0
     3da:	08 78       	andi	r16, 0x88	; 136
     3dc:	88 78       	andi	r24, 0x88	; 136
     3de:	80 80       	ld	r8, Z
     3e0:	b0 c8       	rjmp	.-3744   	; 0xfffff542 <__eeprom_end+0xff7ef542>
     3e2:	88 88       	ldd	r8, Y+16	; 0x10
     3e4:	f0 00       	.word	0x00f0	; ????
     3e6:	00 70       	andi	r16, 0x00	; 0
     3e8:	80 80       	ld	r8, Z
     3ea:	88 70       	andi	r24, 0x08	; 8
     3ec:	08 08       	sbc	r0, r8
     3ee:	68 98       	cbi	0x0d, 0	; 13
     3f0:	88 88       	ldd	r8, Y+16	; 0x10
     3f2:	78 00       	.word	0x0078	; ????
     3f4:	00 70       	andi	r16, 0x00	; 0
     3f6:	88 f8       	.word	0xf888	; ????
     3f8:	80 70       	andi	r24, 0x00	; 0
     3fa:	30 48       	sbci	r19, 0x80	; 128
     3fc:	40 e0       	ldi	r20, 0x00	; 0
     3fe:	40 40       	sbci	r20, 0x00	; 0
     400:	40 00       	.word	0x0040	; ????
     402:	00 78       	andi	r16, 0x80	; 128
     404:	88 78       	andi	r24, 0x88	; 136
     406:	08 30       	cpi	r16, 0x08	; 8
     408:	80 80       	ld	r8, Z
     40a:	b0 c8       	rjmp	.-3744   	; 0xfffff56c <__eeprom_end+0xff7ef56c>
     40c:	88 88       	ldd	r8, Y+16	; 0x10
     40e:	88 20       	and	r8, r8
     410:	00 60       	ori	r16, 0x00	; 0
     412:	20 20       	and	r2, r0
     414:	20 70       	andi	r18, 0x00	; 0
     416:	10 00       	.word	0x0010	; ????
     418:	30 10       	cpse	r3, r0
     41a:	10 90 60 40 	lds	r1, 0x4060	; 0x804060 <ucHeap+0x1c5e>
     41e:	40 48       	sbci	r20, 0x80	; 128
     420:	50 60       	ori	r21, 0x00	; 0
     422:	50 48       	sbci	r21, 0x80	; 128
     424:	60 20       	and	r6, r0
     426:	20 20       	and	r2, r0
     428:	20 20       	and	r2, r0
     42a:	70 00       	.word	0x0070	; ????
     42c:	00 d0       	rcall	.+0      	; 0x42e <__FUSE_REGION_LENGTH__+0x2e>
     42e:	a8 a8       	ldd	r10, Y+48	; 0x30
     430:	88 88       	ldd	r8, Y+16	; 0x10
     432:	00 00       	nop
     434:	b0 c8       	rjmp	.-3744   	; 0xfffff596 <__eeprom_end+0xff7ef596>
     436:	88 88       	ldd	r8, Y+16	; 0x10
     438:	88 00       	.word	0x0088	; ????
     43a:	00 70       	andi	r16, 0x00	; 0
     43c:	88 88       	ldd	r8, Y+16	; 0x10
     43e:	88 70       	andi	r24, 0x08	; 8
     440:	00 00       	nop
     442:	f0 88       	ldd	r15, Z+16	; 0x10
     444:	f0 80       	ld	r15, Z
     446:	80 00       	.word	0x0080	; ????
     448:	00 68       	ori	r16, 0x80	; 128
     44a:	98 78       	andi	r25, 0x88	; 136
     44c:	08 08       	sbc	r0, r8
     44e:	00 00       	nop
     450:	b0 c8       	rjmp	.-3744   	; 0xfffff5b2 <__eeprom_end+0xff7ef5b2>
     452:	80 80       	ld	r8, Z
     454:	80 00       	.word	0x0080	; ????
     456:	00 70       	andi	r16, 0x00	; 0
     458:	80 70       	andi	r24, 0x00	; 0
     45a:	08 f0       	brcs	.+2      	; 0x45e <__FUSE_REGION_LENGTH__+0x5e>
     45c:	40 40       	sbci	r20, 0x00	; 0
     45e:	e0 40       	sbci	r30, 0x00	; 0
     460:	40 48       	sbci	r20, 0x80	; 128
     462:	30 00       	.word	0x0030	; ????
     464:	00 88       	ldd	r0, Z+16	; 0x10
     466:	88 88       	ldd	r8, Y+16	; 0x10
     468:	98 68       	ori	r25, 0x88	; 136
     46a:	00 00       	nop
     46c:	88 88       	ldd	r8, Y+16	; 0x10
     46e:	88 50       	subi	r24, 0x08	; 8
     470:	20 00       	.word	0x0020	; ????
     472:	00 88       	ldd	r0, Z+16	; 0x10
     474:	88 a8       	ldd	r8, Y+48	; 0x30
     476:	a8 50       	subi	r26, 0x08	; 8
     478:	00 00       	nop
     47a:	88 50       	subi	r24, 0x08	; 8
     47c:	20 50       	subi	r18, 0x00	; 0
     47e:	88 00       	.word	0x0088	; ????
     480:	00 88       	ldd	r0, Z+16	; 0x10
     482:	88 78       	andi	r24, 0x88	; 136
     484:	08 70       	andi	r16, 0x08	; 8
     486:	00 00       	nop
     488:	f8 10       	cpse	r15, r8
     48a:	20 40       	sbci	r18, 0x00	; 0
     48c:	f8 10       	cpse	r15, r8
     48e:	20 20       	and	r2, r0
     490:	40 20       	and	r4, r0
     492:	20 10       	cpse	r2, r0
     494:	20 20       	and	r2, r0
     496:	20 20       	and	r2, r0
     498:	20 20       	and	r2, r0
     49a:	20 40       	sbci	r18, 0x00	; 0
     49c:	20 20       	and	r2, r0
     49e:	10 20       	and	r1, r0
     4a0:	20 40       	sbci	r18, 0x00	; 0

000004a2 <__ctors_end>:
     4a2:	11 24       	eor	r1, r1
     4a4:	1f be       	out	0x3f, r1	; 63
     4a6:	cf ef       	ldi	r28, 0xFF	; 255
     4a8:	cd bf       	out	0x3d, r28	; 61
     4aa:	df e5       	ldi	r29, 0x5F	; 95
     4ac:	de bf       	out	0x3e, r29	; 62
     4ae:	00 e0       	ldi	r16, 0x00	; 0
     4b0:	0c bf       	out	0x3c, r16	; 60

000004b2 <__do_copy_data>:
     4b2:	11 e2       	ldi	r17, 0x21	; 33
     4b4:	a0 e0       	ldi	r26, 0x00	; 0
     4b6:	b0 e2       	ldi	r27, 0x20	; 32
     4b8:	e6 e8       	ldi	r30, 0x86	; 134
     4ba:	f2 e4       	ldi	r31, 0x42	; 66
     4bc:	00 e0       	ldi	r16, 0x00	; 0
     4be:	0b bf       	out	0x3b, r16	; 59
     4c0:	02 c0       	rjmp	.+4      	; 0x4c6 <__do_copy_data+0x14>
     4c2:	07 90       	elpm	r0, Z+
     4c4:	0d 92       	st	X+, r0
     4c6:	a2 3f       	cpi	r26, 0xF2	; 242
     4c8:	b1 07       	cpc	r27, r17
     4ca:	d9 f7       	brne	.-10     	; 0x4c2 <__do_copy_data+0x10>

000004cc <__do_clear_bss>:
     4cc:	20 e6       	ldi	r18, 0x60	; 96
     4ce:	a2 ef       	ldi	r26, 0xF2	; 242
     4d0:	b1 e2       	ldi	r27, 0x21	; 33
     4d2:	01 c0       	rjmp	.+2      	; 0x4d6 <.do_clear_bss_start>

000004d4 <.do_clear_bss_loop>:
     4d4:	1d 92       	st	X+, r1

000004d6 <.do_clear_bss_start>:
     4d6:	ae 3b       	cpi	r26, 0xBE	; 190
     4d8:	b2 07       	cpc	r27, r18
     4da:	e1 f7       	brne	.-8      	; 0x4d4 <.do_clear_bss_loop>
     4dc:	0e 94 56 1d 	call	0x3aac	; 0x3aac <main>
     4e0:	0c 94 41 21 	jmp	0x4282	; 0x4282 <_exit>

000004e4 <__bad_interrupt>:
     4e4:	8d cd       	rjmp	.-1254   	; 0x0 <__vectors>

000004e6 <st7565r_init>:
 * Call this function to initialize the hardware interface and the LCD
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void st7565r_init(void)
{
     4e6:	bf 92       	push	r11
     4e8:	cf 92       	push	r12
     4ea:	df 92       	push	r13
     4ec:	ef 92       	push	r14
     4ee:	ff 92       	push	r15
     4f0:	0f 93       	push	r16
     4f2:	1f 93       	push	r17
     4f4:	cf 93       	push	r28
     4f6:	df 93       	push	r29
     4f8:	1f 92       	push	r1
     4fa:	cd b7       	in	r28, 0x3d	; 61
     4fc:	de b7       	in	r29, 0x3e	; 62
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     4fe:	e0 e0       	ldi	r30, 0x00	; 0
     500:	f6 e0       	ldi	r31, 0x06	; 6
     502:	88 e0       	ldi	r24, 0x08	; 8
     504:	86 83       	std	Z+6, r24	; 0x06
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     506:	85 83       	std	Z+5, r24	; 0x05
	spi_flags_t spi_flags = SPI_MODE_3;
	board_spi_select_id_t spi_select_id = 0;
#endif

#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {
     508:	0f 2e       	mov	r0, r31
     50a:	fb e2       	ldi	r31, 0x2B	; 43
     50c:	bf 2e       	mov	r11, r31
     50e:	f0 2d       	mov	r31, r0
     510:	b9 82       	std	Y+1, r11	; 0x01
		.id = ST7565R_CS_PIN,
	};
	usart_spi_init(ST7565R_USART_SPI);
     512:	80 ea       	ldi	r24, 0xA0	; 160
     514:	99 e0       	ldi	r25, 0x09	; 9
     516:	09 d4       	rcall	.+2066   	; 0xd2a <usart_spi_init>
	usart_spi_setup_device(ST7565R_USART_SPI, &device, spi_flags,
     518:	c1 2c       	mov	r12, r1
     51a:	d1 2c       	mov	r13, r1
     51c:	76 01       	movw	r14, r12
     51e:	00 e4       	ldi	r16, 0x40	; 64
     520:	12 e4       	ldi	r17, 0x42	; 66
     522:	2f e0       	ldi	r18, 0x0F	; 15
     524:	30 e0       	ldi	r19, 0x00	; 0
     526:	43 e0       	ldi	r20, 0x03	; 3
     528:	be 01       	movw	r22, r28
     52a:	6f 5f       	subi	r22, 0xFF	; 255
     52c:	7f 4f       	sbci	r23, 0xFF	; 255
     52e:	80 ea       	ldi	r24, 0xA0	; 160
     530:	99 e0       	ldi	r25, 0x09	; 9
     532:	2a d4       	rcall	.+2132   	; 0xd88 <usart_spi_setup_device>
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     534:	00 e6       	ldi	r16, 0x60	; 96
     536:	16 e0       	ldi	r17, 0x06	; 6
     538:	ff 24       	eor	r15, r15
     53a:	f3 94       	inc	r15
     53c:	f8 01       	movw	r30, r16
     53e:	f6 82       	std	Z+6, r15	; 0x06
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     540:	b9 82       	std	Y+1, r11	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     542:	be 01       	movw	r22, r28
     544:	6f 5f       	subi	r22, 0xFF	; 255
     546:	7f 4f       	sbci	r23, 0xFF	; 255
     548:	80 ea       	ldi	r24, 0xA0	; 160
     54a:	99 e0       	ldi	r25, 0x09	; 9
     54c:	37 d4       	rcall	.+2158   	; 0xdbc <usart_spi_select_device>
     54e:	f8 01       	movw	r30, r16
     550:	f6 82       	std	Z+6, r15	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     552:	e0 ea       	ldi	r30, 0xA0	; 160
     554:	f9 e0       	ldi	r31, 0x09	; 9
     556:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     558:	85 ff       	sbrs	r24, 5
     55a:	fd cf       	rjmp	.-6      	; 0x556 <st7565r_init+0x70>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     55c:	80 ea       	ldi	r24, 0xA0	; 160
     55e:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     562:	e0 ea       	ldi	r30, 0xA0	; 160
     564:	f9 e0       	ldi	r31, 0x09	; 9
     566:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     568:	86 ff       	sbrs	r24, 6
     56a:	fd cf       	rjmp	.-6      	; 0x566 <st7565r_init+0x80>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     56c:	e0 ea       	ldi	r30, 0xA0	; 160
     56e:	f9 e0       	ldi	r31, 0x09	; 9
     570:	80 e4       	ldi	r24, 0x40	; 64
     572:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     574:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     576:	be 01       	movw	r22, r28
     578:	6f 5f       	subi	r22, 0xFF	; 255
     57a:	7f 4f       	sbci	r23, 0xFF	; 255
     57c:	80 ea       	ldi	r24, 0xA0	; 160
     57e:	99 e0       	ldi	r25, 0x09	; 9
     580:	33 d4       	rcall	.+2150   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     582:	8b e2       	ldi	r24, 0x2B	; 43
     584:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     586:	be 01       	movw	r22, r28
     588:	6f 5f       	subi	r22, 0xFF	; 255
     58a:	7f 4f       	sbci	r23, 0xFF	; 255
     58c:	80 ea       	ldi	r24, 0xA0	; 160
     58e:	99 e0       	ldi	r25, 0x09	; 9
     590:	15 d4       	rcall	.+2090   	; 0xdbc <usart_spi_select_device>
     592:	81 e0       	ldi	r24, 0x01	; 1
     594:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     598:	e0 ea       	ldi	r30, 0xA0	; 160
     59a:	f9 e0       	ldi	r31, 0x09	; 9
     59c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     59e:	85 ff       	sbrs	r24, 5
     5a0:	fd cf       	rjmp	.-6      	; 0x59c <st7565r_init+0xb6>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     5a2:	86 ea       	ldi	r24, 0xA6	; 166
     5a4:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     5a8:	e0 ea       	ldi	r30, 0xA0	; 160
     5aa:	f9 e0       	ldi	r31, 0x09	; 9
     5ac:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     5ae:	86 ff       	sbrs	r24, 6
     5b0:	fd cf       	rjmp	.-6      	; 0x5ac <st7565r_init+0xc6>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     5b2:	e0 ea       	ldi	r30, 0xA0	; 160
     5b4:	f9 e0       	ldi	r31, 0x09	; 9
     5b6:	80 e4       	ldi	r24, 0x40	; 64
     5b8:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     5ba:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     5bc:	be 01       	movw	r22, r28
     5be:	6f 5f       	subi	r22, 0xFF	; 255
     5c0:	7f 4f       	sbci	r23, 0xFF	; 255
     5c2:	80 ea       	ldi	r24, 0xA0	; 160
     5c4:	99 e0       	ldi	r25, 0x09	; 9
     5c6:	10 d4       	rcall	.+2080   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     5c8:	8b e2       	ldi	r24, 0x2B	; 43
     5ca:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     5cc:	be 01       	movw	r22, r28
     5ce:	6f 5f       	subi	r22, 0xFF	; 255
     5d0:	7f 4f       	sbci	r23, 0xFF	; 255
     5d2:	80 ea       	ldi	r24, 0xA0	; 160
     5d4:	99 e0       	ldi	r25, 0x09	; 9
     5d6:	f2 d3       	rcall	.+2020   	; 0xdbc <usart_spi_select_device>
     5d8:	81 e0       	ldi	r24, 0x01	; 1
     5da:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     5de:	e0 ea       	ldi	r30, 0xA0	; 160
     5e0:	f9 e0       	ldi	r31, 0x09	; 9
     5e2:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     5e4:	85 ff       	sbrs	r24, 5
     5e6:	fd cf       	rjmp	.-6      	; 0x5e2 <st7565r_init+0xfc>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     5e8:	88 ec       	ldi	r24, 0xC8	; 200
     5ea:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     5ee:	e0 ea       	ldi	r30, 0xA0	; 160
     5f0:	f9 e0       	ldi	r31, 0x09	; 9
     5f2:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     5f4:	86 ff       	sbrs	r24, 6
     5f6:	fd cf       	rjmp	.-6      	; 0x5f2 <st7565r_init+0x10c>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     5f8:	e0 ea       	ldi	r30, 0xA0	; 160
     5fa:	f9 e0       	ldi	r31, 0x09	; 9
     5fc:	80 e4       	ldi	r24, 0x40	; 64
     5fe:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     600:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     602:	be 01       	movw	r22, r28
     604:	6f 5f       	subi	r22, 0xFF	; 255
     606:	7f 4f       	sbci	r23, 0xFF	; 255
     608:	80 ea       	ldi	r24, 0xA0	; 160
     60a:	99 e0       	ldi	r25, 0x09	; 9
     60c:	ed d3       	rcall	.+2010   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     60e:	8b e2       	ldi	r24, 0x2B	; 43
     610:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     612:	be 01       	movw	r22, r28
     614:	6f 5f       	subi	r22, 0xFF	; 255
     616:	7f 4f       	sbci	r23, 0xFF	; 255
     618:	80 ea       	ldi	r24, 0xA0	; 160
     61a:	99 e0       	ldi	r25, 0x09	; 9
     61c:	cf d3       	rcall	.+1950   	; 0xdbc <usart_spi_select_device>
     61e:	81 e0       	ldi	r24, 0x01	; 1
     620:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     624:	e0 ea       	ldi	r30, 0xA0	; 160
     626:	f9 e0       	ldi	r31, 0x09	; 9
     628:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     62a:	85 ff       	sbrs	r24, 5
     62c:	fd cf       	rjmp	.-6      	; 0x628 <st7565r_init+0x142>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     62e:	82 ea       	ldi	r24, 0xA2	; 162
     630:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     634:	e0 ea       	ldi	r30, 0xA0	; 160
     636:	f9 e0       	ldi	r31, 0x09	; 9
     638:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     63a:	86 ff       	sbrs	r24, 6
     63c:	fd cf       	rjmp	.-6      	; 0x638 <st7565r_init+0x152>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     63e:	e0 ea       	ldi	r30, 0xA0	; 160
     640:	f9 e0       	ldi	r31, 0x09	; 9
     642:	80 e4       	ldi	r24, 0x40	; 64
     644:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     646:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     648:	be 01       	movw	r22, r28
     64a:	6f 5f       	subi	r22, 0xFF	; 255
     64c:	7f 4f       	sbci	r23, 0xFF	; 255
     64e:	80 ea       	ldi	r24, 0xA0	; 160
     650:	99 e0       	ldi	r25, 0x09	; 9
     652:	ca d3       	rcall	.+1940   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     654:	8b e2       	ldi	r24, 0x2B	; 43
     656:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     658:	be 01       	movw	r22, r28
     65a:	6f 5f       	subi	r22, 0xFF	; 255
     65c:	7f 4f       	sbci	r23, 0xFF	; 255
     65e:	80 ea       	ldi	r24, 0xA0	; 160
     660:	99 e0       	ldi	r25, 0x09	; 9
     662:	ac d3       	rcall	.+1880   	; 0xdbc <usart_spi_select_device>
     664:	81 e0       	ldi	r24, 0x01	; 1
     666:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     66a:	e0 ea       	ldi	r30, 0xA0	; 160
     66c:	f9 e0       	ldi	r31, 0x09	; 9
     66e:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     670:	85 ff       	sbrs	r24, 5
     672:	fd cf       	rjmp	.-6      	; 0x66e <st7565r_init+0x188>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     674:	8f e2       	ldi	r24, 0x2F	; 47
     676:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     67a:	e0 ea       	ldi	r30, 0xA0	; 160
     67c:	f9 e0       	ldi	r31, 0x09	; 9
     67e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     680:	86 ff       	sbrs	r24, 6
     682:	fd cf       	rjmp	.-6      	; 0x67e <st7565r_init+0x198>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     684:	e0 ea       	ldi	r30, 0xA0	; 160
     686:	f9 e0       	ldi	r31, 0x09	; 9
     688:	80 e4       	ldi	r24, 0x40	; 64
     68a:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     68c:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     68e:	be 01       	movw	r22, r28
     690:	6f 5f       	subi	r22, 0xFF	; 255
     692:	7f 4f       	sbci	r23, 0xFF	; 255
     694:	80 ea       	ldi	r24, 0xA0	; 160
     696:	99 e0       	ldi	r25, 0x09	; 9
     698:	a7 d3       	rcall	.+1870   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     69a:	8b e2       	ldi	r24, 0x2B	; 43
     69c:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     69e:	be 01       	movw	r22, r28
     6a0:	6f 5f       	subi	r22, 0xFF	; 255
     6a2:	7f 4f       	sbci	r23, 0xFF	; 255
     6a4:	80 ea       	ldi	r24, 0xA0	; 160
     6a6:	99 e0       	ldi	r25, 0x09	; 9
     6a8:	89 d3       	rcall	.+1810   	; 0xdbc <usart_spi_select_device>
     6aa:	81 e0       	ldi	r24, 0x01	; 1
     6ac:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     6b0:	e0 ea       	ldi	r30, 0xA0	; 160
     6b2:	f9 e0       	ldi	r31, 0x09	; 9
     6b4:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     6b6:	85 ff       	sbrs	r24, 5
     6b8:	fd cf       	rjmp	.-6      	; 0x6b4 <st7565r_init+0x1ce>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     6ba:	88 ef       	ldi	r24, 0xF8	; 248
     6bc:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     6c0:	e0 ea       	ldi	r30, 0xA0	; 160
     6c2:	f9 e0       	ldi	r31, 0x09	; 9
     6c4:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     6c6:	86 ff       	sbrs	r24, 6
     6c8:	fd cf       	rjmp	.-6      	; 0x6c4 <st7565r_init+0x1de>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     6ca:	e0 ea       	ldi	r30, 0xA0	; 160
     6cc:	f9 e0       	ldi	r31, 0x09	; 9
     6ce:	80 e4       	ldi	r24, 0x40	; 64
     6d0:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     6d2:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     6d4:	be 01       	movw	r22, r28
     6d6:	6f 5f       	subi	r22, 0xFF	; 255
     6d8:	7f 4f       	sbci	r23, 0xFF	; 255
     6da:	80 ea       	ldi	r24, 0xA0	; 160
     6dc:	99 e0       	ldi	r25, 0x09	; 9
     6de:	84 d3       	rcall	.+1800   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     6e0:	8b e2       	ldi	r24, 0x2B	; 43
     6e2:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     6e4:	be 01       	movw	r22, r28
     6e6:	6f 5f       	subi	r22, 0xFF	; 255
     6e8:	7f 4f       	sbci	r23, 0xFF	; 255
     6ea:	80 ea       	ldi	r24, 0xA0	; 160
     6ec:	99 e0       	ldi	r25, 0x09	; 9
     6ee:	66 d3       	rcall	.+1740   	; 0xdbc <usart_spi_select_device>
     6f0:	81 e0       	ldi	r24, 0x01	; 1
     6f2:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     6f6:	e0 ea       	ldi	r30, 0xA0	; 160
     6f8:	f9 e0       	ldi	r31, 0x09	; 9
     6fa:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     6fc:	85 ff       	sbrs	r24, 5
     6fe:	fd cf       	rjmp	.-6      	; 0x6fa <st7565r_init+0x214>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     700:	10 92 a0 09 	sts	0x09A0, r1	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     704:	e0 ea       	ldi	r30, 0xA0	; 160
     706:	f9 e0       	ldi	r31, 0x09	; 9
     708:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     70a:	86 ff       	sbrs	r24, 6
     70c:	fd cf       	rjmp	.-6      	; 0x708 <st7565r_init+0x222>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     70e:	e0 ea       	ldi	r30, 0xA0	; 160
     710:	f9 e0       	ldi	r31, 0x09	; 9
     712:	80 e4       	ldi	r24, 0x40	; 64
     714:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     716:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     718:	be 01       	movw	r22, r28
     71a:	6f 5f       	subi	r22, 0xFF	; 255
     71c:	7f 4f       	sbci	r23, 0xFF	; 255
     71e:	80 ea       	ldi	r24, 0xA0	; 160
     720:	99 e0       	ldi	r25, 0x09	; 9
     722:	62 d3       	rcall	.+1732   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     724:	8b e2       	ldi	r24, 0x2B	; 43
     726:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     728:	be 01       	movw	r22, r28
     72a:	6f 5f       	subi	r22, 0xFF	; 255
     72c:	7f 4f       	sbci	r23, 0xFF	; 255
     72e:	80 ea       	ldi	r24, 0xA0	; 160
     730:	99 e0       	ldi	r25, 0x09	; 9
     732:	44 d3       	rcall	.+1672   	; 0xdbc <usart_spi_select_device>
     734:	81 e0       	ldi	r24, 0x01	; 1
     736:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     73a:	e0 ea       	ldi	r30, 0xA0	; 160
     73c:	f9 e0       	ldi	r31, 0x09	; 9
     73e:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     740:	85 ff       	sbrs	r24, 5
     742:	fd cf       	rjmp	.-6      	; 0x73e <st7565r_init+0x258>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     744:	81 e2       	ldi	r24, 0x21	; 33
     746:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     74a:	e0 ea       	ldi	r30, 0xA0	; 160
     74c:	f9 e0       	ldi	r31, 0x09	; 9
     74e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     750:	86 ff       	sbrs	r24, 6
     752:	fd cf       	rjmp	.-6      	; 0x74e <st7565r_init+0x268>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     754:	e0 ea       	ldi	r30, 0xA0	; 160
     756:	f9 e0       	ldi	r31, 0x09	; 9
     758:	80 e4       	ldi	r24, 0x40	; 64
     75a:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     75c:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     75e:	be 01       	movw	r22, r28
     760:	6f 5f       	subi	r22, 0xFF	; 255
     762:	7f 4f       	sbci	r23, 0xFF	; 255
     764:	80 ea       	ldi	r24, 0xA0	; 160
     766:	99 e0       	ldi	r25, 0x09	; 9
     768:	3f d3       	rcall	.+1662   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     76a:	8b e2       	ldi	r24, 0x2B	; 43
     76c:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     76e:	be 01       	movw	r22, r28
     770:	6f 5f       	subi	r22, 0xFF	; 255
     772:	7f 4f       	sbci	r23, 0xFF	; 255
     774:	80 ea       	ldi	r24, 0xA0	; 160
     776:	99 e0       	ldi	r25, 0x09	; 9
     778:	21 d3       	rcall	.+1602   	; 0xdbc <usart_spi_select_device>
     77a:	81 e0       	ldi	r24, 0x01	; 1
     77c:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     780:	e0 ea       	ldi	r30, 0xA0	; 160
     782:	f9 e0       	ldi	r31, 0x09	; 9
     784:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     786:	85 ff       	sbrs	r24, 5
     788:	fd cf       	rjmp	.-6      	; 0x784 <st7565r_init+0x29e>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     78a:	81 e8       	ldi	r24, 0x81	; 129
     78c:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     790:	e0 ea       	ldi	r30, 0xA0	; 160
     792:	f9 e0       	ldi	r31, 0x09	; 9
     794:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     796:	86 ff       	sbrs	r24, 6
     798:	fd cf       	rjmp	.-6      	; 0x794 <st7565r_init+0x2ae>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     79a:	e0 ea       	ldi	r30, 0xA0	; 160
     79c:	f9 e0       	ldi	r31, 0x09	; 9
     79e:	80 e4       	ldi	r24, 0x40	; 64
     7a0:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     7a2:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     7a4:	be 01       	movw	r22, r28
     7a6:	6f 5f       	subi	r22, 0xFF	; 255
     7a8:	7f 4f       	sbci	r23, 0xFF	; 255
     7aa:	80 ea       	ldi	r24, 0xA0	; 160
     7ac:	99 e0       	ldi	r25, 0x09	; 9
     7ae:	1c d3       	rcall	.+1592   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     7b0:	8b e2       	ldi	r24, 0x2B	; 43
     7b2:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     7b4:	be 01       	movw	r22, r28
     7b6:	6f 5f       	subi	r22, 0xFF	; 255
     7b8:	7f 4f       	sbci	r23, 0xFF	; 255
     7ba:	80 ea       	ldi	r24, 0xA0	; 160
     7bc:	99 e0       	ldi	r25, 0x09	; 9
     7be:	fe d2       	rcall	.+1532   	; 0xdbc <usart_spi_select_device>
     7c0:	81 e0       	ldi	r24, 0x01	; 1
     7c2:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     7c6:	e0 ea       	ldi	r30, 0xA0	; 160
     7c8:	f9 e0       	ldi	r31, 0x09	; 9
     7ca:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     7cc:	85 ff       	sbrs	r24, 5
     7ce:	fd cf       	rjmp	.-6      	; 0x7ca <st7565r_init+0x2e4>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     7d0:	81 e2       	ldi	r24, 0x21	; 33
     7d2:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     7d6:	e0 ea       	ldi	r30, 0xA0	; 160
     7d8:	f9 e0       	ldi	r31, 0x09	; 9
     7da:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     7dc:	86 ff       	sbrs	r24, 6
     7de:	fd cf       	rjmp	.-6      	; 0x7da <st7565r_init+0x2f4>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     7e0:	e0 ea       	ldi	r30, 0xA0	; 160
     7e2:	f9 e0       	ldi	r31, 0x09	; 9
     7e4:	80 e4       	ldi	r24, 0x40	; 64
     7e6:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     7e8:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     7ea:	be 01       	movw	r22, r28
     7ec:	6f 5f       	subi	r22, 0xFF	; 255
     7ee:	7f 4f       	sbci	r23, 0xFF	; 255
     7f0:	80 ea       	ldi	r24, 0xA0	; 160
     7f2:	99 e0       	ldi	r25, 0x09	; 9
     7f4:	f9 d2       	rcall	.+1522   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     7f6:	8b e2       	ldi	r24, 0x2B	; 43
     7f8:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     7fa:	be 01       	movw	r22, r28
     7fc:	6f 5f       	subi	r22, 0xFF	; 255
     7fe:	7f 4f       	sbci	r23, 0xFF	; 255
     800:	80 ea       	ldi	r24, 0xA0	; 160
     802:	99 e0       	ldi	r25, 0x09	; 9
     804:	db d2       	rcall	.+1462   	; 0xdbc <usart_spi_select_device>
     806:	81 e0       	ldi	r24, 0x01	; 1
     808:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     80c:	e0 ea       	ldi	r30, 0xA0	; 160
     80e:	f9 e0       	ldi	r31, 0x09	; 9
     810:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     812:	85 ff       	sbrs	r24, 5
     814:	fd cf       	rjmp	.-6      	; 0x810 <st7565r_init+0x32a>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     816:	8f ea       	ldi	r24, 0xAF	; 175
     818:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     81c:	e0 ea       	ldi	r30, 0xA0	; 160
     81e:	f9 e0       	ldi	r31, 0x09	; 9
     820:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     822:	86 ff       	sbrs	r24, 6
     824:	fd cf       	rjmp	.-6      	; 0x820 <st7565r_init+0x33a>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     826:	e0 ea       	ldi	r30, 0xA0	; 160
     828:	f9 e0       	ldi	r31, 0x09	; 9
     82a:	80 e4       	ldi	r24, 0x40	; 64
     82c:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     82e:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     830:	be 01       	movw	r22, r28
     832:	6f 5f       	subi	r22, 0xFF	; 255
     834:	7f 4f       	sbci	r23, 0xFF	; 255
     836:	80 ea       	ldi	r24, 0xA0	; 160
     838:	99 e0       	ldi	r25, 0x09	; 9
     83a:	d6 d2       	rcall	.+1452   	; 0xde8 <usart_spi_deselect_device>
	is set to the defined min*/
	st7565r_set_contrast(ST7565R_DISPLAY_CONTRAST_MIN);

	// Turn on the display
	st7565r_display_on();
}
     83c:	0f 90       	pop	r0
     83e:	df 91       	pop	r29
     840:	cf 91       	pop	r28
     842:	1f 91       	pop	r17
     844:	0f 91       	pop	r16
     846:	ff 90       	pop	r15
     848:	ef 90       	pop	r14
     84a:	df 90       	pop	r13
     84c:	cf 90       	pop	r12
     84e:	bf 90       	pop	r11
     850:	08 95       	ret

00000852 <sysclk_enable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     852:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
     854:	f8 94       	cli

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
     856:	e8 2f       	mov	r30, r24
     858:	f0 e0       	ldi	r31, 0x00	; 0
     85a:	e0 59       	subi	r30, 0x90	; 144
     85c:	ff 4f       	sbci	r31, 0xFF	; 255
     85e:	60 95       	com	r22
     860:	80 81       	ld	r24, Z
     862:	68 23       	and	r22, r24
     864:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     866:	9f bf       	out	0x3f, r25	; 63
     868:	08 95       	ret

0000086a <sysclk_disable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     86a:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
     86c:	f8 94       	cli

void sysclk_disable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) |= id;
     86e:	e8 2f       	mov	r30, r24
     870:	f0 e0       	ldi	r31, 0x00	; 0
     872:	e0 59       	subi	r30, 0x90	; 144
     874:	ff 4f       	sbci	r31, 0xFF	; 255
     876:	80 81       	ld	r24, Z
     878:	68 2b       	or	r22, r24
     87a:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     87c:	9f bf       	out	0x3f, r25	; 63
     87e:	08 95       	ret

00000880 <gfx_mono_st7565r_put_byte>:
	gfx_mono_st7565r_put_byte(0, 0, 0xFF);
\endcode
 */
void gfx_mono_st7565r_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
     880:	ff 92       	push	r15
     882:	0f 93       	push	r16
     884:	1f 93       	push	r17
     886:	cf 93       	push	r28
     888:	df 93       	push	r29
     88a:	1f 92       	push	r1
     88c:	cd b7       	in	r28, 0x3d	; 61
     88e:	de b7       	in	r29, 0x3e	; 62
     890:	08 2f       	mov	r16, r24
     892:	f6 2e       	mov	r15, r22
     894:	14 2f       	mov	r17, r20
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_framebuffer_put_byte(page, column, data);
     896:	22 d1       	rcall	.+580    	; 0xadc <gfx_mono_framebuffer_put_byte>
 * \param address the page address
 */
static inline void st7565r_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
     898:	0f 70       	andi	r16, 0x0F	; 15
	st7565r_write_command(ST7565R_CMD_PAGE_ADDRESS_SET(address));
     89a:	00 6b       	ori	r16, 0xB0	; 176
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     89c:	8b e2       	ldi	r24, 0x2B	; 43
     89e:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     8a0:	be 01       	movw	r22, r28
     8a2:	6f 5f       	subi	r22, 0xFF	; 255
     8a4:	7f 4f       	sbci	r23, 0xFF	; 255
     8a6:	80 ea       	ldi	r24, 0xA0	; 160
     8a8:	99 e0       	ldi	r25, 0x09	; 9
     8aa:	88 d2       	rcall	.+1296   	; 0xdbc <usart_spi_select_device>
     8ac:	81 e0       	ldi	r24, 0x01	; 1
     8ae:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     8b2:	e0 ea       	ldi	r30, 0xA0	; 160
     8b4:	f9 e0       	ldi	r31, 0x09	; 9
     8b6:	91 81       	ldd	r25, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     8b8:	95 ff       	sbrs	r25, 5
     8ba:	fd cf       	rjmp	.-6      	; 0x8b6 <gfx_mono_st7565r_put_byte+0x36>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     8bc:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     8c0:	e0 ea       	ldi	r30, 0xA0	; 160
     8c2:	f9 e0       	ldi	r31, 0x09	; 9
     8c4:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     8c6:	86 ff       	sbrs	r24, 6
     8c8:	fd cf       	rjmp	.-6      	; 0x8c4 <gfx_mono_st7565r_put_byte+0x44>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     8ca:	e0 ea       	ldi	r30, 0xA0	; 160
     8cc:	f9 e0       	ldi	r31, 0x09	; 9
     8ce:	80 e4       	ldi	r24, 0x40	; 64
     8d0:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     8d2:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     8d4:	be 01       	movw	r22, r28
     8d6:	6f 5f       	subi	r22, 0xFF	; 255
     8d8:	7f 4f       	sbci	r23, 0xFF	; 255
     8da:	80 ea       	ldi	r24, 0xA0	; 160
     8dc:	99 e0       	ldi	r25, 0x09	; 9
     8de:	84 d2       	rcall	.+1288   	; 0xde8 <usart_spi_deselect_device>
 * \param address the column address
 */
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
     8e0:	0f 2d       	mov	r16, r15
     8e2:	0f 77       	andi	r16, 0x7F	; 127
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
     8e4:	02 95       	swap	r16
     8e6:	0f 70       	andi	r16, 0x0F	; 15
     8e8:	00 61       	ori	r16, 0x10	; 16
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     8ea:	8b e2       	ldi	r24, 0x2B	; 43
     8ec:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     8ee:	be 01       	movw	r22, r28
     8f0:	6f 5f       	subi	r22, 0xFF	; 255
     8f2:	7f 4f       	sbci	r23, 0xFF	; 255
     8f4:	80 ea       	ldi	r24, 0xA0	; 160
     8f6:	99 e0       	ldi	r25, 0x09	; 9
     8f8:	61 d2       	rcall	.+1218   	; 0xdbc <usart_spi_select_device>
     8fa:	81 e0       	ldi	r24, 0x01	; 1
     8fc:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     900:	e0 ea       	ldi	r30, 0xA0	; 160
     902:	f9 e0       	ldi	r31, 0x09	; 9
     904:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     906:	85 ff       	sbrs	r24, 5
     908:	fd cf       	rjmp	.-6      	; 0x904 <gfx_mono_st7565r_put_byte+0x84>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     90a:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     90e:	e0 ea       	ldi	r30, 0xA0	; 160
     910:	f9 e0       	ldi	r31, 0x09	; 9
     912:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     914:	86 ff       	sbrs	r24, 6
     916:	fd cf       	rjmp	.-6      	; 0x912 <gfx_mono_st7565r_put_byte+0x92>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     918:	e0 ea       	ldi	r30, 0xA0	; 160
     91a:	f9 e0       	ldi	r31, 0x09	; 9
     91c:	80 e4       	ldi	r24, 0x40	; 64
     91e:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     920:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     922:	be 01       	movw	r22, r28
     924:	6f 5f       	subi	r22, 0xFF	; 255
     926:	7f 4f       	sbci	r23, 0xFF	; 255
     928:	80 ea       	ldi	r24, 0xA0	; 160
     92a:	99 e0       	ldi	r25, 0x09	; 9
     92c:	5d d2       	rcall	.+1210   	; 0xde8 <usart_spi_deselect_device>
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_LSB(address & 0x0F));
     92e:	0f 2d       	mov	r16, r15
     930:	0f 70       	andi	r16, 0x0F	; 15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     932:	8b e2       	ldi	r24, 0x2B	; 43
     934:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     936:	be 01       	movw	r22, r28
     938:	6f 5f       	subi	r22, 0xFF	; 255
     93a:	7f 4f       	sbci	r23, 0xFF	; 255
     93c:	80 ea       	ldi	r24, 0xA0	; 160
     93e:	99 e0       	ldi	r25, 0x09	; 9
     940:	3d d2       	rcall	.+1146   	; 0xdbc <usart_spi_select_device>
     942:	81 e0       	ldi	r24, 0x01	; 1
     944:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     948:	e0 ea       	ldi	r30, 0xA0	; 160
     94a:	f9 e0       	ldi	r31, 0x09	; 9
     94c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     94e:	85 ff       	sbrs	r24, 5
     950:	fd cf       	rjmp	.-6      	; 0x94c <gfx_mono_st7565r_put_byte+0xcc>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     952:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     956:	e0 ea       	ldi	r30, 0xA0	; 160
     958:	f9 e0       	ldi	r31, 0x09	; 9
     95a:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     95c:	86 ff       	sbrs	r24, 6
     95e:	fd cf       	rjmp	.-6      	; 0x95a <gfx_mono_st7565r_put_byte+0xda>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     960:	e0 ea       	ldi	r30, 0xA0	; 160
     962:	f9 e0       	ldi	r31, 0x09	; 9
     964:	80 e4       	ldi	r24, 0x40	; 64
     966:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     968:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     96a:	be 01       	movw	r22, r28
     96c:	6f 5f       	subi	r22, 0xFF	; 255
     96e:	7f 4f       	sbci	r23, 0xFF	; 255
     970:	80 ea       	ldi	r24, 0xA0	; 160
     972:	99 e0       	ldi	r25, 0x09	; 9
     974:	39 d2       	rcall	.+1138   	; 0xde8 <usart_spi_deselect_device>
 * \param data the data to write
 */
static inline void st7565r_write_data(uint8_t data)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     976:	8b e2       	ldi	r24, 0x2B	; 43
     978:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     97a:	be 01       	movw	r22, r28
     97c:	6f 5f       	subi	r22, 0xFF	; 255
     97e:	7f 4f       	sbci	r23, 0xFF	; 255
     980:	80 ea       	ldi	r24, 0xA0	; 160
     982:	99 e0       	ldi	r25, 0x09	; 9
     984:	1b d2       	rcall	.+1078   	; 0xdbc <usart_spi_select_device>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     986:	81 e0       	ldi	r24, 0x01	; 1
     988:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x700665>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     98c:	e0 ea       	ldi	r30, 0xA0	; 160
     98e:	f9 e0       	ldi	r31, 0x09	; 9
     990:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     992:	85 ff       	sbrs	r24, 5
     994:	fd cf       	rjmp	.-6      	; 0x990 <gfx_mono_st7565r_put_byte+0x110>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     996:	10 93 a0 09 	sts	0x09A0, r17	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     99a:	e0 ea       	ldi	r30, 0xA0	; 160
     99c:	f9 e0       	ldi	r31, 0x09	; 9
     99e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     9a0:	86 ff       	sbrs	r24, 6
     9a2:	fd cf       	rjmp	.-6      	; 0x99e <gfx_mono_st7565r_put_byte+0x11e>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     9a4:	e0 ea       	ldi	r30, 0xA0	; 160
     9a6:	f9 e0       	ldi	r31, 0x09	; 9
     9a8:	80 e4       	ldi	r24, 0x40	; 64
     9aa:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     9ac:	80 81       	ld	r24, Z
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     9ae:	81 e0       	ldi	r24, 0x01	; 1
     9b0:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
	ioport_set_pin_high(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, data);
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     9b4:	be 01       	movw	r22, r28
     9b6:	6f 5f       	subi	r22, 0xFF	; 255
     9b8:	7f 4f       	sbci	r23, 0xFF	; 255
     9ba:	80 ea       	ldi	r24, 0xA0	; 160
     9bc:	99 e0       	ldi	r25, 0x09	; 9
     9be:	14 d2       	rcall	.+1064   	; 0xde8 <usart_spi_deselect_device>

	st7565r_set_page_address(page);
	st7565r_set_column_address(column);

	st7565r_write_data(data);
}
     9c0:	0f 90       	pop	r0
     9c2:	df 91       	pop	r29
     9c4:	cf 91       	pop	r28
     9c6:	1f 91       	pop	r17
     9c8:	0f 91       	pop	r16
     9ca:	ff 90       	pop	r15
     9cc:	08 95       	ret

000009ce <gfx_mono_st7565r_init>:
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     9ce:	0f 93       	push	r16
     9d0:	1f 93       	push	r17
     9d2:	cf 93       	push	r28
     9d4:	df 93       	push	r29
     9d6:	1f 92       	push	r1
     9d8:	cd b7       	in	r28, 0x3d	; 61
     9da:	de b7       	in	r29, 0x3e	; 62
	uint8_t page;
	uint8_t column;

#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_set_framebuffer(framebuffer);
     9dc:	82 ef       	ldi	r24, 0xF2	; 242
     9de:	91 e2       	ldi	r25, 0x21	; 33
     9e0:	78 d0       	rcall	.+240    	; 0xad2 <gfx_mono_set_framebuffer>
#endif

	/* Initialize the low-level display controller. */
	st7565r_init();
     9e2:	81 dd       	rcall	.-1278   	; 0x4e6 <st7565r_init>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     9e4:	8b e2       	ldi	r24, 0x2B	; 43
     9e6:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     9e8:	be 01       	movw	r22, r28
     9ea:	6f 5f       	subi	r22, 0xFF	; 255
     9ec:	7f 4f       	sbci	r23, 0xFF	; 255
     9ee:	80 ea       	ldi	r24, 0xA0	; 160
     9f0:	99 e0       	ldi	r25, 0x09	; 9
     9f2:	e4 d1       	rcall	.+968    	; 0xdbc <usart_spi_select_device>
     9f4:	81 e0       	ldi	r24, 0x01	; 1
     9f6:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     9fa:	e0 ea       	ldi	r30, 0xA0	; 160
     9fc:	f9 e0       	ldi	r31, 0x09	; 9
     9fe:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     a00:	85 ff       	sbrs	r24, 5
     a02:	fd cf       	rjmp	.-6      	; 0x9fe <gfx_mono_st7565r_init+0x30>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     a04:	80 e4       	ldi	r24, 0x40	; 64
     a06:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     a0a:	e0 ea       	ldi	r30, 0xA0	; 160
     a0c:	f9 e0       	ldi	r31, 0x09	; 9
     a0e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     a10:	86 ff       	sbrs	r24, 6
     a12:	fd cf       	rjmp	.-6      	; 0xa0e <gfx_mono_st7565r_init+0x40>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     a14:	e0 ea       	ldi	r30, 0xA0	; 160
     a16:	f9 e0       	ldi	r31, 0x09	; 9
     a18:	80 e4       	ldi	r24, 0x40	; 64
     a1a:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     a1c:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     a1e:	be 01       	movw	r22, r28
     a20:	6f 5f       	subi	r22, 0xFF	; 255
     a22:	7f 4f       	sbci	r23, 0xFF	; 255
     a24:	80 ea       	ldi	r24, 0xA0	; 160
     a26:	99 e0       	ldi	r25, 0x09	; 9
     a28:	df d1       	rcall	.+958    	; 0xde8 <usart_spi_deselect_device>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     a2a:	00 e0       	ldi	r16, 0x00	; 0
     a2c:	0a c0       	rjmp	.+20     	; 0xa42 <gfx_mono_st7565r_init+0x74>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
     a2e:	40 e0       	ldi	r20, 0x00	; 0
     a30:	61 2f       	mov	r22, r17
     a32:	80 2f       	mov	r24, r16
     a34:	25 df       	rcall	.-438    	; 0x880 <gfx_mono_st7565r_put_byte>
	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
     a36:	1f 5f       	subi	r17, 0xFF	; 255
     a38:	10 38       	cpi	r17, 0x80	; 128
     a3a:	c9 f7       	brne	.-14     	; 0xa2e <gfx_mono_st7565r_init+0x60>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     a3c:	0f 5f       	subi	r16, 0xFF	; 255
     a3e:	04 30       	cpi	r16, 0x04	; 4
     a40:	11 f0       	breq	.+4      	; 0xa46 <gfx_mono_st7565r_init+0x78>
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     a42:	10 e0       	ldi	r17, 0x00	; 0
     a44:	f4 cf       	rjmp	.-24     	; 0xa2e <gfx_mono_st7565r_init+0x60>
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
		}
	}
}
     a46:	0f 90       	pop	r0
     a48:	df 91       	pop	r29
     a4a:	cf 91       	pop	r28
     a4c:	1f 91       	pop	r17
     a4e:	0f 91       	pop	r16
     a50:	08 95       	ret

00000a52 <gfx_mono_st7565r_draw_pixel>:
	gfx_mono_st7565r_draw_pixel(10, 10, GFX_PIXEL_XOR);
\endcode
 */
void gfx_mono_st7565r_draw_pixel(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t color)
{
     a52:	ff 92       	push	r15
     a54:	0f 93       	push	r16
     a56:	1f 93       	push	r17
     a58:	cf 93       	push	r28
     a5a:	df 93       	push	r29
	uint8_t page;
	uint8_t pixel_mask;
	uint8_t pixel_value;

	/* Discard pixels drawn outside the screen */
	if ((x > GFX_MONO_LCD_WIDTH - 1) || (y > GFX_MONO_LCD_HEIGHT - 1)) {
     a5c:	88 23       	and	r24, r24
     a5e:	8c f1       	brlt	.+98     	; 0xac2 <gfx_mono_st7565r_draw_pixel+0x70>
     a60:	60 32       	cpi	r22, 0x20	; 32
     a62:	78 f5       	brcc	.+94     	; 0xac2 <gfx_mono_st7565r_draw_pixel+0x70>
     a64:	d4 2f       	mov	r29, r20
     a66:	c8 2f       	mov	r28, r24
		return;
	}

	page = y / GFX_MONO_LCD_PIXELS_PER_BYTE;
     a68:	f6 2e       	mov	r15, r22
     a6a:	f6 94       	lsr	r15
     a6c:	f6 94       	lsr	r15
     a6e:	f6 94       	lsr	r15
	pixel_mask = (1 << (y - (page * 8)));
     a70:	2f 2d       	mov	r18, r15
     a72:	30 e0       	ldi	r19, 0x00	; 0
     a74:	31 95       	neg	r19
     a76:	21 95       	neg	r18
     a78:	31 09       	sbc	r19, r1
     a7a:	22 0f       	add	r18, r18
     a7c:	33 1f       	adc	r19, r19
     a7e:	22 0f       	add	r18, r18
     a80:	33 1f       	adc	r19, r19
     a82:	22 0f       	add	r18, r18
     a84:	33 1f       	adc	r19, r19
     a86:	26 0f       	add	r18, r22
     a88:	31 1d       	adc	r19, r1
     a8a:	61 e0       	ldi	r22, 0x01	; 1
     a8c:	70 e0       	ldi	r23, 0x00	; 0
     a8e:	8b 01       	movw	r16, r22
     a90:	02 c0       	rjmp	.+4      	; 0xa96 <gfx_mono_st7565r_draw_pixel+0x44>
     a92:	00 0f       	add	r16, r16
     a94:	11 1f       	adc	r17, r17
     a96:	2a 95       	dec	r18
     a98:	e2 f7       	brpl	.-8      	; 0xa92 <gfx_mono_st7565r_draw_pixel+0x40>
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     a9a:	68 2f       	mov	r22, r24
     a9c:	8f 2d       	mov	r24, r15
     a9e:	2c d0       	rcall	.+88     	; 0xaf8 <gfx_mono_framebuffer_get_byte>
	 * requested action on this pixel before writing the page back to the
	 * display.
	 */
	pixel_value = gfx_mono_get_byte(page, x);

	switch (color) {
     aa0:	d1 30       	cpi	r29, 0x01	; 1
     aa2:	21 f0       	breq	.+8      	; 0xaac <gfx_mono_st7565r_draw_pixel+0x5a>
     aa4:	28 f0       	brcs	.+10     	; 0xab0 <gfx_mono_st7565r_draw_pixel+0x5e>
     aa6:	d2 30       	cpi	r29, 0x02	; 2
     aa8:	39 f0       	breq	.+14     	; 0xab8 <gfx_mono_st7565r_draw_pixel+0x66>
     aaa:	07 c0       	rjmp	.+14     	; 0xaba <gfx_mono_st7565r_draw_pixel+0x68>
	case GFX_PIXEL_SET:
		pixel_value |= pixel_mask;
     aac:	80 2b       	or	r24, r16
		break;
     aae:	05 c0       	rjmp	.+10     	; 0xaba <gfx_mono_st7565r_draw_pixel+0x68>

	case GFX_PIXEL_CLR:
		pixel_value &= ~pixel_mask;
     ab0:	60 2f       	mov	r22, r16
     ab2:	60 95       	com	r22
     ab4:	86 23       	and	r24, r22
		break;
     ab6:	01 c0       	rjmp	.+2      	; 0xaba <gfx_mono_st7565r_draw_pixel+0x68>

	case GFX_PIXEL_XOR:
		pixel_value ^= pixel_mask;
     ab8:	80 27       	eor	r24, r16

	default:
		break;
	}

	gfx_mono_put_byte(page, x, pixel_value);
     aba:	48 2f       	mov	r20, r24
     abc:	6c 2f       	mov	r22, r28
     abe:	8f 2d       	mov	r24, r15
     ac0:	df de       	rcall	.-578    	; 0x880 <gfx_mono_st7565r_put_byte>
}
     ac2:	df 91       	pop	r29
     ac4:	cf 91       	pop	r28
     ac6:	1f 91       	pop	r17
     ac8:	0f 91       	pop	r16
     aca:	ff 90       	pop	r15
     acc:	08 95       	ret

00000ace <gfx_mono_st7565r_get_byte>:
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     ace:	14 c0       	rjmp	.+40     	; 0xaf8 <gfx_mono_framebuffer_get_byte>
	st7565r_set_column_address(column);

	return st7565r_read_data();

#endif
}
     ad0:	08 95       	ret

00000ad2 <gfx_mono_set_framebuffer>:
	gfx_coord_t *framebuffer_pt = fbpointer +
			((page * GFX_MONO_LCD_WIDTH) + column);
	do {
		*data++ = *framebuffer_pt++;
	} while (--width > 0);
}
     ad2:	80 93 f2 23 	sts	0x23F2, r24	; 0x8023f2 <fbpointer>
     ad6:	90 93 f3 23 	sts	0x23F3, r25	; 0x8023f3 <fbpointer+0x1>
     ada:	08 95       	ret

00000adc <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
     adc:	20 e8       	ldi	r18, 0x80	; 128
     ade:	82 9f       	mul	r24, r18
     ae0:	c0 01       	movw	r24, r0
     ae2:	11 24       	eor	r1, r1
     ae4:	86 0f       	add	r24, r22
     ae6:	91 1d       	adc	r25, r1
     ae8:	e0 91 f2 23 	lds	r30, 0x23F2	; 0x8023f2 <fbpointer>
     aec:	f0 91 f3 23 	lds	r31, 0x23F3	; 0x8023f3 <fbpointer+0x1>
     af0:	e8 0f       	add	r30, r24
     af2:	f9 1f       	adc	r31, r25
     af4:	40 83       	st	Z, r20
     af6:	08 95       	ret

00000af8 <gfx_mono_framebuffer_get_byte>:
	data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(gfx_coord_t page, gfx_coord_t column)
{
	return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
     af8:	20 e8       	ldi	r18, 0x80	; 128
     afa:	82 9f       	mul	r24, r18
     afc:	c0 01       	movw	r24, r0
     afe:	11 24       	eor	r1, r1
     b00:	86 0f       	add	r24, r22
     b02:	91 1d       	adc	r25, r1
     b04:	e0 91 f2 23 	lds	r30, 0x23F2	; 0x8023f2 <fbpointer>
     b08:	f0 91 f3 23 	lds	r31, 0x23F3	; 0x8023f3 <fbpointer+0x1>
     b0c:	e8 0f       	add	r30, r24
     b0e:	f9 1f       	adc	r31, r25
}
     b10:	80 81       	ld	r24, Z
     b12:	08 95       	ret

00000b14 <gfx_mono_generic_draw_horizontal_line>:
	gfx_mono_draw_horizontal_line(x, y, width, color);
	gfx_mono_draw_horizontal_line(x, y + height - 1, width, color);

	gfx_mono_draw_vertical_line(x, y, height, color);
	gfx_mono_draw_vertical_line(x + width - 1, y, height, color);
}
     b14:	ff 92       	push	r15
     b16:	0f 93       	push	r16
     b18:	1f 93       	push	r17
     b1a:	cf 93       	push	r28
     b1c:	df 93       	push	r29
     b1e:	e4 2f       	mov	r30, r20
     b20:	f0 e0       	ldi	r31, 0x00	; 0
     b22:	e8 0f       	add	r30, r24
     b24:	f1 1d       	adc	r31, r1
     b26:	e1 38       	cpi	r30, 0x81	; 129
     b28:	f1 05       	cpc	r31, r1
     b2a:	1c f0       	brlt	.+6      	; 0xb32 <gfx_mono_generic_draw_horizontal_line+0x1e>
     b2c:	c0 e8       	ldi	r28, 0x80	; 128
     b2e:	4c 2f       	mov	r20, r28
     b30:	48 1b       	sub	r20, r24
     b32:	44 23       	and	r20, r20
     b34:	09 f4       	brne	.+2      	; 0xb38 <gfx_mono_generic_draw_horizontal_line+0x24>
     b36:	53 c0       	rjmp	.+166    	; 0xbde <gfx_mono_generic_draw_horizontal_line+0xca>
     b38:	d6 2f       	mov	r29, r22
     b3a:	d6 95       	lsr	r29
     b3c:	d6 95       	lsr	r29
     b3e:	d6 95       	lsr	r29
     b40:	ed 2f       	mov	r30, r29
     b42:	f0 e0       	ldi	r31, 0x00	; 0
     b44:	f1 95       	neg	r31
     b46:	e1 95       	neg	r30
     b48:	f1 09       	sbc	r31, r1
     b4a:	ee 0f       	add	r30, r30
     b4c:	ff 1f       	adc	r31, r31
     b4e:	ee 0f       	add	r30, r30
     b50:	ff 1f       	adc	r31, r31
     b52:	ee 0f       	add	r30, r30
     b54:	ff 1f       	adc	r31, r31
     b56:	df 01       	movw	r26, r30
     b58:	a6 0f       	add	r26, r22
     b5a:	b1 1d       	adc	r27, r1
     b5c:	bd 01       	movw	r22, r26
     b5e:	e1 e0       	ldi	r30, 0x01	; 1
     b60:	f0 e0       	ldi	r31, 0x00	; 0
     b62:	df 01       	movw	r26, r30
     b64:	02 c0       	rjmp	.+4      	; 0xb6a <gfx_mono_generic_draw_horizontal_line+0x56>
     b66:	aa 0f       	add	r26, r26
     b68:	bb 1f       	adc	r27, r27
     b6a:	6a 95       	dec	r22
     b6c:	e2 f7       	brpl	.-8      	; 0xb66 <gfx_mono_generic_draw_horizontal_line+0x52>
     b6e:	fa 2e       	mov	r15, r26
     b70:	21 30       	cpi	r18, 0x01	; 1
     b72:	21 f0       	breq	.+8      	; 0xb7c <gfx_mono_generic_draw_horizontal_line+0x68>
     b74:	98 f0       	brcs	.+38     	; 0xb9c <gfx_mono_generic_draw_horizontal_line+0x88>
     b76:	22 30       	cpi	r18, 0x02	; 2
     b78:	19 f1       	breq	.+70     	; 0xbc0 <gfx_mono_generic_draw_horizontal_line+0xac>
     b7a:	31 c0       	rjmp	.+98     	; 0xbde <gfx_mono_generic_draw_horizontal_line+0xca>
     b7c:	c4 2f       	mov	r28, r20
     b7e:	1f ef       	ldi	r17, 0xFF	; 255
     b80:	18 0f       	add	r17, r24
     b82:	01 2f       	mov	r16, r17
     b84:	0c 0f       	add	r16, r28
     b86:	60 2f       	mov	r22, r16
     b88:	8d 2f       	mov	r24, r29
     b8a:	a1 df       	rcall	.-190    	; 0xace <gfx_mono_st7565r_get_byte>
     b8c:	48 2f       	mov	r20, r24
     b8e:	4f 29       	or	r20, r15
     b90:	60 2f       	mov	r22, r16
     b92:	8d 2f       	mov	r24, r29
     b94:	75 de       	rcall	.-790    	; 0x880 <gfx_mono_st7565r_put_byte>
     b96:	c1 50       	subi	r28, 0x01	; 1
     b98:	a1 f7       	brne	.-24     	; 0xb82 <gfx_mono_generic_draw_horizontal_line+0x6e>
     b9a:	21 c0       	rjmp	.+66     	; 0xbde <gfx_mono_generic_draw_horizontal_line+0xca>
     b9c:	c4 2f       	mov	r28, r20
     b9e:	1f ef       	ldi	r17, 0xFF	; 255
     ba0:	18 0f       	add	r17, r24
     ba2:	fa 2e       	mov	r15, r26
     ba4:	f0 94       	com	r15
     ba6:	01 2f       	mov	r16, r17
     ba8:	0c 0f       	add	r16, r28
     baa:	60 2f       	mov	r22, r16
     bac:	8d 2f       	mov	r24, r29
     bae:	8f df       	rcall	.-226    	; 0xace <gfx_mono_st7565r_get_byte>
     bb0:	48 2f       	mov	r20, r24
     bb2:	4f 21       	and	r20, r15
     bb4:	60 2f       	mov	r22, r16
     bb6:	8d 2f       	mov	r24, r29
     bb8:	63 de       	rcall	.-826    	; 0x880 <gfx_mono_st7565r_put_byte>
     bba:	c1 50       	subi	r28, 0x01	; 1
     bbc:	a1 f7       	brne	.-24     	; 0xba6 <gfx_mono_generic_draw_horizontal_line+0x92>
     bbe:	0f c0       	rjmp	.+30     	; 0xbde <gfx_mono_generic_draw_horizontal_line+0xca>
     bc0:	c4 2f       	mov	r28, r20
     bc2:	1f ef       	ldi	r17, 0xFF	; 255
     bc4:	18 0f       	add	r17, r24
     bc6:	01 2f       	mov	r16, r17
     bc8:	0c 0f       	add	r16, r28
     bca:	60 2f       	mov	r22, r16
     bcc:	8d 2f       	mov	r24, r29
     bce:	7f df       	rcall	.-258    	; 0xace <gfx_mono_st7565r_get_byte>
     bd0:	48 2f       	mov	r20, r24
     bd2:	4f 25       	eor	r20, r15
     bd4:	60 2f       	mov	r22, r16
     bd6:	8d 2f       	mov	r24, r29
     bd8:	53 de       	rcall	.-858    	; 0x880 <gfx_mono_st7565r_put_byte>
     bda:	c1 50       	subi	r28, 0x01	; 1
     bdc:	a1 f7       	brne	.-24     	; 0xbc6 <gfx_mono_generic_draw_horizontal_line+0xb2>
     bde:	df 91       	pop	r29
     be0:	cf 91       	pop	r28
     be2:	1f 91       	pop	r17
     be4:	0f 91       	pop	r16
     be6:	ff 90       	pop	r15
     be8:	08 95       	ret

00000bea <gfx_mono_generic_draw_filled_rect>:
 * \param  color       Pixel operation of the line
 */
void gfx_mono_generic_draw_filled_rect(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t width, gfx_coord_t height,
		enum gfx_mono_color color)
{
     bea:	ff 92       	push	r15
     bec:	0f 93       	push	r16
     bee:	1f 93       	push	r17
     bf0:	cf 93       	push	r28
     bf2:	df 93       	push	r29
	if (height == 0) {
     bf4:	22 23       	and	r18, r18
     bf6:	69 f0       	breq	.+26     	; 0xc12 <gfx_mono_generic_draw_filled_rect+0x28>
     bf8:	c2 2f       	mov	r28, r18
     bfa:	f4 2e       	mov	r15, r20
     bfc:	18 2f       	mov	r17, r24
     bfe:	df ef       	ldi	r29, 0xFF	; 255
     c00:	d6 0f       	add	r29, r22
     c02:	6d 2f       	mov	r22, r29
     c04:	6c 0f       	add	r22, r28
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
     c06:	20 2f       	mov	r18, r16
     c08:	4f 2d       	mov	r20, r15
     c0a:	81 2f       	mov	r24, r17
     c0c:	83 df       	rcall	.-250    	; 0xb14 <gfx_mono_generic_draw_horizontal_line>
     c0e:	c1 50       	subi	r28, 0x01	; 1
	if (height == 0) {
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
     c10:	c1 f7       	brne	.-16     	; 0xc02 <gfx_mono_generic_draw_filled_rect+0x18>
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
	}
}
     c12:	df 91       	pop	r29
     c14:	cf 91       	pop	r28
     c16:	1f 91       	pop	r17
     c18:	0f 91       	pop	r16
     c1a:	ff 90       	pop	r15
     c1c:	08 95       	ret

00000c1e <gfx_mono_draw_char>:
 * \param y        Y coordinate on screen.
 * \param font     Font to draw character in
 */
void gfx_mono_draw_char(const char c, const gfx_coord_t x, const gfx_coord_t y,
		const struct font *font)
{
     c1e:	af 92       	push	r10
     c20:	bf 92       	push	r11
     c22:	cf 92       	push	r12
     c24:	df 92       	push	r13
     c26:	ef 92       	push	r14
     c28:	ff 92       	push	r15
     c2a:	0f 93       	push	r16
     c2c:	1f 93       	push	r17
     c2e:	cf 93       	push	r28
     c30:	df 93       	push	r29
     c32:	c8 2f       	mov	r28, r24
     c34:	e6 2e       	mov	r14, r22
     c36:	b4 2e       	mov	r11, r20
     c38:	69 01       	movw	r12, r18
	gfx_mono_draw_filled_rect(x, y, font->width, font->height,
     c3a:	00 e0       	ldi	r16, 0x00	; 0
     c3c:	f9 01       	movw	r30, r18
     c3e:	24 81       	ldd	r18, Z+4	; 0x04
     c40:	43 81       	ldd	r20, Z+3	; 0x03
     c42:	6b 2d       	mov	r22, r11
     c44:	8e 2d       	mov	r24, r14
     c46:	d1 df       	rcall	.-94     	; 0xbea <gfx_mono_generic_draw_filled_rect>
			GFX_PIXEL_CLR);

	switch (font->type) {
     c48:	f6 01       	movw	r30, r12
     c4a:	80 81       	ld	r24, Z
     c4c:	81 11       	cpse	r24, r1
     c4e:	39 c0       	rjmp	.+114    	; 0xcc2 <gfx_mono_draw_char+0xa4>
	Assert(font != NULL);

	gfx_coord_t inc_x = x;
	gfx_coord_t inc_y = y;

	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
     c50:	83 81       	ldd	r24, Z+3	; 0x03
     c52:	28 2f       	mov	r18, r24
     c54:	26 95       	lsr	r18
     c56:	26 95       	lsr	r18
     c58:	26 95       	lsr	r18
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
     c5a:	87 70       	andi	r24, 0x07	; 7
     c5c:	09 f0       	breq	.+2      	; 0xc60 <gfx_mono_draw_char+0x42>
		char_row_size++;
     c5e:	2f 5f       	subi	r18, 0xFF	; 255
	}

	glyph_data_offset = char_row_size * font->height *
     c60:	f6 01       	movw	r30, r12
     c62:	a4 80       	ldd	r10, Z+4	; 0x04
     c64:	2a 9d       	mul	r18, r10
     c66:	90 01       	movw	r18, r0
     c68:	11 24       	eor	r1, r1
			((uint8_t)ch - font->first_char);
     c6a:	8c 2f       	mov	r24, r28
     c6c:	90 e0       	ldi	r25, 0x00	; 0
     c6e:	45 81       	ldd	r20, Z+5	; 0x05
     c70:	84 1b       	sub	r24, r20
     c72:	91 09       	sbc	r25, r1
	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
		char_row_size++;
	}

	glyph_data_offset = char_row_size * font->height *
     c74:	28 9f       	mul	r18, r24
     c76:	a0 01       	movw	r20, r0
     c78:	29 9f       	mul	r18, r25
     c7a:	50 0d       	add	r21, r0
     c7c:	38 9f       	mul	r19, r24
     c7e:	50 0d       	add	r21, r0
     c80:	11 24       	eor	r1, r1
			((uint8_t)ch - font->first_char);
	glyph_data = font->data.progmem + glyph_data_offset;
     c82:	01 81       	ldd	r16, Z+1	; 0x01
     c84:	12 81       	ldd	r17, Z+2	; 0x02
     c86:	04 0f       	add	r16, r20
     c88:	15 1f       	adc	r17, r21
	rows_left = font->height;

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;
     c8a:	f6 01       	movw	r30, r12
     c8c:	f3 80       	ldd	r15, Z+3	; 0x03

		for (i = 0; i < pixelsToDraw; i++) {
     c8e:	ff 20       	and	r15, r15
     c90:	a1 f0       	breq	.+40     	; 0xcba <gfx_mono_draw_char+0x9c>
     c92:	d0 e0       	ldi	r29, 0x00	; 0
     c94:	c0 e0       	ldi	r28, 0x00	; 0
     c96:	8c 2f       	mov	r24, r28
     c98:	8e 0d       	add	r24, r14
			if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
     c9a:	9c 2f       	mov	r25, r28
     c9c:	97 70       	andi	r25, 0x07	; 7
     c9e:	21 f4       	brne	.+8      	; 0xca8 <gfx_mono_draw_char+0x8a>
				glyph_byte = PROGMEM_READ_BYTE(glyph_data);
     ca0:	f8 01       	movw	r30, r16
     ca2:	d4 91       	lpm	r29, Z
				glyph_data++;
     ca4:	0f 5f       	subi	r16, 0xFF	; 255
     ca6:	1f 4f       	sbci	r17, 0xFF	; 255
			}

			if ((glyph_byte & 0x80)) {
     ca8:	dd 23       	and	r29, r29
     caa:	1c f4       	brge	.+6      	; 0xcb2 <gfx_mono_draw_char+0x94>
				gfx_mono_draw_pixel(inc_x, inc_y,
     cac:	41 e0       	ldi	r20, 0x01	; 1
     cae:	6b 2d       	mov	r22, r11
     cb0:	d0 de       	rcall	.-608    	; 0xa52 <gfx_mono_st7565r_draw_pixel>
						GFX_PIXEL_SET);
			}

			inc_x += 1;
			glyph_byte <<= 1;
     cb2:	dd 0f       	add	r29, r29

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
     cb4:	cf 5f       	subi	r28, 0xFF	; 255
     cb6:	cf 11       	cpse	r28, r15
     cb8:	ee cf       	rjmp	.-36     	; 0xc96 <gfx_mono_draw_char+0x78>

			inc_x += 1;
			glyph_byte <<= 1;
		}

		inc_y += 1;
     cba:	b3 94       	inc	r11
		inc_x = x;
		rows_left--;
     cbc:	aa 94       	dec	r10
	} while (rows_left > 0);
     cbe:	a1 10       	cpse	r10, r1
     cc0:	e4 cf       	rjmp	.-56     	; 0xc8a <gfx_mono_draw_char+0x6c>
	default:
		/* Unsupported mode, call assert */
		Assert(false);
		break;
	}
}
     cc2:	df 91       	pop	r29
     cc4:	cf 91       	pop	r28
     cc6:	1f 91       	pop	r17
     cc8:	0f 91       	pop	r16
     cca:	ff 90       	pop	r15
     ccc:	ef 90       	pop	r14
     cce:	df 90       	pop	r13
     cd0:	cf 90       	pop	r12
     cd2:	bf 90       	pop	r11
     cd4:	af 90       	pop	r10
     cd6:	08 95       	ret

00000cd8 <gfx_mono_draw_string>:
 * \param y         Y coordinate on screen.
 * \param font      Font to draw string in
 */
void gfx_mono_draw_string(const char *str, gfx_coord_t x, gfx_coord_t y,
		const struct font *font)
{
     cd8:	df 92       	push	r13
     cda:	ef 92       	push	r14
     cdc:	ff 92       	push	r15
     cde:	0f 93       	push	r16
     ce0:	1f 93       	push	r17
     ce2:	cf 93       	push	r28
     ce4:	df 93       	push	r29
     ce6:	04 2f       	mov	r16, r20
     ce8:	79 01       	movw	r14, r18
     cea:	ec 01       	movw	r28, r24
     cec:	16 2f       	mov	r17, r22

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
     cee:	d6 2e       	mov	r13, r22
	Assert(font != NULL);

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
     cf0:	89 91       	ld	r24, Y+
     cf2:	8a 30       	cpi	r24, 0x0A	; 10
     cf4:	31 f4       	brne	.+12     	; 0xd02 <gfx_mono_draw_string+0x2a>
     cf6:	f7 01       	movw	r30, r14
     cf8:	84 81       	ldd	r24, Z+4	; 0x04
     cfa:	8f 5f       	subi	r24, 0xFF	; 255
			x = start_of_string_position_x;
			y += font->height + 1;
     cfc:	08 0f       	add	r16, r24

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
     cfe:	1d 2d       	mov	r17, r13
     d00:	09 c0       	rjmp	.+18     	; 0xd14 <gfx_mono_draw_string+0x3c>
			y += font->height + 1;
		} else if (*str == '\r') {
     d02:	8d 30       	cpi	r24, 0x0D	; 13
     d04:	39 f0       	breq	.+14     	; 0xd14 <gfx_mono_draw_string+0x3c>
			/* Skip '\r' characters. */
		} else {
			gfx_mono_draw_char(*str, x, y, font);
     d06:	97 01       	movw	r18, r14
     d08:	40 2f       	mov	r20, r16
     d0a:	61 2f       	mov	r22, r17
     d0c:	88 df       	rcall	.-240    	; 0xc1e <gfx_mono_draw_char>
			x += font->width;
     d0e:	f7 01       	movw	r30, r14
     d10:	83 81       	ldd	r24, Z+3	; 0x03
     d12:	18 0f       	add	r17, r24
		}
	} while (*(++str));
     d14:	88 81       	ld	r24, Y
     d16:	81 11       	cpse	r24, r1
     d18:	eb cf       	rjmp	.-42     	; 0xcf0 <gfx_mono_draw_string+0x18>
}
     d1a:	df 91       	pop	r29
     d1c:	cf 91       	pop	r28
     d1e:	1f 91       	pop	r17
     d20:	0f 91       	pop	r16
     d22:	ff 90       	pop	r15
     d24:	ef 90       	pop	r14
     d26:	df 90       	pop	r13
     d28:	08 95       	ret

00000d2a <usart_spi_init>:
		*data = usart_spi_transmit(usart, CONFIG_USART_SPI_DUMMY);
		len--;
		data++;
 	}
	return STATUS_OK;
}
     d2a:	80 3a       	cpi	r24, 0xA0	; 160
     d2c:	28 e0       	ldi	r18, 0x08	; 8
     d2e:	92 07       	cpc	r25, r18
     d30:	21 f4       	brne	.+8      	; 0xd3a <usart_spi_init+0x10>
     d32:	60 e1       	ldi	r22, 0x10	; 16
     d34:	83 e0       	ldi	r24, 0x03	; 3
     d36:	8d cd       	rjmp	.-1254   	; 0x852 <sysclk_enable_module>
     d38:	08 95       	ret
     d3a:	80 3b       	cpi	r24, 0xB0	; 176
     d3c:	28 e0       	ldi	r18, 0x08	; 8
     d3e:	92 07       	cpc	r25, r18
     d40:	21 f4       	brne	.+8      	; 0xd4a <usart_spi_init+0x20>
     d42:	60 e2       	ldi	r22, 0x20	; 32
     d44:	83 e0       	ldi	r24, 0x03	; 3
     d46:	85 cd       	rjmp	.-1270   	; 0x852 <sysclk_enable_module>
     d48:	08 95       	ret
     d4a:	80 3a       	cpi	r24, 0xA0	; 160
     d4c:	29 e0       	ldi	r18, 0x09	; 9
     d4e:	92 07       	cpc	r25, r18
     d50:	21 f4       	brne	.+8      	; 0xd5a <usart_spi_init+0x30>
     d52:	60 e1       	ldi	r22, 0x10	; 16
     d54:	84 e0       	ldi	r24, 0x04	; 4
     d56:	7d cd       	rjmp	.-1286   	; 0x852 <sysclk_enable_module>
     d58:	08 95       	ret
     d5a:	80 3b       	cpi	r24, 0xB0	; 176
     d5c:	29 e0       	ldi	r18, 0x09	; 9
     d5e:	92 07       	cpc	r25, r18
     d60:	21 f4       	brne	.+8      	; 0xd6a <usart_spi_init+0x40>
     d62:	60 e2       	ldi	r22, 0x20	; 32
     d64:	84 e0       	ldi	r24, 0x04	; 4
     d66:	75 cd       	rjmp	.-1302   	; 0x852 <sysclk_enable_module>
     d68:	08 95       	ret
     d6a:	80 3a       	cpi	r24, 0xA0	; 160
     d6c:	2a e0       	ldi	r18, 0x0A	; 10
     d6e:	92 07       	cpc	r25, r18
     d70:	21 f4       	brne	.+8      	; 0xd7a <usart_spi_init+0x50>
     d72:	60 e1       	ldi	r22, 0x10	; 16
     d74:	85 e0       	ldi	r24, 0x05	; 5
     d76:	6d cd       	rjmp	.-1318   	; 0x852 <sysclk_enable_module>
     d78:	08 95       	ret
     d7a:	80 3a       	cpi	r24, 0xA0	; 160
     d7c:	9b 40       	sbci	r25, 0x0B	; 11
     d7e:	19 f4       	brne	.+6      	; 0xd86 <usart_spi_init+0x5c>
     d80:	60 e1       	ldi	r22, 0x10	; 16
     d82:	86 e0       	ldi	r24, 0x06	; 6
     d84:	66 cd       	rjmp	.-1332   	; 0x852 <sysclk_enable_module>
     d86:	08 95       	ret

00000d88 <usart_spi_setup_device>:
     d88:	0f 93       	push	r16
     d8a:	1f 93       	push	r17
     d8c:	cf 93       	push	r28
     d8e:	df 93       	push	r29
     d90:	00 d0       	rcall	.+0      	; 0xd92 <usart_spi_setup_device+0xa>
     d92:	00 d0       	rcall	.+0      	; 0xd94 <usart_spi_setup_device+0xc>
     d94:	cd b7       	in	r28, 0x3d	; 61
     d96:	de b7       	in	r29, 0x3e	; 62
     d98:	09 83       	std	Y+1, r16	; 0x01
     d9a:	1a 83       	std	Y+2, r17	; 0x02
     d9c:	2b 83       	std	Y+3, r18	; 0x03
     d9e:	3c 83       	std	Y+4, r19	; 0x04
     da0:	4d 83       	std	Y+5, r20	; 0x05
     da2:	1e 82       	std	Y+6, r1	; 0x06
     da4:	be 01       	movw	r22, r28
     da6:	6f 5f       	subi	r22, 0xFF	; 255
     da8:	7f 4f       	sbci	r23, 0xFF	; 255
     daa:	6a d5       	rcall	.+2772   	; 0x1880 <usart_init_spi>
     dac:	26 96       	adiw	r28, 0x06	; 6
     dae:	cd bf       	out	0x3d, r28	; 61
     db0:	de bf       	out	0x3e, r29	; 62
     db2:	df 91       	pop	r29
     db4:	cf 91       	pop	r28
     db6:	1f 91       	pop	r17
     db8:	0f 91       	pop	r16
     dba:	08 95       	ret

00000dbc <usart_spi_select_device>:

void usart_spi_select_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_low(device->id);
     dbc:	fb 01       	movw	r30, r22
     dbe:	80 81       	ld	r24, Z
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
     dc0:	e8 2f       	mov	r30, r24
     dc2:	e6 95       	lsr	r30
     dc4:	e6 95       	lsr	r30
     dc6:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
     dc8:	40 e2       	ldi	r20, 0x20	; 32
     dca:	e4 9f       	mul	r30, r20
     dcc:	f0 01       	movw	r30, r0
     dce:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
     dd0:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
     dd2:	87 70       	andi	r24, 0x07	; 7
     dd4:	21 e0       	ldi	r18, 0x01	; 1
     dd6:	30 e0       	ldi	r19, 0x00	; 0
     dd8:	a9 01       	movw	r20, r18
     dda:	02 c0       	rjmp	.+4      	; 0xde0 <usart_spi_select_device+0x24>
     ddc:	44 0f       	add	r20, r20
     dde:	55 1f       	adc	r21, r21
     de0:	8a 95       	dec	r24
     de2:	e2 f7       	brpl	.-8      	; 0xddc <usart_spi_select_device+0x20>
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     de4:	46 83       	std	Z+6, r20	; 0x06
     de6:	08 95       	ret

00000de8 <usart_spi_deselect_device>:
}

void usart_spi_deselect_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_high(device->id);
     de8:	fb 01       	movw	r30, r22
     dea:	80 81       	ld	r24, Z
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
     dec:	e8 2f       	mov	r30, r24
     dee:	e6 95       	lsr	r30
     df0:	e6 95       	lsr	r30
     df2:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
     df4:	40 e2       	ldi	r20, 0x20	; 32
     df6:	e4 9f       	mul	r30, r20
     df8:	f0 01       	movw	r30, r0
     dfa:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
     dfc:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
     dfe:	87 70       	andi	r24, 0x07	; 7
     e00:	21 e0       	ldi	r18, 0x01	; 1
     e02:	30 e0       	ldi	r19, 0x00	; 0
     e04:	a9 01       	movw	r20, r18
     e06:	02 c0       	rjmp	.+4      	; 0xe0c <usart_spi_deselect_device+0x24>
     e08:	44 0f       	add	r20, r20
     e0a:	55 1f       	adc	r21, r21
     e0c:	8a 95       	dec	r24
     e0e:	e2 f7       	brpl	.-8      	; 0xe08 <usart_spi_deselect_device+0x20>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     e10:	45 83       	std	Z+5, r20	; 0x05
     e12:	08 95       	ret

00000e14 <adc_enable_clock>:
void adc_enable_clock(ADC_t *adc);

void adc_enable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
     e14:	81 15       	cp	r24, r1
     e16:	22 e0       	ldi	r18, 0x02	; 2
     e18:	92 07       	cpc	r25, r18
     e1a:	61 f4       	brne	.+24     	; 0xe34 <adc_enable_clock+0x20>
		Assert(adca_enable_count < 0xff);
		if (!adca_enable_count++) {
     e1c:	80 91 f5 23 	lds	r24, 0x23F5	; 0x8023f5 <adca_enable_count>
     e20:	91 e0       	ldi	r25, 0x01	; 1
     e22:	98 0f       	add	r25, r24
     e24:	90 93 f5 23 	sts	0x23F5, r25	; 0x8023f5 <adca_enable_count>
     e28:	81 11       	cpse	r24, r1
     e2a:	12 c0       	rjmp	.+36     	; 0xe50 <adc_enable_clock+0x3c>
			sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
     e2c:	62 e0       	ldi	r22, 0x02	; 2
     e2e:	81 e0       	ldi	r24, 0x01	; 1
     e30:	10 cd       	rjmp	.-1504   	; 0x852 <sysclk_enable_module>
     e32:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
     e34:	80 34       	cpi	r24, 0x40	; 64
     e36:	92 40       	sbci	r25, 0x02	; 2
     e38:	59 f4       	brne	.+22     	; 0xe50 <adc_enable_clock+0x3c>
		Assert(adcb_enable_count < 0xff);
		if (!adcb_enable_count++) {
     e3a:	80 91 f4 23 	lds	r24, 0x23F4	; 0x8023f4 <adcb_enable_count>
     e3e:	91 e0       	ldi	r25, 0x01	; 1
     e40:	98 0f       	add	r25, r24
     e42:	90 93 f4 23 	sts	0x23F4, r25	; 0x8023f4 <adcb_enable_count>
     e46:	81 11       	cpse	r24, r1
     e48:	03 c0       	rjmp	.+6      	; 0xe50 <adc_enable_clock+0x3c>
			sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
     e4a:	62 e0       	ldi	r22, 0x02	; 2
     e4c:	82 e0       	ldi	r24, 0x02	; 2
     e4e:	01 cd       	rjmp	.-1534   	; 0x852 <sysclk_enable_module>
     e50:	08 95       	ret

00000e52 <adc_disable_clock>:
void adc_disable_clock(ADC_t *adc);

void adc_disable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
     e52:	81 15       	cp	r24, r1
     e54:	22 e0       	ldi	r18, 0x02	; 2
     e56:	92 07       	cpc	r25, r18
     e58:	59 f4       	brne	.+22     	; 0xe70 <adc_disable_clock+0x1e>
		Assert(adca_enable_count);
		if (!--adca_enable_count) {
     e5a:	80 91 f5 23 	lds	r24, 0x23F5	; 0x8023f5 <adca_enable_count>
     e5e:	81 50       	subi	r24, 0x01	; 1
     e60:	80 93 f5 23 	sts	0x23F5, r24	; 0x8023f5 <adca_enable_count>
     e64:	81 11       	cpse	r24, r1
     e66:	11 c0       	rjmp	.+34     	; 0xe8a <adc_disable_clock+0x38>
			sysclk_disable_module(SYSCLK_PORT_A, SYSCLK_ADC);
     e68:	62 e0       	ldi	r22, 0x02	; 2
     e6a:	81 e0       	ldi	r24, 0x01	; 1
     e6c:	fe cc       	rjmp	.-1540   	; 0x86a <sysclk_disable_module>
     e6e:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
     e70:	80 34       	cpi	r24, 0x40	; 64
     e72:	92 40       	sbci	r25, 0x02	; 2
     e74:	51 f4       	brne	.+20     	; 0xe8a <adc_disable_clock+0x38>
		Assert(adcb_enable_count);
		if (!--adcb_enable_count) {
     e76:	80 91 f4 23 	lds	r24, 0x23F4	; 0x8023f4 <adcb_enable_count>
     e7a:	81 50       	subi	r24, 0x01	; 1
     e7c:	80 93 f4 23 	sts	0x23F4, r24	; 0x8023f4 <adcb_enable_count>
     e80:	81 11       	cpse	r24, r1
     e82:	03 c0       	rjmp	.+6      	; 0xe8a <adc_disable_clock+0x38>
			sysclk_disable_module(SYSCLK_PORT_B, SYSCLK_ADC);
     e84:	62 e0       	ldi	r22, 0x02	; 2
     e86:	82 e0       	ldi	r24, 0x02	; 2
     e88:	f0 cc       	rjmp	.-1568   	; 0x86a <sysclk_disable_module>
     e8a:	08 95       	ret

00000e8c <adc_enable>:
 * a conversion. For most XMEGA devices the start-up time is specified
 * to be a maximum of 24 ADC clock cycles. Please verify the start-up time for
 * the device in use.
 */
void adc_enable(ADC_t *adc)
{
     e8c:	1f 93       	push	r17
     e8e:	cf 93       	push	r28
     e90:	df 93       	push	r29
     e92:	ec 01       	movw	r28, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     e94:	1f b7       	in	r17, 0x3f	; 63
	cpu_irq_disable();
     e96:	f8 94       	cli
	irqflags_t flags = cpu_irq_save();
	adc_enable_clock(adc);
     e98:	bd df       	rcall	.-134    	; 0xe14 <adc_enable_clock>
	adc->CTRLA |= ADC_ENABLE_bm;
     e9a:	88 81       	ld	r24, Y
     e9c:	81 60       	ori	r24, 0x01	; 1
     e9e:	88 83       	st	Y, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     ea0:	1f bf       	out	0x3f, r17	; 63

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     ea2:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
     ea4:	f8 94       	cli
	Assert(sleepmgr_locks[mode] < 0xff);

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
     ea6:	e4 eb       	ldi	r30, 0xB4	; 180
     ea8:	f0 e6       	ldi	r31, 0x60	; 96
     eaa:	81 81       	ldd	r24, Z+1	; 0x01
     eac:	8f 5f       	subi	r24, 0xFF	; 255
     eae:	81 83       	std	Z+1, r24	; 0x01
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     eb0:	9f bf       	out	0x3f, r25	; 63
	cpu_irq_restore(flags);

	sleepmgr_lock_mode(SLEEPMGR_IDLE);
}
     eb2:	df 91       	pop	r29
     eb4:	cf 91       	pop	r28
     eb6:	1f 91       	pop	r17
     eb8:	08 95       	ret

00000eba <__vector_71>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH0_vect)
{
     eba:	1f 92       	push	r1
     ebc:	0f 92       	push	r0
     ebe:	0f b6       	in	r0, 0x3f	; 63
     ec0:	0f 92       	push	r0
     ec2:	11 24       	eor	r1, r1
     ec4:	0b b6       	in	r0, 0x3b	; 59
     ec6:	0f 92       	push	r0
     ec8:	2f 93       	push	r18
     eca:	3f 93       	push	r19
     ecc:	4f 93       	push	r20
     ece:	5f 93       	push	r21
     ed0:	6f 93       	push	r22
     ed2:	7f 93       	push	r23
     ed4:	8f 93       	push	r24
     ed6:	9f 93       	push	r25
     ed8:	af 93       	push	r26
     eda:	bf 93       	push	r27
     edc:	ef 93       	push	r30
     ede:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH0, adc_get_result(&ADCA, ADC_CH0));
     ee0:	40 91 24 02 	lds	r20, 0x0224	; 0x800224 <__TEXT_REGION_LENGTH__+0x700224>
     ee4:	50 91 25 02 	lds	r21, 0x0225	; 0x800225 <__TEXT_REGION_LENGTH__+0x700225>
     ee8:	e0 91 bc 60 	lds	r30, 0x60BC	; 0x8060bc <adca_callback>
     eec:	f0 91 bd 60 	lds	r31, 0x60BD	; 0x8060bd <adca_callback+0x1>
     ef0:	61 e0       	ldi	r22, 0x01	; 1
     ef2:	80 e0       	ldi	r24, 0x00	; 0
     ef4:	92 e0       	ldi	r25, 0x02	; 2
     ef6:	19 95       	eicall
}
     ef8:	ff 91       	pop	r31
     efa:	ef 91       	pop	r30
     efc:	bf 91       	pop	r27
     efe:	af 91       	pop	r26
     f00:	9f 91       	pop	r25
     f02:	8f 91       	pop	r24
     f04:	7f 91       	pop	r23
     f06:	6f 91       	pop	r22
     f08:	5f 91       	pop	r21
     f0a:	4f 91       	pop	r20
     f0c:	3f 91       	pop	r19
     f0e:	2f 91       	pop	r18
     f10:	0f 90       	pop	r0
     f12:	0b be       	out	0x3b, r0	; 59
     f14:	0f 90       	pop	r0
     f16:	0f be       	out	0x3f, r0	; 63
     f18:	0f 90       	pop	r0
     f1a:	1f 90       	pop	r1
     f1c:	18 95       	reti

00000f1e <__vector_72>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH1_vect)
{
     f1e:	1f 92       	push	r1
     f20:	0f 92       	push	r0
     f22:	0f b6       	in	r0, 0x3f	; 63
     f24:	0f 92       	push	r0
     f26:	11 24       	eor	r1, r1
     f28:	0b b6       	in	r0, 0x3b	; 59
     f2a:	0f 92       	push	r0
     f2c:	2f 93       	push	r18
     f2e:	3f 93       	push	r19
     f30:	4f 93       	push	r20
     f32:	5f 93       	push	r21
     f34:	6f 93       	push	r22
     f36:	7f 93       	push	r23
     f38:	8f 93       	push	r24
     f3a:	9f 93       	push	r25
     f3c:	af 93       	push	r26
     f3e:	bf 93       	push	r27
     f40:	ef 93       	push	r30
     f42:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH1, adc_get_result(&ADCA, ADC_CH1));
     f44:	40 91 2c 02 	lds	r20, 0x022C	; 0x80022c <__TEXT_REGION_LENGTH__+0x70022c>
     f48:	50 91 2d 02 	lds	r21, 0x022D	; 0x80022d <__TEXT_REGION_LENGTH__+0x70022d>
     f4c:	e0 91 bc 60 	lds	r30, 0x60BC	; 0x8060bc <adca_callback>
     f50:	f0 91 bd 60 	lds	r31, 0x60BD	; 0x8060bd <adca_callback+0x1>
     f54:	62 e0       	ldi	r22, 0x02	; 2
     f56:	80 e0       	ldi	r24, 0x00	; 0
     f58:	92 e0       	ldi	r25, 0x02	; 2
     f5a:	19 95       	eicall
}
     f5c:	ff 91       	pop	r31
     f5e:	ef 91       	pop	r30
     f60:	bf 91       	pop	r27
     f62:	af 91       	pop	r26
     f64:	9f 91       	pop	r25
     f66:	8f 91       	pop	r24
     f68:	7f 91       	pop	r23
     f6a:	6f 91       	pop	r22
     f6c:	5f 91       	pop	r21
     f6e:	4f 91       	pop	r20
     f70:	3f 91       	pop	r19
     f72:	2f 91       	pop	r18
     f74:	0f 90       	pop	r0
     f76:	0b be       	out	0x3b, r0	; 59
     f78:	0f 90       	pop	r0
     f7a:	0f be       	out	0x3f, r0	; 63
     f7c:	0f 90       	pop	r0
     f7e:	1f 90       	pop	r1
     f80:	18 95       	reti

00000f82 <__vector_73>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH2_vect)
{
     f82:	1f 92       	push	r1
     f84:	0f 92       	push	r0
     f86:	0f b6       	in	r0, 0x3f	; 63
     f88:	0f 92       	push	r0
     f8a:	11 24       	eor	r1, r1
     f8c:	0b b6       	in	r0, 0x3b	; 59
     f8e:	0f 92       	push	r0
     f90:	2f 93       	push	r18
     f92:	3f 93       	push	r19
     f94:	4f 93       	push	r20
     f96:	5f 93       	push	r21
     f98:	6f 93       	push	r22
     f9a:	7f 93       	push	r23
     f9c:	8f 93       	push	r24
     f9e:	9f 93       	push	r25
     fa0:	af 93       	push	r26
     fa2:	bf 93       	push	r27
     fa4:	ef 93       	push	r30
     fa6:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH2, adc_get_result(&ADCA, ADC_CH2));
     fa8:	40 91 34 02 	lds	r20, 0x0234	; 0x800234 <__TEXT_REGION_LENGTH__+0x700234>
     fac:	50 91 35 02 	lds	r21, 0x0235	; 0x800235 <__TEXT_REGION_LENGTH__+0x700235>
     fb0:	e0 91 bc 60 	lds	r30, 0x60BC	; 0x8060bc <adca_callback>
     fb4:	f0 91 bd 60 	lds	r31, 0x60BD	; 0x8060bd <adca_callback+0x1>
     fb8:	64 e0       	ldi	r22, 0x04	; 4
     fba:	80 e0       	ldi	r24, 0x00	; 0
     fbc:	92 e0       	ldi	r25, 0x02	; 2
     fbe:	19 95       	eicall
}
     fc0:	ff 91       	pop	r31
     fc2:	ef 91       	pop	r30
     fc4:	bf 91       	pop	r27
     fc6:	af 91       	pop	r26
     fc8:	9f 91       	pop	r25
     fca:	8f 91       	pop	r24
     fcc:	7f 91       	pop	r23
     fce:	6f 91       	pop	r22
     fd0:	5f 91       	pop	r21
     fd2:	4f 91       	pop	r20
     fd4:	3f 91       	pop	r19
     fd6:	2f 91       	pop	r18
     fd8:	0f 90       	pop	r0
     fda:	0b be       	out	0x3b, r0	; 59
     fdc:	0f 90       	pop	r0
     fde:	0f be       	out	0x3f, r0	; 63
     fe0:	0f 90       	pop	r0
     fe2:	1f 90       	pop	r1
     fe4:	18 95       	reti

00000fe6 <__vector_74>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH3_vect)
{
     fe6:	1f 92       	push	r1
     fe8:	0f 92       	push	r0
     fea:	0f b6       	in	r0, 0x3f	; 63
     fec:	0f 92       	push	r0
     fee:	11 24       	eor	r1, r1
     ff0:	0b b6       	in	r0, 0x3b	; 59
     ff2:	0f 92       	push	r0
     ff4:	2f 93       	push	r18
     ff6:	3f 93       	push	r19
     ff8:	4f 93       	push	r20
     ffa:	5f 93       	push	r21
     ffc:	6f 93       	push	r22
     ffe:	7f 93       	push	r23
    1000:	8f 93       	push	r24
    1002:	9f 93       	push	r25
    1004:	af 93       	push	r26
    1006:	bf 93       	push	r27
    1008:	ef 93       	push	r30
    100a:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH3, adc_get_result(&ADCA, ADC_CH3));
    100c:	40 91 3c 02 	lds	r20, 0x023C	; 0x80023c <__TEXT_REGION_LENGTH__+0x70023c>
    1010:	50 91 3d 02 	lds	r21, 0x023D	; 0x80023d <__TEXT_REGION_LENGTH__+0x70023d>
    1014:	e0 91 bc 60 	lds	r30, 0x60BC	; 0x8060bc <adca_callback>
    1018:	f0 91 bd 60 	lds	r31, 0x60BD	; 0x8060bd <adca_callback+0x1>
    101c:	68 e0       	ldi	r22, 0x08	; 8
    101e:	80 e0       	ldi	r24, 0x00	; 0
    1020:	92 e0       	ldi	r25, 0x02	; 2
    1022:	19 95       	eicall
}
    1024:	ff 91       	pop	r31
    1026:	ef 91       	pop	r30
    1028:	bf 91       	pop	r27
    102a:	af 91       	pop	r26
    102c:	9f 91       	pop	r25
    102e:	8f 91       	pop	r24
    1030:	7f 91       	pop	r23
    1032:	6f 91       	pop	r22
    1034:	5f 91       	pop	r21
    1036:	4f 91       	pop	r20
    1038:	3f 91       	pop	r19
    103a:	2f 91       	pop	r18
    103c:	0f 90       	pop	r0
    103e:	0b be       	out	0x3b, r0	; 59
    1040:	0f 90       	pop	r0
    1042:	0f be       	out	0x3f, r0	; 63
    1044:	0f 90       	pop	r0
    1046:	1f 90       	pop	r1
    1048:	18 95       	reti

0000104a <__vector_39>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH0_vect)
{
    104a:	1f 92       	push	r1
    104c:	0f 92       	push	r0
    104e:	0f b6       	in	r0, 0x3f	; 63
    1050:	0f 92       	push	r0
    1052:	11 24       	eor	r1, r1
    1054:	0b b6       	in	r0, 0x3b	; 59
    1056:	0f 92       	push	r0
    1058:	2f 93       	push	r18
    105a:	3f 93       	push	r19
    105c:	4f 93       	push	r20
    105e:	5f 93       	push	r21
    1060:	6f 93       	push	r22
    1062:	7f 93       	push	r23
    1064:	8f 93       	push	r24
    1066:	9f 93       	push	r25
    1068:	af 93       	push	r26
    106a:	bf 93       	push	r27
    106c:	ef 93       	push	r30
    106e:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH0, adc_get_result(&ADCB, ADC_CH0));
    1070:	40 91 64 02 	lds	r20, 0x0264	; 0x800264 <__TEXT_REGION_LENGTH__+0x700264>
    1074:	50 91 65 02 	lds	r21, 0x0265	; 0x800265 <__TEXT_REGION_LENGTH__+0x700265>
    1078:	e0 91 ba 60 	lds	r30, 0x60BA	; 0x8060ba <adcb_callback>
    107c:	f0 91 bb 60 	lds	r31, 0x60BB	; 0x8060bb <adcb_callback+0x1>
    1080:	61 e0       	ldi	r22, 0x01	; 1
    1082:	80 e4       	ldi	r24, 0x40	; 64
    1084:	92 e0       	ldi	r25, 0x02	; 2
    1086:	19 95       	eicall
}
    1088:	ff 91       	pop	r31
    108a:	ef 91       	pop	r30
    108c:	bf 91       	pop	r27
    108e:	af 91       	pop	r26
    1090:	9f 91       	pop	r25
    1092:	8f 91       	pop	r24
    1094:	7f 91       	pop	r23
    1096:	6f 91       	pop	r22
    1098:	5f 91       	pop	r21
    109a:	4f 91       	pop	r20
    109c:	3f 91       	pop	r19
    109e:	2f 91       	pop	r18
    10a0:	0f 90       	pop	r0
    10a2:	0b be       	out	0x3b, r0	; 59
    10a4:	0f 90       	pop	r0
    10a6:	0f be       	out	0x3f, r0	; 63
    10a8:	0f 90       	pop	r0
    10aa:	1f 90       	pop	r1
    10ac:	18 95       	reti

000010ae <__vector_40>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH1_vect)
{
    10ae:	1f 92       	push	r1
    10b0:	0f 92       	push	r0
    10b2:	0f b6       	in	r0, 0x3f	; 63
    10b4:	0f 92       	push	r0
    10b6:	11 24       	eor	r1, r1
    10b8:	0b b6       	in	r0, 0x3b	; 59
    10ba:	0f 92       	push	r0
    10bc:	2f 93       	push	r18
    10be:	3f 93       	push	r19
    10c0:	4f 93       	push	r20
    10c2:	5f 93       	push	r21
    10c4:	6f 93       	push	r22
    10c6:	7f 93       	push	r23
    10c8:	8f 93       	push	r24
    10ca:	9f 93       	push	r25
    10cc:	af 93       	push	r26
    10ce:	bf 93       	push	r27
    10d0:	ef 93       	push	r30
    10d2:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH1, adc_get_result(&ADCB, ADC_CH1));
    10d4:	40 91 6c 02 	lds	r20, 0x026C	; 0x80026c <__TEXT_REGION_LENGTH__+0x70026c>
    10d8:	50 91 6d 02 	lds	r21, 0x026D	; 0x80026d <__TEXT_REGION_LENGTH__+0x70026d>
    10dc:	e0 91 ba 60 	lds	r30, 0x60BA	; 0x8060ba <adcb_callback>
    10e0:	f0 91 bb 60 	lds	r31, 0x60BB	; 0x8060bb <adcb_callback+0x1>
    10e4:	62 e0       	ldi	r22, 0x02	; 2
    10e6:	80 e4       	ldi	r24, 0x40	; 64
    10e8:	92 e0       	ldi	r25, 0x02	; 2
    10ea:	19 95       	eicall
}
    10ec:	ff 91       	pop	r31
    10ee:	ef 91       	pop	r30
    10f0:	bf 91       	pop	r27
    10f2:	af 91       	pop	r26
    10f4:	9f 91       	pop	r25
    10f6:	8f 91       	pop	r24
    10f8:	7f 91       	pop	r23
    10fa:	6f 91       	pop	r22
    10fc:	5f 91       	pop	r21
    10fe:	4f 91       	pop	r20
    1100:	3f 91       	pop	r19
    1102:	2f 91       	pop	r18
    1104:	0f 90       	pop	r0
    1106:	0b be       	out	0x3b, r0	; 59
    1108:	0f 90       	pop	r0
    110a:	0f be       	out	0x3f, r0	; 63
    110c:	0f 90       	pop	r0
    110e:	1f 90       	pop	r1
    1110:	18 95       	reti

00001112 <__vector_41>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH2_vect)
{
    1112:	1f 92       	push	r1
    1114:	0f 92       	push	r0
    1116:	0f b6       	in	r0, 0x3f	; 63
    1118:	0f 92       	push	r0
    111a:	11 24       	eor	r1, r1
    111c:	0b b6       	in	r0, 0x3b	; 59
    111e:	0f 92       	push	r0
    1120:	2f 93       	push	r18
    1122:	3f 93       	push	r19
    1124:	4f 93       	push	r20
    1126:	5f 93       	push	r21
    1128:	6f 93       	push	r22
    112a:	7f 93       	push	r23
    112c:	8f 93       	push	r24
    112e:	9f 93       	push	r25
    1130:	af 93       	push	r26
    1132:	bf 93       	push	r27
    1134:	ef 93       	push	r30
    1136:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH2, adc_get_result(&ADCB, ADC_CH2));
    1138:	40 91 74 02 	lds	r20, 0x0274	; 0x800274 <__TEXT_REGION_LENGTH__+0x700274>
    113c:	50 91 75 02 	lds	r21, 0x0275	; 0x800275 <__TEXT_REGION_LENGTH__+0x700275>
    1140:	e0 91 ba 60 	lds	r30, 0x60BA	; 0x8060ba <adcb_callback>
    1144:	f0 91 bb 60 	lds	r31, 0x60BB	; 0x8060bb <adcb_callback+0x1>
    1148:	64 e0       	ldi	r22, 0x04	; 4
    114a:	80 e4       	ldi	r24, 0x40	; 64
    114c:	92 e0       	ldi	r25, 0x02	; 2
    114e:	19 95       	eicall
}
    1150:	ff 91       	pop	r31
    1152:	ef 91       	pop	r30
    1154:	bf 91       	pop	r27
    1156:	af 91       	pop	r26
    1158:	9f 91       	pop	r25
    115a:	8f 91       	pop	r24
    115c:	7f 91       	pop	r23
    115e:	6f 91       	pop	r22
    1160:	5f 91       	pop	r21
    1162:	4f 91       	pop	r20
    1164:	3f 91       	pop	r19
    1166:	2f 91       	pop	r18
    1168:	0f 90       	pop	r0
    116a:	0b be       	out	0x3b, r0	; 59
    116c:	0f 90       	pop	r0
    116e:	0f be       	out	0x3f, r0	; 63
    1170:	0f 90       	pop	r0
    1172:	1f 90       	pop	r1
    1174:	18 95       	reti

00001176 <__vector_42>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH3_vect)
{
    1176:	1f 92       	push	r1
    1178:	0f 92       	push	r0
    117a:	0f b6       	in	r0, 0x3f	; 63
    117c:	0f 92       	push	r0
    117e:	11 24       	eor	r1, r1
    1180:	0b b6       	in	r0, 0x3b	; 59
    1182:	0f 92       	push	r0
    1184:	2f 93       	push	r18
    1186:	3f 93       	push	r19
    1188:	4f 93       	push	r20
    118a:	5f 93       	push	r21
    118c:	6f 93       	push	r22
    118e:	7f 93       	push	r23
    1190:	8f 93       	push	r24
    1192:	9f 93       	push	r25
    1194:	af 93       	push	r26
    1196:	bf 93       	push	r27
    1198:	ef 93       	push	r30
    119a:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH3, adc_get_result(&ADCB, ADC_CH3));
    119c:	40 91 7c 02 	lds	r20, 0x027C	; 0x80027c <__TEXT_REGION_LENGTH__+0x70027c>
    11a0:	50 91 7d 02 	lds	r21, 0x027D	; 0x80027d <__TEXT_REGION_LENGTH__+0x70027d>
    11a4:	e0 91 ba 60 	lds	r30, 0x60BA	; 0x8060ba <adcb_callback>
    11a8:	f0 91 bb 60 	lds	r31, 0x60BB	; 0x8060bb <adcb_callback+0x1>
    11ac:	68 e0       	ldi	r22, 0x08	; 8
    11ae:	80 e4       	ldi	r24, 0x40	; 64
    11b0:	92 e0       	ldi	r25, 0x02	; 2
    11b2:	19 95       	eicall
}
    11b4:	ff 91       	pop	r31
    11b6:	ef 91       	pop	r30
    11b8:	bf 91       	pop	r27
    11ba:	af 91       	pop	r26
    11bc:	9f 91       	pop	r25
    11be:	8f 91       	pop	r24
    11c0:	7f 91       	pop	r23
    11c2:	6f 91       	pop	r22
    11c4:	5f 91       	pop	r21
    11c6:	4f 91       	pop	r20
    11c8:	3f 91       	pop	r19
    11ca:	2f 91       	pop	r18
    11cc:	0f 90       	pop	r0
    11ce:	0b be       	out	0x3b, r0	; 59
    11d0:	0f 90       	pop	r0
    11d2:	0f be       	out	0x3f, r0	; 63
    11d4:	0f 90       	pop	r0
    11d6:	1f 90       	pop	r1
    11d8:	18 95       	reti

000011da <adc_write_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_write_configuration(ADC_t *adc, const struct adc_config *conf)
{
    11da:	df 92       	push	r13
    11dc:	ef 92       	push	r14
    11de:	ff 92       	push	r15
    11e0:	0f 93       	push	r16
    11e2:	1f 93       	push	r17
    11e4:	cf 93       	push	r28
    11e6:	df 93       	push	r29
    11e8:	ec 01       	movw	r28, r24
    11ea:	8b 01       	movw	r16, r22
	uint16_t cal;
	uint8_t enable;
	irqflags_t flags;

#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)&ADCA) {
    11ec:	c1 15       	cp	r28, r1
    11ee:	22 e0       	ldi	r18, 0x02	; 2
    11f0:	d2 07       	cpc	r29, r18
    11f2:	71 f4       	brne	.+28     	; 0x1210 <adc_write_configuration+0x36>
 *
 * \param address Byte offset into the signature row
 */
static inline uint8_t nvm_read_production_signature_row(uint8_t address)
{
	return nvm_read_byte(NVM_CMD_READ_CALIB_ROW_gc, address);
    11f4:	61 e2       	ldi	r22, 0x21	; 33
    11f6:	70 e0       	ldi	r23, 0x00	; 0
    11f8:	82 e0       	ldi	r24, 0x02	; 2
    11fa:	d4 d0       	rcall	.+424    	; 0x13a4 <nvm_read_byte>
	uint16_t data;

	switch (cal) {
#ifdef ADCA
	case ADC_CAL_ADCA:
		data = nvm_read_production_signature_row(ADCACAL1);
    11fc:	e8 2e       	mov	r14, r24
    11fe:	f1 2c       	mov	r15, r1
    1200:	60 e2       	ldi	r22, 0x20	; 32
    1202:	70 e0       	ldi	r23, 0x00	; 0
    1204:	82 e0       	ldi	r24, 0x02	; 2
    1206:	ce d0       	rcall	.+412    	; 0x13a4 <nvm_read_byte>
		data <<= 8;
    1208:	fe 2c       	mov	r15, r14
    120a:	ee 24       	eor	r14, r14
		data |= nvm_read_production_signature_row(ADCACAL0);
    120c:	e8 2a       	or	r14, r24
    120e:	10 c0       	rjmp	.+32     	; 0x1230 <adc_write_configuration+0x56>
		cal = adc_get_calibration_data(ADC_CAL_ADCA);
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)&ADCB) {
    1210:	80 34       	cpi	r24, 0x40	; 64
    1212:	92 40       	sbci	r25, 0x02	; 2
    1214:	51 f5       	brne	.+84     	; 0x126a <adc_write_configuration+0x90>
    1216:	65 e2       	ldi	r22, 0x25	; 37
    1218:	70 e0       	ldi	r23, 0x00	; 0
    121a:	82 e0       	ldi	r24, 0x02	; 2
    121c:	c3 d0       	rcall	.+390    	; 0x13a4 <nvm_read_byte>
		break;
#endif

#ifdef ADCB
	case ADC_CAL_ADCB:
		data = nvm_read_production_signature_row(ADCBCAL1);
    121e:	e8 2e       	mov	r14, r24
    1220:	f1 2c       	mov	r15, r1
    1222:	64 e2       	ldi	r22, 0x24	; 36
    1224:	70 e0       	ldi	r23, 0x00	; 0
    1226:	82 e0       	ldi	r24, 0x02	; 2
    1228:	bd d0       	rcall	.+378    	; 0x13a4 <nvm_read_byte>
		data <<= 8;
    122a:	fe 2c       	mov	r15, r14
    122c:	ee 24       	eor	r14, r14
		data |= nvm_read_production_signature_row(ADCBCAL0);
    122e:	e8 2a       	or	r14, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1230:	df b6       	in	r13, 0x3f	; 63
	cpu_irq_disable();
    1232:	f8 94       	cli
		Assert(0);
		return;
	}

	flags = cpu_irq_save();
	adc_enable_clock(adc);
    1234:	ce 01       	movw	r24, r28
    1236:	ee dd       	rcall	.-1060   	; 0xe14 <adc_enable_clock>
	enable = adc->CTRLA & ADC_ENABLE_bm;
    1238:	88 81       	ld	r24, Y

	adc->CTRLA = ADC_FLUSH_bm;
    123a:	92 e0       	ldi	r25, 0x02	; 2
    123c:	98 83       	st	Y, r25
	adc->CAL = cal;
    123e:	ec 86       	std	Y+12, r14	; 0x0c
    1240:	fd 86       	std	Y+13, r15	; 0x0d
	adc->CMP = conf->cmp;
    1242:	f8 01       	movw	r30, r16
    1244:	25 81       	ldd	r18, Z+5	; 0x05
    1246:	36 81       	ldd	r19, Z+6	; 0x06
    1248:	28 8f       	std	Y+24, r18	; 0x18
    124a:	39 8f       	std	Y+25, r19	; 0x19
	adc->REFCTRL = conf->refctrl;
    124c:	92 81       	ldd	r25, Z+2	; 0x02
    124e:	9a 83       	std	Y+2, r25	; 0x02
	adc->PRESCALER = conf->prescaler;
    1250:	94 81       	ldd	r25, Z+4	; 0x04
    1252:	9c 83       	std	Y+4, r25	; 0x04
	adc->EVCTRL = conf->evctrl;
    1254:	93 81       	ldd	r25, Z+3	; 0x03
    1256:	9b 83       	std	Y+3, r25	; 0x03
	adc->CTRLB = conf->ctrlb;
    1258:	91 81       	ldd	r25, Z+1	; 0x01
    125a:	99 83       	std	Y+1, r25	; 0x01
		return;
	}

	flags = cpu_irq_save();
	adc_enable_clock(adc);
	enable = adc->CTRLA & ADC_ENABLE_bm;
    125c:	81 70       	andi	r24, 0x01	; 1
	adc->REFCTRL = conf->refctrl;
	adc->PRESCALER = conf->prescaler;
	adc->EVCTRL = conf->evctrl;
	adc->CTRLB = conf->ctrlb;

	adc->CTRLA = enable | conf->ctrla;
    125e:	90 81       	ld	r25, Z
    1260:	89 2b       	or	r24, r25
    1262:	88 83       	st	Y, r24

	adc_disable_clock(adc);
    1264:	ce 01       	movw	r24, r28
    1266:	f5 dd       	rcall	.-1046   	; 0xe52 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1268:	df be       	out	0x3f, r13	; 63

	cpu_irq_restore(flags);
}
    126a:	df 91       	pop	r29
    126c:	cf 91       	pop	r28
    126e:	1f 91       	pop	r17
    1270:	0f 91       	pop	r16
    1272:	ff 90       	pop	r15
    1274:	ef 90       	pop	r14
    1276:	df 90       	pop	r13
    1278:	08 95       	ret

0000127a <adc_read_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_read_configuration(ADC_t *adc, struct adc_config *conf)
{
    127a:	ff 92       	push	r15
    127c:	0f 93       	push	r16
    127e:	1f 93       	push	r17
    1280:	cf 93       	push	r28
    1282:	df 93       	push	r29
    1284:	ec 01       	movw	r28, r24
    1286:	8b 01       	movw	r16, r22

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1288:	ff b6       	in	r15, 0x3f	; 63
	cpu_irq_disable();
    128a:	f8 94       	cli
	irqflags_t flags = cpu_irq_save();

	adc_enable_clock(adc);
    128c:	c3 dd       	rcall	.-1146   	; 0xe14 <adc_enable_clock>

	conf->ctrla = adc->CTRLA & ADC_DMASEL_gm;
    128e:	88 81       	ld	r24, Y
    1290:	80 7c       	andi	r24, 0xC0	; 192
    1292:	f8 01       	movw	r30, r16
    1294:	80 83       	st	Z, r24

	conf->cmp = adc->CMP;
    1296:	88 8d       	ldd	r24, Y+24	; 0x18
    1298:	99 8d       	ldd	r25, Y+25	; 0x19
    129a:	85 83       	std	Z+5, r24	; 0x05
    129c:	96 83       	std	Z+6, r25	; 0x06
	conf->refctrl = adc->REFCTRL;
    129e:	8a 81       	ldd	r24, Y+2	; 0x02
    12a0:	82 83       	std	Z+2, r24	; 0x02
	conf->prescaler = adc->PRESCALER;
    12a2:	8c 81       	ldd	r24, Y+4	; 0x04
    12a4:	84 83       	std	Z+4, r24	; 0x04
	conf->evctrl = adc->EVCTRL;
    12a6:	8b 81       	ldd	r24, Y+3	; 0x03
    12a8:	83 83       	std	Z+3, r24	; 0x03
	conf->ctrlb = adc->CTRLB;
    12aa:	89 81       	ldd	r24, Y+1	; 0x01
    12ac:	81 83       	std	Z+1, r24	; 0x01

	adc_disable_clock(adc);
    12ae:	ce 01       	movw	r24, r28
    12b0:	d0 dd       	rcall	.-1120   	; 0xe52 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    12b2:	ff be       	out	0x3f, r15	; 63

	cpu_irq_restore(flags);
}
    12b4:	df 91       	pop	r29
    12b6:	cf 91       	pop	r28
    12b8:	1f 91       	pop	r17
    12ba:	0f 91       	pop	r16
    12bc:	ff 90       	pop	r15
    12be:	08 95       	ret

000012c0 <adcch_write_configuration>:
 * is called if callbacks are enabled and interrupts are enabled in the
 * channel configuration.
 */
void adcch_write_configuration(ADC_t *adc, uint8_t ch_mask,
		const struct adc_channel_config *ch_conf)
{
    12c0:	cf 92       	push	r12
    12c2:	df 92       	push	r13
    12c4:	ef 92       	push	r14
    12c6:	ff 92       	push	r15
    12c8:	0f 93       	push	r16
    12ca:	1f 93       	push	r17
    12cc:	cf 93       	push	r28
    12ce:	df 93       	push	r29
    12d0:	7c 01       	movw	r14, r24
    12d2:	d6 2e       	mov	r13, r22
    12d4:	8a 01       	movw	r16, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    12d6:	86 2f       	mov	r24, r22
    12d8:	83 70       	andi	r24, 0x03	; 3
    12da:	29 f4       	brne	.+10     	; 0x12e6 <adcch_write_configuration+0x26>
		index += 2;
		ch_mask >>= 2;
    12dc:	96 2f       	mov	r25, r22
    12de:	96 95       	lsr	r25
    12e0:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    12e2:	82 e0       	ldi	r24, 0x02	; 2
    12e4:	02 c0       	rjmp	.+4      	; 0x12ea <adcch_write_configuration+0x2a>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    12e6:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
static __always_inline ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    12e8:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    12ea:	90 ff       	sbrs	r25, 0
		index++;
    12ec:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    12ee:	e7 01       	movw	r28, r14
    12f0:	a0 96       	adiw	r28, 0x20	; 32
    12f2:	98 e0       	ldi	r25, 0x08	; 8
    12f4:	89 9f       	mul	r24, r25
    12f6:	c0 0d       	add	r28, r0
    12f8:	d1 1d       	adc	r29, r1
    12fa:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    12fc:	cf b6       	in	r12, 0x3f	; 63
	cpu_irq_disable();
    12fe:	f8 94       	cli
			return;
		}
	}
#endif

	adc_enable_clock(adc);
    1300:	c7 01       	movw	r24, r14
    1302:	88 dd       	rcall	.-1264   	; 0xe14 <adc_enable_clock>
	adc_ch->CTRL = ch_conf->ctrl;
    1304:	f8 01       	movw	r30, r16
    1306:	80 81       	ld	r24, Z
    1308:	88 83       	st	Y, r24
	adc_ch->INTCTRL = ch_conf->intctrl;
    130a:	82 81       	ldd	r24, Z+2	; 0x02
    130c:	8a 83       	std	Y+2, r24	; 0x02
	adc_ch->MUXCTRL = ch_conf->muxctrl;
    130e:	81 81       	ldd	r24, Z+1	; 0x01
    1310:	89 83       	std	Y+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    1312:	d0 fe       	sbrs	r13, 0
    1314:	02 c0       	rjmp	.+4      	; 0x131a <adcch_write_configuration+0x5a>
		/* USB devices has channel scan available on ADC channel 0 */
		adc_ch->SCAN = ch_conf->scan;
    1316:	83 81       	ldd	r24, Z+3	; 0x03
    1318:	8e 83       	std	Y+6, r24	; 0x06
	}
	adc_disable_clock(adc);
    131a:	c7 01       	movw	r24, r14
    131c:	9a dd       	rcall	.-1228   	; 0xe52 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    131e:	cf be       	out	0x3f, r12	; 63

	cpu_irq_restore(flags);
}
    1320:	df 91       	pop	r29
    1322:	cf 91       	pop	r28
    1324:	1f 91       	pop	r17
    1326:	0f 91       	pop	r16
    1328:	ff 90       	pop	r15
    132a:	ef 90       	pop	r14
    132c:	df 90       	pop	r13
    132e:	cf 90       	pop	r12
    1330:	08 95       	ret

00001332 <adcch_read_configuration>:
 * can be given in mask)
 * \param ch_conf Pointer to ADC channel configuration.
 */
void adcch_read_configuration(ADC_t *adc, uint8_t ch_mask,
		struct adc_channel_config *ch_conf)
{
    1332:	cf 92       	push	r12
    1334:	df 92       	push	r13
    1336:	ef 92       	push	r14
    1338:	ff 92       	push	r15
    133a:	0f 93       	push	r16
    133c:	1f 93       	push	r17
    133e:	cf 93       	push	r28
    1340:	df 93       	push	r29
    1342:	7c 01       	movw	r14, r24
    1344:	d6 2e       	mov	r13, r22
    1346:	8a 01       	movw	r16, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1348:	86 2f       	mov	r24, r22
    134a:	83 70       	andi	r24, 0x03	; 3
    134c:	29 f4       	brne	.+10     	; 0x1358 <adcch_read_configuration+0x26>
		index += 2;
		ch_mask >>= 2;
    134e:	96 2f       	mov	r25, r22
    1350:	96 95       	lsr	r25
    1352:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    1354:	82 e0       	ldi	r24, 0x02	; 2
    1356:	02 c0       	rjmp	.+4      	; 0x135c <adcch_read_configuration+0x2a>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1358:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
static __always_inline ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    135a:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    135c:	90 ff       	sbrs	r25, 0
		index++;
    135e:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    1360:	e7 01       	movw	r28, r14
    1362:	a0 96       	adiw	r28, 0x20	; 32
    1364:	98 e0       	ldi	r25, 0x08	; 8
    1366:	89 9f       	mul	r24, r25
    1368:	c0 0d       	add	r28, r0
    136a:	d1 1d       	adc	r29, r1
    136c:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    136e:	cf b6       	in	r12, 0x3f	; 63
	cpu_irq_disable();
    1370:	f8 94       	cli

	adc_ch = adc_get_channel(adc, ch_mask);

	flags = cpu_irq_save();

	adc_enable_clock(adc);
    1372:	c7 01       	movw	r24, r14
    1374:	4f dd       	rcall	.-1378   	; 0xe14 <adc_enable_clock>
	ch_conf->ctrl = adc_ch->CTRL;
    1376:	88 81       	ld	r24, Y
    1378:	f8 01       	movw	r30, r16
    137a:	80 83       	st	Z, r24
	ch_conf->intctrl = adc_ch->INTCTRL;
    137c:	8a 81       	ldd	r24, Y+2	; 0x02
    137e:	82 83       	std	Z+2, r24	; 0x02
	ch_conf->muxctrl = adc_ch->MUXCTRL;
    1380:	89 81       	ldd	r24, Y+1	; 0x01
    1382:	81 83       	std	Z+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    1384:	d0 fe       	sbrs	r13, 0
    1386:	02 c0       	rjmp	.+4      	; 0x138c <adcch_read_configuration+0x5a>
		/* USB devices has channel scan available on ADC channel 0 */
		ch_conf->scan = adc_ch->SCAN;
    1388:	8e 81       	ldd	r24, Y+6	; 0x06
    138a:	83 83       	std	Z+3, r24	; 0x03
	}
	adc_disable_clock(adc);
    138c:	c7 01       	movw	r24, r14
    138e:	61 dd       	rcall	.-1342   	; 0xe52 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1390:	cf be       	out	0x3f, r12	; 63

	cpu_irq_restore(flags);
}
    1392:	df 91       	pop	r29
    1394:	cf 91       	pop	r28
    1396:	1f 91       	pop	r17
    1398:	0f 91       	pop	r16
    139a:	ff 90       	pop	r15
    139c:	ef 90       	pop	r14
    139e:	df 90       	pop	r13
    13a0:	cf 90       	pop	r12
    13a2:	08 95       	ret

000013a4 <nvm_read_byte>:
#endif

#ifndef __DOXYGEN__
	PUBLIC_FUNCTION(nvm_read_byte)
#if defined(__GNUC__)
	lds r20, NVM_CMD          ; Store NVM command register
    13a4:	40 91 ca 01 	lds	r20, 0x01CA	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	mov ZL, r22               ; Load byte index into low byte of Z.
    13a8:	e6 2f       	mov	r30, r22
	mov ZH, r23               ; Load high byte into Z.
    13aa:	f7 2f       	mov	r31, r23
	sts NVM_CMD, r24          ; Load prepared command into NVM Command register.
    13ac:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	lpm r24, Z                ; Perform an LPM to read out byte
    13b0:	84 91       	lpm	r24, Z
	sts NVM_CMD, r20          ; Restore NVM command register
    13b2:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	sts NVM_CMD, r16          ; Load prepared command into NVM Command register.
	lpm r16, Z                ; Perform an LPM to read out byte
	sts NVM_CMD, r20          ; Restore NVM command register
#endif

	ret
    13b6:	08 95       	ret

000013b8 <usart_putchar>:

	if (baud_offset != USART_BAUD_UNDEFINED) {
		(usart)->BAUDCTRLB = (uint8_t)((uint16_t)baudctrl);
		(usart)->BAUDCTRLA = (uint8_t)((uint16_t)baudctrl >> 8);
	}
}
    13b8:	fc 01       	movw	r30, r24
    13ba:	91 81       	ldd	r25, Z+1	; 0x01
    13bc:	95 ff       	sbrs	r25, 5
    13be:	fd cf       	rjmp	.-6      	; 0x13ba <usart_putchar+0x2>
    13c0:	60 83       	st	Z, r22
    13c2:	80 e0       	ldi	r24, 0x00	; 0
    13c4:	90 e0       	ldi	r25, 0x00	; 0
    13c6:	08 95       	ret

000013c8 <usart_set_baudrate>:
 * \retval true if the hardware supports the baud rate
 * \retval false if the hardware does not support the baud rate (i.e. it's
 *               either too high or too low.)
 */
bool usart_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    13c8:	2f 92       	push	r2
    13ca:	3f 92       	push	r3
    13cc:	4f 92       	push	r4
    13ce:	5f 92       	push	r5
    13d0:	6f 92       	push	r6
    13d2:	7f 92       	push	r7
    13d4:	8f 92       	push	r8
    13d6:	9f 92       	push	r9
    13d8:	af 92       	push	r10
    13da:	bf 92       	push	r11
    13dc:	cf 92       	push	r12
    13de:	df 92       	push	r13
    13e0:	ef 92       	push	r14
    13e2:	ff 92       	push	r15
    13e4:	0f 93       	push	r16
    13e6:	1f 93       	push	r17
    13e8:	cf 93       	push	r28
    13ea:	1c 01       	movw	r2, r24
    13ec:	2a 01       	movw	r4, r20
    13ee:	3b 01       	movw	r6, r22
    13f0:	48 01       	movw	r8, r16
    13f2:	59 01       	movw	r10, r18

	/*
	 * Check if the hardware supports the given baud rate
	 */
	/* 8 = (2^0) * 8 * (2^0) = (2^BSCALE_MIN) * 8 * (BSEL_MIN) */
	max_rate = cpu_hz / 8;
    13f4:	d9 01       	movw	r26, r18
    13f6:	c8 01       	movw	r24, r16
    13f8:	68 94       	set
    13fa:	12 f8       	bld	r1, 2
    13fc:	b6 95       	lsr	r27
    13fe:	a7 95       	ror	r26
    1400:	97 95       	ror	r25
    1402:	87 95       	ror	r24
    1404:	16 94       	lsr	r1
    1406:	d1 f7       	brne	.-12     	; 0x13fc <usart_set_baudrate+0x34>
	/* 4194304 = (2^7) * 8 * (2^12) = (2^BSCALE_MAX) * 8 * (BSEL_MAX+1) */
	min_rate = cpu_hz / 4194304;
    1408:	b9 01       	movw	r22, r18
    140a:	a8 01       	movw	r20, r16
    140c:	03 2e       	mov	r0, r19
    140e:	36 e1       	ldi	r19, 0x16	; 22
    1410:	76 95       	lsr	r23
    1412:	67 95       	ror	r22
    1414:	57 95       	ror	r21
    1416:	47 95       	ror	r20
    1418:	3a 95       	dec	r19
    141a:	d1 f7       	brne	.-12     	; 0x1410 <usart_set_baudrate+0x48>
    141c:	30 2d       	mov	r19, r0

	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
    141e:	f1 01       	movw	r30, r2
    1420:	24 81       	ldd	r18, Z+4	; 0x04
    1422:	22 fd       	sbrc	r18, 2
    1424:	08 c0       	rjmp	.+16     	; 0x1436 <usart_set_baudrate+0x6e>
		max_rate /= 2;
    1426:	b6 95       	lsr	r27
    1428:	a7 95       	ror	r26
    142a:	97 95       	ror	r25
    142c:	87 95       	ror	r24
		min_rate /= 2;
    142e:	76 95       	lsr	r23
    1430:	67 95       	ror	r22
    1432:	57 95       	ror	r21
    1434:	47 95       	ror	r20
	}

	if ((baud > max_rate) || (baud < min_rate)) {
    1436:	84 15       	cp	r24, r4
    1438:	95 05       	cpc	r25, r5
    143a:	a6 05       	cpc	r26, r6
    143c:	b7 05       	cpc	r27, r7
    143e:	08 f4       	brcc	.+2      	; 0x1442 <usart_set_baudrate+0x7a>
    1440:	ae c0       	rjmp	.+348    	; 0x159e <usart_set_baudrate+0x1d6>
    1442:	44 16       	cp	r4, r20
    1444:	55 06       	cpc	r5, r21
    1446:	66 06       	cpc	r6, r22
    1448:	77 06       	cpc	r7, r23
    144a:	08 f4       	brcc	.+2      	; 0x144e <usart_set_baudrate+0x86>
    144c:	aa c0       	rjmp	.+340    	; 0x15a2 <usart_set_baudrate+0x1da>
		return false;
	}

	/* Check if double speed is enabled. */
	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
    144e:	f1 01       	movw	r30, r2
    1450:	84 81       	ldd	r24, Z+4	; 0x04
    1452:	82 fd       	sbrc	r24, 2
    1454:	04 c0       	rjmp	.+8      	; 0x145e <usart_set_baudrate+0x96>
		baud *= 2;
    1456:	44 0c       	add	r4, r4
    1458:	55 1c       	adc	r5, r5
    145a:	66 1c       	adc	r6, r6
    145c:	77 1c       	adc	r7, r7
	}

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;
    145e:	c5 01       	movw	r24, r10
    1460:	b4 01       	movw	r22, r8
    1462:	a3 01       	movw	r20, r6
    1464:	92 01       	movw	r18, r4
    1466:	0e 94 44 1e 	call	0x3c88	; 0x3c88 <__udivmodsi4>

	for (exp = -7; exp < 7; exp++) {
		if (ratio < limit) {
    146a:	2f 3f       	cpi	r18, 0xFF	; 255
    146c:	31 05       	cpc	r19, r1
    146e:	41 05       	cpc	r20, r1
    1470:	51 05       	cpc	r21, r1
    1472:	08 f4       	brcc	.+2      	; 0x1476 <usart_set_baudrate+0xae>
    1474:	98 c0       	rjmp	.+304    	; 0x15a6 <usart_set_baudrate+0x1de>
    1476:	c1 2c       	mov	r12, r1
    1478:	d1 2c       	mov	r13, r1
    147a:	76 01       	movw	r14, r12
    147c:	ca 94       	dec	r12
    147e:	c9 ef       	ldi	r28, 0xF9	; 249
    1480:	05 c0       	rjmp	.+10     	; 0x148c <usart_set_baudrate+0xc4>
    1482:	2c 15       	cp	r18, r12
    1484:	3d 05       	cpc	r19, r13
    1486:	4e 05       	cpc	r20, r14
    1488:	5f 05       	cpc	r21, r15
    148a:	68 f0       	brcs	.+26     	; 0x14a6 <usart_set_baudrate+0xde>
			break;
		}

		limit <<= 1;
    148c:	cc 0c       	add	r12, r12
    148e:	dd 1c       	adc	r13, r13
    1490:	ee 1c       	adc	r14, r14
    1492:	ff 1c       	adc	r15, r15

		if (exp < -3) {
    1494:	cd 3f       	cpi	r28, 0xFD	; 253
    1496:	14 f4       	brge	.+4      	; 0x149c <usart_set_baudrate+0xd4>
			limit |= 1;
    1498:	68 94       	set
    149a:	c0 f8       	bld	r12, 0
    149c:	cf 5f       	subi	r28, 0xFF	; 255

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;

	for (exp = -7; exp < 7; exp++) {
    149e:	c7 30       	cpi	r28, 0x07	; 7
    14a0:	81 f7       	brne	.-32     	; 0x1482 <usart_set_baudrate+0xba>
    14a2:	8c 2f       	mov	r24, r28
    14a4:	56 c0       	rjmp	.+172    	; 0x1552 <usart_set_baudrate+0x18a>
    14a6:	8c 2f       	mov	r24, r28
	 * point.
	 *
	 * The formula for calculating BSEL is slightly different when exp is
	 * negative than it is when exp is positive.
	 */
	if (exp < 0) {
    14a8:	cc 23       	and	r28, r28
    14aa:	0c f0       	brlt	.+2      	; 0x14ae <usart_set_baudrate+0xe6>
    14ac:	52 c0       	rjmp	.+164    	; 0x1552 <usart_set_baudrate+0x18a>
		/* We are supposed to subtract 1, then apply BSCALE. We want to
		 * apply BSCALE first, so we need to turn everything inside the
		 * parenthesis into a single fractional expression.
		 */
		cpu_hz -= 8 * baud;
    14ae:	d3 01       	movw	r26, r6
    14b0:	c2 01       	movw	r24, r4
    14b2:	88 0f       	add	r24, r24
    14b4:	99 1f       	adc	r25, r25
    14b6:	aa 1f       	adc	r26, r26
    14b8:	bb 1f       	adc	r27, r27
    14ba:	88 0f       	add	r24, r24
    14bc:	99 1f       	adc	r25, r25
    14be:	aa 1f       	adc	r26, r26
    14c0:	bb 1f       	adc	r27, r27
    14c2:	88 0f       	add	r24, r24
    14c4:	99 1f       	adc	r25, r25
    14c6:	aa 1f       	adc	r26, r26
    14c8:	bb 1f       	adc	r27, r27
    14ca:	85 01       	movw	r16, r10
    14cc:	74 01       	movw	r14, r8
    14ce:	e8 1a       	sub	r14, r24
    14d0:	f9 0a       	sbc	r15, r25
    14d2:	0a 0b       	sbc	r16, r26
    14d4:	1b 0b       	sbc	r17, r27
    14d6:	d8 01       	movw	r26, r16
    14d8:	c7 01       	movw	r24, r14
		/* If we end up with a left-shift after taking the final
		 * divide-by-8 into account, do the shift before the divide.
		 * Otherwise, left-shift the denominator instead (effectively
		 * resulting in an overall right shift.)
		 */
		if (exp <= -3) {
    14da:	ce 3f       	cpi	r28, 0xFE	; 254
    14dc:	f4 f4       	brge	.+60     	; 0x151a <usart_set_baudrate+0x152>
			div = ((cpu_hz << (-exp - 3)) + baud / 2) / baud;
    14de:	2d ef       	ldi	r18, 0xFD	; 253
    14e0:	3f ef       	ldi	r19, 0xFF	; 255
    14e2:	2c 1b       	sub	r18, r28
    14e4:	31 09       	sbc	r19, r1
    14e6:	c7 fd       	sbrc	r28, 7
    14e8:	33 95       	inc	r19
    14ea:	04 c0       	rjmp	.+8      	; 0x14f4 <usart_set_baudrate+0x12c>
    14ec:	88 0f       	add	r24, r24
    14ee:	99 1f       	adc	r25, r25
    14f0:	aa 1f       	adc	r26, r26
    14f2:	bb 1f       	adc	r27, r27
    14f4:	2a 95       	dec	r18
    14f6:	d2 f7       	brpl	.-12     	; 0x14ec <usart_set_baudrate+0x124>
    14f8:	73 01       	movw	r14, r6
    14fa:	62 01       	movw	r12, r4
    14fc:	f6 94       	lsr	r15
    14fe:	e7 94       	ror	r14
    1500:	d7 94       	ror	r13
    1502:	c7 94       	ror	r12
    1504:	bc 01       	movw	r22, r24
    1506:	cd 01       	movw	r24, r26
    1508:	6c 0d       	add	r22, r12
    150a:	7d 1d       	adc	r23, r13
    150c:	8e 1d       	adc	r24, r14
    150e:	9f 1d       	adc	r25, r15
    1510:	a3 01       	movw	r20, r6
    1512:	92 01       	movw	r18, r4
    1514:	0e 94 44 1e 	call	0x3c88	; 0x3c88 <__udivmodsi4>
    1518:	38 c0       	rjmp	.+112    	; 0x158a <usart_set_baudrate+0x1c2>
		} else {
			baud <<= exp + 3;
    151a:	23 e0       	ldi	r18, 0x03	; 3
    151c:	2c 0f       	add	r18, r28
    151e:	83 01       	movw	r16, r6
    1520:	72 01       	movw	r14, r4
    1522:	04 c0       	rjmp	.+8      	; 0x152c <usart_set_baudrate+0x164>
    1524:	ee 0c       	add	r14, r14
    1526:	ff 1c       	adc	r15, r15
    1528:	00 1f       	adc	r16, r16
    152a:	11 1f       	adc	r17, r17
    152c:	2a 95       	dec	r18
    152e:	d2 f7       	brpl	.-12     	; 0x1524 <usart_set_baudrate+0x15c>
    1530:	a8 01       	movw	r20, r16
    1532:	97 01       	movw	r18, r14
			div = (cpu_hz + baud / 2) / baud;
    1534:	67 01       	movw	r12, r14
    1536:	78 01       	movw	r14, r16
    1538:	f6 94       	lsr	r15
    153a:	e7 94       	ror	r14
    153c:	d7 94       	ror	r13
    153e:	c7 94       	ror	r12
    1540:	bc 01       	movw	r22, r24
    1542:	cd 01       	movw	r24, r26
    1544:	6c 0d       	add	r22, r12
    1546:	7d 1d       	adc	r23, r13
    1548:	8e 1d       	adc	r24, r14
    154a:	9f 1d       	adc	r25, r15
    154c:	0e 94 44 1e 	call	0x3c88	; 0x3c88 <__udivmodsi4>
    1550:	1c c0       	rjmp	.+56     	; 0x158a <usart_set_baudrate+0x1c2>
		}
	} else {
		/* We will always do a right shift in this case, but we need to
		 * shift three extra positions because of the divide-by-8.
		 */
		baud <<= exp + 3;
    1552:	8d 5f       	subi	r24, 0xFD	; 253
    1554:	a3 01       	movw	r20, r6
    1556:	92 01       	movw	r18, r4
    1558:	04 c0       	rjmp	.+8      	; 0x1562 <usart_set_baudrate+0x19a>
    155a:	22 0f       	add	r18, r18
    155c:	33 1f       	adc	r19, r19
    155e:	44 1f       	adc	r20, r20
    1560:	55 1f       	adc	r21, r21
    1562:	8a 95       	dec	r24
    1564:	d2 f7       	brpl	.-12     	; 0x155a <usart_set_baudrate+0x192>
		div = (cpu_hz + baud / 2) / baud - 1;
    1566:	da 01       	movw	r26, r20
    1568:	c9 01       	movw	r24, r18
    156a:	b6 95       	lsr	r27
    156c:	a7 95       	ror	r26
    156e:	97 95       	ror	r25
    1570:	87 95       	ror	r24
    1572:	bc 01       	movw	r22, r24
    1574:	cd 01       	movw	r24, r26
    1576:	68 0d       	add	r22, r8
    1578:	79 1d       	adc	r23, r9
    157a:	8a 1d       	adc	r24, r10
    157c:	9b 1d       	adc	r25, r11
    157e:	0e 94 44 1e 	call	0x3c88	; 0x3c88 <__udivmodsi4>
    1582:	21 50       	subi	r18, 0x01	; 1
    1584:	31 09       	sbc	r19, r1
    1586:	41 09       	sbc	r20, r1
    1588:	51 09       	sbc	r21, r1
	}

	(usart)->BAUDCTRLB = (uint8_t)(((div >> 8) & 0X0F) | (exp << 4));
    158a:	83 2f       	mov	r24, r19
    158c:	8f 70       	andi	r24, 0x0F	; 15
    158e:	c2 95       	swap	r28
    1590:	c0 7f       	andi	r28, 0xF0	; 240
    1592:	c8 2b       	or	r28, r24
    1594:	f1 01       	movw	r30, r2
    1596:	c7 83       	std	Z+7, r28	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)div;
    1598:	26 83       	std	Z+6, r18	; 0x06

	return true;
    159a:	81 e0       	ldi	r24, 0x01	; 1
    159c:	1c c0       	rjmp	.+56     	; 0x15d6 <usart_set_baudrate+0x20e>
		max_rate /= 2;
		min_rate /= 2;
	}

	if ((baud > max_rate) || (baud < min_rate)) {
		return false;
    159e:	80 e0       	ldi	r24, 0x00	; 0
    15a0:	1a c0       	rjmp	.+52     	; 0x15d6 <usart_set_baudrate+0x20e>
    15a2:	80 e0       	ldi	r24, 0x00	; 0
    15a4:	18 c0       	rjmp	.+48     	; 0x15d6 <usart_set_baudrate+0x20e>
	if (exp < 0) {
		/* We are supposed to subtract 1, then apply BSCALE. We want to
		 * apply BSCALE first, so we need to turn everything inside the
		 * parenthesis into a single fractional expression.
		 */
		cpu_hz -= 8 * baud;
    15a6:	d3 01       	movw	r26, r6
    15a8:	c2 01       	movw	r24, r4
    15aa:	88 0f       	add	r24, r24
    15ac:	99 1f       	adc	r25, r25
    15ae:	aa 1f       	adc	r26, r26
    15b0:	bb 1f       	adc	r27, r27
    15b2:	88 0f       	add	r24, r24
    15b4:	99 1f       	adc	r25, r25
    15b6:	aa 1f       	adc	r26, r26
    15b8:	bb 1f       	adc	r27, r27
    15ba:	88 0f       	add	r24, r24
    15bc:	99 1f       	adc	r25, r25
    15be:	aa 1f       	adc	r26, r26
    15c0:	bb 1f       	adc	r27, r27
    15c2:	85 01       	movw	r16, r10
    15c4:	74 01       	movw	r14, r8
    15c6:	e8 1a       	sub	r14, r24
    15c8:	f9 0a       	sbc	r15, r25
    15ca:	0a 0b       	sbc	r16, r26
    15cc:	1b 0b       	sbc	r17, r27
    15ce:	d8 01       	movw	r26, r16
    15d0:	c7 01       	movw	r24, r14

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;

	for (exp = -7; exp < 7; exp++) {
    15d2:	c9 ef       	ldi	r28, 0xF9	; 249
    15d4:	84 cf       	rjmp	.-248    	; 0x14de <usart_set_baudrate+0x116>

	(usart)->BAUDCTRLB = (uint8_t)(((div >> 8) & 0X0F) | (exp << 4));
	(usart)->BAUDCTRLA = (uint8_t)div;

	return true;
}
    15d6:	cf 91       	pop	r28
    15d8:	1f 91       	pop	r17
    15da:	0f 91       	pop	r16
    15dc:	ff 90       	pop	r15
    15de:	ef 90       	pop	r14
    15e0:	df 90       	pop	r13
    15e2:	cf 90       	pop	r12
    15e4:	bf 90       	pop	r11
    15e6:	af 90       	pop	r10
    15e8:	9f 90       	pop	r9
    15ea:	8f 90       	pop	r8
    15ec:	7f 90       	pop	r7
    15ee:	6f 90       	pop	r6
    15f0:	5f 90       	pop	r5
    15f2:	4f 90       	pop	r4
    15f4:	3f 90       	pop	r3
    15f6:	2f 90       	pop	r2
    15f8:	08 95       	ret

000015fa <usart_init_rs232>:
 *
 * \retval true if the initialization was successfull
 * \retval false if the initialization failed (error in baud rate calculation)
 */
bool usart_init_rs232(USART_t *usart, const usart_rs232_options_t *opt)
{
    15fa:	0f 93       	push	r16
    15fc:	1f 93       	push	r17
    15fe:	cf 93       	push	r28
    1600:	df 93       	push	r29
    1602:	ec 01       	movw	r28, r24
    1604:	8b 01       	movw	r16, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    1606:	00 97       	sbiw	r24, 0x00	; 0
    1608:	09 f4       	brne	.+2      	; 0x160c <usart_init_rs232+0x12>
    160a:	e6 c0       	rjmp	.+460    	; 0x17d8 <usart_init_rs232+0x1de>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    160c:	80 3c       	cpi	r24, 0xC0	; 192
    160e:	91 05       	cpc	r25, r1
    1610:	21 f4       	brne	.+8      	; 0x161a <usart_init_rs232+0x20>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    1612:	60 e1       	ldi	r22, 0x10	; 16
    1614:	80 e0       	ldi	r24, 0x00	; 0
    1616:	1d d9       	rcall	.-3526   	; 0x852 <sysclk_enable_module>
    1618:	df c0       	rjmp	.+446    	; 0x17d8 <usart_init_rs232+0x1de>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    161a:	c0 38       	cpi	r28, 0x80	; 128
    161c:	81 e0       	ldi	r24, 0x01	; 1
    161e:	d8 07       	cpc	r29, r24
    1620:	21 f4       	brne	.+8      	; 0x162a <usart_init_rs232+0x30>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    1622:	62 e0       	ldi	r22, 0x02	; 2
    1624:	80 e0       	ldi	r24, 0x00	; 0
    1626:	15 d9       	rcall	.-3542   	; 0x852 <sysclk_enable_module>
    1628:	d7 c0       	rjmp	.+430    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    162a:	c1 15       	cp	r28, r1
    162c:	e1 e0       	ldi	r30, 0x01	; 1
    162e:	de 07       	cpc	r29, r30
    1630:	21 f4       	brne	.+8      	; 0x163a <usart_init_rs232+0x40>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    1632:	61 e0       	ldi	r22, 0x01	; 1
    1634:	80 e0       	ldi	r24, 0x00	; 0
    1636:	0d d9       	rcall	.-3558   	; 0x852 <sysclk_enable_module>
    1638:	cf c0       	rjmp	.+414    	; 0x17d8 <usart_init_rs232+0x1de>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    163a:	c0 38       	cpi	r28, 0x80	; 128
    163c:	f3 e0       	ldi	r31, 0x03	; 3
    163e:	df 07       	cpc	r29, r31
    1640:	21 f4       	brne	.+8      	; 0x164a <usart_init_rs232+0x50>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    1642:	61 e0       	ldi	r22, 0x01	; 1
    1644:	81 e0       	ldi	r24, 0x01	; 1
    1646:	05 d9       	rcall	.-3574   	; 0x852 <sysclk_enable_module>
    1648:	c7 c0       	rjmp	.+398    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    164a:	c0 39       	cpi	r28, 0x90	; 144
    164c:	83 e0       	ldi	r24, 0x03	; 3
    164e:	d8 07       	cpc	r29, r24
    1650:	21 f4       	brne	.+8      	; 0x165a <usart_init_rs232+0x60>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    1652:	61 e0       	ldi	r22, 0x01	; 1
    1654:	82 e0       	ldi	r24, 0x02	; 2
    1656:	fd d8       	rcall	.-3590   	; 0x852 <sysclk_enable_module>
    1658:	bf c0       	rjmp	.+382    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    165a:	c1 15       	cp	r28, r1
    165c:	e2 e0       	ldi	r30, 0x02	; 2
    165e:	de 07       	cpc	r29, r30
    1660:	21 f4       	brne	.+8      	; 0x166a <usart_init_rs232+0x70>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    1662:	62 e0       	ldi	r22, 0x02	; 2
    1664:	81 e0       	ldi	r24, 0x01	; 1
    1666:	f5 d8       	rcall	.-3606   	; 0x852 <sysclk_enable_module>
    1668:	b7 c0       	rjmp	.+366    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    166a:	c0 34       	cpi	r28, 0x40	; 64
    166c:	f2 e0       	ldi	r31, 0x02	; 2
    166e:	df 07       	cpc	r29, r31
    1670:	21 f4       	brne	.+8      	; 0x167a <usart_init_rs232+0x80>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    1672:	62 e0       	ldi	r22, 0x02	; 2
    1674:	82 e0       	ldi	r24, 0x02	; 2
    1676:	ed d8       	rcall	.-3622   	; 0x852 <sysclk_enable_module>
    1678:	af c0       	rjmp	.+350    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    167a:	c0 32       	cpi	r28, 0x20	; 32
    167c:	83 e0       	ldi	r24, 0x03	; 3
    167e:	d8 07       	cpc	r29, r24
    1680:	21 f4       	brne	.+8      	; 0x168a <usart_init_rs232+0x90>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    1682:	64 e0       	ldi	r22, 0x04	; 4
    1684:	82 e0       	ldi	r24, 0x02	; 2
    1686:	e5 d8       	rcall	.-3638   	; 0x852 <sysclk_enable_module>
    1688:	a7 c0       	rjmp	.+334    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    168a:	c1 15       	cp	r28, r1
    168c:	e8 e0       	ldi	r30, 0x08	; 8
    168e:	de 07       	cpc	r29, r30
    1690:	21 f4       	brne	.+8      	; 0x169a <usart_init_rs232+0xa0>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    1692:	61 e0       	ldi	r22, 0x01	; 1
    1694:	83 e0       	ldi	r24, 0x03	; 3
    1696:	dd d8       	rcall	.-3654   	; 0x852 <sysclk_enable_module>
    1698:	9f c0       	rjmp	.+318    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    169a:	c1 15       	cp	r28, r1
    169c:	f9 e0       	ldi	r31, 0x09	; 9
    169e:	df 07       	cpc	r29, r31
    16a0:	21 f4       	brne	.+8      	; 0x16aa <usart_init_rs232+0xb0>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    16a2:	61 e0       	ldi	r22, 0x01	; 1
    16a4:	84 e0       	ldi	r24, 0x04	; 4
    16a6:	d5 d8       	rcall	.-3670   	; 0x852 <sysclk_enable_module>
    16a8:	97 c0       	rjmp	.+302    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    16aa:	c1 15       	cp	r28, r1
    16ac:	8a e0       	ldi	r24, 0x0A	; 10
    16ae:	d8 07       	cpc	r29, r24
    16b0:	21 f4       	brne	.+8      	; 0x16ba <usart_init_rs232+0xc0>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    16b2:	61 e0       	ldi	r22, 0x01	; 1
    16b4:	85 e0       	ldi	r24, 0x05	; 5
    16b6:	cd d8       	rcall	.-3686   	; 0x852 <sysclk_enable_module>
    16b8:	8f c0       	rjmp	.+286    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    16ba:	c1 15       	cp	r28, r1
    16bc:	eb e0       	ldi	r30, 0x0B	; 11
    16be:	de 07       	cpc	r29, r30
    16c0:	21 f4       	brne	.+8      	; 0x16ca <usart_init_rs232+0xd0>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    16c2:	61 e0       	ldi	r22, 0x01	; 1
    16c4:	86 e0       	ldi	r24, 0x06	; 6
    16c6:	c5 d8       	rcall	.-3702   	; 0x852 <sysclk_enable_module>
    16c8:	87 c0       	rjmp	.+270    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    16ca:	c0 34       	cpi	r28, 0x40	; 64
    16cc:	f8 e0       	ldi	r31, 0x08	; 8
    16ce:	df 07       	cpc	r29, r31
    16d0:	21 f4       	brne	.+8      	; 0x16da <usart_init_rs232+0xe0>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    16d2:	62 e0       	ldi	r22, 0x02	; 2
    16d4:	83 e0       	ldi	r24, 0x03	; 3
    16d6:	bd d8       	rcall	.-3718   	; 0x852 <sysclk_enable_module>
    16d8:	7f c0       	rjmp	.+254    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    16da:	c0 34       	cpi	r28, 0x40	; 64
    16dc:	89 e0       	ldi	r24, 0x09	; 9
    16de:	d8 07       	cpc	r29, r24
    16e0:	21 f4       	brne	.+8      	; 0x16ea <usart_init_rs232+0xf0>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    16e2:	62 e0       	ldi	r22, 0x02	; 2
    16e4:	84 e0       	ldi	r24, 0x04	; 4
    16e6:	b5 d8       	rcall	.-3734   	; 0x852 <sysclk_enable_module>
    16e8:	77 c0       	rjmp	.+238    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    16ea:	c0 34       	cpi	r28, 0x40	; 64
    16ec:	ea e0       	ldi	r30, 0x0A	; 10
    16ee:	de 07       	cpc	r29, r30
    16f0:	21 f4       	brne	.+8      	; 0x16fa <usart_init_rs232+0x100>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    16f2:	62 e0       	ldi	r22, 0x02	; 2
    16f4:	85 e0       	ldi	r24, 0x05	; 5
    16f6:	ad d8       	rcall	.-3750   	; 0x852 <sysclk_enable_module>
    16f8:	6f c0       	rjmp	.+222    	; 0x17d8 <usart_init_rs232+0x1de>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    16fa:	c0 39       	cpi	r28, 0x90	; 144
    16fc:	f8 e0       	ldi	r31, 0x08	; 8
    16fe:	df 07       	cpc	r29, r31
    1700:	21 f4       	brne	.+8      	; 0x170a <usart_init_rs232+0x110>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    1702:	64 e0       	ldi	r22, 0x04	; 4
    1704:	83 e0       	ldi	r24, 0x03	; 3
    1706:	a5 d8       	rcall	.-3766   	; 0x852 <sysclk_enable_module>
    1708:	67 c0       	rjmp	.+206    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    170a:	c0 39       	cpi	r28, 0x90	; 144
    170c:	89 e0       	ldi	r24, 0x09	; 9
    170e:	d8 07       	cpc	r29, r24
    1710:	21 f4       	brne	.+8      	; 0x171a <usart_init_rs232+0x120>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    1712:	64 e0       	ldi	r22, 0x04	; 4
    1714:	84 e0       	ldi	r24, 0x04	; 4
    1716:	9d d8       	rcall	.-3782   	; 0x852 <sysclk_enable_module>
    1718:	5f c0       	rjmp	.+190    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    171a:	c0 39       	cpi	r28, 0x90	; 144
    171c:	ea e0       	ldi	r30, 0x0A	; 10
    171e:	de 07       	cpc	r29, r30
    1720:	21 f4       	brne	.+8      	; 0x172a <usart_init_rs232+0x130>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    1722:	64 e0       	ldi	r22, 0x04	; 4
    1724:	85 e0       	ldi	r24, 0x05	; 5
    1726:	95 d8       	rcall	.-3798   	; 0x852 <sysclk_enable_module>
    1728:	57 c0       	rjmp	.+174    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    172a:	c0 39       	cpi	r28, 0x90	; 144
    172c:	fb e0       	ldi	r31, 0x0B	; 11
    172e:	df 07       	cpc	r29, r31
    1730:	21 f4       	brne	.+8      	; 0x173a <usart_init_rs232+0x140>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    1732:	64 e0       	ldi	r22, 0x04	; 4
    1734:	86 e0       	ldi	r24, 0x06	; 6
    1736:	8d d8       	rcall	.-3814   	; 0x852 <sysclk_enable_module>
    1738:	4f c0       	rjmp	.+158    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    173a:	c0 3c       	cpi	r28, 0xC0	; 192
    173c:	88 e0       	ldi	r24, 0x08	; 8
    173e:	d8 07       	cpc	r29, r24
    1740:	21 f4       	brne	.+8      	; 0x174a <usart_init_rs232+0x150>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    1742:	68 e0       	ldi	r22, 0x08	; 8
    1744:	83 e0       	ldi	r24, 0x03	; 3
    1746:	85 d8       	rcall	.-3830   	; 0x852 <sysclk_enable_module>
    1748:	47 c0       	rjmp	.+142    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    174a:	c0 3c       	cpi	r28, 0xC0	; 192
    174c:	e9 e0       	ldi	r30, 0x09	; 9
    174e:	de 07       	cpc	r29, r30
    1750:	21 f4       	brne	.+8      	; 0x175a <usart_init_rs232+0x160>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    1752:	68 e0       	ldi	r22, 0x08	; 8
    1754:	84 e0       	ldi	r24, 0x04	; 4
    1756:	7d d8       	rcall	.-3846   	; 0x852 <sysclk_enable_module>
    1758:	3f c0       	rjmp	.+126    	; 0x17d8 <usart_init_rs232+0x1de>
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    175a:	c0 3a       	cpi	r28, 0xA0	; 160
    175c:	f8 e0       	ldi	r31, 0x08	; 8
    175e:	df 07       	cpc	r29, r31
    1760:	21 f4       	brne	.+8      	; 0x176a <usart_init_rs232+0x170>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    1762:	60 e1       	ldi	r22, 0x10	; 16
    1764:	83 e0       	ldi	r24, 0x03	; 3
    1766:	75 d8       	rcall	.-3862   	; 0x852 <sysclk_enable_module>
    1768:	37 c0       	rjmp	.+110    	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    176a:	c0 3a       	cpi	r28, 0xA0	; 160
    176c:	89 e0       	ldi	r24, 0x09	; 9
    176e:	d8 07       	cpc	r29, r24
    1770:	21 f4       	brne	.+8      	; 0x177a <usart_init_rs232+0x180>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    1772:	60 e1       	ldi	r22, 0x10	; 16
    1774:	84 e0       	ldi	r24, 0x04	; 4
    1776:	6d d8       	rcall	.-3878   	; 0x852 <sysclk_enable_module>
    1778:	2f c0       	rjmp	.+94     	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    177a:	c0 3a       	cpi	r28, 0xA0	; 160
    177c:	ea e0       	ldi	r30, 0x0A	; 10
    177e:	de 07       	cpc	r29, r30
    1780:	21 f4       	brne	.+8      	; 0x178a <usart_init_rs232+0x190>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    1782:	60 e1       	ldi	r22, 0x10	; 16
    1784:	85 e0       	ldi	r24, 0x05	; 5
    1786:	65 d8       	rcall	.-3894   	; 0x852 <sysclk_enable_module>
    1788:	27 c0       	rjmp	.+78     	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    178a:	c0 3a       	cpi	r28, 0xA0	; 160
    178c:	fb e0       	ldi	r31, 0x0B	; 11
    178e:	df 07       	cpc	r29, r31
    1790:	21 f4       	brne	.+8      	; 0x179a <usart_init_rs232+0x1a0>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    1792:	60 e1       	ldi	r22, 0x10	; 16
    1794:	86 e0       	ldi	r24, 0x06	; 6
    1796:	5d d8       	rcall	.-3910   	; 0x852 <sysclk_enable_module>
    1798:	1f c0       	rjmp	.+62     	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    179a:	c0 3b       	cpi	r28, 0xB0	; 176
    179c:	88 e0       	ldi	r24, 0x08	; 8
    179e:	d8 07       	cpc	r29, r24
    17a0:	21 f4       	brne	.+8      	; 0x17aa <usart_init_rs232+0x1b0>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    17a2:	60 e2       	ldi	r22, 0x20	; 32
    17a4:	83 e0       	ldi	r24, 0x03	; 3
    17a6:	55 d8       	rcall	.-3926   	; 0x852 <sysclk_enable_module>
    17a8:	17 c0       	rjmp	.+46     	; 0x17d8 <usart_init_rs232+0x1de>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    17aa:	c0 3b       	cpi	r28, 0xB0	; 176
    17ac:	e9 e0       	ldi	r30, 0x09	; 9
    17ae:	de 07       	cpc	r29, r30
    17b0:	21 f4       	brne	.+8      	; 0x17ba <usart_init_rs232+0x1c0>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    17b2:	60 e2       	ldi	r22, 0x20	; 32
    17b4:	84 e0       	ldi	r24, 0x04	; 4
    17b6:	4d d8       	rcall	.-3942   	; 0x852 <sysclk_enable_module>
    17b8:	0f c0       	rjmp	.+30     	; 0x17d8 <usart_init_rs232+0x1de>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    17ba:	c0 38       	cpi	r28, 0x80	; 128
    17bc:	f4 e0       	ldi	r31, 0x04	; 4
    17be:	df 07       	cpc	r29, r31
    17c0:	21 f4       	brne	.+8      	; 0x17ca <usart_init_rs232+0x1d0>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    17c2:	60 e4       	ldi	r22, 0x40	; 64
    17c4:	83 e0       	ldi	r24, 0x03	; 3
    17c6:	45 d8       	rcall	.-3958   	; 0x852 <sysclk_enable_module>
    17c8:	07 c0       	rjmp	.+14     	; 0x17d8 <usart_init_rs232+0x1de>
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    17ca:	c0 3a       	cpi	r28, 0xA0	; 160
    17cc:	84 e0       	ldi	r24, 0x04	; 4
    17ce:	d8 07       	cpc	r29, r24
    17d0:	19 f4       	brne	.+6      	; 0x17d8 <usart_init_rs232+0x1de>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    17d2:	60 e4       	ldi	r22, 0x40	; 64
    17d4:	85 e0       	ldi	r24, 0x05	; 5
    17d6:	3d d8       	rcall	.-3974   	; 0x852 <sysclk_enable_module>
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    17d8:	8d 81       	ldd	r24, Y+5	; 0x05
    17da:	8f 73       	andi	r24, 0x3F	; 63
    17dc:	8d 83       	std	Y+5, r24	; 0x05
 *  \param twoStopBits Enable two stop bit mode. Use bool type.
 */
static inline void usart_format_set(USART_t *usart, USART_CHSIZE_t charSize,
		USART_PMODE_t parityMode, bool twoStopBits)
{
	(usart)->CTRLC = (uint8_t)charSize | parityMode
    17de:	f8 01       	movw	r30, r16
    17e0:	94 81       	ldd	r25, Z+4	; 0x04
    17e2:	85 81       	ldd	r24, Z+5	; 0x05
    17e4:	89 2b       	or	r24, r25
    17e6:	96 81       	ldd	r25, Z+6	; 0x06
    17e8:	91 11       	cpse	r25, r1
    17ea:	98 e0       	ldi	r25, 0x08	; 8
    17ec:	89 2b       	or	r24, r25
    17ee:	8d 83       	std	Y+5, r24	; 0x05
	bool result;
	sysclk_enable_peripheral_clock(usart);
	usart_set_mode(usart, USART_CMODE_ASYNCHRONOUS_gc);
	usart_format_set(usart, opt->charlength, opt->paritytype,
			opt->stopbits);
	result = usart_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    17f0:	f8 01       	movw	r30, r16
    17f2:	40 81       	ld	r20, Z
    17f4:	51 81       	ldd	r21, Z+1	; 0x01
    17f6:	62 81       	ldd	r22, Z+2	; 0x02
    17f8:	73 81       	ldd	r23, Z+3	; 0x03
    17fa:	00 e8       	ldi	r16, 0x80	; 128
    17fc:	14 e8       	ldi	r17, 0x84	; 132
    17fe:	2e e1       	ldi	r18, 0x1E	; 30
    1800:	30 e0       	ldi	r19, 0x00	; 0
    1802:	ce 01       	movw	r24, r28
    1804:	e1 dd       	rcall	.-1086   	; 0x13c8 <usart_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    1806:	9c 81       	ldd	r25, Y+4	; 0x04
    1808:	98 60       	ori	r25, 0x08	; 8
    180a:	9c 83       	std	Y+4, r25	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    180c:	9c 81       	ldd	r25, Y+4	; 0x04
    180e:	90 61       	ori	r25, 0x10	; 16
    1810:	9c 83       	std	Y+4, r25	; 0x04
	usart_tx_enable(usart);
	usart_rx_enable(usart);
	
	return result;
}
    1812:	df 91       	pop	r29
    1814:	cf 91       	pop	r28
    1816:	1f 91       	pop	r17
    1818:	0f 91       	pop	r16
    181a:	08 95       	ret

0000181c <usart_spi_set_baudrate>:
 * \param usart The USART(SPI) module.
 * \param baud The baudrate.
 * \param cpu_hz The CPU frequency.
 */
void usart_spi_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    181c:	cf 92       	push	r12
    181e:	df 92       	push	r13
    1820:	ef 92       	push	r14
    1822:	ff 92       	push	r15
    1824:	0f 93       	push	r16
    1826:	1f 93       	push	r17
    1828:	cf 93       	push	r28
    182a:	df 93       	push	r29
    182c:	ec 01       	movw	r28, r24
	uint16_t bsel_value;

	/* Check if baudrate is less than the maximim limit specified in
	 * datasheet */
	if (baud < (cpu_hz / 2)) {
    182e:	d9 01       	movw	r26, r18
    1830:	c8 01       	movw	r24, r16
    1832:	b6 95       	lsr	r27
    1834:	a7 95       	ror	r26
    1836:	97 95       	ror	r25
    1838:	87 95       	ror	r24
    183a:	48 17       	cp	r20, r24
    183c:	59 07       	cpc	r21, r25
    183e:	6a 07       	cpc	r22, r26
    1840:	7b 07       	cpc	r23, r27
    1842:	78 f4       	brcc	.+30     	; 0x1862 <usart_spi_set_baudrate+0x46>
		bsel_value = (cpu_hz / (baud * 2)) - 1;
    1844:	6a 01       	movw	r12, r20
    1846:	7b 01       	movw	r14, r22
    1848:	cc 0c       	add	r12, r12
    184a:	dd 1c       	adc	r13, r13
    184c:	ee 1c       	adc	r14, r14
    184e:	ff 1c       	adc	r15, r15
    1850:	c9 01       	movw	r24, r18
    1852:	b8 01       	movw	r22, r16
    1854:	a7 01       	movw	r20, r14
    1856:	96 01       	movw	r18, r12
    1858:	0e 94 44 1e 	call	0x3c88	; 0x3c88 <__udivmodsi4>
    185c:	21 50       	subi	r18, 0x01	; 1
    185e:	31 09       	sbc	r19, r1
    1860:	02 c0       	rjmp	.+4      	; 0x1866 <usart_spi_set_baudrate+0x4a>
	} else {
		/* If baudrate is not within the specfication in datasheet,
		 * assign maximum baudrate possible for the current CPU frequency */
		bsel_value = 0;
    1862:	20 e0       	ldi	r18, 0x00	; 0
    1864:	30 e0       	ldi	r19, 0x00	; 0
	}

	(usart)->BAUDCTRLB = (uint8_t)((~USART_BSCALE_gm) & (bsel_value >> 8));
    1866:	83 2f       	mov	r24, r19
    1868:	8f 70       	andi	r24, 0x0F	; 15
    186a:	8f 83       	std	Y+7, r24	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)(bsel_value);
    186c:	2e 83       	std	Y+6, r18	; 0x06
}
    186e:	df 91       	pop	r29
    1870:	cf 91       	pop	r28
    1872:	1f 91       	pop	r17
    1874:	0f 91       	pop	r16
    1876:	ff 90       	pop	r15
    1878:	ef 90       	pop	r14
    187a:	df 90       	pop	r13
    187c:	cf 90       	pop	r12
    187e:	08 95       	ret

00001880 <usart_init_spi>:
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    1880:	ef 92       	push	r14
    1882:	ff 92       	push	r15
    1884:	0f 93       	push	r16
    1886:	1f 93       	push	r17
    1888:	cf 93       	push	r28
    188a:	df 93       	push	r29
    188c:	ec 01       	movw	r28, r24
    188e:	7b 01       	movw	r14, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    1890:	00 97       	sbiw	r24, 0x00	; 0
    1892:	09 f4       	brne	.+2      	; 0x1896 <usart_init_spi+0x16>
    1894:	98 c1       	rjmp	.+816    	; 0x1bc6 <usart_init_spi+0x346>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    1896:	80 3c       	cpi	r24, 0xC0	; 192
    1898:	91 05       	cpc	r25, r1
    189a:	29 f4       	brne	.+10     	; 0x18a6 <usart_init_spi+0x26>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    189c:	60 e1       	ldi	r22, 0x10	; 16
    189e:	80 e0       	ldi	r24, 0x00	; 0
    18a0:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    18a4:	90 c1       	rjmp	.+800    	; 0x1bc6 <usart_init_spi+0x346>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    18a6:	80 38       	cpi	r24, 0x80	; 128
    18a8:	91 40       	sbci	r25, 0x01	; 1
    18aa:	29 f4       	brne	.+10     	; 0x18b6 <usart_init_spi+0x36>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    18ac:	62 e0       	ldi	r22, 0x02	; 2
    18ae:	80 e0       	ldi	r24, 0x00	; 0
    18b0:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    18b4:	88 c1       	rjmp	.+784    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    18b6:	c1 15       	cp	r28, r1
    18b8:	81 e0       	ldi	r24, 0x01	; 1
    18ba:	d8 07       	cpc	r29, r24
    18bc:	29 f4       	brne	.+10     	; 0x18c8 <usart_init_spi+0x48>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    18be:	61 e0       	ldi	r22, 0x01	; 1
    18c0:	80 e0       	ldi	r24, 0x00	; 0
    18c2:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    18c6:	7f c1       	rjmp	.+766    	; 0x1bc6 <usart_init_spi+0x346>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    18c8:	c0 38       	cpi	r28, 0x80	; 128
    18ca:	e3 e0       	ldi	r30, 0x03	; 3
    18cc:	de 07       	cpc	r29, r30
    18ce:	29 f4       	brne	.+10     	; 0x18da <usart_init_spi+0x5a>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    18d0:	61 e0       	ldi	r22, 0x01	; 1
    18d2:	81 e0       	ldi	r24, 0x01	; 1
    18d4:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    18d8:	76 c1       	rjmp	.+748    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    18da:	c0 39       	cpi	r28, 0x90	; 144
    18dc:	f3 e0       	ldi	r31, 0x03	; 3
    18de:	df 07       	cpc	r29, r31
    18e0:	29 f4       	brne	.+10     	; 0x18ec <usart_init_spi+0x6c>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    18e2:	61 e0       	ldi	r22, 0x01	; 1
    18e4:	82 e0       	ldi	r24, 0x02	; 2
    18e6:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    18ea:	6d c1       	rjmp	.+730    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    18ec:	c1 15       	cp	r28, r1
    18ee:	32 e0       	ldi	r19, 0x02	; 2
    18f0:	d3 07       	cpc	r29, r19
    18f2:	29 f4       	brne	.+10     	; 0x18fe <usart_init_spi+0x7e>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    18f4:	62 e0       	ldi	r22, 0x02	; 2
    18f6:	81 e0       	ldi	r24, 0x01	; 1
    18f8:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    18fc:	64 c1       	rjmp	.+712    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    18fe:	c0 34       	cpi	r28, 0x40	; 64
    1900:	82 e0       	ldi	r24, 0x02	; 2
    1902:	d8 07       	cpc	r29, r24
    1904:	29 f4       	brne	.+10     	; 0x1910 <usart_init_spi+0x90>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    1906:	62 e0       	ldi	r22, 0x02	; 2
    1908:	82 e0       	ldi	r24, 0x02	; 2
    190a:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    190e:	5b c1       	rjmp	.+694    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    1910:	c0 32       	cpi	r28, 0x20	; 32
    1912:	e3 e0       	ldi	r30, 0x03	; 3
    1914:	de 07       	cpc	r29, r30
    1916:	29 f4       	brne	.+10     	; 0x1922 <usart_init_spi+0xa2>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    1918:	64 e0       	ldi	r22, 0x04	; 4
    191a:	82 e0       	ldi	r24, 0x02	; 2
    191c:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1920:	52 c1       	rjmp	.+676    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    1922:	c1 15       	cp	r28, r1
    1924:	f8 e0       	ldi	r31, 0x08	; 8
    1926:	df 07       	cpc	r29, r31
    1928:	29 f4       	brne	.+10     	; 0x1934 <usart_init_spi+0xb4>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    192a:	61 e0       	ldi	r22, 0x01	; 1
    192c:	83 e0       	ldi	r24, 0x03	; 3
    192e:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1932:	49 c1       	rjmp	.+658    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    1934:	c1 15       	cp	r28, r1
    1936:	39 e0       	ldi	r19, 0x09	; 9
    1938:	d3 07       	cpc	r29, r19
    193a:	29 f4       	brne	.+10     	; 0x1946 <usart_init_spi+0xc6>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    193c:	61 e0       	ldi	r22, 0x01	; 1
    193e:	84 e0       	ldi	r24, 0x04	; 4
    1940:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1944:	40 c1       	rjmp	.+640    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    1946:	c1 15       	cp	r28, r1
    1948:	8a e0       	ldi	r24, 0x0A	; 10
    194a:	d8 07       	cpc	r29, r24
    194c:	29 f4       	brne	.+10     	; 0x1958 <usart_init_spi+0xd8>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    194e:	61 e0       	ldi	r22, 0x01	; 1
    1950:	85 e0       	ldi	r24, 0x05	; 5
    1952:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1956:	37 c1       	rjmp	.+622    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    1958:	c1 15       	cp	r28, r1
    195a:	eb e0       	ldi	r30, 0x0B	; 11
    195c:	de 07       	cpc	r29, r30
    195e:	29 f4       	brne	.+10     	; 0x196a <usart_init_spi+0xea>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    1960:	61 e0       	ldi	r22, 0x01	; 1
    1962:	86 e0       	ldi	r24, 0x06	; 6
    1964:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1968:	2e c1       	rjmp	.+604    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    196a:	c0 34       	cpi	r28, 0x40	; 64
    196c:	f8 e0       	ldi	r31, 0x08	; 8
    196e:	df 07       	cpc	r29, r31
    1970:	29 f4       	brne	.+10     	; 0x197c <usart_init_spi+0xfc>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    1972:	62 e0       	ldi	r22, 0x02	; 2
    1974:	83 e0       	ldi	r24, 0x03	; 3
    1976:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    197a:	25 c1       	rjmp	.+586    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    197c:	c0 34       	cpi	r28, 0x40	; 64
    197e:	39 e0       	ldi	r19, 0x09	; 9
    1980:	d3 07       	cpc	r29, r19
    1982:	29 f4       	brne	.+10     	; 0x198e <usart_init_spi+0x10e>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    1984:	62 e0       	ldi	r22, 0x02	; 2
    1986:	84 e0       	ldi	r24, 0x04	; 4
    1988:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    198c:	1c c1       	rjmp	.+568    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    198e:	c0 34       	cpi	r28, 0x40	; 64
    1990:	8a e0       	ldi	r24, 0x0A	; 10
    1992:	d8 07       	cpc	r29, r24
    1994:	29 f4       	brne	.+10     	; 0x19a0 <usart_init_spi+0x120>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    1996:	62 e0       	ldi	r22, 0x02	; 2
    1998:	85 e0       	ldi	r24, 0x05	; 5
    199a:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    199e:	13 c1       	rjmp	.+550    	; 0x1bc6 <usart_init_spi+0x346>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    19a0:	c0 39       	cpi	r28, 0x90	; 144
    19a2:	e8 e0       	ldi	r30, 0x08	; 8
    19a4:	de 07       	cpc	r29, r30
    19a6:	29 f4       	brne	.+10     	; 0x19b2 <usart_init_spi+0x132>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    19a8:	64 e0       	ldi	r22, 0x04	; 4
    19aa:	83 e0       	ldi	r24, 0x03	; 3
    19ac:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    19b0:	0a c1       	rjmp	.+532    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    19b2:	c0 39       	cpi	r28, 0x90	; 144
    19b4:	f9 e0       	ldi	r31, 0x09	; 9
    19b6:	df 07       	cpc	r29, r31
    19b8:	29 f4       	brne	.+10     	; 0x19c4 <usart_init_spi+0x144>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    19ba:	64 e0       	ldi	r22, 0x04	; 4
    19bc:	84 e0       	ldi	r24, 0x04	; 4
    19be:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    19c2:	01 c1       	rjmp	.+514    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    19c4:	c0 39       	cpi	r28, 0x90	; 144
    19c6:	3a e0       	ldi	r19, 0x0A	; 10
    19c8:	d3 07       	cpc	r29, r19
    19ca:	29 f4       	brne	.+10     	; 0x19d6 <usart_init_spi+0x156>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    19cc:	64 e0       	ldi	r22, 0x04	; 4
    19ce:	85 e0       	ldi	r24, 0x05	; 5
    19d0:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    19d4:	f8 c0       	rjmp	.+496    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    19d6:	c0 39       	cpi	r28, 0x90	; 144
    19d8:	8b e0       	ldi	r24, 0x0B	; 11
    19da:	d8 07       	cpc	r29, r24
    19dc:	29 f4       	brne	.+10     	; 0x19e8 <usart_init_spi+0x168>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    19de:	64 e0       	ldi	r22, 0x04	; 4
    19e0:	86 e0       	ldi	r24, 0x06	; 6
    19e2:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    19e6:	ef c0       	rjmp	.+478    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    19e8:	c0 3c       	cpi	r28, 0xC0	; 192
    19ea:	e8 e0       	ldi	r30, 0x08	; 8
    19ec:	de 07       	cpc	r29, r30
    19ee:	29 f4       	brne	.+10     	; 0x19fa <usart_init_spi+0x17a>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    19f0:	68 e0       	ldi	r22, 0x08	; 8
    19f2:	83 e0       	ldi	r24, 0x03	; 3
    19f4:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    19f8:	e6 c0       	rjmp	.+460    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    19fa:	c0 3c       	cpi	r28, 0xC0	; 192
    19fc:	f9 e0       	ldi	r31, 0x09	; 9
    19fe:	df 07       	cpc	r29, r31
    1a00:	29 f4       	brne	.+10     	; 0x1a0c <usart_init_spi+0x18c>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    1a02:	68 e0       	ldi	r22, 0x08	; 8
    1a04:	84 e0       	ldi	r24, 0x04	; 4
    1a06:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1a0a:	dd c0       	rjmp	.+442    	; 0x1bc6 <usart_init_spi+0x346>
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    1a0c:	c0 3a       	cpi	r28, 0xA0	; 160
    1a0e:	38 e0       	ldi	r19, 0x08	; 8
    1a10:	d3 07       	cpc	r29, r19
    1a12:	69 f4       	brne	.+26     	; 0x1a2e <usart_init_spi+0x1ae>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    1a14:	60 e1       	ldi	r22, 0x10	; 16
    1a16:	83 e0       	ldi	r24, 0x03	; 3
    1a18:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    1a1c:	e0 ea       	ldi	r30, 0xA0	; 160
    1a1e:	f8 e0       	ldi	r31, 0x08	; 8
    1a20:	84 81       	ldd	r24, Z+4	; 0x04
    1a22:	8f 7e       	andi	r24, 0xEF	; 239
    1a24:	84 83       	std	Z+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    1a26:	f7 01       	movw	r30, r14
    1a28:	24 81       	ldd	r18, Z+4	; 0x04
    1a2a:	22 50       	subi	r18, 0x02	; 2
    1a2c:	4a c0       	rjmp	.+148    	; 0x1ac2 <usart_init_spi+0x242>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    1a2e:	c0 3a       	cpi	r28, 0xA0	; 160
    1a30:	f9 e0       	ldi	r31, 0x09	; 9
    1a32:	df 07       	cpc	r29, r31
    1a34:	29 f4       	brne	.+10     	; 0x1a40 <usart_init_spi+0x1c0>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    1a36:	60 e1       	ldi	r22, 0x10	; 16
    1a38:	84 e0       	ldi	r24, 0x04	; 4
    1a3a:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1a3e:	c3 c0       	rjmp	.+390    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    1a40:	c0 3a       	cpi	r28, 0xA0	; 160
    1a42:	3a e0       	ldi	r19, 0x0A	; 10
    1a44:	d3 07       	cpc	r29, r19
    1a46:	29 f4       	brne	.+10     	; 0x1a52 <usart_init_spi+0x1d2>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    1a48:	60 e1       	ldi	r22, 0x10	; 16
    1a4a:	85 e0       	ldi	r24, 0x05	; 5
    1a4c:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1a50:	ba c0       	rjmp	.+372    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    1a52:	c0 3a       	cpi	r28, 0xA0	; 160
    1a54:	8b e0       	ldi	r24, 0x0B	; 11
    1a56:	d8 07       	cpc	r29, r24
    1a58:	29 f4       	brne	.+10     	; 0x1a64 <usart_init_spi+0x1e4>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    1a5a:	60 e1       	ldi	r22, 0x10	; 16
    1a5c:	86 e0       	ldi	r24, 0x06	; 6
    1a5e:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1a62:	b1 c0       	rjmp	.+354    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    1a64:	c0 3b       	cpi	r28, 0xB0	; 176
    1a66:	e8 e0       	ldi	r30, 0x08	; 8
    1a68:	de 07       	cpc	r29, r30
    1a6a:	29 f4       	brne	.+10     	; 0x1a76 <usart_init_spi+0x1f6>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    1a6c:	60 e2       	ldi	r22, 0x20	; 32
    1a6e:	83 e0       	ldi	r24, 0x03	; 3
    1a70:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1a74:	a8 c0       	rjmp	.+336    	; 0x1bc6 <usart_init_spi+0x346>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    1a76:	c0 3b       	cpi	r28, 0xB0	; 176
    1a78:	f9 e0       	ldi	r31, 0x09	; 9
    1a7a:	df 07       	cpc	r29, r31
    1a7c:	29 f4       	brne	.+10     	; 0x1a88 <usart_init_spi+0x208>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    1a7e:	60 e2       	ldi	r22, 0x20	; 32
    1a80:	84 e0       	ldi	r24, 0x04	; 4
    1a82:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1a86:	9f c0       	rjmp	.+318    	; 0x1bc6 <usart_init_spi+0x346>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    1a88:	c0 38       	cpi	r28, 0x80	; 128
    1a8a:	34 e0       	ldi	r19, 0x04	; 4
    1a8c:	d3 07       	cpc	r29, r19
    1a8e:	29 f4       	brne	.+10     	; 0x1a9a <usart_init_spi+0x21a>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    1a90:	60 e4       	ldi	r22, 0x40	; 64
    1a92:	83 e0       	ldi	r24, 0x03	; 3
    1a94:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1a98:	96 c0       	rjmp	.+300    	; 0x1bc6 <usart_init_spi+0x346>
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    1a9a:	c0 3a       	cpi	r28, 0xA0	; 160
    1a9c:	84 e0       	ldi	r24, 0x04	; 4
    1a9e:	d8 07       	cpc	r29, r24
    1aa0:	29 f4       	brne	.+10     	; 0x1aac <usart_init_spi+0x22c>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    1aa2:	60 e4       	ldi	r22, 0x40	; 64
    1aa4:	85 e0       	ldi	r24, 0x05	; 5
    1aa6:	0e 94 29 04 	call	0x852	; 0x852 <sysclk_enable_module>
    1aaa:	8d c0       	rjmp	.+282    	; 0x1bc6 <usart_init_spi+0x346>
    1aac:	8c 81       	ldd	r24, Y+4	; 0x04
    1aae:	8f 7e       	andi	r24, 0xEF	; 239
    1ab0:	8c 83       	std	Y+4, r24	; 0x04
    1ab2:	fb 01       	movw	r30, r22
    1ab4:	24 81       	ldd	r18, Z+4	; 0x04
    1ab6:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    1ab8:	ce 01       	movw	r24, r28
    1aba:	c0 3a       	cpi	r28, 0xA0	; 160
    1abc:	f8 e0       	ldi	r31, 0x08	; 8
    1abe:	df 07       	cpc	r29, r31
    1ac0:	31 f4       	brne	.+12     	; 0x1ace <usart_init_spi+0x24e>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
    1ac2:	80 91 4e 06 	lds	r24, 0x064E	; 0x80064e <__TEXT_REGION_LENGTH__+0x70064e>
    1ac6:	84 fd       	sbrc	r24, 4
    1ac8:	86 c0       	rjmp	.+268    	; 0x1bd6 <usart_init_spi+0x356>
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
    1aca:	11 e1       	ldi	r17, 0x11	; 17
    1acc:	85 c0       	rjmp	.+266    	; 0x1bd8 <usart_init_spi+0x358>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
    1ace:	80 3b       	cpi	r24, 0xB0	; 176
    1ad0:	38 e0       	ldi	r19, 0x08	; 8
    1ad2:	93 07       	cpc	r25, r19
    1ad4:	79 f0       	breq	.+30     	; 0x1af4 <usart_init_spi+0x274>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
	}
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
    1ad6:	80 3a       	cpi	r24, 0xA0	; 160
    1ad8:	e9 e0       	ldi	r30, 0x09	; 9
    1ada:	9e 07       	cpc	r25, r30
    1adc:	31 f4       	brne	.+12     	; 0x1aea <usart_init_spi+0x26a>
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
    1ade:	30 91 6e 06 	lds	r19, 0x066E	; 0x80066e <__TEXT_REGION_LENGTH__+0x70066e>
    1ae2:	34 fd       	sbrc	r19, 4
    1ae4:	7c c0       	rjmp	.+248    	; 0x1bde <usart_init_spi+0x35e>
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
    1ae6:	19 e1       	ldi	r17, 0x19	; 25
    1ae8:	10 c0       	rjmp	.+32     	; 0x1b0a <usart_init_spi+0x28a>
		sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
    1aea:	80 3b       	cpi	r24, 0xB0	; 176
    1aec:	f9 e0       	ldi	r31, 0x09	; 9
    1aee:	9f 07       	cpc	r25, r31
    1af0:	a9 f0       	breq	.+42     	; 0x1b1c <usart_init_spi+0x29c>
    1af2:	01 c0       	rjmp	.+2      	; 0x1af6 <usart_init_spi+0x276>
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    1af4:	15 e1       	ldi	r17, 0x15	; 21
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
	}
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
    1af6:	80 3a       	cpi	r24, 0xA0	; 160
    1af8:	3a e0       	ldi	r19, 0x0A	; 10
    1afa:	93 07       	cpc	r25, r19
    1afc:	31 f4       	brne	.+12     	; 0x1b0a <usart_init_spi+0x28a>
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
    1afe:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <__TEXT_REGION_LENGTH__+0x70068e>
    1b02:	84 fd       	sbrc	r24, 4
    1b04:	6e c0       	rjmp	.+220    	; 0x1be2 <usart_init_spi+0x362>
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 1);
    1b06:	11 e2       	ldi	r17, 0x21	; 33
    1b08:	0c c0       	rjmp	.+24     	; 0x1b22 <usart_init_spi+0x2a2>
	if ((uint16_t)usart == (uint16_t)&USARTE1) {
		sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
	}
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
    1b0a:	80 3a       	cpi	r24, 0xA0	; 160
    1b0c:	9b 40       	sbci	r25, 0x0B	; 11
    1b0e:	49 f4       	brne	.+18     	; 0x1b22 <usart_init_spi+0x2a2>
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
    1b10:	80 91 ae 06 	lds	r24, 0x06AE	; 0x8006ae <__TEXT_REGION_LENGTH__+0x7006ae>
    1b14:	84 fd       	sbrc	r24, 4
    1b16:	04 c0       	rjmp	.+8      	; 0x1b20 <usart_init_spi+0x2a0>
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 1);
    1b18:	19 e2       	ldi	r17, 0x29	; 41
    1b1a:	03 c0       	rjmp	.+6      	; 0x1b22 <usart_init_spi+0x2a2>
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    1b1c:	1d e1       	ldi	r17, 0x1D	; 29
    1b1e:	01 c0       	rjmp	.+2      	; 0x1b22 <usart_init_spi+0x2a2>
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
    1b20:	1d e2       	ldi	r17, 0x2D	; 45
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
    1b22:	e1 2f       	mov	r30, r17
    1b24:	e6 95       	lsr	r30
    1b26:	e6 95       	lsr	r30
    1b28:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
    1b2a:	30 e2       	ldi	r19, 0x20	; 32
    1b2c:	e3 9f       	mul	r30, r19
    1b2e:	f0 01       	movw	r30, r0
    1b30:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    1b32:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    1b34:	17 70       	andi	r17, 0x07	; 7
    1b36:	81 e0       	ldi	r24, 0x01	; 1
    1b38:	90 e0       	ldi	r25, 0x00	; 0
    1b3a:	01 2e       	mov	r0, r17
    1b3c:	02 c0       	rjmp	.+4      	; 0x1b42 <usart_init_spi+0x2c2>
    1b3e:	88 0f       	add	r24, r24
    1b40:	99 1f       	adc	r25, r25
    1b42:	0a 94       	dec	r0
    1b44:	e2 f7       	brpl	.-8      	; 0x1b3e <usart_init_spi+0x2be>
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    1b46:	81 83       	std	Z+1, r24	; 0x01
	}
#endif

	/* Configure the USART output pin */
	ioport_set_pin_dir(sck_pin, IOPORT_DIR_OUTPUT);
	ioport_set_pin_mode(sck_pin,
    1b48:	22 30       	cpi	r18, 0x02	; 2
    1b4a:	10 f0       	brcs	.+4      	; 0x1b50 <usart_init_spi+0x2d0>
    1b4c:	40 e0       	ldi	r20, 0x00	; 0
    1b4e:	01 c0       	rjmp	.+2      	; 0x1b52 <usart_init_spi+0x2d2>
    1b50:	40 e4       	ldi	r20, 0x40	; 64
__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));
    1b52:	df 01       	movw	r26, r30
    1b54:	50 96       	adiw	r26, 0x10	; 16

__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
    1b56:	a1 0f       	add	r26, r17
    1b58:	b1 1d       	adc	r27, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1b5a:	3f b7       	in	r19, 0x3f	; 63
	cpu_irq_disable();
    1b5c:	f8 94       	cli
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));

	uint8_t flags = cpu_irq_save();

	*pin_ctrl &= PORT_ISC_gm;
    1b5e:	2c 91       	ld	r18, X
    1b60:	27 70       	andi	r18, 0x07	; 7
    1b62:	2c 93       	st	X, r18
	*pin_ctrl |= mode;
    1b64:	9c 91       	ld	r25, X
    1b66:	94 2b       	or	r25, r20
    1b68:	9c 93       	st	X, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1b6a:	3f bf       	out	0x3f, r19	; 63
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    1b6c:	85 83       	std	Z+5, r24	; 0x05
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    1b6e:	8d 81       	ldd	r24, Y+5	; 0x05
    1b70:	80 6c       	ori	r24, 0xC0	; 192
    1b72:	8d 83       	std	Y+5, r24	; 0x05
			IOPORT_MODE_TOTEM | (invert_sck? IOPORT_MODE_INVERT_PIN : 0));
	ioport_set_pin_level(sck_pin, IOPORT_PIN_LEVEL_HIGH);

	usart_set_mode(usart, USART_CMODE_MSPI_gc);

	if (opt->spimode == 1 || opt->spimode == 3) {
    1b74:	f7 01       	movw	r30, r14
    1b76:	84 81       	ldd	r24, Z+4	; 0x04
    1b78:	8d 7f       	andi	r24, 0xFD	; 253
    1b7a:	81 30       	cpi	r24, 0x01	; 1
    1b7c:	21 f4       	brne	.+8      	; 0x1b86 <usart_init_spi+0x306>
		usart->CTRLC |= USART_UCPHA_bm;
    1b7e:	8d 81       	ldd	r24, Y+5	; 0x05
    1b80:	82 60       	ori	r24, 0x02	; 2
    1b82:	8d 83       	std	Y+5, r24	; 0x05
    1b84:	03 c0       	rjmp	.+6      	; 0x1b8c <usart_init_spi+0x30c>
	} else {
		usart->CTRLC &= ~USART_UCPHA_bm;
    1b86:	8d 81       	ldd	r24, Y+5	; 0x05
    1b88:	8d 7f       	andi	r24, 0xFD	; 253
    1b8a:	8d 83       	std	Y+5, r24	; 0x05
	}
	if (opt->data_order) {
    1b8c:	f7 01       	movw	r30, r14
    1b8e:	85 81       	ldd	r24, Z+5	; 0x05
    1b90:	88 23       	and	r24, r24
    1b92:	21 f0       	breq	.+8      	; 0x1b9c <usart_init_spi+0x31c>
		(usart)->CTRLC |= USART_DORD_bm;
    1b94:	8d 81       	ldd	r24, Y+5	; 0x05
    1b96:	84 60       	ori	r24, 0x04	; 4
    1b98:	8d 83       	std	Y+5, r24	; 0x05
    1b9a:	03 c0       	rjmp	.+6      	; 0x1ba2 <usart_init_spi+0x322>
	} else {
		(usart)->CTRLC &= ~USART_DORD_bm;
    1b9c:	8d 81       	ldd	r24, Y+5	; 0x05
    1b9e:	8b 7f       	andi	r24, 0xFB	; 251
    1ba0:	8d 83       	std	Y+5, r24	; 0x05
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    1ba2:	f7 01       	movw	r30, r14
    1ba4:	40 81       	ld	r20, Z
    1ba6:	51 81       	ldd	r21, Z+1	; 0x01
    1ba8:	62 81       	ldd	r22, Z+2	; 0x02
    1baa:	73 81       	ldd	r23, Z+3	; 0x03
    1bac:	00 e8       	ldi	r16, 0x80	; 128
    1bae:	14 e8       	ldi	r17, 0x84	; 132
    1bb0:	2e e1       	ldi	r18, 0x1E	; 30
    1bb2:	30 e0       	ldi	r19, 0x00	; 0
    1bb4:	ce 01       	movw	r24, r28
    1bb6:	32 de       	rcall	.-924    	; 0x181c <usart_spi_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    1bb8:	8c 81       	ldd	r24, Y+4	; 0x04
    1bba:	88 60       	ori	r24, 0x08	; 8
    1bbc:	8c 83       	std	Y+4, r24	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    1bbe:	8c 81       	ldd	r24, Y+4	; 0x04
    1bc0:	80 61       	ori	r24, 0x10	; 16
    1bc2:	8c 83       	std	Y+4, r24	; 0x04
    1bc4:	10 c0       	rjmp	.+32     	; 0x1be6 <usart_init_spi+0x366>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    1bc6:	8c 81       	ldd	r24, Y+4	; 0x04
    1bc8:	8f 7e       	andi	r24, 0xEF	; 239
    1bca:	8c 83       	std	Y+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    1bcc:	f7 01       	movw	r30, r14
    1bce:	24 81       	ldd	r18, Z+4	; 0x04
    1bd0:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    1bd2:	ce 01       	movw	r24, r28
    1bd4:	7c cf       	rjmp	.-264    	; 0x1ace <usart_init_spi+0x24e>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    1bd6:	15 e1       	ldi	r17, 0x15	; 21
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    1bd8:	80 ea       	ldi	r24, 0xA0	; 160
    1bda:	98 e0       	ldi	r25, 0x08	; 8
    1bdc:	86 cf       	rjmp	.-244    	; 0x1aea <usart_init_spi+0x26a>
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    1bde:	1d e1       	ldi	r17, 0x1D	; 29
    1be0:	94 cf       	rjmp	.-216    	; 0x1b0a <usart_init_spi+0x28a>
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
    1be2:	15 e2       	ldi	r17, 0x25	; 37
    1be4:	9e cf       	rjmp	.-196    	; 0x1b22 <usart_init_spi+0x2a2>
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    1be6:	df 91       	pop	r29
    1be8:	cf 91       	pop	r28
    1bea:	1f 91       	pop	r17
    1bec:	0f 91       	pop	r16
    1bee:	ff 90       	pop	r15
    1bf0:	ef 90       	pop	r14
    1bf2:	08 95       	ret

00001bf4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1bf4:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bf6:	03 96       	adiw	r24, 0x03	; 3
    1bf8:	81 83       	std	Z+1, r24	; 0x01
    1bfa:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1bfc:	2f ef       	ldi	r18, 0xFF	; 255
    1bfe:	3f ef       	ldi	r19, 0xFF	; 255
    1c00:	23 83       	std	Z+3, r18	; 0x03
    1c02:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c04:	85 83       	std	Z+5, r24	; 0x05
    1c06:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c08:	87 83       	std	Z+7, r24	; 0x07
    1c0a:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1c0c:	10 82       	st	Z, r1
    1c0e:	08 95       	ret

00001c10 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1c10:	fc 01       	movw	r30, r24
    1c12:	10 86       	std	Z+8, r1	; 0x08
    1c14:	11 86       	std	Z+9, r1	; 0x09
    1c16:	08 95       	ret

00001c18 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1c18:	cf 93       	push	r28
    1c1a:	df 93       	push	r29
    1c1c:	9c 01       	movw	r18, r24
    1c1e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1c20:	dc 01       	movw	r26, r24
    1c22:	11 96       	adiw	r26, 0x01	; 1
    1c24:	cd 91       	ld	r28, X+
    1c26:	dc 91       	ld	r29, X
    1c28:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1c2a:	c2 83       	std	Z+2, r28	; 0x02
    1c2c:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1c2e:	8c 81       	ldd	r24, Y+4	; 0x04
    1c30:	9d 81       	ldd	r25, Y+5	; 0x05
    1c32:	84 83       	std	Z+4, r24	; 0x04
    1c34:	95 83       	std	Z+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1c36:	8c 81       	ldd	r24, Y+4	; 0x04
    1c38:	9d 81       	ldd	r25, Y+5	; 0x05
    1c3a:	dc 01       	movw	r26, r24
    1c3c:	12 96       	adiw	r26, 0x02	; 2
    1c3e:	6d 93       	st	X+, r22
    1c40:	7c 93       	st	X, r23
    1c42:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    1c44:	6c 83       	std	Y+4, r22	; 0x04
    1c46:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1c48:	20 87       	std	Z+8, r18	; 0x08
    1c4a:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    1c4c:	f9 01       	movw	r30, r18
    1c4e:	80 81       	ld	r24, Z
    1c50:	8f 5f       	subi	r24, 0xFF	; 255
    1c52:	80 83       	st	Z, r24
}
    1c54:	df 91       	pop	r29
    1c56:	cf 91       	pop	r28
    1c58:	08 95       	ret

00001c5a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1c5a:	cf 93       	push	r28
    1c5c:	df 93       	push	r29
    1c5e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1c60:	48 81       	ld	r20, Y
    1c62:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1c64:	4f 3f       	cpi	r20, 0xFF	; 255
    1c66:	2f ef       	ldi	r18, 0xFF	; 255
    1c68:	52 07       	cpc	r21, r18
    1c6a:	21 f4       	brne	.+8      	; 0x1c74 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1c6c:	fc 01       	movw	r30, r24
    1c6e:	a7 81       	ldd	r26, Z+7	; 0x07
    1c70:	b0 85       	ldd	r27, Z+8	; 0x08
    1c72:	0d c0       	rjmp	.+26     	; 0x1c8e <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c74:	dc 01       	movw	r26, r24
    1c76:	13 96       	adiw	r26, 0x03	; 3
    1c78:	01 c0       	rjmp	.+2      	; 0x1c7c <vListInsert+0x22>
    1c7a:	df 01       	movw	r26, r30
    1c7c:	12 96       	adiw	r26, 0x02	; 2
    1c7e:	ed 91       	ld	r30, X+
    1c80:	fc 91       	ld	r31, X
    1c82:	13 97       	sbiw	r26, 0x03	; 3
    1c84:	20 81       	ld	r18, Z
    1c86:	31 81       	ldd	r19, Z+1	; 0x01
    1c88:	42 17       	cp	r20, r18
    1c8a:	53 07       	cpc	r21, r19
    1c8c:	b0 f7       	brcc	.-20     	; 0x1c7a <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1c8e:	12 96       	adiw	r26, 0x02	; 2
    1c90:	ed 91       	ld	r30, X+
    1c92:	fc 91       	ld	r31, X
    1c94:	13 97       	sbiw	r26, 0x03	; 3
    1c96:	ea 83       	std	Y+2, r30	; 0x02
    1c98:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1c9a:	c4 83       	std	Z+4, r28	; 0x04
    1c9c:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    1c9e:	ac 83       	std	Y+4, r26	; 0x04
    1ca0:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    1ca2:	12 96       	adiw	r26, 0x02	; 2
    1ca4:	cd 93       	st	X+, r28
    1ca6:	dc 93       	st	X, r29
    1ca8:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1caa:	88 87       	std	Y+8, r24	; 0x08
    1cac:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    1cae:	fc 01       	movw	r30, r24
    1cb0:	20 81       	ld	r18, Z
    1cb2:	2f 5f       	subi	r18, 0xFF	; 255
    1cb4:	20 83       	st	Z, r18
}
    1cb6:	df 91       	pop	r29
    1cb8:	cf 91       	pop	r28
    1cba:	08 95       	ret

00001cbc <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1cbc:	cf 93       	push	r28
    1cbe:	df 93       	push	r29
    1cc0:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1cc2:	a0 85       	ldd	r26, Z+8	; 0x08
    1cc4:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1cc6:	c2 81       	ldd	r28, Z+2	; 0x02
    1cc8:	d3 81       	ldd	r29, Z+3	; 0x03
    1cca:	84 81       	ldd	r24, Z+4	; 0x04
    1ccc:	95 81       	ldd	r25, Z+5	; 0x05
    1cce:	8c 83       	std	Y+4, r24	; 0x04
    1cd0:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1cd2:	c4 81       	ldd	r28, Z+4	; 0x04
    1cd4:	d5 81       	ldd	r29, Z+5	; 0x05
    1cd6:	82 81       	ldd	r24, Z+2	; 0x02
    1cd8:	93 81       	ldd	r25, Z+3	; 0x03
    1cda:	8a 83       	std	Y+2, r24	; 0x02
    1cdc:	9b 83       	std	Y+3, r25	; 0x03

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1cde:	11 96       	adiw	r26, 0x01	; 1
    1ce0:	cd 91       	ld	r28, X+
    1ce2:	dc 91       	ld	r29, X
    1ce4:	12 97       	sbiw	r26, 0x02	; 2
    1ce6:	ce 17       	cp	r28, r30
    1ce8:	df 07       	cpc	r29, r31
    1cea:	31 f4       	brne	.+12     	; 0x1cf8 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1cec:	8c 81       	ldd	r24, Y+4	; 0x04
    1cee:	9d 81       	ldd	r25, Y+5	; 0x05
    1cf0:	11 96       	adiw	r26, 0x01	; 1
    1cf2:	8d 93       	st	X+, r24
    1cf4:	9c 93       	st	X, r25
    1cf6:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1cf8:	10 86       	std	Z+8, r1	; 0x08
    1cfa:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    1cfc:	8c 91       	ld	r24, X
    1cfe:	81 50       	subi	r24, 0x01	; 1
    1d00:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    1d02:	df 91       	pop	r29
    1d04:	cf 91       	pop	r28
    1d06:	08 95       	ret

00001d08 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1d08:	0f 93       	push	r16
    1d0a:	1f 93       	push	r17
    1d0c:	8b 01       	movw	r16, r22
uint16_t usAddress;

    /* Place a few bytes of known values on the bottom of the stack.
    This is just useful for debugging. */

    *pxTopOfStack = 0x11;
    1d0e:	71 e1       	ldi	r23, 0x11	; 17
    1d10:	fc 01       	movw	r30, r24
    1d12:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = 0x22;
    1d14:	31 97       	sbiw	r30, 0x01	; 1
    1d16:	62 e2       	ldi	r22, 0x22	; 34
    1d18:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = 0x33;
    1d1a:	31 97       	sbiw	r30, 0x01	; 1
    1d1c:	23 e3       	ldi	r18, 0x33	; 51
    1d1e:	20 83       	st	Z, r18

    /*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

    /* The start of the task code will be popped off the stack last, so place
    it on first. */
    ulAddress = ( uint32_t ) pxCode;
    1d20:	01 2e       	mov	r0, r17
    1d22:	00 0c       	add	r0, r0
    1d24:	22 0b       	sbc	r18, r18
    1d26:	33 0b       	sbc	r19, r19
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    1d28:	31 97       	sbiw	r30, 0x01	; 1
    1d2a:	00 83       	st	Z, r16
    pxTopOfStack--;

    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    1d2c:	31 97       	sbiw	r30, 0x01	; 1
    1d2e:	10 83       	st	Z, r17
    pxTopOfStack--;

#ifdef __AVR_3_BYTE_PC__
    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    1d30:	31 97       	sbiw	r30, 0x01	; 1
    1d32:	20 83       	st	Z, r18

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
    portSAVE_CONTEXT places the flags on the stack immediately after r0
    to ensure the interrupts get disabled as soon as possible, and so ensuring
    the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R0 */
    1d34:	31 97       	sbiw	r30, 0x01	; 1
    1d36:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = portFLAGS_INT_ENABLED;
    1d38:	31 97       	sbiw	r30, 0x01	; 1
    1d3a:	20 e8       	ldi	r18, 0x80	; 128
    1d3c:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Now the remaining registers.   The compiler expects R1 to be 0. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R1 */
    1d3e:	31 97       	sbiw	r30, 0x01	; 1
    1d40:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x02;   /* R2 */
    1d42:	31 97       	sbiw	r30, 0x01	; 1
    1d44:	22 e0       	ldi	r18, 0x02	; 2
    1d46:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x03;   /* R3 */
    1d48:	31 97       	sbiw	r30, 0x01	; 1
    1d4a:	23 e0       	ldi	r18, 0x03	; 3
    1d4c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x04;   /* R4 */
    1d4e:	31 97       	sbiw	r30, 0x01	; 1
    1d50:	24 e0       	ldi	r18, 0x04	; 4
    1d52:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x05;   /* R5 */
    1d54:	31 97       	sbiw	r30, 0x01	; 1
    1d56:	25 e0       	ldi	r18, 0x05	; 5
    1d58:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x06;   /* R6 */
    1d5a:	31 97       	sbiw	r30, 0x01	; 1
    1d5c:	26 e0       	ldi	r18, 0x06	; 6
    1d5e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x07;   /* R7 */
    1d60:	31 97       	sbiw	r30, 0x01	; 1
    1d62:	27 e0       	ldi	r18, 0x07	; 7
    1d64:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x08;   /* R8 */
    1d66:	31 97       	sbiw	r30, 0x01	; 1
    1d68:	28 e0       	ldi	r18, 0x08	; 8
    1d6a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x09;   /* R9 */
    1d6c:	31 97       	sbiw	r30, 0x01	; 1
    1d6e:	29 e0       	ldi	r18, 0x09	; 9
    1d70:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x10;   /* R10 */
    1d72:	31 97       	sbiw	r30, 0x01	; 1
    1d74:	20 e1       	ldi	r18, 0x10	; 16
    1d76:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x11;   /* R11 */
    1d78:	31 97       	sbiw	r30, 0x01	; 1
    1d7a:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x12;   /* R12 */
    1d7c:	31 97       	sbiw	r30, 0x01	; 1
    1d7e:	22 e1       	ldi	r18, 0x12	; 18
    1d80:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x13;   /* R13 */
    1d82:	31 97       	sbiw	r30, 0x01	; 1
    1d84:	23 e1       	ldi	r18, 0x13	; 19
    1d86:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x14;   /* R14 */
    1d88:	31 97       	sbiw	r30, 0x01	; 1
    1d8a:	24 e1       	ldi	r18, 0x14	; 20
    1d8c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x15;   /* R15 */
    1d8e:	31 97       	sbiw	r30, 0x01	; 1
    1d90:	25 e1       	ldi	r18, 0x15	; 21
    1d92:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x16;   /* R16 */
    1d94:	31 97       	sbiw	r30, 0x01	; 1
    1d96:	26 e1       	ldi	r18, 0x16	; 22
    1d98:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x17;   /* R17 */
    1d9a:	31 97       	sbiw	r30, 0x01	; 1
    1d9c:	27 e1       	ldi	r18, 0x17	; 23
    1d9e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x18;   /* R18 */
    1da0:	31 97       	sbiw	r30, 0x01	; 1
    1da2:	28 e1       	ldi	r18, 0x18	; 24
    1da4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x19;   /* R19 */
    1da6:	31 97       	sbiw	r30, 0x01	; 1
    1da8:	29 e1       	ldi	r18, 0x19	; 25
    1daa:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x20;   /* R20 */
    1dac:	31 97       	sbiw	r30, 0x01	; 1
    1dae:	20 e2       	ldi	r18, 0x20	; 32
    1db0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x21;   /* R21 */
    1db2:	31 97       	sbiw	r30, 0x01	; 1
    1db4:	21 e2       	ldi	r18, 0x21	; 33
    1db6:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x22;   /* R22 */
    1db8:	31 97       	sbiw	r30, 0x01	; 1
    1dba:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x23;   /* R23 */
    1dbc:	31 97       	sbiw	r30, 0x01	; 1
    1dbe:	23 e2       	ldi	r18, 0x23	; 35
    1dc0:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    1dc2:	31 97       	sbiw	r30, 0x01	; 1
    1dc4:	40 83       	st	Z, r20
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    1dc6:	31 97       	sbiw	r30, 0x01	; 1
    1dc8:	50 83       	st	Z, r21
    pxTopOfStack--;

    *pxTopOfStack = ( StackType_t ) 0x26;   /* R26 X */
    1dca:	31 97       	sbiw	r30, 0x01	; 1
    1dcc:	26 e2       	ldi	r18, 0x26	; 38
    1dce:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x27;   /* R27 */
    1dd0:	31 97       	sbiw	r30, 0x01	; 1
    1dd2:	27 e2       	ldi	r18, 0x27	; 39
    1dd4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x28;   /* R28 Y */
    1dd6:	31 97       	sbiw	r30, 0x01	; 1
    1dd8:	28 e2       	ldi	r18, 0x28	; 40
    1dda:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x29;   /* R29 */
    1ddc:	31 97       	sbiw	r30, 0x01	; 1
    1dde:	29 e2       	ldi	r18, 0x29	; 41
    1de0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x30;   /* R30 Z */
    1de2:	31 97       	sbiw	r30, 0x01	; 1
    1de4:	20 e3       	ldi	r18, 0x30	; 48
    1de6:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x31;   /* R31 */
    1de8:	31 97       	sbiw	r30, 0x01	; 1
    1dea:	21 e3       	ldi	r18, 0x31	; 49
    1dec:	20 83       	st	Z, r18
    pxTopOfStack--;

    /*lint +e950 +e611 +e923 */

    return pxTopOfStack;
}
    1dee:	87 97       	sbiw	r24, 0x27	; 39
    1df0:	1f 91       	pop	r17
    1df2:	0f 91       	pop	r16
    1df4:	08 95       	ret

00001df6 <xPortStartScheduler>:
 * Setup timer generate a tick interrupt.
 */
static void prvSetupTimerInterrupt(void)
{
    // disable global interrupt for a moment
    cli();
    1df6:	f8 94       	cli

    {
        //enable TC0 clock source, high resolution
        PR.PRPC &= ~(PR_TC0_bm | PR_HIRES_bm);
    1df8:	e0 e7       	ldi	r30, 0x70	; 112
    1dfa:	f0 e0       	ldi	r31, 0x00	; 0
    1dfc:	83 81       	ldd	r24, Z+3	; 0x03
    1dfe:	8a 7f       	andi	r24, 0xFA	; 250
    1e00:	83 83       	std	Z+3, r24	; 0x03

        //set period of counter
        TCC0.PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ / 1;
    1e02:	e0 e0       	ldi	r30, 0x00	; 0
    1e04:	f8 e0       	ldi	r31, 0x08	; 8
    1e06:	80 e0       	ldi	r24, 0x00	; 0
    1e08:	9a ef       	ldi	r25, 0xFA	; 250
    1e0a:	86 a3       	std	Z+38, r24	; 0x26
    1e0c:	97 a3       	std	Z+39, r25	; 0x27

        //enable interrupt and set low level
        TCC0.INTCTRLA = TC_OVFINTLVL_LO_gc;
    1e0e:	91 e0       	ldi	r25, 0x01	; 1
    1e10:	96 83       	std	Z+6, r25	; 0x06

        //enable low-level interrupt
        PMIC.CTRL |= PMIC_LOLVLEN_bm;
    1e12:	a0 ea       	ldi	r26, 0xA0	; 160
    1e14:	b0 e0       	ldi	r27, 0x00	; 0
    1e16:	12 96       	adiw	r26, 0x02	; 2
    1e18:	8c 91       	ld	r24, X
    1e1a:	12 97       	sbiw	r26, 0x02	; 2
    1e1c:	81 60       	ori	r24, 0x01	; 1
    1e1e:	12 96       	adiw	r26, 0x02	; 2
    1e20:	8c 93       	st	X, r24

        //select (start) the clock source
        TCC0.CTRLA = TC_CLKSEL_DIV1_gc;
    1e22:	90 83       	st	Z, r25

    }

    // enable global interrupt
    sei();
    1e24:	78 94       	sei
{
    /* Setup the hardware to generate the tick. */
    prvSetupTimerInterrupt();

    /* Restore the context of the first task that is going to run. */
    portRESTORE_CONTEXT();
    1e26:	a0 91 f2 5e 	lds	r26, 0x5EF2	; 0x805ef2 <pxCurrentTCB>
    1e2a:	b0 91 f3 5e 	lds	r27, 0x5EF3	; 0x805ef3 <pxCurrentTCB+0x1>
    1e2e:	0d 90       	ld	r0, X+
    1e30:	0d be       	out	0x3d, r0	; 61
    1e32:	0d 90       	ld	r0, X+
    1e34:	0e be       	out	0x3e, r0	; 62
    1e36:	ff 91       	pop	r31
    1e38:	ef 91       	pop	r30
    1e3a:	df 91       	pop	r29
    1e3c:	cf 91       	pop	r28
    1e3e:	bf 91       	pop	r27
    1e40:	af 91       	pop	r26
    1e42:	9f 91       	pop	r25
    1e44:	8f 91       	pop	r24
    1e46:	7f 91       	pop	r23
    1e48:	6f 91       	pop	r22
    1e4a:	5f 91       	pop	r21
    1e4c:	4f 91       	pop	r20
    1e4e:	3f 91       	pop	r19
    1e50:	2f 91       	pop	r18
    1e52:	1f 91       	pop	r17
    1e54:	0f 91       	pop	r16
    1e56:	ff 90       	pop	r15
    1e58:	ef 90       	pop	r14
    1e5a:	df 90       	pop	r13
    1e5c:	cf 90       	pop	r12
    1e5e:	bf 90       	pop	r11
    1e60:	af 90       	pop	r10
    1e62:	9f 90       	pop	r9
    1e64:	8f 90       	pop	r8
    1e66:	7f 90       	pop	r7
    1e68:	6f 90       	pop	r6
    1e6a:	5f 90       	pop	r5
    1e6c:	4f 90       	pop	r4
    1e6e:	3f 90       	pop	r3
    1e70:	2f 90       	pop	r2
    1e72:	1f 90       	pop	r1
    1e74:	0f 90       	pop	r0
    1e76:	0f be       	out	0x3f, r0	; 63
    1e78:	0f 90       	pop	r0

    /* Simulate a function call end as generated by the compiler.  We will now
    jump to the start of the task the context of which we have just restored. */
    asm volatile ( "ret" );
    1e7a:	08 95       	ret

    /* Should not get here. */
    return pdTRUE;
}
    1e7c:	81 e0       	ldi	r24, 0x01	; 1
    1e7e:	08 95       	ret

00001e80 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    1e80:	0f 92       	push	r0
    1e82:	0f b6       	in	r0, 0x3f	; 63
    1e84:	f8 94       	cli
    1e86:	0f 92       	push	r0
    1e88:	1f 92       	push	r1
    1e8a:	11 24       	eor	r1, r1
    1e8c:	2f 92       	push	r2
    1e8e:	3f 92       	push	r3
    1e90:	4f 92       	push	r4
    1e92:	5f 92       	push	r5
    1e94:	6f 92       	push	r6
    1e96:	7f 92       	push	r7
    1e98:	8f 92       	push	r8
    1e9a:	9f 92       	push	r9
    1e9c:	af 92       	push	r10
    1e9e:	bf 92       	push	r11
    1ea0:	cf 92       	push	r12
    1ea2:	df 92       	push	r13
    1ea4:	ef 92       	push	r14
    1ea6:	ff 92       	push	r15
    1ea8:	0f 93       	push	r16
    1eaa:	1f 93       	push	r17
    1eac:	2f 93       	push	r18
    1eae:	3f 93       	push	r19
    1eb0:	4f 93       	push	r20
    1eb2:	5f 93       	push	r21
    1eb4:	6f 93       	push	r22
    1eb6:	7f 93       	push	r23
    1eb8:	8f 93       	push	r24
    1eba:	9f 93       	push	r25
    1ebc:	af 93       	push	r26
    1ebe:	bf 93       	push	r27
    1ec0:	cf 93       	push	r28
    1ec2:	df 93       	push	r29
    1ec4:	ef 93       	push	r30
    1ec6:	ff 93       	push	r31
    1ec8:	a0 91 f2 5e 	lds	r26, 0x5EF2	; 0x805ef2 <pxCurrentTCB>
    1ecc:	b0 91 f3 5e 	lds	r27, 0x5EF3	; 0x805ef3 <pxCurrentTCB+0x1>
    1ed0:	0d b6       	in	r0, 0x3d	; 61
    1ed2:	0d 92       	st	X+, r0
    1ed4:	0e b6       	in	r0, 0x3e	; 62
    1ed6:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    1ed8:	34 d7       	rcall	.+3688   	; 0x2d42 <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    1eda:	a0 91 f2 5e 	lds	r26, 0x5EF2	; 0x805ef2 <pxCurrentTCB>
    1ede:	b0 91 f3 5e 	lds	r27, 0x5EF3	; 0x805ef3 <pxCurrentTCB+0x1>
    1ee2:	0d 90       	ld	r0, X+
    1ee4:	0d be       	out	0x3d, r0	; 61
    1ee6:	0d 90       	ld	r0, X+
    1ee8:	0e be       	out	0x3e, r0	; 62
    1eea:	ff 91       	pop	r31
    1eec:	ef 91       	pop	r30
    1eee:	df 91       	pop	r29
    1ef0:	cf 91       	pop	r28
    1ef2:	bf 91       	pop	r27
    1ef4:	af 91       	pop	r26
    1ef6:	9f 91       	pop	r25
    1ef8:	8f 91       	pop	r24
    1efa:	7f 91       	pop	r23
    1efc:	6f 91       	pop	r22
    1efe:	5f 91       	pop	r21
    1f00:	4f 91       	pop	r20
    1f02:	3f 91       	pop	r19
    1f04:	2f 91       	pop	r18
    1f06:	1f 91       	pop	r17
    1f08:	0f 91       	pop	r16
    1f0a:	ff 90       	pop	r15
    1f0c:	ef 90       	pop	r14
    1f0e:	df 90       	pop	r13
    1f10:	cf 90       	pop	r12
    1f12:	bf 90       	pop	r11
    1f14:	af 90       	pop	r10
    1f16:	9f 90       	pop	r9
    1f18:	8f 90       	pop	r8
    1f1a:	7f 90       	pop	r7
    1f1c:	6f 90       	pop	r6
    1f1e:	5f 90       	pop	r5
    1f20:	4f 90       	pop	r4
    1f22:	3f 90       	pop	r3
    1f24:	2f 90       	pop	r2
    1f26:	1f 90       	pop	r1
    1f28:	0f 90       	pop	r0
    1f2a:	0f be       	out	0x3f, r0	; 63
    1f2c:	0f 90       	pop	r0

    asm volatile ( "ret" );
    1f2e:	08 95       	ret

00001f30 <__vector_14>:
         * Context switch function used by the tick.  This must be identical to
         * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
         * difference from vPortYield() is the tick count is incremented as the
         * call comes from the tick ISR.
         */
        portSAVE_CONTEXT();
    1f30:	0f 92       	push	r0
    1f32:	0f b6       	in	r0, 0x3f	; 63
    1f34:	f8 94       	cli
    1f36:	0f 92       	push	r0
    1f38:	1f 92       	push	r1
    1f3a:	11 24       	eor	r1, r1
    1f3c:	2f 92       	push	r2
    1f3e:	3f 92       	push	r3
    1f40:	4f 92       	push	r4
    1f42:	5f 92       	push	r5
    1f44:	6f 92       	push	r6
    1f46:	7f 92       	push	r7
    1f48:	8f 92       	push	r8
    1f4a:	9f 92       	push	r9
    1f4c:	af 92       	push	r10
    1f4e:	bf 92       	push	r11
    1f50:	cf 92       	push	r12
    1f52:	df 92       	push	r13
    1f54:	ef 92       	push	r14
    1f56:	ff 92       	push	r15
    1f58:	0f 93       	push	r16
    1f5a:	1f 93       	push	r17
    1f5c:	2f 93       	push	r18
    1f5e:	3f 93       	push	r19
    1f60:	4f 93       	push	r20
    1f62:	5f 93       	push	r21
    1f64:	6f 93       	push	r22
    1f66:	7f 93       	push	r23
    1f68:	8f 93       	push	r24
    1f6a:	9f 93       	push	r25
    1f6c:	af 93       	push	r26
    1f6e:	bf 93       	push	r27
    1f70:	cf 93       	push	r28
    1f72:	df 93       	push	r29
    1f74:	ef 93       	push	r30
    1f76:	ff 93       	push	r31
    1f78:	a0 91 f2 5e 	lds	r26, 0x5EF2	; 0x805ef2 <pxCurrentTCB>
    1f7c:	b0 91 f3 5e 	lds	r27, 0x5EF3	; 0x805ef3 <pxCurrentTCB+0x1>
    1f80:	0d b6       	in	r0, 0x3d	; 61
    1f82:	0d 92       	st	X+, r0
    1f84:	0e b6       	in	r0, 0x3e	; 62
    1f86:	0d 92       	st	X+, r0
        if( xTaskIncrementTick() != pdFALSE )
    1f88:	6f d5       	rcall	.+2782   	; 0x2a68 <xTaskIncrementTick>
    1f8a:	81 11       	cpse	r24, r1
        {
            vTaskSwitchContext();
    1f8c:	da d6       	rcall	.+3508   	; 0x2d42 <vTaskSwitchContext>
        }
        portRESTORE_CONTEXT();
    1f8e:	a0 91 f2 5e 	lds	r26, 0x5EF2	; 0x805ef2 <pxCurrentTCB>
    1f92:	b0 91 f3 5e 	lds	r27, 0x5EF3	; 0x805ef3 <pxCurrentTCB+0x1>
    1f96:	0d 90       	ld	r0, X+
    1f98:	0d be       	out	0x3d, r0	; 61
    1f9a:	0d 90       	ld	r0, X+
    1f9c:	0e be       	out	0x3e, r0	; 62
    1f9e:	ff 91       	pop	r31
    1fa0:	ef 91       	pop	r30
    1fa2:	df 91       	pop	r29
    1fa4:	cf 91       	pop	r28
    1fa6:	bf 91       	pop	r27
    1fa8:	af 91       	pop	r26
    1faa:	9f 91       	pop	r25
    1fac:	8f 91       	pop	r24
    1fae:	7f 91       	pop	r23
    1fb0:	6f 91       	pop	r22
    1fb2:	5f 91       	pop	r21
    1fb4:	4f 91       	pop	r20
    1fb6:	3f 91       	pop	r19
    1fb8:	2f 91       	pop	r18
    1fba:	1f 91       	pop	r17
    1fbc:	0f 91       	pop	r16
    1fbe:	ff 90       	pop	r15
    1fc0:	ef 90       	pop	r14
    1fc2:	df 90       	pop	r13
    1fc4:	cf 90       	pop	r12
    1fc6:	bf 90       	pop	r11
    1fc8:	af 90       	pop	r10
    1fca:	9f 90       	pop	r9
    1fcc:	8f 90       	pop	r8
    1fce:	7f 90       	pop	r7
    1fd0:	6f 90       	pop	r6
    1fd2:	5f 90       	pop	r5
    1fd4:	4f 90       	pop	r4
    1fd6:	3f 90       	pop	r3
    1fd8:	2f 90       	pop	r2
    1fda:	1f 90       	pop	r1
    1fdc:	0f 90       	pop	r0
    1fde:	0f be       	out	0x3f, r0	; 63
    1fe0:	0f 90       	pop	r0

        asm volatile ( "reti" );
    1fe2:	18 95       	reti

00001fe4 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
    1fe4:	cf 93       	push	r28
    1fe6:	df 93       	push	r29
    1fe8:	dc 01       	movw	r26, r24
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    1fea:	ee ef       	ldi	r30, 0xFE	; 254
    1fec:	f3 e2       	ldi	r31, 0x23	; 35
    1fee:	01 c0       	rjmp	.+2      	; 0x1ff2 <prvInsertBlockIntoFreeList+0xe>
    1ff0:	f9 01       	movw	r30, r18
    1ff2:	20 81       	ld	r18, Z
    1ff4:	31 81       	ldd	r19, Z+1	; 0x01
    1ff6:	2a 17       	cp	r18, r26
    1ff8:	3b 07       	cpc	r19, r27
    1ffa:	d0 f3       	brcs	.-12     	; 0x1ff0 <prvInsertBlockIntoFreeList+0xc>
    1ffc:	ef 01       	movw	r28, r30
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    1ffe:	82 81       	ldd	r24, Z+2	; 0x02
    2000:	93 81       	ldd	r25, Z+3	; 0x03
    2002:	af 01       	movw	r20, r30
    2004:	48 0f       	add	r20, r24
    2006:	59 1f       	adc	r21, r25
    2008:	4a 17       	cp	r20, r26
    200a:	5b 07       	cpc	r21, r27
    200c:	51 f4       	brne	.+20     	; 0x2022 <prvInsertBlockIntoFreeList+0x3e>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    200e:	da 01       	movw	r26, r20
    2010:	12 96       	adiw	r26, 0x02	; 2
    2012:	4d 91       	ld	r20, X+
    2014:	5c 91       	ld	r21, X
    2016:	13 97       	sbiw	r26, 0x03	; 3
    2018:	84 0f       	add	r24, r20
    201a:	95 1f       	adc	r25, r21
    201c:	82 83       	std	Z+2, r24	; 0x02
    201e:	93 83       	std	Z+3, r25	; 0x03
    2020:	df 01       	movw	r26, r30
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    2022:	12 96       	adiw	r26, 0x02	; 2
    2024:	8d 91       	ld	r24, X+
    2026:	9c 91       	ld	r25, X
    2028:	13 97       	sbiw	r26, 0x03	; 3
    202a:	fd 01       	movw	r30, r26
    202c:	e8 0f       	add	r30, r24
    202e:	f9 1f       	adc	r31, r25
    2030:	e2 17       	cp	r30, r18
    2032:	f3 07       	cpc	r31, r19
    2034:	d9 f4       	brne	.+54     	; 0x206c <prvInsertBlockIntoFreeList+0x88>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
    2036:	20 91 fc 23 	lds	r18, 0x23FC	; 0x8023fc <pxEnd>
    203a:	30 91 fd 23 	lds	r19, 0x23FD	; 0x8023fd <pxEnd+0x1>
    203e:	e2 17       	cp	r30, r18
    2040:	f3 07       	cpc	r31, r19
    2042:	81 f0       	breq	.+32     	; 0x2064 <prvInsertBlockIntoFreeList+0x80>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    2044:	22 81       	ldd	r18, Z+2	; 0x02
    2046:	33 81       	ldd	r19, Z+3	; 0x03
    2048:	82 0f       	add	r24, r18
    204a:	93 1f       	adc	r25, r19
    204c:	12 96       	adiw	r26, 0x02	; 2
    204e:	8d 93       	st	X+, r24
    2050:	9c 93       	st	X, r25
    2052:	13 97       	sbiw	r26, 0x03	; 3
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    2054:	e8 81       	ld	r30, Y
    2056:	f9 81       	ldd	r31, Y+1	; 0x01
    2058:	80 81       	ld	r24, Z
    205a:	91 81       	ldd	r25, Z+1	; 0x01
    205c:	8d 93       	st	X+, r24
    205e:	9c 93       	st	X, r25
    2060:	11 97       	sbiw	r26, 0x01	; 1
    2062:	07 c0       	rjmp	.+14     	; 0x2072 <prvInsertBlockIntoFreeList+0x8e>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
    2064:	ed 93       	st	X+, r30
    2066:	fc 93       	st	X, r31
    2068:	11 97       	sbiw	r26, 0x01	; 1
    206a:	03 c0       	rjmp	.+6      	; 0x2072 <prvInsertBlockIntoFreeList+0x8e>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    206c:	2d 93       	st	X+, r18
    206e:	3c 93       	st	X, r19
    2070:	11 97       	sbiw	r26, 0x01	; 1

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
    2072:	ca 17       	cp	r28, r26
    2074:	db 07       	cpc	r29, r27
    2076:	11 f0       	breq	.+4      	; 0x207c <prvInsertBlockIntoFreeList+0x98>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    2078:	a8 83       	st	Y, r26
    207a:	b9 83       	std	Y+1, r27	; 0x01
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    207c:	df 91       	pop	r29
    207e:	cf 91       	pop	r28
    2080:	08 95       	ret

00002082 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2082:	cf 92       	push	r12
    2084:	df 92       	push	r13
    2086:	ef 92       	push	r14
    2088:	ff 92       	push	r15
    208a:	0f 93       	push	r16
    208c:	1f 93       	push	r17
    208e:	cf 93       	push	r28
    2090:	df 93       	push	r29
    2092:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
    2094:	d9 d4       	rcall	.+2482   	; 0x2a48 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
    2096:	80 91 fc 23 	lds	r24, 0x23FC	; 0x8023fc <pxEnd>
    209a:	90 91 fd 23 	lds	r25, 0x23FD	; 0x8023fd <pxEnd+0x1>
    209e:	89 2b       	or	r24, r25
    20a0:	41 f5       	brne	.+80     	; 0x20f2 <pvPortMalloc+0x70>

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    20a2:	ee ef       	ldi	r30, 0xFE	; 254
    20a4:	f3 e2       	ldi	r31, 0x23	; 35
    20a6:	a2 e0       	ldi	r26, 0x02	; 2
    20a8:	b4 e2       	ldi	r27, 0x24	; 36
    20aa:	a0 83       	st	Z, r26
    20ac:	b1 83       	std	Z+1, r27	; 0x01
	xStart.xBlockSize = ( size_t ) 0;
    20ae:	12 82       	std	Z+2, r1	; 0x02
    20b0:	13 82       	std	Z+3, r1	; 0x03

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
    20b2:	e6 e9       	ldi	r30, 0x96	; 150
    20b4:	fe e5       	ldi	r31, 0x5E	; 94
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
    20b6:	e0 93 fc 23 	sts	0x23FC, r30	; 0x8023fc <pxEnd>
    20ba:	f0 93 fd 23 	sts	0x23FD, r31	; 0x8023fd <pxEnd+0x1>
	pxEnd->xBlockSize = 0;
    20be:	12 82       	std	Z+2, r1	; 0x02
    20c0:	13 82       	std	Z+3, r1	; 0x03
	pxEnd->pxNextFreeBlock = NULL;
    20c2:	10 82       	st	Z, r1
    20c4:	11 82       	std	Z+1, r1	; 0x01

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
    20c6:	84 e9       	ldi	r24, 0x94	; 148
    20c8:	9a e3       	ldi	r25, 0x3A	; 58
    20ca:	12 96       	adiw	r26, 0x02	; 2
    20cc:	8d 93       	st	X+, r24
    20ce:	9c 93       	st	X, r25
    20d0:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    20d2:	ed 93       	st	X+, r30
    20d4:	fc 93       	st	X, r31

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    20d6:	80 93 f8 23 	sts	0x23F8, r24	; 0x8023f8 <xMinimumEverFreeBytesRemaining>
    20da:	90 93 f9 23 	sts	0x23F9, r25	; 0x8023f9 <xMinimumEverFreeBytesRemaining+0x1>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    20de:	80 93 fa 23 	sts	0x23FA, r24	; 0x8023fa <xFreeBytesRemaining>
    20e2:	90 93 fb 23 	sts	0x23FB, r25	; 0x8023fb <xFreeBytesRemaining+0x1>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    20e6:	80 e0       	ldi	r24, 0x00	; 0
    20e8:	90 e8       	ldi	r25, 0x80	; 128
    20ea:	80 93 f6 23 	sts	0x23F6, r24	; 0x8023f6 <xBlockAllocatedBit>
    20ee:	90 93 f7 23 	sts	0x23F7, r25	; 0x8023f7 <xBlockAllocatedBit+0x1>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    20f2:	e0 90 f6 23 	lds	r14, 0x23F6	; 0x8023f6 <xBlockAllocatedBit>
    20f6:	f0 90 f7 23 	lds	r15, 0x23F7	; 0x8023f7 <xBlockAllocatedBit+0x1>
    20fa:	ce 01       	movw	r24, r28
    20fc:	8e 21       	and	r24, r14
    20fe:	9f 21       	and	r25, r15
    2100:	89 2b       	or	r24, r25
    2102:	09 f0       	breq	.+2      	; 0x2106 <pvPortMalloc+0x84>
    2104:	5e c0       	rjmp	.+188    	; 0x21c2 <pvPortMalloc+0x140>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
    2106:	20 97       	sbiw	r28, 0x00	; 0
    2108:	09 f4       	brne	.+2      	; 0x210c <pvPortMalloc+0x8a>
    210a:	5e c0       	rjmp	.+188    	; 0x21c8 <pvPortMalloc+0x146>
			{
				xWantedSize += xHeapStructSize;
    210c:	ae 01       	movw	r20, r28
    210e:	4c 5f       	subi	r20, 0xFC	; 252
    2110:	5f 4f       	sbci	r21, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    2112:	09 f4       	brne	.+2      	; 0x2116 <pvPortMalloc+0x94>
    2114:	5c c0       	rjmp	.+184    	; 0x21ce <pvPortMalloc+0x14c>
    2116:	00 91 fa 23 	lds	r16, 0x23FA	; 0x8023fa <xFreeBytesRemaining>
    211a:	10 91 fb 23 	lds	r17, 0x23FB	; 0x8023fb <xFreeBytesRemaining+0x1>
    211e:	04 17       	cp	r16, r20
    2120:	15 07       	cpc	r17, r21
    2122:	08 f4       	brcc	.+2      	; 0x2126 <pvPortMalloc+0xa4>
    2124:	57 c0       	rjmp	.+174    	; 0x21d4 <pvPortMalloc+0x152>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
    2126:	c0 91 fe 23 	lds	r28, 0x23FE	; 0x8023fe <xStart>
    212a:	d0 91 ff 23 	lds	r29, 0x23FF	; 0x8023ff <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
    212e:	ee ef       	ldi	r30, 0xFE	; 254
    2130:	f3 e2       	ldi	r31, 0x23	; 35
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    2132:	02 c0       	rjmp	.+4      	; 0x2138 <pvPortMalloc+0xb6>
    2134:	fe 01       	movw	r30, r28
				{
					pxPreviousBlock = pxBlock;
					pxBlock = pxBlock->pxNextFreeBlock;
    2136:	e9 01       	movw	r28, r18
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    2138:	2a 81       	ldd	r18, Y+2	; 0x02
    213a:	3b 81       	ldd	r19, Y+3	; 0x03
    213c:	24 17       	cp	r18, r20
    213e:	35 07       	cpc	r19, r21
    2140:	28 f4       	brcc	.+10     	; 0x214c <pvPortMalloc+0xca>
    2142:	28 81       	ld	r18, Y
    2144:	39 81       	ldd	r19, Y+1	; 0x01
    2146:	21 15       	cp	r18, r1
    2148:	31 05       	cpc	r19, r1
    214a:	a1 f7       	brne	.-24     	; 0x2134 <pvPortMalloc+0xb2>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
    214c:	80 91 fc 23 	lds	r24, 0x23FC	; 0x8023fc <pxEnd>
    2150:	90 91 fd 23 	lds	r25, 0x23FD	; 0x8023fd <pxEnd+0x1>
    2154:	c8 17       	cp	r28, r24
    2156:	d9 07       	cpc	r29, r25
    2158:	09 f4       	brne	.+2      	; 0x215c <pvPortMalloc+0xda>
    215a:	3f c0       	rjmp	.+126    	; 0x21da <pvPortMalloc+0x158>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    215c:	c0 80       	ld	r12, Z
    215e:	d1 80       	ldd	r13, Z+1	; 0x01
    2160:	84 e0       	ldi	r24, 0x04	; 4
    2162:	c8 0e       	add	r12, r24
    2164:	d1 1c       	adc	r13, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    2166:	88 81       	ld	r24, Y
    2168:	99 81       	ldd	r25, Y+1	; 0x01
    216a:	80 83       	st	Z, r24
    216c:	91 83       	std	Z+1, r25	; 0x01

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    216e:	2a 81       	ldd	r18, Y+2	; 0x02
    2170:	3b 81       	ldd	r19, Y+3	; 0x03
    2172:	24 1b       	sub	r18, r20
    2174:	35 0b       	sbc	r19, r21
    2176:	29 30       	cpi	r18, 0x09	; 9
    2178:	31 05       	cpc	r19, r1
    217a:	48 f0       	brcs	.+18     	; 0x218e <pvPortMalloc+0x10c>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    217c:	ce 01       	movw	r24, r28
    217e:	84 0f       	add	r24, r20
    2180:	95 1f       	adc	r25, r21
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    2182:	fc 01       	movw	r30, r24
    2184:	22 83       	std	Z+2, r18	; 0x02
    2186:	33 83       	std	Z+3, r19	; 0x03
						pxBlock->xBlockSize = xWantedSize;
    2188:	4a 83       	std	Y+2, r20	; 0x02
    218a:	5b 83       	std	Y+3, r21	; 0x03

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
    218c:	2b df       	rcall	.-426    	; 0x1fe4 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
    218e:	8a 81       	ldd	r24, Y+2	; 0x02
    2190:	9b 81       	ldd	r25, Y+3	; 0x03
    2192:	08 1b       	sub	r16, r24
    2194:	19 0b       	sbc	r17, r25
    2196:	00 93 fa 23 	sts	0x23FA, r16	; 0x8023fa <xFreeBytesRemaining>
    219a:	10 93 fb 23 	sts	0x23FB, r17	; 0x8023fb <xFreeBytesRemaining+0x1>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    219e:	20 91 f8 23 	lds	r18, 0x23F8	; 0x8023f8 <xMinimumEverFreeBytesRemaining>
    21a2:	30 91 f9 23 	lds	r19, 0x23F9	; 0x8023f9 <xMinimumEverFreeBytesRemaining+0x1>
    21a6:	02 17       	cp	r16, r18
    21a8:	13 07       	cpc	r17, r19
    21aa:	20 f4       	brcc	.+8      	; 0x21b4 <pvPortMalloc+0x132>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    21ac:	00 93 f8 23 	sts	0x23F8, r16	; 0x8023f8 <xMinimumEverFreeBytesRemaining>
    21b0:	10 93 f9 23 	sts	0x23F9, r17	; 0x8023f9 <xMinimumEverFreeBytesRemaining+0x1>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    21b4:	e8 2a       	or	r14, r24
    21b6:	f9 2a       	or	r15, r25
    21b8:	ea 82       	std	Y+2, r14	; 0x02
    21ba:	fb 82       	std	Y+3, r15	; 0x03
					pxBlock->pxNextFreeBlock = NULL;
    21bc:	18 82       	st	Y, r1
    21be:	19 82       	std	Y+1, r1	; 0x01
    21c0:	0e c0       	rjmp	.+28     	; 0x21de <pvPortMalloc+0x15c>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
    21c2:	c1 2c       	mov	r12, r1
    21c4:	d1 2c       	mov	r13, r1
    21c6:	0b c0       	rjmp	.+22     	; 0x21de <pvPortMalloc+0x15c>
    21c8:	c1 2c       	mov	r12, r1
    21ca:	d1 2c       	mov	r13, r1
    21cc:	08 c0       	rjmp	.+16     	; 0x21de <pvPortMalloc+0x15c>
    21ce:	c1 2c       	mov	r12, r1
    21d0:	d1 2c       	mov	r13, r1
    21d2:	05 c0       	rjmp	.+10     	; 0x21de <pvPortMalloc+0x15c>
    21d4:	c1 2c       	mov	r12, r1
    21d6:	d1 2c       	mov	r13, r1
    21d8:	02 c0       	rjmp	.+4      	; 0x21de <pvPortMalloc+0x15c>
    21da:	c1 2c       	mov	r12, r1
    21dc:	d1 2c       	mov	r13, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    21de:	17 d5       	rcall	.+2606   	; 0x2c0e <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
    21e0:	c6 01       	movw	r24, r12
    21e2:	df 91       	pop	r29
    21e4:	cf 91       	pop	r28
    21e6:	1f 91       	pop	r17
    21e8:	0f 91       	pop	r16
    21ea:	ff 90       	pop	r15
    21ec:	ef 90       	pop	r14
    21ee:	df 90       	pop	r13
    21f0:	cf 90       	pop	r12
    21f2:	08 95       	ret

000021f4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    21f4:	cf 93       	push	r28
    21f6:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
    21f8:	00 97       	sbiw	r24, 0x00	; 0
    21fa:	41 f1       	breq	.+80     	; 0x224c <vPortFree+0x58>

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
    21fc:	fc 01       	movw	r30, r24
    21fe:	34 97       	sbiw	r30, 0x04	; 4
    2200:	22 81       	ldd	r18, Z+2	; 0x02
    2202:	33 81       	ldd	r19, Z+3	; 0x03
    2204:	40 91 f6 23 	lds	r20, 0x23F6	; 0x8023f6 <xBlockAllocatedBit>
    2208:	50 91 f7 23 	lds	r21, 0x23F7	; 0x8023f7 <xBlockAllocatedBit+0x1>
    220c:	ba 01       	movw	r22, r20
    220e:	62 23       	and	r22, r18
    2210:	73 23       	and	r23, r19
    2212:	67 2b       	or	r22, r23
    2214:	d9 f0       	breq	.+54     	; 0x224c <vPortFree+0x58>
		{
			if( pxLink->pxNextFreeBlock == NULL )
    2216:	60 81       	ld	r22, Z
    2218:	71 81       	ldd	r23, Z+1	; 0x01
    221a:	67 2b       	or	r22, r23
    221c:	b9 f4       	brne	.+46     	; 0x224c <vPortFree+0x58>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    221e:	ef 01       	movw	r28, r30
    2220:	40 95       	com	r20
    2222:	50 95       	com	r21
    2224:	24 23       	and	r18, r20
    2226:	35 23       	and	r19, r21
    2228:	22 83       	std	Z+2, r18	; 0x02
    222a:	33 83       	std	Z+3, r19	; 0x03

				vTaskSuspendAll();
    222c:	0d d4       	rcall	.+2074   	; 0x2a48 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
    222e:	20 91 fa 23 	lds	r18, 0x23FA	; 0x8023fa <xFreeBytesRemaining>
    2232:	30 91 fb 23 	lds	r19, 0x23FB	; 0x8023fb <xFreeBytesRemaining+0x1>
    2236:	8a 81       	ldd	r24, Y+2	; 0x02
    2238:	9b 81       	ldd	r25, Y+3	; 0x03
    223a:	82 0f       	add	r24, r18
    223c:	93 1f       	adc	r25, r19
    223e:	80 93 fa 23 	sts	0x23FA, r24	; 0x8023fa <xFreeBytesRemaining>
    2242:	90 93 fb 23 	sts	0x23FB, r25	; 0x8023fb <xFreeBytesRemaining+0x1>
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    2246:	ce 01       	movw	r24, r28
    2248:	cd de       	rcall	.-614    	; 0x1fe4 <prvInsertBlockIntoFreeList>
				}
				( void ) xTaskResumeAll();
    224a:	e1 d4       	rcall	.+2498   	; 0x2c0e <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    224c:	df 91       	pop	r29
    224e:	cf 91       	pop	r28
    2250:	08 95       	ret

00002252 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    2252:	80 91 fa 23 	lds	r24, 0x23FA	; 0x8023fa <xFreeBytesRemaining>
    2256:	90 91 fb 23 	lds	r25, 0x23FB	; 0x8023fb <xFreeBytesRemaining+0x1>
    225a:	08 95       	ret

0000225c <prvCopyDataToQueue>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    225c:	1f 93       	push	r17
    225e:	cf 93       	push	r28
    2260:	df 93       	push	r29
    2262:	ec 01       	movw	r28, r24
    2264:	14 2f       	mov	r17, r20
    2266:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2268:	88 23       	and	r24, r24
    226a:	e9 f1       	breq	.+122    	; 0x22e6 <prvCopyDataToQueue+0x8a>
    226c:	41 11       	cpse	r20, r1
    226e:	17 c0       	rjmp	.+46     	; 0x229e <prvCopyDataToQueue+0x42>
    2270:	48 2f       	mov	r20, r24
    2272:	50 e0       	ldi	r21, 0x00	; 0
    2274:	8c 81       	ldd	r24, Y+4	; 0x04
    2276:	9d 81       	ldd	r25, Y+5	; 0x05
    2278:	0e 94 6e 1e 	call	0x3cdc	; 0x3cdc <memcpy>
    227c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    227e:	8c 81       	ldd	r24, Y+4	; 0x04
    2280:	9d 81       	ldd	r25, Y+5	; 0x05
    2282:	82 0f       	add	r24, r18
    2284:	91 1d       	adc	r25, r1
    2286:	8c 83       	std	Y+4, r24	; 0x04
    2288:	9d 83       	std	Y+5, r25	; 0x05
    228a:	2a 81       	ldd	r18, Y+2	; 0x02
    228c:	3b 81       	ldd	r19, Y+3	; 0x03
    228e:	82 17       	cp	r24, r18
    2290:	93 07       	cpc	r25, r19
    2292:	48 f1       	brcs	.+82     	; 0x22e6 <prvCopyDataToQueue+0x8a>
    2294:	88 81       	ld	r24, Y
    2296:	99 81       	ldd	r25, Y+1	; 0x01
    2298:	8c 83       	std	Y+4, r24	; 0x04
    229a:	9d 83       	std	Y+5, r25	; 0x05
    229c:	24 c0       	rjmp	.+72     	; 0x22e6 <prvCopyDataToQueue+0x8a>
    229e:	48 2f       	mov	r20, r24
    22a0:	50 e0       	ldi	r21, 0x00	; 0
    22a2:	8e 81       	ldd	r24, Y+6	; 0x06
    22a4:	9f 81       	ldd	r25, Y+7	; 0x07
    22a6:	0e 94 6e 1e 	call	0x3cdc	; 0x3cdc <memcpy>
    22aa:	8c 8d       	ldd	r24, Y+28	; 0x1c
    22ac:	90 e0       	ldi	r25, 0x00	; 0
    22ae:	91 95       	neg	r25
    22b0:	81 95       	neg	r24
    22b2:	91 09       	sbc	r25, r1
    22b4:	2e 81       	ldd	r18, Y+6	; 0x06
    22b6:	3f 81       	ldd	r19, Y+7	; 0x07
    22b8:	28 0f       	add	r18, r24
    22ba:	39 1f       	adc	r19, r25
    22bc:	2e 83       	std	Y+6, r18	; 0x06
    22be:	3f 83       	std	Y+7, r19	; 0x07
    22c0:	48 81       	ld	r20, Y
    22c2:	59 81       	ldd	r21, Y+1	; 0x01
    22c4:	24 17       	cp	r18, r20
    22c6:	35 07       	cpc	r19, r21
    22c8:	30 f4       	brcc	.+12     	; 0x22d6 <prvCopyDataToQueue+0x7a>
    22ca:	2a 81       	ldd	r18, Y+2	; 0x02
    22cc:	3b 81       	ldd	r19, Y+3	; 0x03
    22ce:	82 0f       	add	r24, r18
    22d0:	93 1f       	adc	r25, r19
    22d2:	8e 83       	std	Y+6, r24	; 0x06
    22d4:	9f 83       	std	Y+7, r25	; 0x07
    22d6:	12 30       	cpi	r17, 0x02	; 2
    22d8:	31 f4       	brne	.+12     	; 0x22e6 <prvCopyDataToQueue+0x8a>
    22da:	8a 8d       	ldd	r24, Y+26	; 0x1a
    22dc:	88 23       	and	r24, r24
    22de:	19 f0       	breq	.+6      	; 0x22e6 <prvCopyDataToQueue+0x8a>
    22e0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    22e2:	81 50       	subi	r24, 0x01	; 1
    22e4:	8a 8f       	std	Y+26, r24	; 0x1a
    22e6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    22e8:	8f 5f       	subi	r24, 0xFF	; 255
    22ea:	8a 8f       	std	Y+26, r24	; 0x1a
    22ec:	80 e0       	ldi	r24, 0x00	; 0
    22ee:	df 91       	pop	r29
    22f0:	cf 91       	pop	r28
    22f2:	1f 91       	pop	r17
    22f4:	08 95       	ret

000022f6 <prvCopyDataFromQueue>:
    22f6:	fc 01       	movw	r30, r24
    22f8:	44 8d       	ldd	r20, Z+28	; 0x1c
    22fa:	44 23       	and	r20, r20
    22fc:	a9 f0       	breq	.+42     	; 0x2328 <prvCopyDataFromQueue+0x32>
    22fe:	50 e0       	ldi	r21, 0x00	; 0
    2300:	26 81       	ldd	r18, Z+6	; 0x06
    2302:	37 81       	ldd	r19, Z+7	; 0x07
    2304:	24 0f       	add	r18, r20
    2306:	35 1f       	adc	r19, r21
    2308:	26 83       	std	Z+6, r18	; 0x06
    230a:	37 83       	std	Z+7, r19	; 0x07
    230c:	82 81       	ldd	r24, Z+2	; 0x02
    230e:	93 81       	ldd	r25, Z+3	; 0x03
    2310:	28 17       	cp	r18, r24
    2312:	39 07       	cpc	r19, r25
    2314:	20 f0       	brcs	.+8      	; 0x231e <prvCopyDataFromQueue+0x28>
    2316:	80 81       	ld	r24, Z
    2318:	91 81       	ldd	r25, Z+1	; 0x01
    231a:	86 83       	std	Z+6, r24	; 0x06
    231c:	97 83       	std	Z+7, r25	; 0x07
    231e:	cb 01       	movw	r24, r22
    2320:	66 81       	ldd	r22, Z+6	; 0x06
    2322:	77 81       	ldd	r23, Z+7	; 0x07
    2324:	0c 94 6e 1e 	jmp	0x3cdc	; 0x3cdc <memcpy>
    2328:	08 95       	ret

0000232a <prvUnlockQueue>:
    232a:	0f 93       	push	r16
    232c:	1f 93       	push	r17
    232e:	cf 93       	push	r28
    2330:	df 93       	push	r29
    2332:	ec 01       	movw	r28, r24
    2334:	0f b6       	in	r0, 0x3f	; 63
    2336:	f8 94       	cli
    2338:	0f 92       	push	r0
    233a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    233c:	18 16       	cp	r1, r24
    233e:	ac f4       	brge	.+42     	; 0x236a <prvUnlockQueue+0x40>
    2340:	89 89       	ldd	r24, Y+17	; 0x11
    2342:	81 11       	cpse	r24, r1
    2344:	05 c0       	rjmp	.+10     	; 0x2350 <prvUnlockQueue+0x26>
    2346:	11 c0       	rjmp	.+34     	; 0x236a <prvUnlockQueue+0x40>
    2348:	99 89       	ldd	r25, Y+17	; 0x11
    234a:	91 11       	cpse	r25, r1
    234c:	04 c0       	rjmp	.+8      	; 0x2356 <prvUnlockQueue+0x2c>
    234e:	0d c0       	rjmp	.+26     	; 0x236a <prvUnlockQueue+0x40>
    2350:	8e 01       	movw	r16, r28
    2352:	0f 5e       	subi	r16, 0xEF	; 239
    2354:	1f 4f       	sbci	r17, 0xFF	; 255
    2356:	c8 01       	movw	r24, r16
    2358:	9b d5       	rcall	.+2870   	; 0x2e90 <xTaskRemoveFromEventList>
    235a:	81 11       	cpse	r24, r1
    235c:	1d d6       	rcall	.+3130   	; 0x2f98 <vTaskMissedYield>
    235e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2360:	91 50       	subi	r25, 0x01	; 1
    2362:	9e 8f       	std	Y+30, r25	; 0x1e
    2364:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2366:	19 16       	cp	r1, r25
    2368:	7c f3       	brlt	.-34     	; 0x2348 <prvUnlockQueue+0x1e>
    236a:	8f ef       	ldi	r24, 0xFF	; 255
    236c:	8e 8f       	std	Y+30, r24	; 0x1e
    236e:	0f 90       	pop	r0
    2370:	0f be       	out	0x3f, r0	; 63
    2372:	0f b6       	in	r0, 0x3f	; 63
    2374:	f8 94       	cli
    2376:	0f 92       	push	r0
    2378:	8d 8d       	ldd	r24, Y+29	; 0x1d
    237a:	18 16       	cp	r1, r24
    237c:	ac f4       	brge	.+42     	; 0x23a8 <prvUnlockQueue+0x7e>
    237e:	88 85       	ldd	r24, Y+8	; 0x08
    2380:	81 11       	cpse	r24, r1
    2382:	05 c0       	rjmp	.+10     	; 0x238e <prvUnlockQueue+0x64>
    2384:	11 c0       	rjmp	.+34     	; 0x23a8 <prvUnlockQueue+0x7e>
    2386:	98 85       	ldd	r25, Y+8	; 0x08
    2388:	91 11       	cpse	r25, r1
    238a:	04 c0       	rjmp	.+8      	; 0x2394 <prvUnlockQueue+0x6a>
    238c:	0d c0       	rjmp	.+26     	; 0x23a8 <prvUnlockQueue+0x7e>
    238e:	8e 01       	movw	r16, r28
    2390:	08 5f       	subi	r16, 0xF8	; 248
    2392:	1f 4f       	sbci	r17, 0xFF	; 255
    2394:	c8 01       	movw	r24, r16
    2396:	7c d5       	rcall	.+2808   	; 0x2e90 <xTaskRemoveFromEventList>
    2398:	81 11       	cpse	r24, r1
    239a:	fe d5       	rcall	.+3068   	; 0x2f98 <vTaskMissedYield>
    239c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    239e:	91 50       	subi	r25, 0x01	; 1
    23a0:	9d 8f       	std	Y+29, r25	; 0x1d
    23a2:	9d 8d       	ldd	r25, Y+29	; 0x1d
    23a4:	19 16       	cp	r1, r25
    23a6:	7c f3       	brlt	.-34     	; 0x2386 <prvUnlockQueue+0x5c>
    23a8:	8f ef       	ldi	r24, 0xFF	; 255
    23aa:	8d 8f       	std	Y+29, r24	; 0x1d
    23ac:	0f 90       	pop	r0
    23ae:	0f be       	out	0x3f, r0	; 63
    23b0:	df 91       	pop	r29
    23b2:	cf 91       	pop	r28
    23b4:	1f 91       	pop	r17
    23b6:	0f 91       	pop	r16
    23b8:	08 95       	ret

000023ba <xQueueGenericReset>:
    23ba:	cf 93       	push	r28
    23bc:	df 93       	push	r29
    23be:	ec 01       	movw	r28, r24
    23c0:	0f b6       	in	r0, 0x3f	; 63
    23c2:	f8 94       	cli
    23c4:	0f 92       	push	r0
    23c6:	48 81       	ld	r20, Y
    23c8:	59 81       	ldd	r21, Y+1	; 0x01
    23ca:	2c 8d       	ldd	r18, Y+28	; 0x1c
    23cc:	30 e0       	ldi	r19, 0x00	; 0
    23ce:	7b 8d       	ldd	r23, Y+27	; 0x1b
    23d0:	72 9f       	mul	r23, r18
    23d2:	c0 01       	movw	r24, r0
    23d4:	73 9f       	mul	r23, r19
    23d6:	90 0d       	add	r25, r0
    23d8:	11 24       	eor	r1, r1
    23da:	fa 01       	movw	r30, r20
    23dc:	e8 0f       	add	r30, r24
    23de:	f9 1f       	adc	r31, r25
    23e0:	ea 83       	std	Y+2, r30	; 0x02
    23e2:	fb 83       	std	Y+3, r31	; 0x03
    23e4:	1a 8e       	std	Y+26, r1	; 0x1a
    23e6:	4c 83       	std	Y+4, r20	; 0x04
    23e8:	5d 83       	std	Y+5, r21	; 0x05
    23ea:	82 1b       	sub	r24, r18
    23ec:	93 0b       	sbc	r25, r19
    23ee:	84 0f       	add	r24, r20
    23f0:	95 1f       	adc	r25, r21
    23f2:	8e 83       	std	Y+6, r24	; 0x06
    23f4:	9f 83       	std	Y+7, r25	; 0x07
    23f6:	8f ef       	ldi	r24, 0xFF	; 255
    23f8:	8d 8f       	std	Y+29, r24	; 0x1d
    23fa:	8e 8f       	std	Y+30, r24	; 0x1e
    23fc:	61 11       	cpse	r22, r1
    23fe:	0a c0       	rjmp	.+20     	; 0x2414 <xQueueGenericReset+0x5a>
    2400:	88 85       	ldd	r24, Y+8	; 0x08
    2402:	88 23       	and	r24, r24
    2404:	69 f0       	breq	.+26     	; 0x2420 <xQueueGenericReset+0x66>
    2406:	ce 01       	movw	r24, r28
    2408:	08 96       	adiw	r24, 0x08	; 8
    240a:	42 d5       	rcall	.+2692   	; 0x2e90 <xTaskRemoveFromEventList>
    240c:	81 30       	cpi	r24, 0x01	; 1
    240e:	41 f4       	brne	.+16     	; 0x2420 <xQueueGenericReset+0x66>
    2410:	37 dd       	rcall	.-1426   	; 0x1e80 <vPortYield>
    2412:	06 c0       	rjmp	.+12     	; 0x2420 <xQueueGenericReset+0x66>
    2414:	ce 01       	movw	r24, r28
    2416:	08 96       	adiw	r24, 0x08	; 8
    2418:	ed db       	rcall	.-2086   	; 0x1bf4 <vListInitialise>
    241a:	ce 01       	movw	r24, r28
    241c:	41 96       	adiw	r24, 0x11	; 17
    241e:	ea db       	rcall	.-2092   	; 0x1bf4 <vListInitialise>
    2420:	0f 90       	pop	r0
    2422:	0f be       	out	0x3f, r0	; 63
    2424:	81 e0       	ldi	r24, 0x01	; 1
    2426:	df 91       	pop	r29
    2428:	cf 91       	pop	r28
    242a:	08 95       	ret

0000242c <xQueueGenericCreate>:
    242c:	0f 93       	push	r16
    242e:	1f 93       	push	r17
    2430:	cf 93       	push	r28
    2432:	df 93       	push	r29
    2434:	08 2f       	mov	r16, r24
    2436:	16 2f       	mov	r17, r22
    2438:	66 23       	and	r22, r22
    243a:	a9 f0       	breq	.+42     	; 0x2466 <xQueueGenericCreate+0x3a>
    243c:	86 9f       	mul	r24, r22
    243e:	c0 01       	movw	r24, r0
    2440:	11 24       	eor	r1, r1
    2442:	80 96       	adiw	r24, 0x20	; 32
    2444:	1e de       	rcall	.-964    	; 0x2082 <pvPortMalloc>
    2446:	ec 01       	movw	r28, r24
    2448:	00 97       	sbiw	r24, 0x00	; 0
    244a:	21 f4       	brne	.+8      	; 0x2454 <xQueueGenericCreate+0x28>
    244c:	12 c0       	rjmp	.+36     	; 0x2472 <xQueueGenericCreate+0x46>
    244e:	c8 83       	st	Y, r28
    2450:	d9 83       	std	Y+1, r29	; 0x01
    2452:	03 c0       	rjmp	.+6      	; 0x245a <xQueueGenericCreate+0x2e>
    2454:	4f 96       	adiw	r24, 0x1f	; 31
    2456:	88 83       	st	Y, r24
    2458:	99 83       	std	Y+1, r25	; 0x01
    245a:	0b 8f       	std	Y+27, r16	; 0x1b
    245c:	1c 8f       	std	Y+28, r17	; 0x1c
    245e:	61 e0       	ldi	r22, 0x01	; 1
    2460:	ce 01       	movw	r24, r28
    2462:	ab df       	rcall	.-170    	; 0x23ba <xQueueGenericReset>
    2464:	06 c0       	rjmp	.+12     	; 0x2472 <xQueueGenericCreate+0x46>
    2466:	8f e1       	ldi	r24, 0x1F	; 31
    2468:	90 e0       	ldi	r25, 0x00	; 0
    246a:	0b de       	rcall	.-1002   	; 0x2082 <pvPortMalloc>
    246c:	ec 01       	movw	r28, r24
    246e:	89 2b       	or	r24, r25
    2470:	71 f7       	brne	.-36     	; 0x244e <xQueueGenericCreate+0x22>
    2472:	ce 01       	movw	r24, r28
    2474:	df 91       	pop	r29
    2476:	cf 91       	pop	r28
    2478:	1f 91       	pop	r17
    247a:	0f 91       	pop	r16
    247c:	08 95       	ret

0000247e <xQueueGenericSend>:
    247e:	af 92       	push	r10
    2480:	bf 92       	push	r11
    2482:	cf 92       	push	r12
    2484:	df 92       	push	r13
    2486:	ef 92       	push	r14
    2488:	ff 92       	push	r15
    248a:	0f 93       	push	r16
    248c:	1f 93       	push	r17
    248e:	cf 93       	push	r28
    2490:	df 93       	push	r29
    2492:	cd b7       	in	r28, 0x3d	; 61
    2494:	de b7       	in	r29, 0x3e	; 62
    2496:	25 97       	sbiw	r28, 0x05	; 5
    2498:	cd bf       	out	0x3d, r28	; 61
    249a:	de bf       	out	0x3e, r29	; 62
    249c:	8c 01       	movw	r16, r24
    249e:	6b 01       	movw	r12, r22
    24a0:	4c 83       	std	Y+4, r20	; 0x04
    24a2:	5d 83       	std	Y+5, r21	; 0x05
    24a4:	a2 2e       	mov	r10, r18
    24a6:	b1 2c       	mov	r11, r1
    24a8:	7c 01       	movw	r14, r24
    24aa:	88 e0       	ldi	r24, 0x08	; 8
    24ac:	e8 0e       	add	r14, r24
    24ae:	f1 1c       	adc	r15, r1
    24b0:	0f b6       	in	r0, 0x3f	; 63
    24b2:	f8 94       	cli
    24b4:	0f 92       	push	r0
    24b6:	f8 01       	movw	r30, r16
    24b8:	32 8d       	ldd	r19, Z+26	; 0x1a
    24ba:	93 8d       	ldd	r25, Z+27	; 0x1b
    24bc:	39 17       	cp	r19, r25
    24be:	18 f0       	brcs	.+6      	; 0x24c6 <xQueueGenericSend+0x48>
    24c0:	f2 e0       	ldi	r31, 0x02	; 2
    24c2:	af 12       	cpse	r10, r31
    24c4:	15 c0       	rjmp	.+42     	; 0x24f0 <xQueueGenericSend+0x72>
    24c6:	4a 2d       	mov	r20, r10
    24c8:	b6 01       	movw	r22, r12
    24ca:	c8 01       	movw	r24, r16
    24cc:	c7 de       	rcall	.-626    	; 0x225c <prvCopyDataToQueue>
    24ce:	f8 01       	movw	r30, r16
    24d0:	91 89       	ldd	r25, Z+17	; 0x11
    24d2:	99 23       	and	r25, r25
    24d4:	39 f0       	breq	.+14     	; 0x24e4 <xQueueGenericSend+0x66>
    24d6:	c8 01       	movw	r24, r16
    24d8:	41 96       	adiw	r24, 0x11	; 17
    24da:	da d4       	rcall	.+2484   	; 0x2e90 <xTaskRemoveFromEventList>
    24dc:	81 30       	cpi	r24, 0x01	; 1
    24de:	21 f4       	brne	.+8      	; 0x24e8 <xQueueGenericSend+0x6a>
    24e0:	cf dc       	rcall	.-1634   	; 0x1e80 <vPortYield>
    24e2:	02 c0       	rjmp	.+4      	; 0x24e8 <xQueueGenericSend+0x6a>
    24e4:	81 11       	cpse	r24, r1
    24e6:	cc dc       	rcall	.-1640   	; 0x1e80 <vPortYield>
    24e8:	0f 90       	pop	r0
    24ea:	0f be       	out	0x3f, r0	; 63
    24ec:	81 e0       	ldi	r24, 0x01	; 1
    24ee:	46 c0       	rjmp	.+140    	; 0x257c <xQueueGenericSend+0xfe>
    24f0:	ec 81       	ldd	r30, Y+4	; 0x04
    24f2:	fd 81       	ldd	r31, Y+5	; 0x05
    24f4:	ef 2b       	or	r30, r31
    24f6:	21 f4       	brne	.+8      	; 0x2500 <xQueueGenericSend+0x82>
    24f8:	0f 90       	pop	r0
    24fa:	0f be       	out	0x3f, r0	; 63
    24fc:	80 e0       	ldi	r24, 0x00	; 0
    24fe:	3e c0       	rjmp	.+124    	; 0x257c <xQueueGenericSend+0xfe>
    2500:	b1 10       	cpse	r11, r1
    2502:	05 c0       	rjmp	.+10     	; 0x250e <xQueueGenericSend+0x90>
    2504:	ce 01       	movw	r24, r28
    2506:	01 96       	adiw	r24, 0x01	; 1
    2508:	0b d5       	rcall	.+2582   	; 0x2f20 <vTaskSetTimeOutState>
    250a:	bb 24       	eor	r11, r11
    250c:	b3 94       	inc	r11
    250e:	0f 90       	pop	r0
    2510:	0f be       	out	0x3f, r0	; 63
    2512:	9a d2       	rcall	.+1332   	; 0x2a48 <vTaskSuspendAll>
    2514:	0f b6       	in	r0, 0x3f	; 63
    2516:	f8 94       	cli
    2518:	0f 92       	push	r0
    251a:	f8 01       	movw	r30, r16
    251c:	85 8d       	ldd	r24, Z+29	; 0x1d
    251e:	8f 3f       	cpi	r24, 0xFF	; 255
    2520:	09 f4       	brne	.+2      	; 0x2524 <xQueueGenericSend+0xa6>
    2522:	15 8e       	std	Z+29, r1	; 0x1d
    2524:	f8 01       	movw	r30, r16
    2526:	86 8d       	ldd	r24, Z+30	; 0x1e
    2528:	8f 3f       	cpi	r24, 0xFF	; 255
    252a:	09 f4       	brne	.+2      	; 0x252e <xQueueGenericSend+0xb0>
    252c:	16 8e       	std	Z+30, r1	; 0x1e
    252e:	0f 90       	pop	r0
    2530:	0f be       	out	0x3f, r0	; 63
    2532:	be 01       	movw	r22, r28
    2534:	6c 5f       	subi	r22, 0xFC	; 252
    2536:	7f 4f       	sbci	r23, 0xFF	; 255
    2538:	ce 01       	movw	r24, r28
    253a:	01 96       	adiw	r24, 0x01	; 1
    253c:	fc d4       	rcall	.+2552   	; 0x2f36 <xTaskCheckForTimeOut>
    253e:	81 11       	cpse	r24, r1
    2540:	19 c0       	rjmp	.+50     	; 0x2574 <xQueueGenericSend+0xf6>
    2542:	0f b6       	in	r0, 0x3f	; 63
    2544:	f8 94       	cli
    2546:	0f 92       	push	r0
    2548:	f8 01       	movw	r30, r16
    254a:	92 8d       	ldd	r25, Z+26	; 0x1a
    254c:	0f 90       	pop	r0
    254e:	0f be       	out	0x3f, r0	; 63
    2550:	83 8d       	ldd	r24, Z+27	; 0x1b
    2552:	98 13       	cpse	r25, r24
    2554:	0b c0       	rjmp	.+22     	; 0x256c <xQueueGenericSend+0xee>
    2556:	6c 81       	ldd	r22, Y+4	; 0x04
    2558:	7d 81       	ldd	r23, Y+5	; 0x05
    255a:	c7 01       	movw	r24, r14
    255c:	5f d4       	rcall	.+2238   	; 0x2e1c <vTaskPlaceOnEventList>
    255e:	c8 01       	movw	r24, r16
    2560:	e4 de       	rcall	.-568    	; 0x232a <prvUnlockQueue>
    2562:	55 d3       	rcall	.+1706   	; 0x2c0e <xTaskResumeAll>
    2564:	81 11       	cpse	r24, r1
    2566:	a4 cf       	rjmp	.-184    	; 0x24b0 <xQueueGenericSend+0x32>
    2568:	8b dc       	rcall	.-1770   	; 0x1e80 <vPortYield>
    256a:	a2 cf       	rjmp	.-188    	; 0x24b0 <xQueueGenericSend+0x32>
    256c:	c8 01       	movw	r24, r16
    256e:	dd de       	rcall	.-582    	; 0x232a <prvUnlockQueue>
    2570:	4e d3       	rcall	.+1692   	; 0x2c0e <xTaskResumeAll>
    2572:	9e cf       	rjmp	.-196    	; 0x24b0 <xQueueGenericSend+0x32>
    2574:	c8 01       	movw	r24, r16
    2576:	d9 de       	rcall	.-590    	; 0x232a <prvUnlockQueue>
    2578:	4a d3       	rcall	.+1684   	; 0x2c0e <xTaskResumeAll>
    257a:	80 e0       	ldi	r24, 0x00	; 0
    257c:	25 96       	adiw	r28, 0x05	; 5
    257e:	cd bf       	out	0x3d, r28	; 61
    2580:	de bf       	out	0x3e, r29	; 62
    2582:	df 91       	pop	r29
    2584:	cf 91       	pop	r28
    2586:	1f 91       	pop	r17
    2588:	0f 91       	pop	r16
    258a:	ff 90       	pop	r15
    258c:	ef 90       	pop	r14
    258e:	df 90       	pop	r13
    2590:	cf 90       	pop	r12
    2592:	bf 90       	pop	r11
    2594:	af 90       	pop	r10
    2596:	08 95       	ret

00002598 <xQueueGenericSendFromISR>:
    2598:	0f 93       	push	r16
    259a:	1f 93       	push	r17
    259c:	cf 93       	push	r28
    259e:	df 93       	push	r29
    25a0:	fa 01       	movw	r30, r20
    25a2:	dc 01       	movw	r26, r24
    25a4:	5a 96       	adiw	r26, 0x1a	; 26
    25a6:	5c 91       	ld	r21, X
    25a8:	5a 97       	sbiw	r26, 0x1a	; 26
    25aa:	5b 96       	adiw	r26, 0x1b	; 27
    25ac:	3c 91       	ld	r19, X
    25ae:	53 17       	cp	r21, r19
    25b0:	10 f0       	brcs	.+4      	; 0x25b6 <xQueueGenericSendFromISR+0x1e>
    25b2:	22 30       	cpi	r18, 0x02	; 2
    25b4:	d9 f4       	brne	.+54     	; 0x25ec <xQueueGenericSendFromISR+0x54>
    25b6:	42 2f       	mov	r20, r18
    25b8:	8f 01       	movw	r16, r30
    25ba:	ec 01       	movw	r28, r24
    25bc:	4f de       	rcall	.-866    	; 0x225c <prvCopyDataToQueue>
    25be:	8e 8d       	ldd	r24, Y+30	; 0x1e
    25c0:	8f 3f       	cpi	r24, 0xFF	; 255
    25c2:	79 f4       	brne	.+30     	; 0x25e2 <xQueueGenericSendFromISR+0x4a>
    25c4:	89 89       	ldd	r24, Y+17	; 0x11
    25c6:	88 23       	and	r24, r24
    25c8:	99 f0       	breq	.+38     	; 0x25f0 <xQueueGenericSendFromISR+0x58>
    25ca:	ce 01       	movw	r24, r28
    25cc:	41 96       	adiw	r24, 0x11	; 17
    25ce:	60 d4       	rcall	.+2240   	; 0x2e90 <xTaskRemoveFromEventList>
    25d0:	88 23       	and	r24, r24
    25d2:	81 f0       	breq	.+32     	; 0x25f4 <xQueueGenericSendFromISR+0x5c>
    25d4:	01 15       	cp	r16, r1
    25d6:	11 05       	cpc	r17, r1
    25d8:	79 f0       	breq	.+30     	; 0x25f8 <xQueueGenericSendFromISR+0x60>
    25da:	81 e0       	ldi	r24, 0x01	; 1
    25dc:	f8 01       	movw	r30, r16
    25de:	80 83       	st	Z, r24
    25e0:	0c c0       	rjmp	.+24     	; 0x25fa <xQueueGenericSendFromISR+0x62>
    25e2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    25e4:	8f 5f       	subi	r24, 0xFF	; 255
    25e6:	8e 8f       	std	Y+30, r24	; 0x1e
    25e8:	81 e0       	ldi	r24, 0x01	; 1
    25ea:	07 c0       	rjmp	.+14     	; 0x25fa <xQueueGenericSendFromISR+0x62>
    25ec:	80 e0       	ldi	r24, 0x00	; 0
    25ee:	05 c0       	rjmp	.+10     	; 0x25fa <xQueueGenericSendFromISR+0x62>
    25f0:	81 e0       	ldi	r24, 0x01	; 1
    25f2:	03 c0       	rjmp	.+6      	; 0x25fa <xQueueGenericSendFromISR+0x62>
    25f4:	81 e0       	ldi	r24, 0x01	; 1
    25f6:	01 c0       	rjmp	.+2      	; 0x25fa <xQueueGenericSendFromISR+0x62>
    25f8:	81 e0       	ldi	r24, 0x01	; 1
    25fa:	df 91       	pop	r29
    25fc:	cf 91       	pop	r28
    25fe:	1f 91       	pop	r17
    2600:	0f 91       	pop	r16
    2602:	08 95       	ret

00002604 <xQueueGenericReceive>:
    2604:	af 92       	push	r10
    2606:	bf 92       	push	r11
    2608:	cf 92       	push	r12
    260a:	df 92       	push	r13
    260c:	ef 92       	push	r14
    260e:	ff 92       	push	r15
    2610:	0f 93       	push	r16
    2612:	1f 93       	push	r17
    2614:	cf 93       	push	r28
    2616:	df 93       	push	r29
    2618:	cd b7       	in	r28, 0x3d	; 61
    261a:	de b7       	in	r29, 0x3e	; 62
    261c:	25 97       	sbiw	r28, 0x05	; 5
    261e:	cd bf       	out	0x3d, r28	; 61
    2620:	de bf       	out	0x3e, r29	; 62
    2622:	8c 01       	movw	r16, r24
    2624:	6b 01       	movw	r12, r22
    2626:	4c 83       	std	Y+4, r20	; 0x04
    2628:	5d 83       	std	Y+5, r21	; 0x05
    262a:	a2 2e       	mov	r10, r18
    262c:	b1 2c       	mov	r11, r1
    262e:	7c 01       	movw	r14, r24
    2630:	81 e1       	ldi	r24, 0x11	; 17
    2632:	e8 0e       	add	r14, r24
    2634:	f1 1c       	adc	r15, r1
    2636:	0f b6       	in	r0, 0x3f	; 63
    2638:	f8 94       	cli
    263a:	0f 92       	push	r0
    263c:	f8 01       	movw	r30, r16
    263e:	92 8d       	ldd	r25, Z+26	; 0x1a
    2640:	99 23       	and	r25, r25
    2642:	21 f1       	breq	.+72     	; 0x268c <xQueueGenericReceive+0x88>
    2644:	e6 80       	ldd	r14, Z+6	; 0x06
    2646:	f7 80       	ldd	r15, Z+7	; 0x07
    2648:	b6 01       	movw	r22, r12
    264a:	c8 01       	movw	r24, r16
    264c:	54 de       	rcall	.-856    	; 0x22f6 <prvCopyDataFromQueue>
    264e:	a1 10       	cpse	r10, r1
    2650:	0e c0       	rjmp	.+28     	; 0x266e <xQueueGenericReceive+0x6a>
    2652:	f8 01       	movw	r30, r16
    2654:	82 8d       	ldd	r24, Z+26	; 0x1a
    2656:	81 50       	subi	r24, 0x01	; 1
    2658:	82 8f       	std	Z+26, r24	; 0x1a
    265a:	80 85       	ldd	r24, Z+8	; 0x08
    265c:	88 23       	and	r24, r24
    265e:	91 f0       	breq	.+36     	; 0x2684 <xQueueGenericReceive+0x80>
    2660:	c8 01       	movw	r24, r16
    2662:	08 96       	adiw	r24, 0x08	; 8
    2664:	15 d4       	rcall	.+2090   	; 0x2e90 <xTaskRemoveFromEventList>
    2666:	81 30       	cpi	r24, 0x01	; 1
    2668:	69 f4       	brne	.+26     	; 0x2684 <xQueueGenericReceive+0x80>
    266a:	0a dc       	rcall	.-2028   	; 0x1e80 <vPortYield>
    266c:	0b c0       	rjmp	.+22     	; 0x2684 <xQueueGenericReceive+0x80>
    266e:	f8 01       	movw	r30, r16
    2670:	e6 82       	std	Z+6, r14	; 0x06
    2672:	f7 82       	std	Z+7, r15	; 0x07
    2674:	81 89       	ldd	r24, Z+17	; 0x11
    2676:	88 23       	and	r24, r24
    2678:	29 f0       	breq	.+10     	; 0x2684 <xQueueGenericReceive+0x80>
    267a:	c8 01       	movw	r24, r16
    267c:	41 96       	adiw	r24, 0x11	; 17
    267e:	08 d4       	rcall	.+2064   	; 0x2e90 <xTaskRemoveFromEventList>
    2680:	81 11       	cpse	r24, r1
    2682:	fe db       	rcall	.-2052   	; 0x1e80 <vPortYield>
    2684:	0f 90       	pop	r0
    2686:	0f be       	out	0x3f, r0	; 63
    2688:	81 e0       	ldi	r24, 0x01	; 1
    268a:	45 c0       	rjmp	.+138    	; 0x2716 <xQueueGenericReceive+0x112>
    268c:	4c 81       	ldd	r20, Y+4	; 0x04
    268e:	5d 81       	ldd	r21, Y+5	; 0x05
    2690:	45 2b       	or	r20, r21
    2692:	21 f4       	brne	.+8      	; 0x269c <xQueueGenericReceive+0x98>
    2694:	0f 90       	pop	r0
    2696:	0f be       	out	0x3f, r0	; 63
    2698:	80 e0       	ldi	r24, 0x00	; 0
    269a:	3d c0       	rjmp	.+122    	; 0x2716 <xQueueGenericReceive+0x112>
    269c:	b1 10       	cpse	r11, r1
    269e:	05 c0       	rjmp	.+10     	; 0x26aa <xQueueGenericReceive+0xa6>
    26a0:	ce 01       	movw	r24, r28
    26a2:	01 96       	adiw	r24, 0x01	; 1
    26a4:	3d d4       	rcall	.+2170   	; 0x2f20 <vTaskSetTimeOutState>
    26a6:	bb 24       	eor	r11, r11
    26a8:	b3 94       	inc	r11
    26aa:	0f 90       	pop	r0
    26ac:	0f be       	out	0x3f, r0	; 63
    26ae:	cc d1       	rcall	.+920    	; 0x2a48 <vTaskSuspendAll>
    26b0:	0f b6       	in	r0, 0x3f	; 63
    26b2:	f8 94       	cli
    26b4:	0f 92       	push	r0
    26b6:	f8 01       	movw	r30, r16
    26b8:	85 8d       	ldd	r24, Z+29	; 0x1d
    26ba:	8f 3f       	cpi	r24, 0xFF	; 255
    26bc:	09 f4       	brne	.+2      	; 0x26c0 <xQueueGenericReceive+0xbc>
    26be:	15 8e       	std	Z+29, r1	; 0x1d
    26c0:	f8 01       	movw	r30, r16
    26c2:	96 8d       	ldd	r25, Z+30	; 0x1e
    26c4:	9f 3f       	cpi	r25, 0xFF	; 255
    26c6:	09 f4       	brne	.+2      	; 0x26ca <xQueueGenericReceive+0xc6>
    26c8:	16 8e       	std	Z+30, r1	; 0x1e
    26ca:	0f 90       	pop	r0
    26cc:	0f be       	out	0x3f, r0	; 63
    26ce:	be 01       	movw	r22, r28
    26d0:	6c 5f       	subi	r22, 0xFC	; 252
    26d2:	7f 4f       	sbci	r23, 0xFF	; 255
    26d4:	ce 01       	movw	r24, r28
    26d6:	01 96       	adiw	r24, 0x01	; 1
    26d8:	2e d4       	rcall	.+2140   	; 0x2f36 <xTaskCheckForTimeOut>
    26da:	81 11       	cpse	r24, r1
    26dc:	18 c0       	rjmp	.+48     	; 0x270e <xQueueGenericReceive+0x10a>
    26de:	0f b6       	in	r0, 0x3f	; 63
    26e0:	f8 94       	cli
    26e2:	0f 92       	push	r0
    26e4:	f8 01       	movw	r30, r16
    26e6:	82 8d       	ldd	r24, Z+26	; 0x1a
    26e8:	0f 90       	pop	r0
    26ea:	0f be       	out	0x3f, r0	; 63
    26ec:	81 11       	cpse	r24, r1
    26ee:	0b c0       	rjmp	.+22     	; 0x2706 <xQueueGenericReceive+0x102>
    26f0:	6c 81       	ldd	r22, Y+4	; 0x04
    26f2:	7d 81       	ldd	r23, Y+5	; 0x05
    26f4:	c7 01       	movw	r24, r14
    26f6:	92 d3       	rcall	.+1828   	; 0x2e1c <vTaskPlaceOnEventList>
    26f8:	c8 01       	movw	r24, r16
    26fa:	17 de       	rcall	.-978    	; 0x232a <prvUnlockQueue>
    26fc:	88 d2       	rcall	.+1296   	; 0x2c0e <xTaskResumeAll>
    26fe:	81 11       	cpse	r24, r1
    2700:	9a cf       	rjmp	.-204    	; 0x2636 <xQueueGenericReceive+0x32>
    2702:	be db       	rcall	.-2180   	; 0x1e80 <vPortYield>
    2704:	98 cf       	rjmp	.-208    	; 0x2636 <xQueueGenericReceive+0x32>
    2706:	c8 01       	movw	r24, r16
    2708:	10 de       	rcall	.-992    	; 0x232a <prvUnlockQueue>
    270a:	81 d2       	rcall	.+1282   	; 0x2c0e <xTaskResumeAll>
    270c:	94 cf       	rjmp	.-216    	; 0x2636 <xQueueGenericReceive+0x32>
    270e:	c8 01       	movw	r24, r16
    2710:	0c de       	rcall	.-1000   	; 0x232a <prvUnlockQueue>
    2712:	7d d2       	rcall	.+1274   	; 0x2c0e <xTaskResumeAll>
    2714:	80 e0       	ldi	r24, 0x00	; 0
    2716:	25 96       	adiw	r28, 0x05	; 5
    2718:	cd bf       	out	0x3d, r28	; 61
    271a:	de bf       	out	0x3e, r29	; 62
    271c:	df 91       	pop	r29
    271e:	cf 91       	pop	r28
    2720:	1f 91       	pop	r17
    2722:	0f 91       	pop	r16
    2724:	ff 90       	pop	r15
    2726:	ef 90       	pop	r14
    2728:	df 90       	pop	r13
    272a:	cf 90       	pop	r12
    272c:	bf 90       	pop	r11
    272e:	af 90       	pop	r10
    2730:	08 95       	ret

00002732 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    2732:	cf 93       	push	r28
    2734:	df 93       	push	r29
    2736:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    2738:	0f b6       	in	r0, 0x3f	; 63
    273a:	f8 94       	cli
    273c:	0f 92       	push	r0
    273e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2740:	8f 3f       	cpi	r24, 0xFF	; 255
    2742:	09 f4       	brne	.+2      	; 0x2746 <vQueueWaitForMessageRestricted+0x14>
    2744:	1d 8e       	std	Y+29, r1	; 0x1d
    2746:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2748:	8f 3f       	cpi	r24, 0xFF	; 255
    274a:	09 f4       	brne	.+2      	; 0x274e <vQueueWaitForMessageRestricted+0x1c>
    274c:	1e 8e       	std	Y+30, r1	; 0x1e
    274e:	0f 90       	pop	r0
    2750:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    2752:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2754:	81 11       	cpse	r24, r1
    2756:	03 c0       	rjmp	.+6      	; 0x275e <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    2758:	ce 01       	movw	r24, r28
    275a:	41 96       	adiw	r24, 0x11	; 17
    275c:	7c d3       	rcall	.+1784   	; 0x2e56 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    275e:	ce 01       	movw	r24, r28
    2760:	e4 dd       	rcall	.-1080   	; 0x232a <prvUnlockQueue>
	}
    2762:	df 91       	pop	r29
    2764:	cf 91       	pop	r28
    2766:	08 95       	ret

00002768 <prvIdleTask>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    2768:	c5 ec       	ldi	r28, 0xC5	; 197
    276a:	de e5       	ldi	r29, 0x5E	; 94
    276c:	88 81       	ld	r24, Y
    276e:	82 30       	cpi	r24, 0x02	; 2
    2770:	f0 f3       	brcs	.-4      	; 0x276e <prvIdleTask+0x6>
    2772:	86 db       	rcall	.-2292   	; 0x1e80 <vPortYield>
    2774:	fb cf       	rjmp	.-10     	; 0x276c <prvIdleTask+0x4>

00002776 <prvAddCurrentTaskToDelayedList>:
    2776:	cf 93       	push	r28
    2778:	df 93       	push	r29
    277a:	ec 01       	movw	r28, r24
    277c:	e0 91 f2 5e 	lds	r30, 0x5EF2	; 0x805ef2 <pxCurrentTCB>
    2780:	f0 91 f3 5e 	lds	r31, 0x5EF3	; 0x805ef3 <pxCurrentTCB+0x1>
    2784:	82 83       	std	Z+2, r24	; 0x02
    2786:	93 83       	std	Z+3, r25	; 0x03
    2788:	80 91 a3 5e 	lds	r24, 0x5EA3	; 0x805ea3 <xTickCount>
    278c:	90 91 a4 5e 	lds	r25, 0x5EA4	; 0x805ea4 <xTickCount+0x1>
    2790:	c8 17       	cp	r28, r24
    2792:	d9 07       	cpc	r29, r25
    2794:	60 f4       	brcc	.+24     	; 0x27ae <prvAddCurrentTaskToDelayedList+0x38>
    2796:	60 91 f2 5e 	lds	r22, 0x5EF2	; 0x805ef2 <pxCurrentTCB>
    279a:	70 91 f3 5e 	lds	r23, 0x5EF3	; 0x805ef3 <pxCurrentTCB+0x1>
    279e:	80 91 af 5e 	lds	r24, 0x5EAF	; 0x805eaf <pxOverflowDelayedTaskList>
    27a2:	90 91 b0 5e 	lds	r25, 0x5EB0	; 0x805eb0 <pxOverflowDelayedTaskList+0x1>
    27a6:	6e 5f       	subi	r22, 0xFE	; 254
    27a8:	7f 4f       	sbci	r23, 0xFF	; 255
    27aa:	57 da       	rcall	.-2898   	; 0x1c5a <vListInsert>
    27ac:	16 c0       	rjmp	.+44     	; 0x27da <prvAddCurrentTaskToDelayedList+0x64>
    27ae:	60 91 f2 5e 	lds	r22, 0x5EF2	; 0x805ef2 <pxCurrentTCB>
    27b2:	70 91 f3 5e 	lds	r23, 0x5EF3	; 0x805ef3 <pxCurrentTCB+0x1>
    27b6:	80 91 b1 5e 	lds	r24, 0x5EB1	; 0x805eb1 <pxDelayedTaskList>
    27ba:	90 91 b2 5e 	lds	r25, 0x5EB2	; 0x805eb2 <pxDelayedTaskList+0x1>
    27be:	6e 5f       	subi	r22, 0xFE	; 254
    27c0:	7f 4f       	sbci	r23, 0xFF	; 255
    27c2:	4b da       	rcall	.-2922   	; 0x1c5a <vListInsert>
    27c4:	80 91 9b 5e 	lds	r24, 0x5E9B	; 0x805e9b <xNextTaskUnblockTime>
    27c8:	90 91 9c 5e 	lds	r25, 0x5E9C	; 0x805e9c <xNextTaskUnblockTime+0x1>
    27cc:	c8 17       	cp	r28, r24
    27ce:	d9 07       	cpc	r29, r25
    27d0:	20 f4       	brcc	.+8      	; 0x27da <prvAddCurrentTaskToDelayedList+0x64>
    27d2:	c0 93 9b 5e 	sts	0x5E9B, r28	; 0x805e9b <xNextTaskUnblockTime>
    27d6:	d0 93 9c 5e 	sts	0x5E9C, r29	; 0x805e9c <xNextTaskUnblockTime+0x1>
    27da:	df 91       	pop	r29
    27dc:	cf 91       	pop	r28
    27de:	08 95       	ret

000027e0 <xTaskGenericCreate>:
    27e0:	4f 92       	push	r4
    27e2:	5f 92       	push	r5
    27e4:	6f 92       	push	r6
    27e6:	7f 92       	push	r7
    27e8:	8f 92       	push	r8
    27ea:	9f 92       	push	r9
    27ec:	af 92       	push	r10
    27ee:	bf 92       	push	r11
    27f0:	cf 92       	push	r12
    27f2:	df 92       	push	r13
    27f4:	ef 92       	push	r14
    27f6:	ff 92       	push	r15
    27f8:	0f 93       	push	r16
    27fa:	1f 93       	push	r17
    27fc:	cf 93       	push	r28
    27fe:	df 93       	push	r29
    2800:	4c 01       	movw	r8, r24
    2802:	eb 01       	movw	r28, r22
    2804:	5a 01       	movw	r10, r20
    2806:	29 01       	movw	r4, r18
    2808:	c1 14       	cp	r12, r1
    280a:	d1 04       	cpc	r13, r1
    280c:	31 f4       	brne	.+12     	; 0x281a <xTaskGenericCreate+0x3a>
    280e:	ca 01       	movw	r24, r20
    2810:	38 dc       	rcall	.-1936   	; 0x2082 <pvPortMalloc>
    2812:	6c 01       	movw	r12, r24
    2814:	89 2b       	or	r24, r25
    2816:	09 f4       	brne	.+2      	; 0x281a <xTaskGenericCreate+0x3a>
    2818:	d2 c0       	rjmp	.+420    	; 0x29be <xTaskGenericCreate+0x1de>
    281a:	86 e2       	ldi	r24, 0x26	; 38
    281c:	90 e0       	ldi	r25, 0x00	; 0
    281e:	31 dc       	rcall	.-1950   	; 0x2082 <pvPortMalloc>
    2820:	3c 01       	movw	r6, r24
    2822:	00 97       	sbiw	r24, 0x00	; 0
    2824:	79 f0       	breq	.+30     	; 0x2844 <xTaskGenericCreate+0x64>
    2826:	fc 01       	movw	r30, r24
    2828:	c7 8a       	std	Z+23, r12	; 0x17
    282a:	d0 8e       	std	Z+24, r13	; 0x18
    282c:	f1 e0       	ldi	r31, 0x01	; 1
    282e:	af 1a       	sub	r10, r31
    2830:	b1 08       	sbc	r11, r1
    2832:	ca 0c       	add	r12, r10
    2834:	db 1c       	adc	r13, r11
    2836:	88 81       	ld	r24, Y
    2838:	f3 01       	movw	r30, r6
    283a:	81 8f       	std	Z+25, r24	; 0x19
    283c:	88 81       	ld	r24, Y
    283e:	81 11       	cpse	r24, r1
    2840:	04 c0       	rjmp	.+8      	; 0x284a <xTaskGenericCreate+0x6a>
    2842:	13 c0       	rjmp	.+38     	; 0x286a <xTaskGenericCreate+0x8a>
    2844:	c6 01       	movw	r24, r12
    2846:	d6 dc       	rcall	.-1620   	; 0x21f4 <vPortFree>
    2848:	ba c0       	rjmp	.+372    	; 0x29be <xTaskGenericCreate+0x1de>
    284a:	d3 01       	movw	r26, r6
    284c:	5a 96       	adiw	r26, 0x1a	; 26
    284e:	fe 01       	movw	r30, r28
    2850:	31 96       	adiw	r30, 0x01	; 1
    2852:	9e 01       	movw	r18, r28
    2854:	28 5f       	subi	r18, 0xF8	; 248
    2856:	3f 4f       	sbci	r19, 0xFF	; 255
    2858:	ef 01       	movw	r28, r30
    285a:	81 91       	ld	r24, Z+
    285c:	8d 93       	st	X+, r24
    285e:	88 81       	ld	r24, Y
    2860:	88 23       	and	r24, r24
    2862:	19 f0       	breq	.+6      	; 0x286a <xTaskGenericCreate+0x8a>
    2864:	e2 17       	cp	r30, r18
    2866:	f3 07       	cpc	r31, r19
    2868:	b9 f7       	brne	.-18     	; 0x2858 <xTaskGenericCreate+0x78>
    286a:	f3 01       	movw	r30, r6
    286c:	10 a2       	std	Z+32, r1	; 0x20
    286e:	10 2f       	mov	r17, r16
    2870:	05 30       	cpi	r16, 0x05	; 5
    2872:	08 f0       	brcs	.+2      	; 0x2876 <xTaskGenericCreate+0x96>
    2874:	14 e0       	ldi	r17, 0x04	; 4
    2876:	f3 01       	movw	r30, r6
    2878:	16 8b       	std	Z+22, r17	; 0x16
    287a:	e3 01       	movw	r28, r6
    287c:	22 96       	adiw	r28, 0x02	; 2
    287e:	ce 01       	movw	r24, r28
    2880:	c7 d9       	rcall	.-3186   	; 0x1c10 <vListInitialiseItem>
    2882:	c3 01       	movw	r24, r6
    2884:	0c 96       	adiw	r24, 0x0c	; 12
    2886:	c4 d9       	rcall	.-3192   	; 0x1c10 <vListInitialiseItem>
    2888:	f3 01       	movw	r30, r6
    288a:	60 86       	std	Z+8, r6	; 0x08
    288c:	71 86       	std	Z+9, r7	; 0x09
    288e:	85 e0       	ldi	r24, 0x05	; 5
    2890:	90 e0       	ldi	r25, 0x00	; 0
    2892:	81 1b       	sub	r24, r17
    2894:	91 09       	sbc	r25, r1
    2896:	84 87       	std	Z+12, r24	; 0x0c
    2898:	95 87       	std	Z+13, r25	; 0x0d
    289a:	62 8a       	std	Z+18, r6	; 0x12
    289c:	73 8a       	std	Z+19, r7	; 0x13
    289e:	11 a2       	std	Z+33, r1	; 0x21
    28a0:	12 a2       	std	Z+34, r1	; 0x22
    28a2:	13 a2       	std	Z+35, r1	; 0x23
    28a4:	14 a2       	std	Z+36, r1	; 0x24
    28a6:	15 a2       	std	Z+37, r1	; 0x25
    28a8:	a2 01       	movw	r20, r4
    28aa:	b4 01       	movw	r22, r8
    28ac:	c6 01       	movw	r24, r12
    28ae:	2c da       	rcall	.-2984   	; 0x1d08 <pxPortInitialiseStack>
    28b0:	f3 01       	movw	r30, r6
    28b2:	80 83       	st	Z, r24
    28b4:	91 83       	std	Z+1, r25	; 0x01
    28b6:	e1 14       	cp	r14, r1
    28b8:	f1 04       	cpc	r15, r1
    28ba:	19 f0       	breq	.+6      	; 0x28c2 <xTaskGenericCreate+0xe2>
    28bc:	f7 01       	movw	r30, r14
    28be:	60 82       	st	Z, r6
    28c0:	71 82       	std	Z+1, r7	; 0x01
    28c2:	0f b6       	in	r0, 0x3f	; 63
    28c4:	f8 94       	cli
    28c6:	0f 92       	push	r0
    28c8:	80 91 a5 5e 	lds	r24, 0x5EA5	; 0x805ea5 <uxCurrentNumberOfTasks>
    28cc:	8f 5f       	subi	r24, 0xFF	; 255
    28ce:	80 93 a5 5e 	sts	0x5EA5, r24	; 0x805ea5 <uxCurrentNumberOfTasks>
    28d2:	80 91 f2 5e 	lds	r24, 0x5EF2	; 0x805ef2 <pxCurrentTCB>
    28d6:	90 91 f3 5e 	lds	r25, 0x5EF3	; 0x805ef3 <pxCurrentTCB+0x1>
    28da:	89 2b       	or	r24, r25
    28dc:	91 f5       	brne	.+100    	; 0x2942 <xTaskGenericCreate+0x162>
    28de:	60 92 f2 5e 	sts	0x5EF2, r6	; 0x805ef2 <pxCurrentTCB>
    28e2:	70 92 f3 5e 	sts	0x5EF3, r7	; 0x805ef3 <pxCurrentTCB+0x1>
    28e6:	80 91 a5 5e 	lds	r24, 0x5EA5	; 0x805ea5 <uxCurrentNumberOfTasks>
    28ea:	81 30       	cpi	r24, 0x01	; 1
    28ec:	c9 f5       	brne	.+114    	; 0x2960 <xTaskGenericCreate+0x180>
    28ee:	0f 2e       	mov	r0, r31
    28f0:	f5 ec       	ldi	r31, 0xC5	; 197
    28f2:	ef 2e       	mov	r14, r31
    28f4:	fe e5       	ldi	r31, 0x5E	; 94
    28f6:	ff 2e       	mov	r15, r31
    28f8:	f0 2d       	mov	r31, r0
    28fa:	0f 2e       	mov	r0, r31
    28fc:	f2 ef       	ldi	r31, 0xF2	; 242
    28fe:	cf 2e       	mov	r12, r31
    2900:	fe e5       	ldi	r31, 0x5E	; 94
    2902:	df 2e       	mov	r13, r31
    2904:	f0 2d       	mov	r31, r0
    2906:	c7 01       	movw	r24, r14
    2908:	75 d9       	rcall	.-3350   	; 0x1bf4 <vListInitialise>
    290a:	f9 e0       	ldi	r31, 0x09	; 9
    290c:	ef 0e       	add	r14, r31
    290e:	f1 1c       	adc	r15, r1
    2910:	ec 14       	cp	r14, r12
    2912:	fd 04       	cpc	r15, r13
    2914:	c1 f7       	brne	.-16     	; 0x2906 <xTaskGenericCreate+0x126>
    2916:	8c eb       	ldi	r24, 0xBC	; 188
    2918:	9e e5       	ldi	r25, 0x5E	; 94
    291a:	6c d9       	rcall	.-3368   	; 0x1bf4 <vListInitialise>
    291c:	83 eb       	ldi	r24, 0xB3	; 179
    291e:	9e e5       	ldi	r25, 0x5E	; 94
    2920:	69 d9       	rcall	.-3374   	; 0x1bf4 <vListInitialise>
    2922:	86 ea       	ldi	r24, 0xA6	; 166
    2924:	9e e5       	ldi	r25, 0x5E	; 94
    2926:	66 d9       	rcall	.-3380   	; 0x1bf4 <vListInitialise>
    2928:	8c eb       	ldi	r24, 0xBC	; 188
    292a:	9e e5       	ldi	r25, 0x5E	; 94
    292c:	80 93 b1 5e 	sts	0x5EB1, r24	; 0x805eb1 <pxDelayedTaskList>
    2930:	90 93 b2 5e 	sts	0x5EB2, r25	; 0x805eb2 <pxDelayedTaskList+0x1>
    2934:	83 eb       	ldi	r24, 0xB3	; 179
    2936:	9e e5       	ldi	r25, 0x5E	; 94
    2938:	80 93 af 5e 	sts	0x5EAF, r24	; 0x805eaf <pxOverflowDelayedTaskList>
    293c:	90 93 b0 5e 	sts	0x5EB0, r25	; 0x805eb0 <pxOverflowDelayedTaskList+0x1>
    2940:	0f c0       	rjmp	.+30     	; 0x2960 <xTaskGenericCreate+0x180>
    2942:	80 91 a1 5e 	lds	r24, 0x5EA1	; 0x805ea1 <xSchedulerRunning>
    2946:	81 11       	cpse	r24, r1
    2948:	0b c0       	rjmp	.+22     	; 0x2960 <xTaskGenericCreate+0x180>
    294a:	e0 91 f2 5e 	lds	r30, 0x5EF2	; 0x805ef2 <pxCurrentTCB>
    294e:	f0 91 f3 5e 	lds	r31, 0x5EF3	; 0x805ef3 <pxCurrentTCB+0x1>
    2952:	86 89       	ldd	r24, Z+22	; 0x16
    2954:	08 17       	cp	r16, r24
    2956:	20 f0       	brcs	.+8      	; 0x2960 <xTaskGenericCreate+0x180>
    2958:	60 92 f2 5e 	sts	0x5EF2, r6	; 0x805ef2 <pxCurrentTCB>
    295c:	70 92 f3 5e 	sts	0x5EF3, r7	; 0x805ef3 <pxCurrentTCB+0x1>
    2960:	80 91 9d 5e 	lds	r24, 0x5E9D	; 0x805e9d <uxTaskNumber>
    2964:	8f 5f       	subi	r24, 0xFF	; 255
    2966:	80 93 9d 5e 	sts	0x5E9D, r24	; 0x805e9d <uxTaskNumber>
    296a:	f3 01       	movw	r30, r6
    296c:	86 89       	ldd	r24, Z+22	; 0x16
    296e:	90 91 a2 5e 	lds	r25, 0x5EA2	; 0x805ea2 <uxTopReadyPriority>
    2972:	98 17       	cp	r25, r24
    2974:	10 f4       	brcc	.+4      	; 0x297a <xTaskGenericCreate+0x19a>
    2976:	80 93 a2 5e 	sts	0x5EA2, r24	; 0x805ea2 <uxTopReadyPriority>
    297a:	90 e0       	ldi	r25, 0x00	; 0
    297c:	9c 01       	movw	r18, r24
    297e:	22 0f       	add	r18, r18
    2980:	33 1f       	adc	r19, r19
    2982:	22 0f       	add	r18, r18
    2984:	33 1f       	adc	r19, r19
    2986:	22 0f       	add	r18, r18
    2988:	33 1f       	adc	r19, r19
    298a:	82 0f       	add	r24, r18
    298c:	93 1f       	adc	r25, r19
    298e:	be 01       	movw	r22, r28
    2990:	8b 53       	subi	r24, 0x3B	; 59
    2992:	91 4a       	sbci	r25, 0xA1	; 161
    2994:	41 d9       	rcall	.-3454   	; 0x1c18 <vListInsertEnd>
    2996:	0f 90       	pop	r0
    2998:	0f be       	out	0x3f, r0	; 63
    299a:	80 91 a1 5e 	lds	r24, 0x5EA1	; 0x805ea1 <xSchedulerRunning>
    299e:	88 23       	and	r24, r24
    29a0:	51 f0       	breq	.+20     	; 0x29b6 <xTaskGenericCreate+0x1d6>
    29a2:	e0 91 f2 5e 	lds	r30, 0x5EF2	; 0x805ef2 <pxCurrentTCB>
    29a6:	f0 91 f3 5e 	lds	r31, 0x5EF3	; 0x805ef3 <pxCurrentTCB+0x1>
    29aa:	86 89       	ldd	r24, Z+22	; 0x16
    29ac:	80 17       	cp	r24, r16
    29ae:	28 f4       	brcc	.+10     	; 0x29ba <xTaskGenericCreate+0x1da>
    29b0:	67 da       	rcall	.-2866   	; 0x1e80 <vPortYield>
    29b2:	81 e0       	ldi	r24, 0x01	; 1
    29b4:	05 c0       	rjmp	.+10     	; 0x29c0 <xTaskGenericCreate+0x1e0>
    29b6:	81 e0       	ldi	r24, 0x01	; 1
    29b8:	03 c0       	rjmp	.+6      	; 0x29c0 <xTaskGenericCreate+0x1e0>
    29ba:	81 e0       	ldi	r24, 0x01	; 1
    29bc:	01 c0       	rjmp	.+2      	; 0x29c0 <xTaskGenericCreate+0x1e0>
    29be:	8f ef       	ldi	r24, 0xFF	; 255
    29c0:	df 91       	pop	r29
    29c2:	cf 91       	pop	r28
    29c4:	1f 91       	pop	r17
    29c6:	0f 91       	pop	r16
    29c8:	ff 90       	pop	r15
    29ca:	ef 90       	pop	r14
    29cc:	df 90       	pop	r13
    29ce:	cf 90       	pop	r12
    29d0:	bf 90       	pop	r11
    29d2:	af 90       	pop	r10
    29d4:	9f 90       	pop	r9
    29d6:	8f 90       	pop	r8
    29d8:	7f 90       	pop	r7
    29da:	6f 90       	pop	r6
    29dc:	5f 90       	pop	r5
    29de:	4f 90       	pop	r4
    29e0:	08 95       	ret

000029e2 <vTaskStartScheduler>:
    29e2:	af 92       	push	r10
    29e4:	bf 92       	push	r11
    29e6:	cf 92       	push	r12
    29e8:	df 92       	push	r13
    29ea:	ef 92       	push	r14
    29ec:	ff 92       	push	r15
    29ee:	0f 93       	push	r16
    29f0:	a1 2c       	mov	r10, r1
    29f2:	b1 2c       	mov	r11, r1
    29f4:	c1 2c       	mov	r12, r1
    29f6:	d1 2c       	mov	r13, r1
    29f8:	e1 2c       	mov	r14, r1
    29fa:	f1 2c       	mov	r15, r1
    29fc:	00 e0       	ldi	r16, 0x00	; 0
    29fe:	20 e0       	ldi	r18, 0x00	; 0
    2a00:	30 e0       	ldi	r19, 0x00	; 0
    2a02:	45 e5       	ldi	r20, 0x55	; 85
    2a04:	50 e0       	ldi	r21, 0x00	; 0
    2a06:	6e e0       	ldi	r22, 0x0E	; 14
    2a08:	70 e2       	ldi	r23, 0x20	; 32
    2a0a:	84 eb       	ldi	r24, 0xB4	; 180
    2a0c:	93 e1       	ldi	r25, 0x13	; 19
    2a0e:	e8 de       	rcall	.-560    	; 0x27e0 <xTaskGenericCreate>
    2a10:	81 30       	cpi	r24, 0x01	; 1
    2a12:	91 f4       	brne	.+36     	; 0x2a38 <vTaskStartScheduler+0x56>
    2a14:	2a d3       	rcall	.+1620   	; 0x306a <xTimerCreateTimerTask>
    2a16:	81 30       	cpi	r24, 0x01	; 1
    2a18:	79 f4       	brne	.+30     	; 0x2a38 <vTaskStartScheduler+0x56>
    2a1a:	f8 94       	cli
    2a1c:	8f ef       	ldi	r24, 0xFF	; 255
    2a1e:	9f ef       	ldi	r25, 0xFF	; 255
    2a20:	80 93 9b 5e 	sts	0x5E9B, r24	; 0x805e9b <xNextTaskUnblockTime>
    2a24:	90 93 9c 5e 	sts	0x5E9C, r25	; 0x805e9c <xNextTaskUnblockTime+0x1>
    2a28:	81 e0       	ldi	r24, 0x01	; 1
    2a2a:	80 93 a1 5e 	sts	0x5EA1, r24	; 0x805ea1 <xSchedulerRunning>
    2a2e:	10 92 a3 5e 	sts	0x5EA3, r1	; 0x805ea3 <xTickCount>
    2a32:	10 92 a4 5e 	sts	0x5EA4, r1	; 0x805ea4 <xTickCount+0x1>
    2a36:	df d9       	rcall	.-3138   	; 0x1df6 <xPortStartScheduler>
    2a38:	0f 91       	pop	r16
    2a3a:	ff 90       	pop	r15
    2a3c:	ef 90       	pop	r14
    2a3e:	df 90       	pop	r13
    2a40:	cf 90       	pop	r12
    2a42:	bf 90       	pop	r11
    2a44:	af 90       	pop	r10
    2a46:	08 95       	ret

00002a48 <vTaskSuspendAll>:
    2a48:	80 91 9a 5e 	lds	r24, 0x5E9A	; 0x805e9a <uxSchedulerSuspended>
    2a4c:	8f 5f       	subi	r24, 0xFF	; 255
    2a4e:	80 93 9a 5e 	sts	0x5E9A, r24	; 0x805e9a <uxSchedulerSuspended>
    2a52:	08 95       	ret

00002a54 <xTaskGetTickCount>:
    2a54:	0f b6       	in	r0, 0x3f	; 63
    2a56:	f8 94       	cli
    2a58:	0f 92       	push	r0
    2a5a:	80 91 a3 5e 	lds	r24, 0x5EA3	; 0x805ea3 <xTickCount>
    2a5e:	90 91 a4 5e 	lds	r25, 0x5EA4	; 0x805ea4 <xTickCount+0x1>
    2a62:	0f 90       	pop	r0
    2a64:	0f be       	out	0x3f, r0	; 63
    2a66:	08 95       	ret

00002a68 <xTaskIncrementTick>:
    2a68:	df 92       	push	r13
    2a6a:	ef 92       	push	r14
    2a6c:	ff 92       	push	r15
    2a6e:	0f 93       	push	r16
    2a70:	1f 93       	push	r17
    2a72:	cf 93       	push	r28
    2a74:	df 93       	push	r29
    2a76:	80 91 9a 5e 	lds	r24, 0x5E9A	; 0x805e9a <uxSchedulerSuspended>
    2a7a:	81 11       	cpse	r24, r1
    2a7c:	b3 c0       	rjmp	.+358    	; 0x2be4 <xTaskIncrementTick+0x17c>
    2a7e:	80 91 a3 5e 	lds	r24, 0x5EA3	; 0x805ea3 <xTickCount>
    2a82:	90 91 a4 5e 	lds	r25, 0x5EA4	; 0x805ea4 <xTickCount+0x1>
    2a86:	01 96       	adiw	r24, 0x01	; 1
    2a88:	80 93 a3 5e 	sts	0x5EA3, r24	; 0x805ea3 <xTickCount>
    2a8c:	90 93 a4 5e 	sts	0x5EA4, r25	; 0x805ea4 <xTickCount+0x1>
    2a90:	e0 90 a3 5e 	lds	r14, 0x5EA3	; 0x805ea3 <xTickCount>
    2a94:	f0 90 a4 5e 	lds	r15, 0x5EA4	; 0x805ea4 <xTickCount+0x1>
    2a98:	e1 14       	cp	r14, r1
    2a9a:	f1 04       	cpc	r15, r1
    2a9c:	99 f5       	brne	.+102    	; 0x2b04 <xTaskIncrementTick+0x9c>
    2a9e:	80 91 b1 5e 	lds	r24, 0x5EB1	; 0x805eb1 <pxDelayedTaskList>
    2aa2:	90 91 b2 5e 	lds	r25, 0x5EB2	; 0x805eb2 <pxDelayedTaskList+0x1>
    2aa6:	20 91 af 5e 	lds	r18, 0x5EAF	; 0x805eaf <pxOverflowDelayedTaskList>
    2aaa:	30 91 b0 5e 	lds	r19, 0x5EB0	; 0x805eb0 <pxOverflowDelayedTaskList+0x1>
    2aae:	20 93 b1 5e 	sts	0x5EB1, r18	; 0x805eb1 <pxDelayedTaskList>
    2ab2:	30 93 b2 5e 	sts	0x5EB2, r19	; 0x805eb2 <pxDelayedTaskList+0x1>
    2ab6:	80 93 af 5e 	sts	0x5EAF, r24	; 0x805eaf <pxOverflowDelayedTaskList>
    2aba:	90 93 b0 5e 	sts	0x5EB0, r25	; 0x805eb0 <pxOverflowDelayedTaskList+0x1>
    2abe:	80 91 9e 5e 	lds	r24, 0x5E9E	; 0x805e9e <xNumOfOverflows>
    2ac2:	8f 5f       	subi	r24, 0xFF	; 255
    2ac4:	80 93 9e 5e 	sts	0x5E9E, r24	; 0x805e9e <xNumOfOverflows>
    2ac8:	e0 91 b1 5e 	lds	r30, 0x5EB1	; 0x805eb1 <pxDelayedTaskList>
    2acc:	f0 91 b2 5e 	lds	r31, 0x5EB2	; 0x805eb2 <pxDelayedTaskList+0x1>
    2ad0:	80 81       	ld	r24, Z
    2ad2:	81 11       	cpse	r24, r1
    2ad4:	07 c0       	rjmp	.+14     	; 0x2ae4 <xTaskIncrementTick+0x7c>
    2ad6:	8f ef       	ldi	r24, 0xFF	; 255
    2ad8:	9f ef       	ldi	r25, 0xFF	; 255
    2ada:	80 93 9b 5e 	sts	0x5E9B, r24	; 0x805e9b <xNextTaskUnblockTime>
    2ade:	90 93 9c 5e 	sts	0x5E9C, r25	; 0x805e9c <xNextTaskUnblockTime+0x1>
    2ae2:	10 c0       	rjmp	.+32     	; 0x2b04 <xTaskIncrementTick+0x9c>
    2ae4:	e0 91 b1 5e 	lds	r30, 0x5EB1	; 0x805eb1 <pxDelayedTaskList>
    2ae8:	f0 91 b2 5e 	lds	r31, 0x5EB2	; 0x805eb2 <pxDelayedTaskList+0x1>
    2aec:	05 80       	ldd	r0, Z+5	; 0x05
    2aee:	f6 81       	ldd	r31, Z+6	; 0x06
    2af0:	e0 2d       	mov	r30, r0
    2af2:	06 80       	ldd	r0, Z+6	; 0x06
    2af4:	f7 81       	ldd	r31, Z+7	; 0x07
    2af6:	e0 2d       	mov	r30, r0
    2af8:	82 81       	ldd	r24, Z+2	; 0x02
    2afa:	93 81       	ldd	r25, Z+3	; 0x03
    2afc:	80 93 9b 5e 	sts	0x5E9B, r24	; 0x805e9b <xNextTaskUnblockTime>
    2b00:	90 93 9c 5e 	sts	0x5E9C, r25	; 0x805e9c <xNextTaskUnblockTime+0x1>
    2b04:	80 91 9b 5e 	lds	r24, 0x5E9B	; 0x805e9b <xNextTaskUnblockTime>
    2b08:	90 91 9c 5e 	lds	r25, 0x5E9C	; 0x805e9c <xNextTaskUnblockTime+0x1>
    2b0c:	e8 16       	cp	r14, r24
    2b0e:	f9 06       	cpc	r15, r25
    2b10:	10 f4       	brcc	.+4      	; 0x2b16 <xTaskIncrementTick+0xae>
    2b12:	d1 2c       	mov	r13, r1
    2b14:	4f c0       	rjmp	.+158    	; 0x2bb4 <xTaskIncrementTick+0x14c>
    2b16:	d1 2c       	mov	r13, r1
    2b18:	e0 91 b1 5e 	lds	r30, 0x5EB1	; 0x805eb1 <pxDelayedTaskList>
    2b1c:	f0 91 b2 5e 	lds	r31, 0x5EB2	; 0x805eb2 <pxDelayedTaskList+0x1>
    2b20:	90 81       	ld	r25, Z
    2b22:	91 11       	cpse	r25, r1
    2b24:	07 c0       	rjmp	.+14     	; 0x2b34 <xTaskIncrementTick+0xcc>
    2b26:	8f ef       	ldi	r24, 0xFF	; 255
    2b28:	9f ef       	ldi	r25, 0xFF	; 255
    2b2a:	80 93 9b 5e 	sts	0x5E9B, r24	; 0x805e9b <xNextTaskUnblockTime>
    2b2e:	90 93 9c 5e 	sts	0x5E9C, r25	; 0x805e9c <xNextTaskUnblockTime+0x1>
    2b32:	40 c0       	rjmp	.+128    	; 0x2bb4 <xTaskIncrementTick+0x14c>
    2b34:	e0 91 b1 5e 	lds	r30, 0x5EB1	; 0x805eb1 <pxDelayedTaskList>
    2b38:	f0 91 b2 5e 	lds	r31, 0x5EB2	; 0x805eb2 <pxDelayedTaskList+0x1>
    2b3c:	05 80       	ldd	r0, Z+5	; 0x05
    2b3e:	f6 81       	ldd	r31, Z+6	; 0x06
    2b40:	e0 2d       	mov	r30, r0
    2b42:	c6 81       	ldd	r28, Z+6	; 0x06
    2b44:	d7 81       	ldd	r29, Z+7	; 0x07
    2b46:	2a 81       	ldd	r18, Y+2	; 0x02
    2b48:	3b 81       	ldd	r19, Y+3	; 0x03
    2b4a:	e2 16       	cp	r14, r18
    2b4c:	f3 06       	cpc	r15, r19
    2b4e:	28 f4       	brcc	.+10     	; 0x2b5a <xTaskIncrementTick+0xf2>
    2b50:	20 93 9b 5e 	sts	0x5E9B, r18	; 0x805e9b <xNextTaskUnblockTime>
    2b54:	30 93 9c 5e 	sts	0x5E9C, r19	; 0x805e9c <xNextTaskUnblockTime+0x1>
    2b58:	2d c0       	rjmp	.+90     	; 0x2bb4 <xTaskIncrementTick+0x14c>
    2b5a:	8e 01       	movw	r16, r28
    2b5c:	0e 5f       	subi	r16, 0xFE	; 254
    2b5e:	1f 4f       	sbci	r17, 0xFF	; 255
    2b60:	c8 01       	movw	r24, r16
    2b62:	ac d8       	rcall	.-3752   	; 0x1cbc <uxListRemove>
    2b64:	8c 89       	ldd	r24, Y+20	; 0x14
    2b66:	9d 89       	ldd	r25, Y+21	; 0x15
    2b68:	89 2b       	or	r24, r25
    2b6a:	19 f0       	breq	.+6      	; 0x2b72 <xTaskIncrementTick+0x10a>
    2b6c:	ce 01       	movw	r24, r28
    2b6e:	0c 96       	adiw	r24, 0x0c	; 12
    2b70:	a5 d8       	rcall	.-3766   	; 0x1cbc <uxListRemove>
    2b72:	2e 89       	ldd	r18, Y+22	; 0x16
    2b74:	80 91 a2 5e 	lds	r24, 0x5EA2	; 0x805ea2 <uxTopReadyPriority>
    2b78:	82 17       	cp	r24, r18
    2b7a:	10 f4       	brcc	.+4      	; 0x2b80 <xTaskIncrementTick+0x118>
    2b7c:	20 93 a2 5e 	sts	0x5EA2, r18	; 0x805ea2 <uxTopReadyPriority>
    2b80:	30 e0       	ldi	r19, 0x00	; 0
    2b82:	c9 01       	movw	r24, r18
    2b84:	88 0f       	add	r24, r24
    2b86:	99 1f       	adc	r25, r25
    2b88:	88 0f       	add	r24, r24
    2b8a:	99 1f       	adc	r25, r25
    2b8c:	88 0f       	add	r24, r24
    2b8e:	99 1f       	adc	r25, r25
    2b90:	82 0f       	add	r24, r18
    2b92:	93 1f       	adc	r25, r19
    2b94:	b8 01       	movw	r22, r16
    2b96:	8b 53       	subi	r24, 0x3B	; 59
    2b98:	91 4a       	sbci	r25, 0xA1	; 161
    2b9a:	3e d8       	rcall	.-3972   	; 0x1c18 <vListInsertEnd>
    2b9c:	e0 91 f2 5e 	lds	r30, 0x5EF2	; 0x805ef2 <pxCurrentTCB>
    2ba0:	f0 91 f3 5e 	lds	r31, 0x5EF3	; 0x805ef3 <pxCurrentTCB+0x1>
    2ba4:	9e 89       	ldd	r25, Y+22	; 0x16
    2ba6:	86 89       	ldd	r24, Z+22	; 0x16
    2ba8:	98 17       	cp	r25, r24
    2baa:	08 f4       	brcc	.+2      	; 0x2bae <xTaskIncrementTick+0x146>
    2bac:	b5 cf       	rjmp	.-150    	; 0x2b18 <xTaskIncrementTick+0xb0>
    2bae:	dd 24       	eor	r13, r13
    2bb0:	d3 94       	inc	r13
    2bb2:	b2 cf       	rjmp	.-156    	; 0x2b18 <xTaskIncrementTick+0xb0>
    2bb4:	e0 91 f2 5e 	lds	r30, 0x5EF2	; 0x805ef2 <pxCurrentTCB>
    2bb8:	f0 91 f3 5e 	lds	r31, 0x5EF3	; 0x805ef3 <pxCurrentTCB+0x1>
    2bbc:	86 89       	ldd	r24, Z+22	; 0x16
    2bbe:	90 e0       	ldi	r25, 0x00	; 0
    2bc0:	fc 01       	movw	r30, r24
    2bc2:	ee 0f       	add	r30, r30
    2bc4:	ff 1f       	adc	r31, r31
    2bc6:	ee 0f       	add	r30, r30
    2bc8:	ff 1f       	adc	r31, r31
    2bca:	ee 0f       	add	r30, r30
    2bcc:	ff 1f       	adc	r31, r31
    2bce:	8e 0f       	add	r24, r30
    2bd0:	9f 1f       	adc	r25, r31
    2bd2:	fc 01       	movw	r30, r24
    2bd4:	eb 53       	subi	r30, 0x3B	; 59
    2bd6:	f1 4a       	sbci	r31, 0xA1	; 161
    2bd8:	80 81       	ld	r24, Z
    2bda:	82 30       	cpi	r24, 0x02	; 2
    2bdc:	48 f0       	brcs	.+18     	; 0x2bf0 <xTaskIncrementTick+0x188>
    2bde:	dd 24       	eor	r13, r13
    2be0:	d3 94       	inc	r13
    2be2:	06 c0       	rjmp	.+12     	; 0x2bf0 <xTaskIncrementTick+0x188>
    2be4:	80 91 a0 5e 	lds	r24, 0x5EA0	; 0x805ea0 <uxPendedTicks>
    2be8:	8f 5f       	subi	r24, 0xFF	; 255
    2bea:	80 93 a0 5e 	sts	0x5EA0, r24	; 0x805ea0 <uxPendedTicks>
    2bee:	d1 2c       	mov	r13, r1
    2bf0:	80 91 9f 5e 	lds	r24, 0x5E9F	; 0x805e9f <xYieldPending>
    2bf4:	88 23       	and	r24, r24
    2bf6:	11 f0       	breq	.+4      	; 0x2bfc <xTaskIncrementTick+0x194>
    2bf8:	dd 24       	eor	r13, r13
    2bfa:	d3 94       	inc	r13
    2bfc:	8d 2d       	mov	r24, r13
    2bfe:	df 91       	pop	r29
    2c00:	cf 91       	pop	r28
    2c02:	1f 91       	pop	r17
    2c04:	0f 91       	pop	r16
    2c06:	ff 90       	pop	r15
    2c08:	ef 90       	pop	r14
    2c0a:	df 90       	pop	r13
    2c0c:	08 95       	ret

00002c0e <xTaskResumeAll>:
    2c0e:	df 92       	push	r13
    2c10:	ef 92       	push	r14
    2c12:	ff 92       	push	r15
    2c14:	0f 93       	push	r16
    2c16:	1f 93       	push	r17
    2c18:	cf 93       	push	r28
    2c1a:	df 93       	push	r29
    2c1c:	0f b6       	in	r0, 0x3f	; 63
    2c1e:	f8 94       	cli
    2c20:	0f 92       	push	r0
    2c22:	80 91 9a 5e 	lds	r24, 0x5E9A	; 0x805e9a <uxSchedulerSuspended>
    2c26:	81 50       	subi	r24, 0x01	; 1
    2c28:	80 93 9a 5e 	sts	0x5E9A, r24	; 0x805e9a <uxSchedulerSuspended>
    2c2c:	80 91 9a 5e 	lds	r24, 0x5E9A	; 0x805e9a <uxSchedulerSuspended>
    2c30:	81 11       	cpse	r24, r1
    2c32:	5e c0       	rjmp	.+188    	; 0x2cf0 <xTaskResumeAll+0xe2>
    2c34:	80 91 a5 5e 	lds	r24, 0x5EA5	; 0x805ea5 <uxCurrentNumberOfTasks>
    2c38:	81 11       	cpse	r24, r1
    2c3a:	31 c0       	rjmp	.+98     	; 0x2c9e <xTaskResumeAll+0x90>
    2c3c:	5c c0       	rjmp	.+184    	; 0x2cf6 <xTaskResumeAll+0xe8>
    2c3e:	d7 01       	movw	r26, r14
    2c40:	15 96       	adiw	r26, 0x05	; 5
    2c42:	ed 91       	ld	r30, X+
    2c44:	fc 91       	ld	r31, X
    2c46:	16 97       	sbiw	r26, 0x06	; 6
    2c48:	c6 81       	ldd	r28, Z+6	; 0x06
    2c4a:	d7 81       	ldd	r29, Z+7	; 0x07
    2c4c:	ce 01       	movw	r24, r28
    2c4e:	0c 96       	adiw	r24, 0x0c	; 12
    2c50:	35 d8       	rcall	.-3990   	; 0x1cbc <uxListRemove>
    2c52:	8e 01       	movw	r16, r28
    2c54:	0e 5f       	subi	r16, 0xFE	; 254
    2c56:	1f 4f       	sbci	r17, 0xFF	; 255
    2c58:	c8 01       	movw	r24, r16
    2c5a:	30 d8       	rcall	.-4000   	; 0x1cbc <uxListRemove>
    2c5c:	2e 89       	ldd	r18, Y+22	; 0x16
    2c5e:	80 91 a2 5e 	lds	r24, 0x5EA2	; 0x805ea2 <uxTopReadyPriority>
    2c62:	82 17       	cp	r24, r18
    2c64:	10 f4       	brcc	.+4      	; 0x2c6a <xTaskResumeAll+0x5c>
    2c66:	20 93 a2 5e 	sts	0x5EA2, r18	; 0x805ea2 <uxTopReadyPriority>
    2c6a:	30 e0       	ldi	r19, 0x00	; 0
    2c6c:	c9 01       	movw	r24, r18
    2c6e:	88 0f       	add	r24, r24
    2c70:	99 1f       	adc	r25, r25
    2c72:	88 0f       	add	r24, r24
    2c74:	99 1f       	adc	r25, r25
    2c76:	88 0f       	add	r24, r24
    2c78:	99 1f       	adc	r25, r25
    2c7a:	82 0f       	add	r24, r18
    2c7c:	93 1f       	adc	r25, r19
    2c7e:	b8 01       	movw	r22, r16
    2c80:	8b 53       	subi	r24, 0x3B	; 59
    2c82:	91 4a       	sbci	r25, 0xA1	; 161
    2c84:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <vListInsertEnd>
    2c88:	e0 91 f2 5e 	lds	r30, 0x5EF2	; 0x805ef2 <pxCurrentTCB>
    2c8c:	f0 91 f3 5e 	lds	r31, 0x5EF3	; 0x805ef3 <pxCurrentTCB+0x1>
    2c90:	9e 89       	ldd	r25, Y+22	; 0x16
    2c92:	86 89       	ldd	r24, Z+22	; 0x16
    2c94:	98 17       	cp	r25, r24
    2c96:	58 f0       	brcs	.+22     	; 0x2cae <xTaskResumeAll+0xa0>
    2c98:	d0 92 9f 5e 	sts	0x5E9F, r13	; 0x805e9f <xYieldPending>
    2c9c:	08 c0       	rjmp	.+16     	; 0x2cae <xTaskResumeAll+0xa0>
    2c9e:	0f 2e       	mov	r0, r31
    2ca0:	f6 ea       	ldi	r31, 0xA6	; 166
    2ca2:	ef 2e       	mov	r14, r31
    2ca4:	fe e5       	ldi	r31, 0x5E	; 94
    2ca6:	ff 2e       	mov	r15, r31
    2ca8:	f0 2d       	mov	r31, r0
    2caa:	dd 24       	eor	r13, r13
    2cac:	d3 94       	inc	r13
    2cae:	f7 01       	movw	r30, r14
    2cb0:	80 81       	ld	r24, Z
    2cb2:	81 11       	cpse	r24, r1
    2cb4:	c4 cf       	rjmp	.-120    	; 0x2c3e <xTaskResumeAll+0x30>
    2cb6:	80 91 a0 5e 	lds	r24, 0x5EA0	; 0x805ea0 <uxPendedTicks>
    2cba:	88 23       	and	r24, r24
    2cbc:	91 f0       	breq	.+36     	; 0x2ce2 <xTaskResumeAll+0xd4>
    2cbe:	80 91 a0 5e 	lds	r24, 0x5EA0	; 0x805ea0 <uxPendedTicks>
    2cc2:	88 23       	and	r24, r24
    2cc4:	71 f0       	breq	.+28     	; 0x2ce2 <xTaskResumeAll+0xd4>
    2cc6:	c1 e0       	ldi	r28, 0x01	; 1
    2cc8:	cf de       	rcall	.-610    	; 0x2a68 <xTaskIncrementTick>
    2cca:	81 11       	cpse	r24, r1
    2ccc:	c0 93 9f 5e 	sts	0x5E9F, r28	; 0x805e9f <xYieldPending>
    2cd0:	80 91 a0 5e 	lds	r24, 0x5EA0	; 0x805ea0 <uxPendedTicks>
    2cd4:	81 50       	subi	r24, 0x01	; 1
    2cd6:	80 93 a0 5e 	sts	0x5EA0, r24	; 0x805ea0 <uxPendedTicks>
    2cda:	80 91 a0 5e 	lds	r24, 0x5EA0	; 0x805ea0 <uxPendedTicks>
    2cde:	81 11       	cpse	r24, r1
    2ce0:	f3 cf       	rjmp	.-26     	; 0x2cc8 <xTaskResumeAll+0xba>
    2ce2:	80 91 9f 5e 	lds	r24, 0x5E9F	; 0x805e9f <xYieldPending>
    2ce6:	81 30       	cpi	r24, 0x01	; 1
    2ce8:	29 f4       	brne	.+10     	; 0x2cf4 <xTaskResumeAll+0xe6>
    2cea:	ca d8       	rcall	.-3692   	; 0x1e80 <vPortYield>
    2cec:	81 e0       	ldi	r24, 0x01	; 1
    2cee:	03 c0       	rjmp	.+6      	; 0x2cf6 <xTaskResumeAll+0xe8>
    2cf0:	80 e0       	ldi	r24, 0x00	; 0
    2cf2:	01 c0       	rjmp	.+2      	; 0x2cf6 <xTaskResumeAll+0xe8>
    2cf4:	80 e0       	ldi	r24, 0x00	; 0
    2cf6:	0f 90       	pop	r0
    2cf8:	0f be       	out	0x3f, r0	; 63
    2cfa:	df 91       	pop	r29
    2cfc:	cf 91       	pop	r28
    2cfe:	1f 91       	pop	r17
    2d00:	0f 91       	pop	r16
    2d02:	ff 90       	pop	r15
    2d04:	ef 90       	pop	r14
    2d06:	df 90       	pop	r13
    2d08:	08 95       	ret

00002d0a <vTaskDelay>:
    2d0a:	cf 93       	push	r28
    2d0c:	df 93       	push	r29
    2d0e:	ec 01       	movw	r28, r24
    2d10:	89 2b       	or	r24, r25
    2d12:	99 f0       	breq	.+38     	; 0x2d3a <vTaskDelay+0x30>
    2d14:	99 de       	rcall	.-718    	; 0x2a48 <vTaskSuspendAll>
    2d16:	80 91 a3 5e 	lds	r24, 0x5EA3	; 0x805ea3 <xTickCount>
    2d1a:	90 91 a4 5e 	lds	r25, 0x5EA4	; 0x805ea4 <xTickCount+0x1>
    2d1e:	c8 0f       	add	r28, r24
    2d20:	d9 1f       	adc	r29, r25
    2d22:	80 91 f2 5e 	lds	r24, 0x5EF2	; 0x805ef2 <pxCurrentTCB>
    2d26:	90 91 f3 5e 	lds	r25, 0x5EF3	; 0x805ef3 <pxCurrentTCB+0x1>
    2d2a:	02 96       	adiw	r24, 0x02	; 2
    2d2c:	0e 94 5e 0e 	call	0x1cbc	; 0x1cbc <uxListRemove>
    2d30:	ce 01       	movw	r24, r28
    2d32:	21 dd       	rcall	.-1470   	; 0x2776 <prvAddCurrentTaskToDelayedList>
    2d34:	6c df       	rcall	.-296    	; 0x2c0e <xTaskResumeAll>
    2d36:	81 11       	cpse	r24, r1
    2d38:	01 c0       	rjmp	.+2      	; 0x2d3c <vTaskDelay+0x32>
    2d3a:	a2 d8       	rcall	.-3772   	; 0x1e80 <vPortYield>
    2d3c:	df 91       	pop	r29
    2d3e:	cf 91       	pop	r28
    2d40:	08 95       	ret

00002d42 <vTaskSwitchContext>:
    2d42:	80 91 9a 5e 	lds	r24, 0x5E9A	; 0x805e9a <uxSchedulerSuspended>
    2d46:	88 23       	and	r24, r24
    2d48:	21 f0       	breq	.+8      	; 0x2d52 <vTaskSwitchContext+0x10>
    2d4a:	81 e0       	ldi	r24, 0x01	; 1
    2d4c:	80 93 9f 5e 	sts	0x5E9F, r24	; 0x805e9f <xYieldPending>
    2d50:	08 95       	ret
    2d52:	10 92 9f 5e 	sts	0x5E9F, r1	; 0x805e9f <xYieldPending>
    2d56:	80 91 a2 5e 	lds	r24, 0x5EA2	; 0x805ea2 <uxTopReadyPriority>
    2d5a:	90 e0       	ldi	r25, 0x00	; 0
    2d5c:	fc 01       	movw	r30, r24
    2d5e:	ee 0f       	add	r30, r30
    2d60:	ff 1f       	adc	r31, r31
    2d62:	ee 0f       	add	r30, r30
    2d64:	ff 1f       	adc	r31, r31
    2d66:	ee 0f       	add	r30, r30
    2d68:	ff 1f       	adc	r31, r31
    2d6a:	8e 0f       	add	r24, r30
    2d6c:	9f 1f       	adc	r25, r31
    2d6e:	fc 01       	movw	r30, r24
    2d70:	eb 53       	subi	r30, 0x3B	; 59
    2d72:	f1 4a       	sbci	r31, 0xA1	; 161
    2d74:	80 81       	ld	r24, Z
    2d76:	81 11       	cpse	r24, r1
    2d78:	17 c0       	rjmp	.+46     	; 0x2da8 <vTaskSwitchContext+0x66>
    2d7a:	80 91 a2 5e 	lds	r24, 0x5EA2	; 0x805ea2 <uxTopReadyPriority>
    2d7e:	81 50       	subi	r24, 0x01	; 1
    2d80:	80 93 a2 5e 	sts	0x5EA2, r24	; 0x805ea2 <uxTopReadyPriority>
    2d84:	80 91 a2 5e 	lds	r24, 0x5EA2	; 0x805ea2 <uxTopReadyPriority>
    2d88:	90 e0       	ldi	r25, 0x00	; 0
    2d8a:	fc 01       	movw	r30, r24
    2d8c:	ee 0f       	add	r30, r30
    2d8e:	ff 1f       	adc	r31, r31
    2d90:	ee 0f       	add	r30, r30
    2d92:	ff 1f       	adc	r31, r31
    2d94:	ee 0f       	add	r30, r30
    2d96:	ff 1f       	adc	r31, r31
    2d98:	8e 0f       	add	r24, r30
    2d9a:	9f 1f       	adc	r25, r31
    2d9c:	fc 01       	movw	r30, r24
    2d9e:	eb 53       	subi	r30, 0x3B	; 59
    2da0:	f1 4a       	sbci	r31, 0xA1	; 161
    2da2:	80 81       	ld	r24, Z
    2da4:	88 23       	and	r24, r24
    2da6:	49 f3       	breq	.-46     	; 0x2d7a <vTaskSwitchContext+0x38>
    2da8:	80 91 a2 5e 	lds	r24, 0x5EA2	; 0x805ea2 <uxTopReadyPriority>
    2dac:	90 e0       	ldi	r25, 0x00	; 0
    2dae:	9c 01       	movw	r18, r24
    2db0:	22 0f       	add	r18, r18
    2db2:	33 1f       	adc	r19, r19
    2db4:	22 0f       	add	r18, r18
    2db6:	33 1f       	adc	r19, r19
    2db8:	22 0f       	add	r18, r18
    2dba:	33 1f       	adc	r19, r19
    2dbc:	28 0f       	add	r18, r24
    2dbe:	39 1f       	adc	r19, r25
    2dc0:	d9 01       	movw	r26, r18
    2dc2:	ab 53       	subi	r26, 0x3B	; 59
    2dc4:	b1 4a       	sbci	r27, 0xA1	; 161
    2dc6:	11 96       	adiw	r26, 0x01	; 1
    2dc8:	ed 91       	ld	r30, X+
    2dca:	fc 91       	ld	r31, X
    2dcc:	12 97       	sbiw	r26, 0x02	; 2
    2dce:	02 80       	ldd	r0, Z+2	; 0x02
    2dd0:	f3 81       	ldd	r31, Z+3	; 0x03
    2dd2:	e0 2d       	mov	r30, r0
    2dd4:	11 96       	adiw	r26, 0x01	; 1
    2dd6:	ed 93       	st	X+, r30
    2dd8:	fc 93       	st	X, r31
    2dda:	12 97       	sbiw	r26, 0x02	; 2
    2ddc:	28 53       	subi	r18, 0x38	; 56
    2dde:	31 4a       	sbci	r19, 0xA1	; 161
    2de0:	e2 17       	cp	r30, r18
    2de2:	f3 07       	cpc	r31, r19
    2de4:	29 f4       	brne	.+10     	; 0x2df0 <vTaskSwitchContext+0xae>
    2de6:	22 81       	ldd	r18, Z+2	; 0x02
    2de8:	33 81       	ldd	r19, Z+3	; 0x03
    2dea:	fd 01       	movw	r30, r26
    2dec:	21 83       	std	Z+1, r18	; 0x01
    2dee:	32 83       	std	Z+2, r19	; 0x02
    2df0:	fc 01       	movw	r30, r24
    2df2:	ee 0f       	add	r30, r30
    2df4:	ff 1f       	adc	r31, r31
    2df6:	ee 0f       	add	r30, r30
    2df8:	ff 1f       	adc	r31, r31
    2dfa:	ee 0f       	add	r30, r30
    2dfc:	ff 1f       	adc	r31, r31
    2dfe:	8e 0f       	add	r24, r30
    2e00:	9f 1f       	adc	r25, r31
    2e02:	fc 01       	movw	r30, r24
    2e04:	eb 53       	subi	r30, 0x3B	; 59
    2e06:	f1 4a       	sbci	r31, 0xA1	; 161
    2e08:	01 80       	ldd	r0, Z+1	; 0x01
    2e0a:	f2 81       	ldd	r31, Z+2	; 0x02
    2e0c:	e0 2d       	mov	r30, r0
    2e0e:	86 81       	ldd	r24, Z+6	; 0x06
    2e10:	97 81       	ldd	r25, Z+7	; 0x07
    2e12:	80 93 f2 5e 	sts	0x5EF2, r24	; 0x805ef2 <pxCurrentTCB>
    2e16:	90 93 f3 5e 	sts	0x5EF3, r25	; 0x805ef3 <pxCurrentTCB+0x1>
    2e1a:	08 95       	ret

00002e1c <vTaskPlaceOnEventList>:
    2e1c:	cf 93       	push	r28
    2e1e:	df 93       	push	r29
    2e20:	eb 01       	movw	r28, r22
    2e22:	20 91 f2 5e 	lds	r18, 0x5EF2	; 0x805ef2 <pxCurrentTCB>
    2e26:	30 91 f3 5e 	lds	r19, 0x5EF3	; 0x805ef3 <pxCurrentTCB+0x1>
    2e2a:	b9 01       	movw	r22, r18
    2e2c:	64 5f       	subi	r22, 0xF4	; 244
    2e2e:	7f 4f       	sbci	r23, 0xFF	; 255
    2e30:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <vListInsert>
    2e34:	80 91 f2 5e 	lds	r24, 0x5EF2	; 0x805ef2 <pxCurrentTCB>
    2e38:	90 91 f3 5e 	lds	r25, 0x5EF3	; 0x805ef3 <pxCurrentTCB+0x1>
    2e3c:	02 96       	adiw	r24, 0x02	; 2
    2e3e:	0e 94 5e 0e 	call	0x1cbc	; 0x1cbc <uxListRemove>
    2e42:	80 91 a3 5e 	lds	r24, 0x5EA3	; 0x805ea3 <xTickCount>
    2e46:	90 91 a4 5e 	lds	r25, 0x5EA4	; 0x805ea4 <xTickCount+0x1>
    2e4a:	8c 0f       	add	r24, r28
    2e4c:	9d 1f       	adc	r25, r29
    2e4e:	93 dc       	rcall	.-1754   	; 0x2776 <prvAddCurrentTaskToDelayedList>
    2e50:	df 91       	pop	r29
    2e52:	cf 91       	pop	r28
    2e54:	08 95       	ret

00002e56 <vTaskPlaceOnEventListRestricted>:
    2e56:	cf 93       	push	r28
    2e58:	df 93       	push	r29
    2e5a:	eb 01       	movw	r28, r22
    2e5c:	20 91 f2 5e 	lds	r18, 0x5EF2	; 0x805ef2 <pxCurrentTCB>
    2e60:	30 91 f3 5e 	lds	r19, 0x5EF3	; 0x805ef3 <pxCurrentTCB+0x1>
    2e64:	b9 01       	movw	r22, r18
    2e66:	64 5f       	subi	r22, 0xF4	; 244
    2e68:	7f 4f       	sbci	r23, 0xFF	; 255
    2e6a:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <vListInsertEnd>
    2e6e:	80 91 f2 5e 	lds	r24, 0x5EF2	; 0x805ef2 <pxCurrentTCB>
    2e72:	90 91 f3 5e 	lds	r25, 0x5EF3	; 0x805ef3 <pxCurrentTCB+0x1>
    2e76:	02 96       	adiw	r24, 0x02	; 2
    2e78:	0e 94 5e 0e 	call	0x1cbc	; 0x1cbc <uxListRemove>
    2e7c:	80 91 a3 5e 	lds	r24, 0x5EA3	; 0x805ea3 <xTickCount>
    2e80:	90 91 a4 5e 	lds	r25, 0x5EA4	; 0x805ea4 <xTickCount+0x1>
    2e84:	8c 0f       	add	r24, r28
    2e86:	9d 1f       	adc	r25, r29
    2e88:	76 dc       	rcall	.-1812   	; 0x2776 <prvAddCurrentTaskToDelayedList>
    2e8a:	df 91       	pop	r29
    2e8c:	cf 91       	pop	r28
    2e8e:	08 95       	ret

00002e90 <xTaskRemoveFromEventList>:
    2e90:	0f 93       	push	r16
    2e92:	1f 93       	push	r17
    2e94:	cf 93       	push	r28
    2e96:	df 93       	push	r29
    2e98:	dc 01       	movw	r26, r24
    2e9a:	15 96       	adiw	r26, 0x05	; 5
    2e9c:	ed 91       	ld	r30, X+
    2e9e:	fc 91       	ld	r31, X
    2ea0:	16 97       	sbiw	r26, 0x06	; 6
    2ea2:	c6 81       	ldd	r28, Z+6	; 0x06
    2ea4:	d7 81       	ldd	r29, Z+7	; 0x07
    2ea6:	8e 01       	movw	r16, r28
    2ea8:	04 5f       	subi	r16, 0xF4	; 244
    2eaa:	1f 4f       	sbci	r17, 0xFF	; 255
    2eac:	c8 01       	movw	r24, r16
    2eae:	0e 94 5e 0e 	call	0x1cbc	; 0x1cbc <uxListRemove>
    2eb2:	80 91 9a 5e 	lds	r24, 0x5E9A	; 0x805e9a <uxSchedulerSuspended>
    2eb6:	81 11       	cpse	r24, r1
    2eb8:	1c c0       	rjmp	.+56     	; 0x2ef2 <xTaskRemoveFromEventList+0x62>
    2eba:	0a 50       	subi	r16, 0x0A	; 10
    2ebc:	11 09       	sbc	r17, r1
    2ebe:	c8 01       	movw	r24, r16
    2ec0:	0e 94 5e 0e 	call	0x1cbc	; 0x1cbc <uxListRemove>
    2ec4:	2e 89       	ldd	r18, Y+22	; 0x16
    2ec6:	80 91 a2 5e 	lds	r24, 0x5EA2	; 0x805ea2 <uxTopReadyPriority>
    2eca:	82 17       	cp	r24, r18
    2ecc:	10 f4       	brcc	.+4      	; 0x2ed2 <xTaskRemoveFromEventList+0x42>
    2ece:	20 93 a2 5e 	sts	0x5EA2, r18	; 0x805ea2 <uxTopReadyPriority>
    2ed2:	30 e0       	ldi	r19, 0x00	; 0
    2ed4:	c9 01       	movw	r24, r18
    2ed6:	88 0f       	add	r24, r24
    2ed8:	99 1f       	adc	r25, r25
    2eda:	88 0f       	add	r24, r24
    2edc:	99 1f       	adc	r25, r25
    2ede:	88 0f       	add	r24, r24
    2ee0:	99 1f       	adc	r25, r25
    2ee2:	82 0f       	add	r24, r18
    2ee4:	93 1f       	adc	r25, r19
    2ee6:	b8 01       	movw	r22, r16
    2ee8:	8b 53       	subi	r24, 0x3B	; 59
    2eea:	91 4a       	sbci	r25, 0xA1	; 161
    2eec:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <vListInsertEnd>
    2ef0:	05 c0       	rjmp	.+10     	; 0x2efc <xTaskRemoveFromEventList+0x6c>
    2ef2:	b8 01       	movw	r22, r16
    2ef4:	86 ea       	ldi	r24, 0xA6	; 166
    2ef6:	9e e5       	ldi	r25, 0x5E	; 94
    2ef8:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <vListInsertEnd>
    2efc:	e0 91 f2 5e 	lds	r30, 0x5EF2	; 0x805ef2 <pxCurrentTCB>
    2f00:	f0 91 f3 5e 	lds	r31, 0x5EF3	; 0x805ef3 <pxCurrentTCB+0x1>
    2f04:	9e 89       	ldd	r25, Y+22	; 0x16
    2f06:	86 89       	ldd	r24, Z+22	; 0x16
    2f08:	89 17       	cp	r24, r25
    2f0a:	20 f4       	brcc	.+8      	; 0x2f14 <xTaskRemoveFromEventList+0x84>
    2f0c:	81 e0       	ldi	r24, 0x01	; 1
    2f0e:	80 93 9f 5e 	sts	0x5E9F, r24	; 0x805e9f <xYieldPending>
    2f12:	01 c0       	rjmp	.+2      	; 0x2f16 <xTaskRemoveFromEventList+0x86>
    2f14:	80 e0       	ldi	r24, 0x00	; 0
    2f16:	df 91       	pop	r29
    2f18:	cf 91       	pop	r28
    2f1a:	1f 91       	pop	r17
    2f1c:	0f 91       	pop	r16
    2f1e:	08 95       	ret

00002f20 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2f20:	20 91 9e 5e 	lds	r18, 0x5E9E	; 0x805e9e <xNumOfOverflows>
    2f24:	fc 01       	movw	r30, r24
    2f26:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2f28:	20 91 a3 5e 	lds	r18, 0x5EA3	; 0x805ea3 <xTickCount>
    2f2c:	30 91 a4 5e 	lds	r19, 0x5EA4	; 0x805ea4 <xTickCount+0x1>
    2f30:	21 83       	std	Z+1, r18	; 0x01
    2f32:	32 83       	std	Z+2, r19	; 0x02
    2f34:	08 95       	ret

00002f36 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    2f36:	cf 93       	push	r28
    2f38:	df 93       	push	r29
    2f3a:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2f3c:	0f b6       	in	r0, 0x3f	; 63
    2f3e:	f8 94       	cli
    2f40:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    2f42:	20 91 a3 5e 	lds	r18, 0x5EA3	; 0x805ea3 <xTickCount>
    2f46:	30 91 a4 5e 	lds	r19, 0x5EA4	; 0x805ea4 <xTickCount+0x1>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    2f4a:	80 91 9e 5e 	lds	r24, 0x5E9E	; 0x805e9e <xNumOfOverflows>
    2f4e:	90 81       	ld	r25, Z
    2f50:	98 17       	cp	r25, r24
    2f52:	29 f0       	breq	.+10     	; 0x2f5e <xTaskCheckForTimeOut+0x28>
    2f54:	81 81       	ldd	r24, Z+1	; 0x01
    2f56:	92 81       	ldd	r25, Z+2	; 0x02
    2f58:	28 17       	cp	r18, r24
    2f5a:	39 07       	cpc	r19, r25
    2f5c:	a8 f4       	brcc	.+42     	; 0x2f88 <xTaskCheckForTimeOut+0x52>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    2f5e:	a1 81       	ldd	r26, Z+1	; 0x01
    2f60:	b2 81       	ldd	r27, Z+2	; 0x02
    2f62:	eb 01       	movw	r28, r22
    2f64:	48 81       	ld	r20, Y
    2f66:	59 81       	ldd	r21, Y+1	; 0x01
    2f68:	c9 01       	movw	r24, r18
    2f6a:	8a 1b       	sub	r24, r26
    2f6c:	9b 0b       	sbc	r25, r27
    2f6e:	84 17       	cp	r24, r20
    2f70:	95 07       	cpc	r25, r21
    2f72:	60 f4       	brcc	.+24     	; 0x2f8c <xTaskCheckForTimeOut+0x56>
    2f74:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    2f76:	a2 1b       	sub	r26, r18
    2f78:	b3 0b       	sbc	r27, r19
    2f7a:	4a 0f       	add	r20, r26
    2f7c:	5b 1f       	adc	r21, r27
    2f7e:	48 83       	st	Y, r20
    2f80:	59 83       	std	Y+1, r21	; 0x01
			vTaskSetTimeOutState( pxTimeOut );
    2f82:	ce df       	rcall	.-100    	; 0x2f20 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2f84:	80 e0       	ldi	r24, 0x00	; 0
    2f86:	03 c0       	rjmp	.+6      	; 0x2f8e <xTaskCheckForTimeOut+0x58>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2f88:	81 e0       	ldi	r24, 0x01	; 1
    2f8a:	01 c0       	rjmp	.+2      	; 0x2f8e <xTaskCheckForTimeOut+0x58>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2f8c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2f8e:	0f 90       	pop	r0
    2f90:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2f92:	df 91       	pop	r29
    2f94:	cf 91       	pop	r28
    2f96:	08 95       	ret

00002f98 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    2f98:	81 e0       	ldi	r24, 0x01	; 1
    2f9a:	80 93 9f 5e 	sts	0x5E9F, r24	; 0x805e9f <xYieldPending>
    2f9e:	08 95       	ret

00002fa0 <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    2fa0:	80 91 a1 5e 	lds	r24, 0x5EA1	; 0x805ea1 <xSchedulerRunning>
    2fa4:	88 23       	and	r24, r24
    2fa6:	31 f0       	breq	.+12     	; 0x2fb4 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2fa8:	80 91 9a 5e 	lds	r24, 0x5E9A	; 0x805e9a <uxSchedulerSuspended>
    2fac:	88 23       	and	r24, r24
    2fae:	21 f0       	breq	.+8      	; 0x2fb8 <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    2fb0:	80 e0       	ldi	r24, 0x00	; 0
    2fb2:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    2fb4:	81 e0       	ldi	r24, 0x01	; 1
    2fb6:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    2fb8:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    2fba:	08 95       	ret

00002fbc <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    2fbc:	fc 01       	movw	r30, r24
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    2fbe:	62 83       	std	Z+2, r22	; 0x02
    2fc0:	73 83       	std	Z+3, r23	; 0x03
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2fc2:	80 87       	std	Z+8, r24	; 0x08
    2fc4:	91 87       	std	Z+9, r25	; 0x09

	if( xNextExpiryTime <= xTimeNow )
    2fc6:	46 17       	cp	r20, r22
    2fc8:	57 07       	cpc	r21, r23
    2fca:	90 f0       	brcs	.+36     	; 0x2ff0 <prvInsertTimerInActiveList+0x34>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
    2fcc:	42 1b       	sub	r20, r18
    2fce:	53 0b       	sbc	r21, r19
    2fd0:	84 85       	ldd	r24, Z+12	; 0x0c
    2fd2:	95 85       	ldd	r25, Z+13	; 0x0d
    2fd4:	48 17       	cp	r20, r24
    2fd6:	59 07       	cpc	r21, r25
    2fd8:	e0 f4       	brcc	.+56     	; 0x3012 <prvInsertTimerInActiveList+0x56>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    2fda:	bf 01       	movw	r22, r30
    2fdc:	6e 5f       	subi	r22, 0xFE	; 254
    2fde:	7f 4f       	sbci	r23, 0xFF	; 255
    2fe0:	80 91 f8 5e 	lds	r24, 0x5EF8	; 0x805ef8 <pxOverflowTimerList>
    2fe4:	90 91 f9 5e 	lds	r25, 0x5EF9	; 0x805ef9 <pxOverflowTimerList+0x1>
    2fe8:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    2fec:	80 e0       	ldi	r24, 0x00	; 0
    2fee:	08 95       	ret
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    2ff0:	42 17       	cp	r20, r18
    2ff2:	53 07       	cpc	r21, r19
    2ff4:	18 f4       	brcc	.+6      	; 0x2ffc <prvInsertTimerInActiveList+0x40>
    2ff6:	62 17       	cp	r22, r18
    2ff8:	73 07       	cpc	r23, r19
    2ffa:	68 f4       	brcc	.+26     	; 0x3016 <prvInsertTimerInActiveList+0x5a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2ffc:	bf 01       	movw	r22, r30
    2ffe:	6e 5f       	subi	r22, 0xFE	; 254
    3000:	7f 4f       	sbci	r23, 0xFF	; 255
    3002:	80 91 fa 5e 	lds	r24, 0x5EFA	; 0x805efa <pxCurrentTimerList>
    3006:	90 91 fb 5e 	lds	r25, 0x5EFB	; 0x805efb <pxCurrentTimerList+0x1>
    300a:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    300e:	80 e0       	ldi	r24, 0x00	; 0
    3010:	08 95       	ret
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    3012:	81 e0       	ldi	r24, 0x01	; 1
    3014:	08 95       	ret
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    3016:	81 e0       	ldi	r24, 0x01	; 1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
    3018:	08 95       	ret

0000301a <prvCheckForValidListAndQueue>:
static void prvCheckForValidListAndQueue( void )
{
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    301a:	0f b6       	in	r0, 0x3f	; 63
    301c:	f8 94       	cli
    301e:	0f 92       	push	r0
	{
		if( xTimerQueue == NULL )
    3020:	80 91 f6 5e 	lds	r24, 0x5EF6	; 0x805ef6 <xTimerQueue>
    3024:	90 91 f7 5e 	lds	r25, 0x5EF7	; 0x805ef7 <xTimerQueue+0x1>
    3028:	89 2b       	or	r24, r25
    302a:	e1 f4       	brne	.+56     	; 0x3064 <prvCheckForValidListAndQueue+0x4a>
		{
			vListInitialise( &xActiveTimerList1 );
    302c:	85 e0       	ldi	r24, 0x05	; 5
    302e:	9f e5       	ldi	r25, 0x5F	; 95
    3030:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
    3034:	8c ef       	ldi	r24, 0xFC	; 252
    3036:	9e e5       	ldi	r25, 0x5E	; 94
    3038:	0e 94 fa 0d 	call	0x1bf4	; 0x1bf4 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
    303c:	85 e0       	ldi	r24, 0x05	; 5
    303e:	9f e5       	ldi	r25, 0x5F	; 95
    3040:	80 93 fa 5e 	sts	0x5EFA, r24	; 0x805efa <pxCurrentTimerList>
    3044:	90 93 fb 5e 	sts	0x5EFB, r25	; 0x805efb <pxCurrentTimerList+0x1>
			pxOverflowTimerList = &xActiveTimerList2;
    3048:	8c ef       	ldi	r24, 0xFC	; 252
    304a:	9e e5       	ldi	r25, 0x5E	; 94
    304c:	80 93 f8 5e 	sts	0x5EF8, r24	; 0x805ef8 <pxOverflowTimerList>
    3050:	90 93 f9 5e 	sts	0x5EF9, r25	; 0x805ef9 <pxOverflowTimerList+0x1>
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    3054:	40 e0       	ldi	r20, 0x00	; 0
    3056:	65 e0       	ldi	r22, 0x05	; 5
    3058:	8a e0       	ldi	r24, 0x0A	; 10
    305a:	e8 d9       	rcall	.-3120   	; 0x242c <xQueueGenericCreate>
    305c:	80 93 f6 5e 	sts	0x5EF6, r24	; 0x805ef6 <xTimerQueue>
    3060:	90 93 f7 5e 	sts	0x5EF7, r25	; 0x805ef7 <xTimerQueue+0x1>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    3064:	0f 90       	pop	r0
    3066:	0f be       	out	0x3f, r0	; 63
    3068:	08 95       	ret

0000306a <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
    306a:	af 92       	push	r10
    306c:	bf 92       	push	r11
    306e:	cf 92       	push	r12
    3070:	df 92       	push	r13
    3072:	ef 92       	push	r14
    3074:	ff 92       	push	r15
    3076:	0f 93       	push	r16

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
    3078:	d0 df       	rcall	.-96     	; 0x301a <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
    307a:	80 91 f6 5e 	lds	r24, 0x5EF6	; 0x805ef6 <xTimerQueue>
    307e:	90 91 f7 5e 	lds	r25, 0x5EF7	; 0x805ef7 <xTimerQueue+0x1>
    3082:	89 2b       	or	r24, r25
    3084:	89 f0       	breq	.+34     	; 0x30a8 <xTimerCreateTimerTask+0x3e>
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
    3086:	a1 2c       	mov	r10, r1
    3088:	b1 2c       	mov	r11, r1
    308a:	c1 2c       	mov	r12, r1
    308c:	d1 2c       	mov	r13, r1
    308e:	e1 2c       	mov	r14, r1
    3090:	f1 2c       	mov	r15, r1
    3092:	03 e0       	ldi	r16, 0x03	; 3
    3094:	20 e0       	ldi	r18, 0x00	; 0
    3096:	30 e0       	ldi	r19, 0x00	; 0
    3098:	45 e5       	ldi	r20, 0x55	; 85
    309a:	50 e0       	ldi	r21, 0x00	; 0
    309c:	63 e1       	ldi	r22, 0x13	; 19
    309e:	70 e2       	ldi	r23, 0x20	; 32
    30a0:	84 e4       	ldi	r24, 0x44	; 68
    30a2:	99 e1       	ldi	r25, 0x19	; 25
    30a4:	9d db       	rcall	.-2246   	; 0x27e0 <xTaskGenericCreate>
    30a6:	01 c0       	rjmp	.+2      	; 0x30aa <xTimerCreateTimerTask+0x40>

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
BaseType_t xReturn = pdFAIL;
    30a8:	80 e0       	ldi	r24, 0x00	; 0
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
	return xReturn;
}
    30aa:	0f 91       	pop	r16
    30ac:	ff 90       	pop	r15
    30ae:	ef 90       	pop	r14
    30b0:	df 90       	pop	r13
    30b2:	cf 90       	pop	r12
    30b4:	bf 90       	pop	r11
    30b6:	af 90       	pop	r10
    30b8:	08 95       	ret

000030ba <xTimerCreate>:
/*-----------------------------------------------------------*/

TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    30ba:	8f 92       	push	r8
    30bc:	9f 92       	push	r9
    30be:	bf 92       	push	r11
    30c0:	cf 92       	push	r12
    30c2:	df 92       	push	r13
    30c4:	ef 92       	push	r14
    30c6:	ff 92       	push	r15
    30c8:	0f 93       	push	r16
    30ca:	1f 93       	push	r17
    30cc:	cf 93       	push	r28
    30ce:	df 93       	push	r29
Timer_t *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
    30d0:	61 15       	cp	r22, r1
    30d2:	71 05       	cpc	r23, r1
    30d4:	d1 f0       	breq	.+52     	; 0x310a <xTimerCreate+0x50>
    30d6:	69 01       	movw	r12, r18
    30d8:	b4 2e       	mov	r11, r20
    30da:	7b 01       	movw	r14, r22
    30dc:	4c 01       	movw	r8, r24
	{
		pxNewTimer = NULL;
	}
	else
	{
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
    30de:	83 e1       	ldi	r24, 0x13	; 19
    30e0:	90 e0       	ldi	r25, 0x00	; 0
    30e2:	0e 94 41 10 	call	0x2082	; 0x2082 <pvPortMalloc>
    30e6:	ec 01       	movw	r28, r24
		if( pxNewTimer != NULL )
    30e8:	89 2b       	or	r24, r25
    30ea:	89 f0       	breq	.+34     	; 0x310e <xTimerCreate+0x54>
		{
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();
    30ec:	96 df       	rcall	.-212    	; 0x301a <prvCheckForValidListAndQueue>

			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
    30ee:	88 82       	st	Y, r8
    30f0:	99 82       	std	Y+1, r9	; 0x01
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    30f2:	ec 86       	std	Y+12, r14	; 0x0c
    30f4:	fd 86       	std	Y+13, r15	; 0x0d
			pxNewTimer->uxAutoReload = uxAutoReload;
    30f6:	be 86       	std	Y+14, r11	; 0x0e
			pxNewTimer->pvTimerID = pvTimerID;
    30f8:	cf 86       	std	Y+15, r12	; 0x0f
    30fa:	d8 8a       	std	Y+16, r13	; 0x10
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    30fc:	09 8b       	std	Y+17, r16	; 0x11
    30fe:	1a 8b       	std	Y+18, r17	; 0x12
			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    3100:	ce 01       	movw	r24, r28
    3102:	02 96       	adiw	r24, 0x02	; 2
    3104:	0e 94 08 0e 	call	0x1c10	; 0x1c10 <vListInitialiseItem>
    3108:	02 c0       	rjmp	.+4      	; 0x310e <xTimerCreate+0x54>
Timer_t *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
	{
		pxNewTimer = NULL;
    310a:	c0 e0       	ldi	r28, 0x00	; 0
    310c:	d0 e0       	ldi	r29, 0x00	; 0

	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	return ( TimerHandle_t ) pxNewTimer;
}
    310e:	ce 01       	movw	r24, r28
    3110:	df 91       	pop	r29
    3112:	cf 91       	pop	r28
    3114:	1f 91       	pop	r17
    3116:	0f 91       	pop	r16
    3118:	ff 90       	pop	r15
    311a:	ef 90       	pop	r14
    311c:	df 90       	pop	r13
    311e:	cf 90       	pop	r12
    3120:	bf 90       	pop	r11
    3122:	9f 90       	pop	r9
    3124:	8f 90       	pop	r8
    3126:	08 95       	ret

00003128 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    3128:	0f 93       	push	r16
    312a:	1f 93       	push	r17
    312c:	cf 93       	push	r28
    312e:	df 93       	push	r29
    3130:	cd b7       	in	r28, 0x3d	; 61
    3132:	de b7       	in	r29, 0x3e	; 62
    3134:	25 97       	sbiw	r28, 0x05	; 5
    3136:	cd bf       	out	0x3d, r28	; 61
    3138:	de bf       	out	0x3e, r29	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    313a:	e0 91 f6 5e 	lds	r30, 0x5EF6	; 0x805ef6 <xTimerQueue>
    313e:	f0 91 f7 5e 	lds	r31, 0x5EF7	; 0x805ef7 <xTimerQueue+0x1>
    3142:	30 97       	sbiw	r30, 0x00	; 0
    3144:	51 f1       	breq	.+84     	; 0x319a <xTimerGenericCommand+0x72>
    3146:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    3148:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    314a:	4a 83       	std	Y+2, r20	; 0x02
    314c:	5b 83       	std	Y+3, r21	; 0x03
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    314e:	8c 83       	std	Y+4, r24	; 0x04
    3150:	9d 83       	std	Y+5, r25	; 0x05

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    3152:	66 30       	cpi	r22, 0x06	; 6
    3154:	d4 f4       	brge	.+52     	; 0x318a <xTimerGenericCommand+0x62>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    3156:	24 df       	rcall	.-440    	; 0x2fa0 <xTaskGetSchedulerState>
    3158:	82 30       	cpi	r24, 0x02	; 2
    315a:	59 f4       	brne	.+22     	; 0x3172 <xTimerGenericCommand+0x4a>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    315c:	20 e0       	ldi	r18, 0x00	; 0
    315e:	a8 01       	movw	r20, r16
    3160:	be 01       	movw	r22, r28
    3162:	6f 5f       	subi	r22, 0xFF	; 255
    3164:	7f 4f       	sbci	r23, 0xFF	; 255
    3166:	80 91 f6 5e 	lds	r24, 0x5EF6	; 0x805ef6 <xTimerQueue>
    316a:	90 91 f7 5e 	lds	r25, 0x5EF7	; 0x805ef7 <xTimerQueue+0x1>
    316e:	87 d9       	rcall	.-3314   	; 0x247e <xQueueGenericSend>
    3170:	15 c0       	rjmp	.+42     	; 0x319c <xTimerGenericCommand+0x74>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    3172:	20 e0       	ldi	r18, 0x00	; 0
    3174:	40 e0       	ldi	r20, 0x00	; 0
    3176:	50 e0       	ldi	r21, 0x00	; 0
    3178:	be 01       	movw	r22, r28
    317a:	6f 5f       	subi	r22, 0xFF	; 255
    317c:	7f 4f       	sbci	r23, 0xFF	; 255
    317e:	80 91 f6 5e 	lds	r24, 0x5EF6	; 0x805ef6 <xTimerQueue>
    3182:	90 91 f7 5e 	lds	r25, 0x5EF7	; 0x805ef7 <xTimerQueue+0x1>
    3186:	7b d9       	rcall	.-3338   	; 0x247e <xQueueGenericSend>
    3188:	09 c0       	rjmp	.+18     	; 0x319c <xTimerGenericCommand+0x74>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    318a:	20 e0       	ldi	r18, 0x00	; 0
    318c:	ad 01       	movw	r20, r26
    318e:	be 01       	movw	r22, r28
    3190:	6f 5f       	subi	r22, 0xFF	; 255
    3192:	7f 4f       	sbci	r23, 0xFF	; 255
    3194:	cf 01       	movw	r24, r30
    3196:	00 da       	rcall	.-3072   	; 0x2598 <xQueueGenericSendFromISR>
    3198:	01 c0       	rjmp	.+2      	; 0x319c <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    319a:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    319c:	25 96       	adiw	r28, 0x05	; 5
    319e:	cd bf       	out	0x3d, r28	; 61
    31a0:	de bf       	out	0x3e, r29	; 62
    31a2:	df 91       	pop	r29
    31a4:	cf 91       	pop	r28
    31a6:	1f 91       	pop	r17
    31a8:	0f 91       	pop	r16
    31aa:	08 95       	ret

000031ac <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    31ac:	af 92       	push	r10
    31ae:	bf 92       	push	r11
    31b0:	cf 92       	push	r12
    31b2:	df 92       	push	r13
    31b4:	ef 92       	push	r14
    31b6:	ff 92       	push	r15
    31b8:	0f 93       	push	r16
    31ba:	1f 93       	push	r17
    31bc:	cf 93       	push	r28
    31be:	df 93       	push	r29
    31c0:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    31c2:	48 dc       	rcall	.-1904   	; 0x2a54 <xTaskGetTickCount>
    31c4:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    31c6:	80 91 f4 5e 	lds	r24, 0x5EF4	; 0x805ef4 <xLastTime.4281>
    31ca:	90 91 f5 5e 	lds	r25, 0x5EF5	; 0x805ef5 <xLastTime.4281+0x1>
    31ce:	e8 16       	cp	r14, r24
    31d0:	f9 06       	cpc	r15, r25
    31d2:	08 f0       	brcs	.+2      	; 0x31d6 <prvSampleTimeNow+0x2a>
    31d4:	47 c0       	rjmp	.+142    	; 0x3264 <prvSampleTimeNow+0xb8>
    31d6:	2f c0       	rjmp	.+94     	; 0x3236 <prvSampleTimeNow+0x8a>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    31d8:	05 80       	ldd	r0, Z+5	; 0x05
    31da:	f6 81       	ldd	r31, Z+6	; 0x06
    31dc:	e0 2d       	mov	r30, r0
    31de:	a0 80       	ld	r10, Z
    31e0:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    31e2:	c6 81       	ldd	r28, Z+6	; 0x06
    31e4:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    31e6:	8e 01       	movw	r16, r28
    31e8:	0e 5f       	subi	r16, 0xFE	; 254
    31ea:	1f 4f       	sbci	r17, 0xFF	; 255
    31ec:	c8 01       	movw	r24, r16
    31ee:	0e 94 5e 0e 	call	0x1cbc	; 0x1cbc <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    31f2:	e9 89       	ldd	r30, Y+17	; 0x11
    31f4:	fa 89       	ldd	r31, Y+18	; 0x12
    31f6:	ce 01       	movw	r24, r28
    31f8:	19 95       	eicall

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    31fa:	8e 85       	ldd	r24, Y+14	; 0x0e
    31fc:	81 30       	cpi	r24, 0x01	; 1
    31fe:	d9 f4       	brne	.+54     	; 0x3236 <prvSampleTimeNow+0x8a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    3200:	8c 85       	ldd	r24, Y+12	; 0x0c
    3202:	9d 85       	ldd	r25, Y+13	; 0x0d
    3204:	8a 0d       	add	r24, r10
    3206:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    3208:	a8 16       	cp	r10, r24
    320a:	b9 06       	cpc	r11, r25
    320c:	60 f4       	brcc	.+24     	; 0x3226 <prvSampleTimeNow+0x7a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    320e:	8a 83       	std	Y+2, r24	; 0x02
    3210:	9b 83       	std	Y+3, r25	; 0x03
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    3212:	c8 87       	std	Y+8, r28	; 0x08
    3214:	d9 87       	std	Y+9, r29	; 0x09
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    3216:	b8 01       	movw	r22, r16
    3218:	80 91 fa 5e 	lds	r24, 0x5EFA	; 0x805efa <pxCurrentTimerList>
    321c:	90 91 fb 5e 	lds	r25, 0x5EFB	; 0x805efb <pxCurrentTimerList+0x1>
    3220:	0e 94 2d 0e 	call	0x1c5a	; 0x1c5a <vListInsert>
    3224:	08 c0       	rjmp	.+16     	; 0x3236 <prvSampleTimeNow+0x8a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3226:	00 e0       	ldi	r16, 0x00	; 0
    3228:	10 e0       	ldi	r17, 0x00	; 0
    322a:	20 e0       	ldi	r18, 0x00	; 0
    322c:	30 e0       	ldi	r19, 0x00	; 0
    322e:	a5 01       	movw	r20, r10
    3230:	60 e0       	ldi	r22, 0x00	; 0
    3232:	ce 01       	movw	r24, r28
    3234:	79 df       	rcall	.-270    	; 0x3128 <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    3236:	e0 91 fa 5e 	lds	r30, 0x5EFA	; 0x805efa <pxCurrentTimerList>
    323a:	f0 91 fb 5e 	lds	r31, 0x5EFB	; 0x805efb <pxCurrentTimerList+0x1>
    323e:	90 81       	ld	r25, Z
    3240:	91 11       	cpse	r25, r1
    3242:	ca cf       	rjmp	.-108    	; 0x31d8 <prvSampleTimeNow+0x2c>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    3244:	80 91 f8 5e 	lds	r24, 0x5EF8	; 0x805ef8 <pxOverflowTimerList>
    3248:	90 91 f9 5e 	lds	r25, 0x5EF9	; 0x805ef9 <pxOverflowTimerList+0x1>
    324c:	80 93 fa 5e 	sts	0x5EFA, r24	; 0x805efa <pxCurrentTimerList>
    3250:	90 93 fb 5e 	sts	0x5EFB, r25	; 0x805efb <pxCurrentTimerList+0x1>
	pxOverflowTimerList = pxTemp;
    3254:	e0 93 f8 5e 	sts	0x5EF8, r30	; 0x805ef8 <pxOverflowTimerList>
    3258:	f0 93 f9 5e 	sts	0x5EF9, r31	; 0x805ef9 <pxOverflowTimerList+0x1>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    325c:	81 e0       	ldi	r24, 0x01	; 1
    325e:	f6 01       	movw	r30, r12
    3260:	80 83       	st	Z, r24
    3262:	02 c0       	rjmp	.+4      	; 0x3268 <prvSampleTimeNow+0xbc>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    3264:	f6 01       	movw	r30, r12
    3266:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    3268:	e0 92 f4 5e 	sts	0x5EF4, r14	; 0x805ef4 <xLastTime.4281>
    326c:	f0 92 f5 5e 	sts	0x5EF5, r15	; 0x805ef5 <xLastTime.4281+0x1>

	return xTimeNow;
}
    3270:	c7 01       	movw	r24, r14
    3272:	df 91       	pop	r29
    3274:	cf 91       	pop	r28
    3276:	1f 91       	pop	r17
    3278:	0f 91       	pop	r16
    327a:	ff 90       	pop	r15
    327c:	ef 90       	pop	r14
    327e:	df 90       	pop	r13
    3280:	cf 90       	pop	r12
    3282:	bf 90       	pop	r11
    3284:	af 90       	pop	r10
    3286:	08 95       	ret

00003288 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    3288:	cf 93       	push	r28
    328a:	df 93       	push	r29
    328c:	00 d0       	rcall	.+0      	; 0x328e <prvTimerTask+0x6>
    328e:	00 d0       	rcall	.+0      	; 0x3290 <prvTimerTask+0x8>
    3290:	cd b7       	in	r28, 0x3d	; 61
    3292:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3294:	ce 01       	movw	r24, r28
    3296:	01 96       	adiw	r24, 0x01	; 1
    3298:	5c 01       	movw	r10, r24
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    329a:	e8 2e       	mov	r14, r24
    329c:	fb 2c       	mov	r15, r11
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    329e:	e0 91 fa 5e 	lds	r30, 0x5EFA	; 0x805efa <pxCurrentTimerList>
    32a2:	f0 91 fb 5e 	lds	r31, 0x5EFB	; 0x805efb <pxCurrentTimerList+0x1>
	if( *pxListWasEmpty == pdFALSE )
    32a6:	80 81       	ld	r24, Z
    32a8:	88 23       	and	r24, r24
    32aa:	69 f0       	breq	.+26     	; 0x32c6 <prvTimerTask+0x3e>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    32ac:	05 80       	ldd	r0, Z+5	; 0x05
    32ae:	f6 81       	ldd	r31, Z+6	; 0x06
    32b0:	e0 2d       	mov	r30, r0
    32b2:	c0 80       	ld	r12, Z
    32b4:	d1 80       	ldd	r13, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    32b6:	c8 db       	rcall	.-2160   	; 0x2a48 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    32b8:	c5 01       	movw	r24, r10
    32ba:	78 df       	rcall	.-272    	; 0x31ac <prvSampleTimeNow>
    32bc:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    32be:	89 81       	ldd	r24, Y+1	; 0x01
    32c0:	88 23       	and	r24, r24
    32c2:	49 f0       	breq	.+18     	; 0x32d6 <prvTimerTask+0x4e>
    32c4:	56 c0       	rjmp	.+172    	; 0x3372 <prvTimerTask+0xea>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    32c6:	c0 db       	rcall	.-2176   	; 0x2a48 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    32c8:	c5 01       	movw	r24, r10
    32ca:	70 df       	rcall	.-288    	; 0x31ac <prvSampleTimeNow>
    32cc:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    32ce:	89 81       	ldd	r24, Y+1	; 0x01
    32d0:	88 23       	and	r24, r24
    32d2:	a9 f1       	breq	.+106    	; 0x333e <prvTimerTask+0xb6>
    32d4:	4e c0       	rjmp	.+156    	; 0x3372 <prvTimerTask+0xea>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    32d6:	0c 15       	cp	r16, r12
    32d8:	1d 05       	cpc	r17, r13
    32da:	08 f4       	brcc	.+2      	; 0x32de <prvTimerTask+0x56>
    32dc:	3b c0       	rjmp	.+118    	; 0x3354 <prvTimerTask+0xcc>
			{
				( void ) xTaskResumeAll();
    32de:	97 dc       	rcall	.-1746   	; 0x2c0e <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    32e0:	e0 91 fa 5e 	lds	r30, 0x5EFA	; 0x805efa <pxCurrentTimerList>
    32e4:	f0 91 fb 5e 	lds	r31, 0x5EFB	; 0x805efb <pxCurrentTimerList+0x1>
    32e8:	05 80       	ldd	r0, Z+5	; 0x05
    32ea:	f6 81       	ldd	r31, Z+6	; 0x06
    32ec:	e0 2d       	mov	r30, r0
    32ee:	86 80       	ldd	r8, Z+6	; 0x06
    32f0:	97 80       	ldd	r9, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    32f2:	c4 01       	movw	r24, r8
    32f4:	02 96       	adiw	r24, 0x02	; 2
    32f6:	0e 94 5e 0e 	call	0x1cbc	; 0x1cbc <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    32fa:	d4 01       	movw	r26, r8
    32fc:	1e 96       	adiw	r26, 0x0e	; 14
    32fe:	8c 91       	ld	r24, X
    3300:	1e 97       	sbiw	r26, 0x0e	; 14
    3302:	81 30       	cpi	r24, 0x01	; 1
    3304:	a1 f4       	brne	.+40     	; 0x332e <prvTimerTask+0xa6>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
    3306:	1c 96       	adiw	r26, 0x0c	; 12
    3308:	6d 91       	ld	r22, X+
    330a:	7c 91       	ld	r23, X
    330c:	1d 97       	sbiw	r26, 0x0d	; 13
    330e:	6c 0d       	add	r22, r12
    3310:	7d 1d       	adc	r23, r13
    3312:	96 01       	movw	r18, r12
    3314:	a8 01       	movw	r20, r16
    3316:	c4 01       	movw	r24, r8
    3318:	51 de       	rcall	.-862    	; 0x2fbc <prvInsertTimerInActiveList>
    331a:	81 30       	cpi	r24, 0x01	; 1
    331c:	41 f4       	brne	.+16     	; 0x332e <prvTimerTask+0xa6>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    331e:	00 e0       	ldi	r16, 0x00	; 0
    3320:	10 e0       	ldi	r17, 0x00	; 0
    3322:	20 e0       	ldi	r18, 0x00	; 0
    3324:	30 e0       	ldi	r19, 0x00	; 0
    3326:	a6 01       	movw	r20, r12
    3328:	60 e0       	ldi	r22, 0x00	; 0
    332a:	c4 01       	movw	r24, r8
    332c:	fd de       	rcall	.-518    	; 0x3128 <xTimerGenericCommand>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    332e:	d4 01       	movw	r26, r8
    3330:	51 96       	adiw	r26, 0x11	; 17
    3332:	ed 91       	ld	r30, X+
    3334:	fc 91       	ld	r31, X
    3336:	52 97       	sbiw	r26, 0x12	; 18
    3338:	c4 01       	movw	r24, r8
    333a:	19 95       	eicall
    333c:	75 c0       	rjmp	.+234    	; 0x3428 <prvTimerTask+0x1a0>
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    333e:	e0 91 f8 5e 	lds	r30, 0x5EF8	; 0x805ef8 <pxOverflowTimerList>
    3342:	f0 91 f9 5e 	lds	r31, 0x5EF9	; 0x805ef9 <pxOverflowTimerList+0x1>
    3346:	41 e0       	ldi	r20, 0x01	; 1
    3348:	80 81       	ld	r24, Z
    334a:	81 11       	cpse	r24, r1
    334c:	40 e0       	ldi	r20, 0x00	; 0
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    334e:	c1 2c       	mov	r12, r1
    3350:	d1 2c       	mov	r13, r1
    3352:	01 c0       	rjmp	.+2      	; 0x3356 <prvTimerTask+0xce>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    3354:	40 e0       	ldi	r20, 0x00	; 0
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    3356:	b6 01       	movw	r22, r12
    3358:	60 1b       	sub	r22, r16
    335a:	71 0b       	sbc	r23, r17
    335c:	80 91 f6 5e 	lds	r24, 0x5EF6	; 0x805ef6 <xTimerQueue>
    3360:	90 91 f7 5e 	lds	r25, 0x5EF7	; 0x805ef7 <xTimerQueue+0x1>
    3364:	e6 d9       	rcall	.-3124   	; 0x2732 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    3366:	53 dc       	rcall	.-1882   	; 0x2c0e <xTaskResumeAll>
    3368:	81 11       	cpse	r24, r1
    336a:	5e c0       	rjmp	.+188    	; 0x3428 <prvTimerTask+0x1a0>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    336c:	0e 94 40 0f 	call	0x1e80	; 0x1e80 <vPortYield>
    3370:	5b c0       	rjmp	.+182    	; 0x3428 <prvTimerTask+0x1a0>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    3372:	4d dc       	rcall	.-1894   	; 0x2c0e <xTaskResumeAll>
    3374:	59 c0       	rjmp	.+178    	; 0x3428 <prvTimerTask+0x1a0>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    3376:	99 81       	ldd	r25, Y+1	; 0x01
    3378:	99 23       	and	r25, r25
    337a:	0c f4       	brge	.+2      	; 0x337e <prvTimerTask+0xf6>
    337c:	55 c0       	rjmp	.+170    	; 0x3428 <prvTimerTask+0x1a0>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    337e:	cc 80       	ldd	r12, Y+4	; 0x04
    3380:	dd 80       	ldd	r13, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    3382:	f6 01       	movw	r30, r12
    3384:	82 85       	ldd	r24, Z+10	; 0x0a
    3386:	93 85       	ldd	r25, Z+11	; 0x0b
    3388:	89 2b       	or	r24, r25
    338a:	21 f0       	breq	.+8      	; 0x3394 <prvTimerTask+0x10c>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    338c:	c6 01       	movw	r24, r12
    338e:	02 96       	adiw	r24, 0x02	; 2
    3390:	0e 94 5e 0e 	call	0x1cbc	; 0x1cbc <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3394:	ce 01       	movw	r24, r28
    3396:	06 96       	adiw	r24, 0x06	; 6
    3398:	09 df       	rcall	.-494    	; 0x31ac <prvSampleTimeNow>
    339a:	ac 01       	movw	r20, r24

			switch( xMessage.xMessageID )
    339c:	09 81       	ldd	r16, Y+1	; 0x01
    339e:	00 2e       	mov	r0, r16
    33a0:	00 0c       	add	r0, r0
    33a2:	11 0b       	sbc	r17, r17
    33a4:	22 0b       	sbc	r18, r18
    33a6:	33 0b       	sbc	r19, r19
    33a8:	0a 30       	cpi	r16, 0x0A	; 10
    33aa:	11 05       	cpc	r17, r1
    33ac:	08 f0       	brcs	.+2      	; 0x33b0 <prvTimerTask+0x128>
    33ae:	3c c0       	rjmp	.+120    	; 0x3428 <prvTimerTask+0x1a0>
    33b0:	f8 01       	movw	r30, r16
    33b2:	88 27       	eor	r24, r24
    33b4:	e2 50       	subi	r30, 0x02	; 2
    33b6:	ff 4f       	sbci	r31, 0xFF	; 255
    33b8:	8f 4f       	sbci	r24, 0xFF	; 255
    33ba:	88 c4       	rjmp	.+2320   	; 0x3ccc <__tablejump2__>
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
    33bc:	2a 81       	ldd	r18, Y+2	; 0x02
    33be:	3b 81       	ldd	r19, Y+3	; 0x03
    33c0:	d6 01       	movw	r26, r12
    33c2:	1c 96       	adiw	r26, 0x0c	; 12
    33c4:	6d 91       	ld	r22, X+
    33c6:	7c 91       	ld	r23, X
    33c8:	1d 97       	sbiw	r26, 0x0d	; 13
    33ca:	62 0f       	add	r22, r18
    33cc:	73 1f       	adc	r23, r19
    33ce:	c6 01       	movw	r24, r12
    33d0:	f5 dd       	rcall	.-1046   	; 0x2fbc <prvInsertTimerInActiveList>
    33d2:	81 30       	cpi	r24, 0x01	; 1
    33d4:	49 f5       	brne	.+82     	; 0x3428 <prvTimerTask+0x1a0>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    33d6:	d6 01       	movw	r26, r12
    33d8:	51 96       	adiw	r26, 0x11	; 17
    33da:	ed 91       	ld	r30, X+
    33dc:	fc 91       	ld	r31, X
    33de:	52 97       	sbiw	r26, 0x12	; 18
    33e0:	c6 01       	movw	r24, r12
    33e2:	19 95       	eicall
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    33e4:	f6 01       	movw	r30, r12
    33e6:	86 85       	ldd	r24, Z+14	; 0x0e
    33e8:	81 30       	cpi	r24, 0x01	; 1
    33ea:	f1 f4       	brne	.+60     	; 0x3428 <prvTimerTask+0x1a0>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    33ec:	44 85       	ldd	r20, Z+12	; 0x0c
    33ee:	55 85       	ldd	r21, Z+13	; 0x0d
    33f0:	8a 81       	ldd	r24, Y+2	; 0x02
    33f2:	9b 81       	ldd	r25, Y+3	; 0x03
    33f4:	48 0f       	add	r20, r24
    33f6:	59 1f       	adc	r21, r25
    33f8:	00 e0       	ldi	r16, 0x00	; 0
    33fa:	10 e0       	ldi	r17, 0x00	; 0
    33fc:	20 e0       	ldi	r18, 0x00	; 0
    33fe:	30 e0       	ldi	r19, 0x00	; 0
    3400:	60 e0       	ldi	r22, 0x00	; 0
    3402:	c6 01       	movw	r24, r12
    3404:	91 de       	rcall	.-734    	; 0x3128 <xTimerGenericCommand>
    3406:	10 c0       	rjmp	.+32     	; 0x3428 <prvTimerTask+0x1a0>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    3408:	6a 81       	ldd	r22, Y+2	; 0x02
    340a:	7b 81       	ldd	r23, Y+3	; 0x03
    340c:	d6 01       	movw	r26, r12
    340e:	1c 96       	adiw	r26, 0x0c	; 12
    3410:	6d 93       	st	X+, r22
    3412:	7c 93       	st	X, r23
    3414:	1d 97       	sbiw	r26, 0x0d	; 13
					longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot be
					zero the next expiry time can only be in the future, meaning
					(unlike for the xTimerStart() case above) there is no fail case
					that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    3416:	64 0f       	add	r22, r20
    3418:	75 1f       	adc	r23, r21
    341a:	9a 01       	movw	r18, r20
    341c:	c6 01       	movw	r24, r12
    341e:	ce dd       	rcall	.-1124   	; 0x2fbc <prvInsertTimerInActiveList>
    3420:	03 c0       	rjmp	.+6      	; 0x3428 <prvTimerTask+0x1a0>
					break;

				case tmrCOMMAND_DELETE :
					/* The timer has already been removed from the active list,
					just free up the memory. */
					vPortFree( pxTimer );
    3422:	c6 01       	movw	r24, r12
    3424:	0e 94 fa 10 	call	0x21f4	; 0x21f4 <vPortFree>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    3428:	20 e0       	ldi	r18, 0x00	; 0
    342a:	40 e0       	ldi	r20, 0x00	; 0
    342c:	50 e0       	ldi	r21, 0x00	; 0
    342e:	6e 2d       	mov	r22, r14
    3430:	7f 2d       	mov	r23, r15
    3432:	80 91 f6 5e 	lds	r24, 0x5EF6	; 0x805ef6 <xTimerQueue>
    3436:	90 91 f7 5e 	lds	r25, 0x5EF7	; 0x805ef7 <xTimerQueue+0x1>
    343a:	e4 d8       	rcall	.-3640   	; 0x2604 <xQueueGenericReceive>
    343c:	81 11       	cpse	r24, r1
    343e:	9b cf       	rjmp	.-202    	; 0x3376 <prvTimerTask+0xee>
    3440:	2e cf       	rjmp	.-420    	; 0x329e <prvTimerTask+0x16>

00003442 <ioport_configure_port_pin>:
#include "ioport_compat.h"

#if defined(IOPORT_XMEGA_COMPAT)
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
    3442:	cf 93       	push	r28
    3444:	df 93       	push	r29
    3446:	fc 01       	movw	r30, r24
    3448:	70 96       	adiw	r30, 0x10	; 16
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    344a:	20 e0       	ldi	r18, 0x00	; 0
    344c:	30 e0       	ldi	r19, 0x00	; 0
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
    344e:	c6 2f       	mov	r28, r22
    3450:	d0 e0       	ldi	r29, 0x00	; 0
    3452:	de 01       	movw	r26, r28
    3454:	02 2e       	mov	r0, r18
    3456:	02 c0       	rjmp	.+4      	; 0x345c <ioport_configure_port_pin+0x1a>
    3458:	b5 95       	asr	r27
    345a:	a7 95       	ror	r26
    345c:	0a 94       	dec	r0
    345e:	e2 f7       	brpl	.-8      	; 0x3458 <ioport_configure_port_pin+0x16>
    3460:	a0 fd       	sbrc	r26, 0
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    3462:	50 83       	st	Z, r21
    3464:	2f 5f       	subi	r18, 0xFF	; 255
    3466:	3f 4f       	sbci	r19, 0xFF	; 255
    3468:	31 96       	adiw	r30, 0x01	; 1
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
    346a:	28 30       	cpi	r18, 0x08	; 8
    346c:	31 05       	cpc	r19, r1
    346e:	89 f7       	brne	.-30     	; 0x3452 <ioport_configure_port_pin+0x10>
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
		}
	}
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
    3470:	40 ff       	sbrs	r20, 0
    3472:	0a c0       	rjmp	.+20     	; 0x3488 <ioport_configure_port_pin+0x46>
		if (flags & IOPORT_INIT_HIGH) {
    3474:	41 ff       	sbrs	r20, 1
    3476:	03 c0       	rjmp	.+6      	; 0x347e <ioport_configure_port_pin+0x3c>
			*((uint8_t *)port + PORT_OUTSET) = pin_mask;
    3478:	fc 01       	movw	r30, r24
    347a:	65 83       	std	Z+5, r22	; 0x05
    347c:	02 c0       	rjmp	.+4      	; 0x3482 <ioport_configure_port_pin+0x40>
		} else {
			*((uint8_t *)port + PORT_OUTCLR) = pin_mask;
    347e:	fc 01       	movw	r30, r24
    3480:	66 83       	std	Z+6, r22	; 0x06
		}

		*((uint8_t *)port + PORT_DIRSET) = pin_mask;
    3482:	fc 01       	movw	r30, r24
    3484:	61 83       	std	Z+1, r22	; 0x01
    3486:	02 c0       	rjmp	.+4      	; 0x348c <ioport_configure_port_pin+0x4a>
	} else {
		*((uint8_t *)port + PORT_DIRCLR) = pin_mask;
    3488:	fc 01       	movw	r30, r24
    348a:	62 83       	std	Z+2, r22	; 0x02
	}
}
    348c:	df 91       	pop	r29
    348e:	cf 91       	pop	r28
    3490:	08 95       	ret

00003492 <board_init>:
 * \param flags Bitmask of flags specifying additional configuration
 * parameters.
 */
static inline void ioport_configure_pin(port_pin_t pin, port_pin_flags_t flags)
{
	ioport_configure_port_pin(arch_ioport_pin_to_base(pin),
    3492:	43 e0       	ldi	r20, 0x03	; 3
    3494:	50 e0       	ldi	r21, 0x00	; 0
    3496:	61 e0       	ldi	r22, 0x01	; 1
    3498:	80 ee       	ldi	r24, 0xE0	; 224
    349a:	97 e0       	ldi	r25, 0x07	; 7
    349c:	d2 df       	rcall	.-92     	; 0x3442 <ioport_configure_port_pin>
    349e:	43 e0       	ldi	r20, 0x03	; 3
    34a0:	50 e0       	ldi	r21, 0x00	; 0
    34a2:	62 e0       	ldi	r22, 0x02	; 2
    34a4:	80 ee       	ldi	r24, 0xE0	; 224
    34a6:	97 e0       	ldi	r25, 0x07	; 7
    34a8:	cc df       	rcall	.-104    	; 0x3442 <ioport_configure_port_pin>
    34aa:	43 e0       	ldi	r20, 0x03	; 3
    34ac:	50 e0       	ldi	r21, 0x00	; 0
    34ae:	60 e1       	ldi	r22, 0x10	; 16
    34b0:	80 e6       	ldi	r24, 0x60	; 96
    34b2:	96 e0       	ldi	r25, 0x06	; 6
    34b4:	c6 df       	rcall	.-116    	; 0x3442 <ioport_configure_port_pin>
    34b6:	41 e0       	ldi	r20, 0x01	; 1
    34b8:	50 e4       	ldi	r21, 0x40	; 64
    34ba:	60 e2       	ldi	r22, 0x20	; 32
    34bc:	80 e6       	ldi	r24, 0x60	; 96
    34be:	96 e0       	ldi	r25, 0x06	; 6
    34c0:	c0 df       	rcall	.-128    	; 0x3442 <ioport_configure_port_pin>
    34c2:	40 e0       	ldi	r20, 0x00	; 0
    34c4:	5b e1       	ldi	r21, 0x1B	; 27
    34c6:	60 e2       	ldi	r22, 0x20	; 32
    34c8:	80 e8       	ldi	r24, 0x80	; 128
    34ca:	96 e0       	ldi	r25, 0x06	; 6
    34cc:	ba df       	rcall	.-140    	; 0x3442 <ioport_configure_port_pin>
    34ce:	40 e0       	ldi	r20, 0x00	; 0
    34d0:	5b e1       	ldi	r21, 0x1B	; 27
    34d2:	62 e0       	ldi	r22, 0x02	; 2
    34d4:	80 ea       	ldi	r24, 0xA0	; 160
    34d6:	96 e0       	ldi	r25, 0x06	; 6
    34d8:	b4 df       	rcall	.-152    	; 0x3442 <ioport_configure_port_pin>
    34da:	40 e0       	ldi	r20, 0x00	; 0
    34dc:	5b e1       	ldi	r21, 0x1B	; 27
    34de:	64 e0       	ldi	r22, 0x04	; 4
    34e0:	80 ea       	ldi	r24, 0xA0	; 160
    34e2:	96 e0       	ldi	r25, 0x06	; 6
    34e4:	ae df       	rcall	.-164    	; 0x3442 <ioport_configure_port_pin>
    34e6:	43 e0       	ldi	r20, 0x03	; 3
    34e8:	50 e0       	ldi	r21, 0x00	; 0
    34ea:	62 e0       	ldi	r22, 0x02	; 2
    34ec:	80 e6       	ldi	r24, 0x60	; 96
    34ee:	96 e0       	ldi	r25, 0x06	; 6
    34f0:	a8 df       	rcall	.-176    	; 0x3442 <ioport_configure_port_pin>
    34f2:	43 e0       	ldi	r20, 0x03	; 3
    34f4:	50 e0       	ldi	r21, 0x00	; 0
    34f6:	68 e0       	ldi	r22, 0x08	; 8
    34f8:	80 e6       	ldi	r24, 0x60	; 96
    34fa:	96 e0       	ldi	r25, 0x06	; 6
    34fc:	a2 df       	rcall	.-188    	; 0x3442 <ioport_configure_port_pin>
    34fe:	43 e0       	ldi	r20, 0x03	; 3
    3500:	50 e0       	ldi	r21, 0x00	; 0
    3502:	68 e0       	ldi	r22, 0x08	; 8
    3504:	80 ea       	ldi	r24, 0xA0	; 160
    3506:	96 e0       	ldi	r25, 0x06	; 6
    3508:	9c df       	rcall	.-200    	; 0x3442 <ioport_configure_port_pin>
    350a:	43 e0       	ldi	r20, 0x03	; 3
    350c:	50 e0       	ldi	r21, 0x00	; 0
    350e:	61 e0       	ldi	r22, 0x01	; 1
    3510:	80 e6       	ldi	r24, 0x60	; 96
    3512:	96 e0       	ldi	r25, 0x06	; 6
    3514:	96 df       	rcall	.-212    	; 0x3442 <ioport_configure_port_pin>
    3516:	43 e0       	ldi	r20, 0x03	; 3
    3518:	50 e0       	ldi	r21, 0x00	; 0
    351a:	68 e0       	ldi	r22, 0x08	; 8
    351c:	80 e0       	ldi	r24, 0x00	; 0
    351e:	96 e0       	ldi	r25, 0x06	; 6
    3520:	90 df       	rcall	.-224    	; 0x3442 <ioport_configure_port_pin>
    3522:	41 e0       	ldi	r20, 0x01	; 1
    3524:	50 e0       	ldi	r21, 0x00	; 0
    3526:	60 e1       	ldi	r22, 0x10	; 16
    3528:	80 e8       	ldi	r24, 0x80	; 128
    352a:	96 e0       	ldi	r25, 0x06	; 6
    352c:	8a df       	rcall	.-236    	; 0x3442 <ioport_configure_port_pin>
    352e:	43 e0       	ldi	r20, 0x03	; 3
    3530:	50 e0       	ldi	r21, 0x00	; 0
    3532:	62 e0       	ldi	r22, 0x02	; 2
    3534:	80 e6       	ldi	r24, 0x60	; 96
    3536:	96 e0       	ldi	r25, 0x06	; 6
    3538:	84 df       	rcall	.-248    	; 0x3442 <ioport_configure_port_pin>
    353a:	43 e0       	ldi	r20, 0x03	; 3
    353c:	50 e0       	ldi	r21, 0x00	; 0
    353e:	68 e0       	ldi	r22, 0x08	; 8
    3540:	80 e6       	ldi	r24, 0x60	; 96
    3542:	96 e0       	ldi	r25, 0x06	; 6
    3544:	7e df       	rcall	.-260    	; 0x3442 <ioport_configure_port_pin>
    3546:	40 e0       	ldi	r20, 0x00	; 0
    3548:	50 e0       	ldi	r21, 0x00	; 0
    354a:	64 e0       	ldi	r22, 0x04	; 4
    354c:	80 e6       	ldi	r24, 0x60	; 96
    354e:	96 e0       	ldi	r25, 0x06	; 6
    3550:	78 df       	rcall	.-272    	; 0x3442 <ioport_configure_port_pin>
    3552:	43 e0       	ldi	r20, 0x03	; 3
    3554:	50 e0       	ldi	r21, 0x00	; 0
    3556:	60 e1       	ldi	r22, 0x10	; 16
    3558:	80 ea       	ldi	r24, 0xA0	; 160
    355a:	96 e0       	ldi	r25, 0x06	; 6
    355c:	72 df       	rcall	.-284    	; 0x3442 <ioport_configure_port_pin>
    355e:	40 e0       	ldi	r20, 0x00	; 0
    3560:	50 e0       	ldi	r21, 0x00	; 0
    3562:	61 e0       	ldi	r22, 0x01	; 1
    3564:	80 e0       	ldi	r24, 0x00	; 0
    3566:	96 e0       	ldi	r25, 0x06	; 6
    3568:	6c df       	rcall	.-296    	; 0x3442 <ioport_configure_port_pin>
    356a:	40 e0       	ldi	r20, 0x00	; 0
    356c:	50 e0       	ldi	r21, 0x00	; 0
    356e:	64 e0       	ldi	r22, 0x04	; 4
    3570:	80 e0       	ldi	r24, 0x00	; 0
    3572:	96 e0       	ldi	r25, 0x06	; 6
    3574:	66 df       	rcall	.-308    	; 0x3442 <ioport_configure_port_pin>
    3576:	40 e0       	ldi	r20, 0x00	; 0
    3578:	50 e0       	ldi	r21, 0x00	; 0
    357a:	62 e0       	ldi	r22, 0x02	; 2
    357c:	80 e2       	ldi	r24, 0x20	; 32
    357e:	96 e0       	ldi	r25, 0x06	; 6
    3580:	60 df       	rcall	.-320    	; 0x3442 <ioport_configure_port_pin>
    3582:	43 e0       	ldi	r20, 0x03	; 3
    3584:	50 e0       	ldi	r21, 0x00	; 0
    3586:	68 e0       	ldi	r22, 0x08	; 8
    3588:	80 e4       	ldi	r24, 0x40	; 64
    358a:	96 e0       	ldi	r25, 0x06	; 6
    358c:	5a df       	rcall	.-332    	; 0x3442 <ioport_configure_port_pin>
    358e:	40 e0       	ldi	r20, 0x00	; 0
    3590:	50 e0       	ldi	r21, 0x00	; 0
    3592:	64 e0       	ldi	r22, 0x04	; 4
    3594:	80 e4       	ldi	r24, 0x40	; 64
    3596:	96 e0       	ldi	r25, 0x06	; 6
    3598:	54 df       	rcall	.-344    	; 0x3442 <ioport_configure_port_pin>
    359a:	43 e0       	ldi	r20, 0x03	; 3
    359c:	50 e0       	ldi	r21, 0x00	; 0
    359e:	68 e0       	ldi	r22, 0x08	; 8
    35a0:	80 e6       	ldi	r24, 0x60	; 96
    35a2:	96 e0       	ldi	r25, 0x06	; 6
    35a4:	4e df       	rcall	.-356    	; 0x3442 <ioport_configure_port_pin>
    35a6:	40 e0       	ldi	r20, 0x00	; 0
    35a8:	50 e0       	ldi	r21, 0x00	; 0
    35aa:	64 e0       	ldi	r22, 0x04	; 4
    35ac:	80 e6       	ldi	r24, 0x60	; 96
    35ae:	96 e0       	ldi	r25, 0x06	; 6
    35b0:	48 df       	rcall	.-368    	; 0x3442 <ioport_configure_port_pin>
    35b2:	43 e0       	ldi	r20, 0x03	; 3
    35b4:	50 e0       	ldi	r21, 0x00	; 0
    35b6:	68 e0       	ldi	r22, 0x08	; 8
    35b8:	80 e8       	ldi	r24, 0x80	; 128
    35ba:	96 e0       	ldi	r25, 0x06	; 6
    35bc:	42 df       	rcall	.-380    	; 0x3442 <ioport_configure_port_pin>
    35be:	40 e0       	ldi	r20, 0x00	; 0
    35c0:	50 e0       	ldi	r21, 0x00	; 0
    35c2:	64 e0       	ldi	r22, 0x04	; 4
    35c4:	80 e8       	ldi	r24, 0x80	; 128
    35c6:	96 e0       	ldi	r25, 0x06	; 6
    35c8:	3c cf       	rjmp	.-392    	; 0x3442 <ioport_configure_port_pin>
    35ca:	08 95       	ret

000035cc <vTimerCallback>:
	while(1){
		char inp = usart_getchar(USART_SERIAL_EXAMPLE);
		if(inp=='\n') break;
		else reads[i++] = inp;
	}
}
    35cc:	80 91 0e 5f 	lds	r24, 0x5F0E	; 0x805f0e <increment>
    35d0:	90 91 0f 5f 	lds	r25, 0x5F0F	; 0x805f0f <increment+0x1>
    35d4:	a0 91 10 5f 	lds	r26, 0x5F10	; 0x805f10 <increment+0x2>
    35d8:	b0 91 11 5f 	lds	r27, 0x5F11	; 0x805f11 <increment+0x3>
    35dc:	01 96       	adiw	r24, 0x01	; 1
    35de:	a1 1d       	adc	r26, r1
    35e0:	b1 1d       	adc	r27, r1
    35e2:	80 93 0e 5f 	sts	0x5F0E, r24	; 0x805f0e <increment>
    35e6:	90 93 0f 5f 	sts	0x5F0F, r25	; 0x805f0f <increment+0x1>
    35ea:	a0 93 10 5f 	sts	0x5F10, r26	; 0x805f10 <increment+0x2>
    35ee:	b0 93 11 5f 	sts	0x5F11, r27	; 0x805f11 <increment+0x3>
    35f2:	08 95       	ret

000035f4 <testLCD>:
    35f4:	80 e1       	ldi	r24, 0x10	; 16
    35f6:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
    35fa:	0f 2e       	mov	r0, r31
    35fc:	fb e1       	ldi	r31, 0x1B	; 27
    35fe:	8f 2e       	mov	r8, r31
    3600:	f0 e2       	ldi	r31, 0x20	; 32
    3602:	9f 2e       	mov	r9, r31
    3604:	f0 2d       	mov	r31, r0
    3606:	19 ec       	ldi	r17, 0xC9	; 201
    3608:	cb ee       	ldi	r28, 0xEB	; 235
    360a:	df e5       	ldi	r29, 0x5F	; 95
    360c:	0f 2e       	mov	r0, r31
    360e:	fa e2       	ldi	r31, 0x2A	; 42
    3610:	af 2e       	mov	r10, r31
    3612:	f0 e2       	ldi	r31, 0x20	; 32
    3614:	bf 2e       	mov	r11, r31
    3616:	f0 2d       	mov	r31, r0
    3618:	0f 2e       	mov	r0, r31
    361a:	f9 e3       	ldi	r31, 0x39	; 57
    361c:	cf 2e       	mov	r12, r31
    361e:	f0 e2       	ldi	r31, 0x20	; 32
    3620:	df 2e       	mov	r13, r31
    3622:	f0 2d       	mov	r31, r0
    3624:	0f 2e       	mov	r0, r31
    3626:	f5 e4       	ldi	r31, 0x45	; 69
    3628:	ef 2e       	mov	r14, r31
    362a:	f0 e2       	ldi	r31, 0x20	; 32
    362c:	ff 2e       	mov	r15, r31
    362e:	f0 2d       	mov	r31, r0
    3630:	80 91 21 5f 	lds	r24, 0x5F21	; 0x805f21 <result+0x1>
    3634:	8f 93       	push	r24
    3636:	80 91 20 5f 	lds	r24, 0x5F20	; 0x805f20 <result>
    363a:	8f 93       	push	r24
    363c:	9f 92       	push	r9
    363e:	8f 92       	push	r8
    3640:	1f 92       	push	r1
    3642:	1f 93       	push	r17
    3644:	df 93       	push	r29
    3646:	cf 93       	push	r28
    3648:	52 d3       	rcall	.+1700   	; 0x3cee <snprintf>
    364a:	20 e0       	ldi	r18, 0x00	; 0
    364c:	30 e2       	ldi	r19, 0x20	; 32
    364e:	40 e0       	ldi	r20, 0x00	; 0
    3650:	60 e0       	ldi	r22, 0x00	; 0
    3652:	ce 01       	movw	r24, r28
    3654:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <gfx_mono_draw_string>
    3658:	80 91 17 5f 	lds	r24, 0x5F17	; 0x805f17 <servotest+0x1>
    365c:	8f 93       	push	r24
    365e:	80 91 16 5f 	lds	r24, 0x5F16	; 0x805f16 <servotest>
    3662:	8f 93       	push	r24
    3664:	80 91 15 5f 	lds	r24, 0x5F15	; 0x805f15 <qtouchtest+0x1>
    3668:	8f 93       	push	r24
    366a:	80 91 14 5f 	lds	r24, 0x5F14	; 0x805f14 <qtouchtest>
    366e:	8f 93       	push	r24
    3670:	bf 92       	push	r11
    3672:	af 92       	push	r10
    3674:	1f 92       	push	r1
    3676:	1f 93       	push	r17
    3678:	df 93       	push	r29
    367a:	cf 93       	push	r28
    367c:	38 d3       	rcall	.+1648   	; 0x3cee <snprintf>
    367e:	20 e0       	ldi	r18, 0x00	; 0
    3680:	30 e2       	ldi	r19, 0x20	; 32
    3682:	48 e0       	ldi	r20, 0x08	; 8
    3684:	60 e0       	ldi	r22, 0x00	; 0
    3686:	ce 01       	movw	r24, r28
    3688:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <gfx_mono_draw_string>
    368c:	80 91 1f 5f 	lds	r24, 0x5F1F	; 0x805f1f <result2+0x1>
    3690:	8f 93       	push	r24
    3692:	80 91 1e 5f 	lds	r24, 0x5F1E	; 0x805f1e <result2>
    3696:	8f 93       	push	r24
    3698:	df 92       	push	r13
    369a:	cf 92       	push	r12
    369c:	1f 92       	push	r1
    369e:	1f 93       	push	r17
    36a0:	df 93       	push	r29
    36a2:	cf 93       	push	r28
    36a4:	24 d3       	rcall	.+1608   	; 0x3cee <snprintf>
    36a6:	20 e0       	ldi	r18, 0x00	; 0
    36a8:	30 e2       	ldi	r19, 0x20	; 32
    36aa:	40 e1       	ldi	r20, 0x10	; 16
    36ac:	60 e0       	ldi	r22, 0x00	; 0
    36ae:	ce 01       	movw	r24, r28
    36b0:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <gfx_mono_draw_string>
    36b4:	80 91 1b 5f 	lds	r24, 0x5F1B	; 0x805f1b <lastReq+0x1>
    36b8:	8f 93       	push	r24
    36ba:	80 91 1a 5f 	lds	r24, 0x5F1A	; 0x805f1a <lastReq>
    36be:	8f 93       	push	r24
    36c0:	80 91 13 5f 	lds	r24, 0x5F13	; 0x805f13 <heap+0x1>
    36c4:	8f 93       	push	r24
    36c6:	80 91 12 5f 	lds	r24, 0x5F12	; 0x805f12 <heap>
    36ca:	8f 93       	push	r24
    36cc:	ff 92       	push	r15
    36ce:	ef 92       	push	r14
    36d0:	1f 92       	push	r1
    36d2:	1f 93       	push	r17
    36d4:	df 93       	push	r29
    36d6:	cf 93       	push	r28
    36d8:	0a d3       	rcall	.+1556   	; 0x3cee <snprintf>
    36da:	8d b7       	in	r24, 0x3d	; 61
    36dc:	9e b7       	in	r25, 0x3e	; 62
    36de:	84 96       	adiw	r24, 0x24	; 36
    36e0:	8d bf       	out	0x3d, r24	; 61
    36e2:	9e bf       	out	0x3e, r25	; 62
    36e4:	20 e0       	ldi	r18, 0x00	; 0
    36e6:	30 e2       	ldi	r19, 0x20	; 32
    36e8:	48 e1       	ldi	r20, 0x18	; 24
    36ea:	60 e0       	ldi	r22, 0x00	; 0
    36ec:	ce 01       	movw	r24, r28
    36ee:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <gfx_mono_draw_string>
    36f2:	82 e3       	ldi	r24, 0x32	; 50
    36f4:	90 e0       	ldi	r25, 0x00	; 0
    36f6:	09 db       	rcall	.-2542   	; 0x2d0a <vTaskDelay>
    36f8:	9b cf       	rjmp	.-202    	; 0x3630 <testLCD+0x3c>

000036fa <testHeap>:
    36fa:	0e 94 29 11 	call	0x2252	; 0x2252 <xPortGetFreeHeapSize>
    36fe:	80 93 12 5f 	sts	0x5F12, r24	; 0x805f12 <heap>
    3702:	90 93 13 5f 	sts	0x5F13, r25	; 0x805f13 <heap+0x1>
    3706:	85 e0       	ldi	r24, 0x05	; 5
    3708:	90 e0       	ldi	r25, 0x00	; 0
    370a:	ff da       	rcall	.-2562   	; 0x2d0a <vTaskDelay>
    370c:	f6 cf       	rjmp	.-20     	; 0x36fa <testHeap>

0000370e <testPotentio>:
    370e:	c0 e0       	ldi	r28, 0x00	; 0
    3710:	d2 e0       	ldi	r29, 0x02	; 2
    3712:	cc 24       	eor	r12, r12
    3714:	c3 94       	inc	r12
    3716:	00 e6       	ldi	r16, 0x60	; 96
    3718:	16 e0       	ldi	r17, 0x06	; 6
    371a:	68 94       	set
    371c:	dd 24       	eor	r13, r13
    371e:	d4 f8       	bld	r13, 4
    3720:	ee 24       	eor	r14, r14
    3722:	e3 94       	inc	r14
    3724:	f1 2c       	mov	r15, r1
    3726:	ce 01       	movw	r24, r28
    3728:	0e 94 46 07 	call	0xe8c	; 0xe8c <adc_enable>
    372c:	9f b7       	in	r25, 0x3f	; 63
    372e:	f8 94       	cli
    3730:	88 81       	ld	r24, Y
    3732:	84 60       	ori	r24, 0x04	; 4
    3734:	88 83       	st	Y, r24
    3736:	9f bf       	out	0x3f, r25	; 63
    3738:	9e 81       	ldd	r25, Y+6	; 0x06
    373a:	90 ff       	sbrs	r25, 0
    373c:	fd cf       	rjmp	.-6      	; 0x3738 <testPotentio+0x2a>
    373e:	ce 82       	std	Y+6, r12	; 0x06
    3740:	8c a1       	ldd	r24, Y+36	; 0x24
    3742:	9d a1       	ldd	r25, Y+37	; 0x25
    3744:	80 93 20 5f 	sts	0x5F20, r24	; 0x805f20 <result>
    3748:	90 93 21 5f 	sts	0x5F21, r25	; 0x805f21 <result+0x1>
    374c:	81 3d       	cpi	r24, 0xD1	; 209
    374e:	97 40       	sbci	r25, 0x07	; 7
    3750:	38 f4       	brcc	.+14     	; 0x3760 <testPotentio+0x52>
    3752:	f8 01       	movw	r30, r16
    3754:	d6 82       	std	Z+6, r13	; 0x06
    3756:	e0 92 18 5f 	sts	0x5F18, r14	; 0x805f18 <potensiotest>
    375a:	f0 92 19 5f 	sts	0x5F19, r15	; 0x805f19 <potensiotest+0x1>
    375e:	06 c0       	rjmp	.+12     	; 0x376c <testPotentio+0x5e>
    3760:	f8 01       	movw	r30, r16
    3762:	d5 82       	std	Z+5, r13	; 0x05
    3764:	10 92 18 5f 	sts	0x5F18, r1	; 0x805f18 <potensiotest>
    3768:	10 92 19 5f 	sts	0x5F19, r1	; 0x805f19 <potensiotest+0x1>
    376c:	85 e0       	ldi	r24, 0x05	; 5
    376e:	90 e0       	ldi	r25, 0x00	; 0
    3770:	cc da       	rcall	.-2664   	; 0x2d0a <vTaskDelay>
    3772:	d9 cf       	rjmp	.-78     	; 0x3726 <testPotentio+0x18>

00003774 <PWM_Init>:
    3774:	e0 e4       	ldi	r30, 0x40	; 64
    3776:	f6 e0       	ldi	r31, 0x06	; 6
    3778:	80 81       	ld	r24, Z
    377a:	81 60       	ori	r24, 0x01	; 1
    377c:	80 83       	st	Z, r24
    377e:	e0 e0       	ldi	r30, 0x00	; 0
    3780:	f8 e0       	ldi	r31, 0x08	; 8
    3782:	85 e0       	ldi	r24, 0x05	; 5
    3784:	80 83       	st	Z, r24
    3786:	86 e1       	ldi	r24, 0x16	; 22
    3788:	81 83       	std	Z+1, r24	; 0x01
    378a:	88 ee       	ldi	r24, 0xE8	; 232
    378c:	93 e0       	ldi	r25, 0x03	; 3
    378e:	86 a3       	std	Z+38, r24	; 0x26
    3790:	97 a3       	std	Z+39, r25	; 0x27
    3792:	87 e7       	ldi	r24, 0x77	; 119
    3794:	91 e0       	ldi	r25, 0x01	; 1
    3796:	80 a7       	std	Z+40, r24	; 0x28
    3798:	91 a7       	std	Z+41, r25	; 0x29
    379a:	08 95       	ret

0000379c <testServo>:
    379c:	eb df       	rcall	.-42     	; 0x3774 <PWM_Init>
    379e:	c0 ea       	ldi	r28, 0xA0	; 160
    37a0:	d6 e0       	ldi	r29, 0x06	; 6
    37a2:	00 e0       	ldi	r16, 0x00	; 0
    37a4:	18 e0       	ldi	r17, 0x08	; 8
    37a6:	0f 2e       	mov	r0, r31
    37a8:	f7 e7       	ldi	r31, 0x77	; 119
    37aa:	8f 2e       	mov	r8, r31
    37ac:	99 24       	eor	r9, r9
    37ae:	93 94       	inc	r9
    37b0:	f0 2d       	mov	r31, r0
    37b2:	cc 24       	eor	r12, r12
    37b4:	c3 94       	inc	r12
    37b6:	d1 2c       	mov	r13, r1
    37b8:	0f 2e       	mov	r0, r31
    37ba:	f0 ee       	ldi	r31, 0xE0	; 224
    37bc:	ef 2e       	mov	r14, r31
    37be:	f7 e0       	ldi	r31, 0x07	; 7
    37c0:	ff 2e       	mov	r15, r31
    37c2:	f0 2d       	mov	r31, r0
    37c4:	77 24       	eor	r7, r7
    37c6:	73 94       	inc	r7
    37c8:	0f 2e       	mov	r0, r31
    37ca:	f6 e9       	ldi	r31, 0x96	; 150
    37cc:	af 2e       	mov	r10, r31
    37ce:	b1 2c       	mov	r11, r1
    37d0:	f0 2d       	mov	r31, r0
    37d2:	88 85       	ldd	r24, Y+8	; 0x08
    37d4:	81 fd       	sbrc	r24, 1
    37d6:	0a c0       	rjmp	.+20     	; 0x37ec <testServo+0x50>
    37d8:	f8 01       	movw	r30, r16
    37da:	a0 a6       	std	Z+40, r10	; 0x28
    37dc:	b1 a6       	std	Z+41, r11	; 0x29
    37de:	f7 01       	movw	r30, r14
    37e0:	76 82       	std	Z+6, r7	; 0x06
    37e2:	c0 92 16 5f 	sts	0x5F16, r12	; 0x805f16 <servotest>
    37e6:	d0 92 17 5f 	sts	0x5F17, r13	; 0x805f17 <servotest+0x1>
    37ea:	10 c0       	rjmp	.+32     	; 0x380c <testServo+0x70>
    37ec:	88 85       	ldd	r24, Y+8	; 0x08
    37ee:	82 fd       	sbrc	r24, 2
    37f0:	0a c0       	rjmp	.+20     	; 0x3806 <testServo+0x6a>
    37f2:	f8 01       	movw	r30, r16
    37f4:	c0 a6       	std	Z+40, r12	; 0x28
    37f6:	d1 a6       	std	Z+41, r13	; 0x29
    37f8:	f7 01       	movw	r30, r14
    37fa:	75 82       	std	Z+5, r7	; 0x05
    37fc:	10 92 16 5f 	sts	0x5F16, r1	; 0x805f16 <servotest>
    3800:	10 92 17 5f 	sts	0x5F17, r1	; 0x805f17 <servotest+0x1>
    3804:	03 c0       	rjmp	.+6      	; 0x380c <testServo+0x70>
    3806:	f8 01       	movw	r30, r16
    3808:	80 a6       	std	Z+40, r8	; 0x28
    380a:	91 a6       	std	Z+41, r9	; 0x29
    380c:	85 e0       	ldi	r24, 0x05	; 5
    380e:	90 e0       	ldi	r25, 0x00	; 0
    3810:	7c da       	rcall	.-2824   	; 0x2d0a <vTaskDelay>
    3812:	df cf       	rjmp	.-66     	; 0x37d2 <testServo+0x36>

00003814 <setUpSerial>:
    3814:	10 92 a7 0a 	sts	0x0AA7, r1	; 0x800aa7 <__TEXT_REGION_LENGTH__+0x700aa7>
    3818:	8c e0       	ldi	r24, 0x0C	; 12
    381a:	80 93 a6 0a 	sts	0x0AA6, r24	; 0x800aa6 <__TEXT_REGION_LENGTH__+0x700aa6>
    381e:	10 92 a3 0a 	sts	0x0AA3, r1	; 0x800aa3 <__TEXT_REGION_LENGTH__+0x700aa3>
    3822:	83 e0       	ldi	r24, 0x03	; 3
    3824:	80 93 a5 0a 	sts	0x0AA5, r24	; 0x800aa5 <__TEXT_REGION_LENGTH__+0x700aa5>
    3828:	88 e1       	ldi	r24, 0x18	; 24
    382a:	80 93 a4 0a 	sts	0x0AA4, r24	; 0x800aa4 <__TEXT_REGION_LENGTH__+0x700aa4>
    382e:	08 95       	ret

00003830 <sendString>:
    3830:	cf 93       	push	r28
    3832:	df 93       	push	r29
    3834:	fc 01       	movw	r30, r24
    3836:	60 81       	ld	r22, Z
    3838:	66 23       	and	r22, r22
    383a:	49 f0       	breq	.+18     	; 0x384e <sendString+0x1e>
    383c:	ec 01       	movw	r28, r24
    383e:	21 96       	adiw	r28, 0x01	; 1
    3840:	80 ea       	ldi	r24, 0xA0	; 160
    3842:	9a e0       	ldi	r25, 0x0A	; 10
    3844:	0e 94 dc 09 	call	0x13b8	; 0x13b8 <usart_putchar>
    3848:	69 91       	ld	r22, Y+
    384a:	61 11       	cpse	r22, r1
    384c:	f9 cf       	rjmp	.-14     	; 0x3840 <sendString+0x10>
    384e:	df 91       	pop	r29
    3850:	cf 91       	pop	r28
    3852:	08 95       	ret

00003854 <testUsart>:
    3854:	0f 2e       	mov	r0, r31
    3856:	ff e3       	ldi	r31, 0x3F	; 63
    3858:	af 2e       	mov	r10, r31
    385a:	f1 e2       	ldi	r31, 0x21	; 33
    385c:	bf 2e       	mov	r11, r31
    385e:	f0 2d       	mov	r31, r0
    3860:	0f 2e       	mov	r0, r31
    3862:	f9 ec       	ldi	r31, 0xC9	; 201
    3864:	7f 2e       	mov	r7, r31
    3866:	f0 2d       	mov	r31, r0
    3868:	c2 e2       	ldi	r28, 0x22	; 34
    386a:	df e5       	ldi	r29, 0x5F	; 95
    386c:	0f 2e       	mov	r0, r31
    386e:	f3 e0       	ldi	r31, 0x03	; 3
    3870:	8f 2e       	mov	r8, r31
    3872:	f1 e2       	ldi	r31, 0x21	; 33
    3874:	9f 2e       	mov	r9, r31
    3876:	f0 2d       	mov	r31, r0
    3878:	0f 2e       	mov	r0, r31
    387a:	f9 ed       	ldi	r31, 0xD9	; 217
    387c:	cf 2e       	mov	r12, r31
    387e:	f0 e2       	ldi	r31, 0x20	; 32
    3880:	df 2e       	mov	r13, r31
    3882:	f0 2d       	mov	r31, r0
    3884:	0f 2e       	mov	r0, r31
    3886:	ff ea       	ldi	r31, 0xAF	; 175
    3888:	ef 2e       	mov	r14, r31
    388a:	f0 e2       	ldi	r31, 0x20	; 32
    388c:	ff 2e       	mov	r15, r31
    388e:	f0 2d       	mov	r31, r0
    3890:	07 e5       	ldi	r16, 0x57	; 87
    3892:	10 e2       	ldi	r17, 0x20	; 32
    3894:	80 91 1c 5f 	lds	r24, 0x5F1C	; 0x805f1c <command>
    3898:	90 91 1d 5f 	lds	r25, 0x5F1D	; 0x805f1d <command+0x1>
    389c:	81 30       	cpi	r24, 0x01	; 1
    389e:	91 05       	cpc	r25, r1
    38a0:	e9 f4       	brne	.+58     	; 0x38dc <testUsart+0x88>
    38a2:	80 91 13 5f 	lds	r24, 0x5F13	; 0x805f13 <heap+0x1>
    38a6:	8f 93       	push	r24
    38a8:	80 91 12 5f 	lds	r24, 0x5F12	; 0x805f12 <heap>
    38ac:	8f 93       	push	r24
    38ae:	1f 93       	push	r17
    38b0:	0f 93       	push	r16
    38b2:	1f 92       	push	r1
    38b4:	7f 92       	push	r7
    38b6:	df 93       	push	r29
    38b8:	cf 93       	push	r28
    38ba:	19 d2       	rcall	.+1074   	; 0x3cee <snprintf>
    38bc:	ce 01       	movw	r24, r28
    38be:	b8 df       	rcall	.-144    	; 0x3830 <sendString>
    38c0:	80 91 1c 5f 	lds	r24, 0x5F1C	; 0x805f1c <command>
    38c4:	90 91 1d 5f 	lds	r25, 0x5F1D	; 0x805f1d <command+0x1>
    38c8:	80 93 1a 5f 	sts	0x5F1A, r24	; 0x805f1a <lastReq>
    38cc:	90 93 1b 5f 	sts	0x5F1B, r25	; 0x805f1b <lastReq+0x1>
    38d0:	8d b7       	in	r24, 0x3d	; 61
    38d2:	9e b7       	in	r25, 0x3e	; 62
    38d4:	08 96       	adiw	r24, 0x08	; 8
    38d6:	8d bf       	out	0x3d, r24	; 61
    38d8:	9e bf       	out	0x3e, r25	; 62
    38da:	cb c0       	rjmp	.+406    	; 0x3a72 <testUsart+0x21e>
    38dc:	82 30       	cpi	r24, 0x02	; 2
    38de:	91 05       	cpc	r25, r1
    38e0:	b9 f4       	brne	.+46     	; 0x3910 <testUsart+0xbc>
    38e2:	80 91 14 5f 	lds	r24, 0x5F14	; 0x805f14 <qtouchtest>
    38e6:	90 91 15 5f 	lds	r25, 0x5F15	; 0x805f15 <qtouchtest+0x1>
    38ea:	18 16       	cp	r1, r24
    38ec:	19 06       	cpc	r1, r25
    38ee:	24 f4       	brge	.+8      	; 0x38f8 <testUsart+0xa4>
    38f0:	89 e6       	ldi	r24, 0x69	; 105
    38f2:	90 e2       	ldi	r25, 0x20	; 32
    38f4:	9d df       	rcall	.-198    	; 0x3830 <sendString>
    38f6:	03 c0       	rjmp	.+6      	; 0x38fe <testUsart+0xaa>
    38f8:	89 e8       	ldi	r24, 0x89	; 137
    38fa:	90 e2       	ldi	r25, 0x20	; 32
    38fc:	99 df       	rcall	.-206    	; 0x3830 <sendString>
    38fe:	80 91 1c 5f 	lds	r24, 0x5F1C	; 0x805f1c <command>
    3902:	90 91 1d 5f 	lds	r25, 0x5F1D	; 0x805f1d <command+0x1>
    3906:	80 93 1a 5f 	sts	0x5F1A, r24	; 0x805f1a <lastReq>
    390a:	90 93 1b 5f 	sts	0x5F1B, r25	; 0x805f1b <lastReq+0x1>
    390e:	b1 c0       	rjmp	.+354    	; 0x3a72 <testUsart+0x21e>
    3910:	83 30       	cpi	r24, 0x03	; 3
    3912:	91 05       	cpc	r25, r1
    3914:	91 f5       	brne	.+100    	; 0x397a <testUsart+0x126>
    3916:	80 91 1e 5f 	lds	r24, 0x5F1E	; 0x805f1e <result2>
    391a:	90 91 1f 5f 	lds	r25, 0x5F1F	; 0x805f1f <result2+0x1>
    391e:	81 3d       	cpi	r24, 0xD1	; 209
    3920:	27 e0       	ldi	r18, 0x07	; 7
    3922:	92 07       	cpc	r25, r18
    3924:	88 f4       	brcc	.+34     	; 0x3948 <testUsart+0xf4>
    3926:	9f 93       	push	r25
    3928:	8f 93       	push	r24
    392a:	ff 92       	push	r15
    392c:	ef 92       	push	r14
    392e:	1f 92       	push	r1
    3930:	7f 92       	push	r7
    3932:	df 93       	push	r29
    3934:	cf 93       	push	r28
    3936:	db d1       	rcall	.+950    	; 0x3cee <snprintf>
    3938:	ce 01       	movw	r24, r28
    393a:	7a df       	rcall	.-268    	; 0x3830 <sendString>
    393c:	8d b7       	in	r24, 0x3d	; 61
    393e:	9e b7       	in	r25, 0x3e	; 62
    3940:	08 96       	adiw	r24, 0x08	; 8
    3942:	8d bf       	out	0x3d, r24	; 61
    3944:	9e bf       	out	0x3e, r25	; 62
    3946:	10 c0       	rjmp	.+32     	; 0x3968 <testUsart+0x114>
    3948:	9f 93       	push	r25
    394a:	8f 93       	push	r24
    394c:	df 92       	push	r13
    394e:	cf 92       	push	r12
    3950:	1f 92       	push	r1
    3952:	7f 92       	push	r7
    3954:	df 93       	push	r29
    3956:	cf 93       	push	r28
    3958:	ca d1       	rcall	.+916    	; 0x3cee <snprintf>
    395a:	ce 01       	movw	r24, r28
    395c:	69 df       	rcall	.-302    	; 0x3830 <sendString>
    395e:	8d b7       	in	r24, 0x3d	; 61
    3960:	9e b7       	in	r25, 0x3e	; 62
    3962:	08 96       	adiw	r24, 0x08	; 8
    3964:	8d bf       	out	0x3d, r24	; 61
    3966:	9e bf       	out	0x3e, r25	; 62
    3968:	80 91 1c 5f 	lds	r24, 0x5F1C	; 0x805f1c <command>
    396c:	90 91 1d 5f 	lds	r25, 0x5F1D	; 0x805f1d <command+0x1>
    3970:	80 93 1a 5f 	sts	0x5F1A, r24	; 0x805f1a <lastReq>
    3974:	90 93 1b 5f 	sts	0x5F1B, r25	; 0x805f1b <lastReq+0x1>
    3978:	7c c0       	rjmp	.+248    	; 0x3a72 <testUsart+0x21e>
    397a:	84 30       	cpi	r24, 0x04	; 4
    397c:	91 05       	cpc	r25, r1
    397e:	91 f5       	brne	.+100    	; 0x39e4 <testUsart+0x190>
    3980:	80 91 20 5f 	lds	r24, 0x5F20	; 0x805f20 <result>
    3984:	90 91 21 5f 	lds	r25, 0x5F21	; 0x805f21 <result+0x1>
    3988:	81 3d       	cpi	r24, 0xD1	; 209
    398a:	27 e0       	ldi	r18, 0x07	; 7
    398c:	92 07       	cpc	r25, r18
    398e:	88 f4       	brcc	.+34     	; 0x39b2 <testUsart+0x15e>
    3990:	9f 93       	push	r25
    3992:	8f 93       	push	r24
    3994:	9f 92       	push	r9
    3996:	8f 92       	push	r8
    3998:	1f 92       	push	r1
    399a:	7f 92       	push	r7
    399c:	df 93       	push	r29
    399e:	cf 93       	push	r28
    39a0:	a6 d1       	rcall	.+844    	; 0x3cee <snprintf>
    39a2:	ce 01       	movw	r24, r28
    39a4:	45 df       	rcall	.-374    	; 0x3830 <sendString>
    39a6:	8d b7       	in	r24, 0x3d	; 61
    39a8:	9e b7       	in	r25, 0x3e	; 62
    39aa:	08 96       	adiw	r24, 0x08	; 8
    39ac:	8d bf       	out	0x3d, r24	; 61
    39ae:	9e bf       	out	0x3e, r25	; 62
    39b0:	10 c0       	rjmp	.+32     	; 0x39d2 <testUsart+0x17e>
    39b2:	9f 93       	push	r25
    39b4:	8f 93       	push	r24
    39b6:	bf 92       	push	r11
    39b8:	af 92       	push	r10
    39ba:	1f 92       	push	r1
    39bc:	7f 92       	push	r7
    39be:	df 93       	push	r29
    39c0:	cf 93       	push	r28
    39c2:	95 d1       	rcall	.+810    	; 0x3cee <snprintf>
    39c4:	ce 01       	movw	r24, r28
    39c6:	34 df       	rcall	.-408    	; 0x3830 <sendString>
    39c8:	8d b7       	in	r24, 0x3d	; 61
    39ca:	9e b7       	in	r25, 0x3e	; 62
    39cc:	08 96       	adiw	r24, 0x08	; 8
    39ce:	8d bf       	out	0x3d, r24	; 61
    39d0:	9e bf       	out	0x3e, r25	; 62
    39d2:	80 91 1c 5f 	lds	r24, 0x5F1C	; 0x805f1c <command>
    39d6:	90 91 1d 5f 	lds	r25, 0x5F1D	; 0x805f1d <command+0x1>
    39da:	80 93 1a 5f 	sts	0x5F1A, r24	; 0x805f1a <lastReq>
    39de:	90 93 1b 5f 	sts	0x5F1B, r25	; 0x805f1b <lastReq+0x1>
    39e2:	47 c0       	rjmp	.+142    	; 0x3a72 <testUsart+0x21e>
    39e4:	85 30       	cpi	r24, 0x05	; 5
    39e6:	91 05       	cpc	r25, r1
    39e8:	b9 f4       	brne	.+46     	; 0x3a18 <testUsart+0x1c4>
    39ea:	80 91 16 5f 	lds	r24, 0x5F16	; 0x805f16 <servotest>
    39ee:	90 91 17 5f 	lds	r25, 0x5F17	; 0x805f17 <servotest+0x1>
    39f2:	18 16       	cp	r1, r24
    39f4:	19 06       	cpc	r1, r25
    39f6:	24 f4       	brge	.+8      	; 0x3a00 <testUsart+0x1ac>
    39f8:	8c e7       	ldi	r24, 0x7C	; 124
    39fa:	91 e2       	ldi	r25, 0x21	; 33
    39fc:	19 df       	rcall	.-462    	; 0x3830 <sendString>
    39fe:	03 c0       	rjmp	.+6      	; 0x3a06 <testUsart+0x1b2>
    3a00:	86 e9       	ldi	r24, 0x96	; 150
    3a02:	91 e2       	ldi	r25, 0x21	; 33
    3a04:	15 df       	rcall	.-470    	; 0x3830 <sendString>
    3a06:	80 91 1c 5f 	lds	r24, 0x5F1C	; 0x805f1c <command>
    3a0a:	90 91 1d 5f 	lds	r25, 0x5F1D	; 0x805f1d <command+0x1>
    3a0e:	80 93 1a 5f 	sts	0x5F1A, r24	; 0x805f1a <lastReq>
    3a12:	90 93 1b 5f 	sts	0x5F1B, r25	; 0x805f1b <lastReq+0x1>
    3a16:	2d c0       	rjmp	.+90     	; 0x3a72 <testUsart+0x21e>
    3a18:	06 97       	sbiw	r24, 0x06	; 6
    3a1a:	59 f5       	brne	.+86     	; 0x3a72 <testUsart+0x21e>
    3a1c:	80 91 14 5f 	lds	r24, 0x5F14	; 0x805f14 <qtouchtest>
    3a20:	90 91 15 5f 	lds	r25, 0x5F15	; 0x805f15 <qtouchtest+0x1>
    3a24:	18 16       	cp	r1, r24
    3a26:	19 06       	cpc	r1, r25
    3a28:	cc f4       	brge	.+50     	; 0x3a5c <testUsart+0x208>
    3a2a:	80 91 1e 5f 	lds	r24, 0x5F1E	; 0x805f1e <result2>
    3a2e:	90 91 1f 5f 	lds	r25, 0x5F1F	; 0x805f1f <result2+0x1>
    3a32:	81 3d       	cpi	r24, 0xD1	; 209
    3a34:	97 40       	sbci	r25, 0x07	; 7
    3a36:	90 f4       	brcc	.+36     	; 0x3a5c <testUsart+0x208>
    3a38:	80 91 20 5f 	lds	r24, 0x5F20	; 0x805f20 <result>
    3a3c:	90 91 21 5f 	lds	r25, 0x5F21	; 0x805f21 <result+0x1>
    3a40:	81 3d       	cpi	r24, 0xD1	; 209
    3a42:	97 40       	sbci	r25, 0x07	; 7
    3a44:	58 f4       	brcc	.+22     	; 0x3a5c <testUsart+0x208>
    3a46:	80 91 16 5f 	lds	r24, 0x5F16	; 0x805f16 <servotest>
    3a4a:	90 91 17 5f 	lds	r25, 0x5F17	; 0x805f17 <servotest+0x1>
    3a4e:	18 16       	cp	r1, r24
    3a50:	19 06       	cpc	r1, r25
    3a52:	24 f4       	brge	.+8      	; 0x3a5c <testUsart+0x208>
    3a54:	80 eb       	ldi	r24, 0xB0	; 176
    3a56:	91 e2       	ldi	r25, 0x21	; 33
    3a58:	eb de       	rcall	.-554    	; 0x3830 <sendString>
    3a5a:	03 c0       	rjmp	.+6      	; 0x3a62 <testUsart+0x20e>
    3a5c:	87 ec       	ldi	r24, 0xC7	; 199
    3a5e:	91 e2       	ldi	r25, 0x21	; 33
    3a60:	e7 de       	rcall	.-562    	; 0x3830 <sendString>
    3a62:	80 91 1c 5f 	lds	r24, 0x5F1C	; 0x805f1c <command>
    3a66:	90 91 1d 5f 	lds	r25, 0x5F1D	; 0x805f1d <command+0x1>
    3a6a:	80 93 1a 5f 	sts	0x5F1A, r24	; 0x805f1a <lastReq>
    3a6e:	90 93 1b 5f 	sts	0x5F1B, r25	; 0x805f1b <lastReq+0x1>
    3a72:	10 92 1c 5f 	sts	0x5F1C, r1	; 0x805f1c <command>
    3a76:	10 92 1d 5f 	sts	0x5F1D, r1	; 0x805f1d <command+0x1>
    3a7a:	85 e0       	ldi	r24, 0x05	; 5
    3a7c:	90 e0       	ldi	r25, 0x00	; 0
    3a7e:	45 d9       	rcall	.-3446   	; 0x2d0a <vTaskDelay>
    3a80:	09 cf       	rjmp	.-494    	; 0x3894 <testUsart+0x40>

00003a82 <receiveChar>:
    3a82:	e1 ea       	ldi	r30, 0xA1	; 161
    3a84:	fa e0       	ldi	r31, 0x0A	; 10
    3a86:	80 81       	ld	r24, Z
    3a88:	88 23       	and	r24, r24
    3a8a:	ec f7       	brge	.-6      	; 0x3a86 <receiveChar+0x4>
    3a8c:	80 91 a0 0a 	lds	r24, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    3a90:	08 95       	ret

00003a92 <testRead>:
    3a92:	f7 df       	rcall	.-18     	; 0x3a82 <receiveChar>
    3a94:	08 2e       	mov	r0, r24
    3a96:	00 0c       	add	r0, r0
    3a98:	99 0b       	sbc	r25, r25
    3a9a:	c0 97       	sbiw	r24, 0x30	; 48
    3a9c:	80 93 1c 5f 	sts	0x5F1C, r24	; 0x805f1c <command>
    3aa0:	90 93 1d 5f 	sts	0x5F1D, r25	; 0x805f1d <command+0x1>
    3aa4:	85 e0       	ldi	r24, 0x05	; 5
    3aa6:	90 e0       	ldi	r25, 0x00	; 0
    3aa8:	30 d9       	rcall	.-3488   	; 0x2d0a <vTaskDelay>
    3aaa:	f3 cf       	rjmp	.-26     	; 0x3a92 <testRead>

00003aac <main>:

int main (void)
{
    3aac:	8f 92       	push	r8
    3aae:	9f 92       	push	r9
    3ab0:	af 92       	push	r10
    3ab2:	bf 92       	push	r11
    3ab4:	cf 92       	push	r12
    3ab6:	df 92       	push	r13
    3ab8:	ef 92       	push	r14
    3aba:	ff 92       	push	r15
    3abc:	0f 93       	push	r16
    3abe:	1f 93       	push	r17
    3ac0:	cf 93       	push	r28
    3ac2:	df 93       	push	r29
    3ac4:	cd b7       	in	r28, 0x3d	; 61
    3ac6:	de b7       	in	r29, 0x3e	; 62
    3ac8:	2b 97       	sbiw	r28, 0x0b	; 11
    3aca:	cd bf       	out	0x3d, r28	; 61
    3acc:	de bf       	out	0x3e, r29	; 62
	//jalankan init pada main
	board_init();
    3ace:	e1 dc       	rcall	.-1598   	; 0x3492 <board_init>
 * Enables all interrupt levels, with vectors located in the application section
 * and fixed priority scheduling.
 */
static inline void pmic_init(void)
{
	PMIC.CTRL = PMIC_LVL_LOW | PMIC_LVL_MEDIUM |
    3ad0:	87 e0       	ldi	r24, 0x07	; 7
    3ad2:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
static void adc_init(void)
{
	struct adc_config adc_conf;
	struct adc_channel_config adcch_conf;

	adc_read_configuration(&MY_ADC, &adc_conf);
    3ad6:	be 01       	movw	r22, r28
    3ad8:	6f 5f       	subi	r22, 0xFF	; 255
    3ada:	7f 4f       	sbci	r23, 0xFF	; 255
    3adc:	80 e0       	ldi	r24, 0x00	; 0
    3ade:	92 e0       	ldi	r25, 0x02	; 2
    3ae0:	0e 94 3d 09 	call	0x127a	; 0x127a <adc_read_configuration>
	adcch_read_configuration(&MY_ADC, MY_ADC_CH, &adcch_conf);
    3ae4:	ae 01       	movw	r20, r28
    3ae6:	48 5f       	subi	r20, 0xF8	; 248
    3ae8:	5f 4f       	sbci	r21, 0xFF	; 255
    3aea:	61 e0       	ldi	r22, 0x01	; 1
    3aec:	80 e0       	ldi	r24, 0x00	; 0
    3aee:	92 e0       	ldi	r25, 0x02	; 2
    3af0:	0e 94 99 09 	call	0x1332	; 0x1332 <adcch_read_configuration>
static inline void adc_set_conversion_parameters(struct adc_config *conf,
		enum adc_sign sign, enum adc_resolution res,
		enum adc_reference ref)
{
	/* Preserve all but conversion and resolution config. */
	conf->ctrlb &= ~(ADC_CONMODE_bm | ADC_RESOLUTION_gm);
    3af4:	9a 81       	ldd	r25, Y+2	; 0x02
	conf->ctrlb |= (uint8_t)res | (uint8_t)sign;

	conf->refctrl &= ~ADC_REFSEL_gm;
    3af6:	8b 81       	ldd	r24, Y+3	; 0x03
    3af8:	8f 78       	andi	r24, 0x8F	; 143
	conf->refctrl |= ref;
    3afa:	80 61       	ori	r24, 0x10	; 16
    3afc:	8b 83       	std	Y+3, r24	; 0x03
	Assert(base_ev_ch <= 3);
#endif

	switch (trig) {
	case ADC_TRIG_MANUAL:
		conf->ctrlb &= ~ADC_FREERUN_bm;
    3afe:	89 2f       	mov	r24, r25
    3b00:	81 7e       	andi	r24, 0xE1	; 225
    3b02:	8a 83       	std	Y+2, r24	; 0x02
		conf->evctrl = ADC_EVACT_NONE_gc;
    3b04:	1c 82       	std	Y+4, r1	; 0x04
		psc = ADC_PRESCALER_DIV256_gc;
	} else {
		psc = ADC_PRESCALER_DIV512_gc;
	}

	conf->prescaler = psc;
    3b06:	02 e0       	ldi	r16, 0x02	; 2
    3b08:	0d 83       	std	Y+5, r16	; 0x05
				ADC_CH_MUXPOS_gp;
	} else if (neg == ADCCH_NEG_NONE) {
		/* Configure for single-ended measurement. */
		Assert(gain == 1);

		ch_conf->ctrl = ADC_CH_INPUTMODE_SINGLEENDED_gc;
    3b0a:	11 e0       	ldi	r17, 0x01	; 1
    3b0c:	18 87       	std	Y+8, r17	; 0x08
		ch_conf->muxctrl = pos << ADC_CH_MUXPOS_gp;
    3b0e:	80 e4       	ldi	r24, 0x40	; 64
    3b10:	89 87       	std	Y+9, r24	; 0x09
	adc_set_conversion_trigger(&adc_conf, ADC_TRIG_MANUAL, 1, 0);
	adc_set_clock_rate(&adc_conf, 200000UL);

	adcch_set_input(&adcch_conf, J2_PIN0, ADCCH_NEG_NONE, 1);

	adc_write_configuration(&MY_ADC, &adc_conf);
    3b12:	be 01       	movw	r22, r28
    3b14:	6f 5f       	subi	r22, 0xFF	; 255
    3b16:	7f 4f       	sbci	r23, 0xFF	; 255
    3b18:	80 e0       	ldi	r24, 0x00	; 0
    3b1a:	92 e0       	ldi	r25, 0x02	; 2
    3b1c:	0e 94 ed 08 	call	0x11da	; 0x11da <adc_write_configuration>
	adcch_write_configuration(&MY_ADC, MY_ADC_CH, &adcch_conf);
    3b20:	ae 01       	movw	r20, r28
    3b22:	48 5f       	subi	r20, 0xF8	; 248
    3b24:	5f 4f       	sbci	r21, 0xFF	; 255
    3b26:	61 e0       	ldi	r22, 0x01	; 1
    3b28:	80 e0       	ldi	r24, 0x00	; 0
    3b2a:	92 e0       	ldi	r25, 0x02	; 2
    3b2c:	0e 94 60 09 	call	0x12c0	; 0x12c0 <adcch_write_configuration>
static void adc_init2(void)
{
	struct adc_config adc_conf;
	struct adc_channel_config adcch_conf;

	adc_read_configuration(&MY_ADC2, &adc_conf);
    3b30:	be 01       	movw	r22, r28
    3b32:	6f 5f       	subi	r22, 0xFF	; 255
    3b34:	7f 4f       	sbci	r23, 0xFF	; 255
    3b36:	80 e0       	ldi	r24, 0x00	; 0
    3b38:	92 e0       	ldi	r25, 0x02	; 2
    3b3a:	0e 94 3d 09 	call	0x127a	; 0x127a <adc_read_configuration>
	adcch_read_configuration(&MY_ADC2, MY_ADC2_CH, &adcch_conf);
    3b3e:	ae 01       	movw	r20, r28
    3b40:	48 5f       	subi	r20, 0xF8	; 248
    3b42:	5f 4f       	sbci	r21, 0xFF	; 255
    3b44:	62 e0       	ldi	r22, 0x02	; 2
    3b46:	80 e0       	ldi	r24, 0x00	; 0
    3b48:	92 e0       	ldi	r25, 0x02	; 2
    3b4a:	0e 94 99 09 	call	0x1332	; 0x1332 <adcch_read_configuration>
static inline void adc_set_conversion_parameters(struct adc_config *conf,
		enum adc_sign sign, enum adc_resolution res,
		enum adc_reference ref)
{
	/* Preserve all but conversion and resolution config. */
	conf->ctrlb &= ~(ADC_CONMODE_bm | ADC_RESOLUTION_gm);
    3b4e:	9a 81       	ldd	r25, Y+2	; 0x02
	conf->ctrlb |= (uint8_t)res | (uint8_t)sign;

	conf->refctrl &= ~ADC_REFSEL_gm;
    3b50:	8b 81       	ldd	r24, Y+3	; 0x03
    3b52:	8f 78       	andi	r24, 0x8F	; 143
	conf->refctrl |= ref;
    3b54:	80 61       	ori	r24, 0x10	; 16
    3b56:	8b 83       	std	Y+3, r24	; 0x03
	Assert(base_ev_ch <= 3);
#endif

	switch (trig) {
	case ADC_TRIG_MANUAL:
		conf->ctrlb &= ~ADC_FREERUN_bm;
    3b58:	89 2f       	mov	r24, r25
    3b5a:	81 7e       	andi	r24, 0xE1	; 225
    3b5c:	8a 83       	std	Y+2, r24	; 0x02
		conf->evctrl = ADC_EVACT_NONE_gc;
    3b5e:	1c 82       	std	Y+4, r1	; 0x04
		psc = ADC_PRESCALER_DIV256_gc;
	} else {
		psc = ADC_PRESCALER_DIV512_gc;
	}

	conf->prescaler = psc;
    3b60:	0d 83       	std	Y+5, r16	; 0x05
				ADC_CH_MUXPOS_gp;
	} else if (neg == ADCCH_NEG_NONE) {
		/* Configure for single-ended measurement. */
		Assert(gain == 1);

		ch_conf->ctrl = ADC_CH_INPUTMODE_SINGLEENDED_gc;
    3b62:	18 87       	std	Y+8, r17	; 0x08
		ch_conf->muxctrl = pos << ADC_CH_MUXPOS_gp;
    3b64:	19 86       	std	Y+9, r1	; 0x09
	adc_set_conversion_trigger(&adc_conf, ADC_TRIG_MANUAL, 1, 0);
	adc_set_clock_rate(&adc_conf, 200000UL);

	adcch_set_input(&adcch_conf, J3_PIN0, ADCCH_NEG_NONE, 1);

	adc_write_configuration(&MY_ADC2, &adc_conf);
    3b66:	be 01       	movw	r22, r28
    3b68:	6f 5f       	subi	r22, 0xFF	; 255
    3b6a:	7f 4f       	sbci	r23, 0xFF	; 255
    3b6c:	80 e0       	ldi	r24, 0x00	; 0
    3b6e:	92 e0       	ldi	r25, 0x02	; 2
    3b70:	0e 94 ed 08 	call	0x11da	; 0x11da <adc_write_configuration>
	adcch_write_configuration(&MY_ADC2, MY_ADC2_CH, &adcch_conf);
    3b74:	ae 01       	movw	r20, r28
    3b76:	48 5f       	subi	r20, 0xF8	; 248
    3b78:	5f 4f       	sbci	r21, 0xFF	; 255
    3b7a:	62 e0       	ldi	r22, 0x02	; 2
    3b7c:	80 e0       	ldi	r24, 0x00	; 0
    3b7e:	92 e0       	ldi	r25, 0x02	; 2
    3b80:	0e 94 60 09 	call	0x12c0	; 0x12c0 <adcch_write_configuration>
	//jalankan init pada main
	board_init();
	pmic_init();
	adc_init();
	adc_init2();
	gfx_mono_init();
    3b84:	0e 94 e7 04 	call	0x9ce	; 0x9ce <gfx_mono_st7565r_init>
    3b88:	80 e1       	ldi	r24, 0x10	; 16
    3b8a:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
	ioport_set_pin_level(LCD_BACKLIGHT_ENABLE_PIN, 1);
	//set port untuk USARTE0
	PORTE_OUTSET = PIN3_bm; // PC3 as TX
    3b8e:	88 e0       	ldi	r24, 0x08	; 8
    3b90:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
	PORTE_DIRSET = PIN3_bm; //TX pin as output
    3b94:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <__TEXT_REGION_LENGTH__+0x700681>
	PORTE_OUTCLR = PIN2_bm; //PC2 as RX
    3b98:	84 e0       	ldi	r24, 0x04	; 4
    3b9a:	80 93 86 06 	sts	0x0686, r24	; 0x800686 <__TEXT_REGION_LENGTH__+0x700686>
	PORTE_DIRCLR = PIN2_bm; //RX pin as input
    3b9e:	80 93 82 06 	sts	0x0682, r24	; 0x800682 <__TEXT_REGION_LENGTH__+0x700682>
	setUpSerial();
    3ba2:	38 de       	rcall	.-912    	; 0x3814 <setUpSerial>
		.baudrate = USART_SERIAL_EXAMPLE_BAUDRATE,
		.charlength = USART_SERIAL_CHAR_LENGTH,
		.paritytype = USART_SERIAL_PARITY,
		.stopbits = USART_SERIAL_STOP_BIT
	};
	usart_init_rs232(USART_SERIAL_EXAMPLE, &USART_SERIAL_OPTIONS);
    3ba4:	67 e0       	ldi	r22, 0x07	; 7
    3ba6:	70 e2       	ldi	r23, 0x20	; 32
    3ba8:	80 ea       	ldi	r24, 0xA0	; 160
    3baa:	9a e0       	ldi	r25, 0x0A	; 10
    3bac:	0e 94 fd 0a 	call	0x15fa	; 0x15fa <usart_init_rs232>
	TimerHandle_t timerPing = xTimerCreate("tPing", 2/portTICK_PERIOD_MS, pdTRUE, (void *) 0, vTimerCallback);
    3bb0:	06 ee       	ldi	r16, 0xE6	; 230
    3bb2:	1a e1       	ldi	r17, 0x1A	; 26
    3bb4:	20 e0       	ldi	r18, 0x00	; 0
    3bb6:	30 e0       	ldi	r19, 0x00	; 0
    3bb8:	41 e0       	ldi	r20, 0x01	; 1
    3bba:	61 e0       	ldi	r22, 0x01	; 1
    3bbc:	70 e0       	ldi	r23, 0x00	; 0
    3bbe:	8c ee       	ldi	r24, 0xEC	; 236
    3bc0:	91 e2       	ldi	r25, 0x21	; 33
    3bc2:	7b da       	rcall	.-2826   	; 0x30ba <xTimerCreate>
    3bc4:	4c 01       	movw	r8, r24
	//create task
	xTaskCreate(testPotentio,"",500,NULL,1,NULL);
    3bc6:	a1 2c       	mov	r10, r1
    3bc8:	b1 2c       	mov	r11, r1
    3bca:	c1 2c       	mov	r12, r1
    3bcc:	d1 2c       	mov	r13, r1
    3bce:	e1 2c       	mov	r14, r1
    3bd0:	f1 2c       	mov	r15, r1
    3bd2:	01 e0       	ldi	r16, 0x01	; 1
    3bd4:	20 e0       	ldi	r18, 0x00	; 0
    3bd6:	30 e0       	ldi	r19, 0x00	; 0
    3bd8:	44 ef       	ldi	r20, 0xF4	; 244
    3bda:	51 e0       	ldi	r21, 0x01	; 1
    3bdc:	68 e8       	ldi	r22, 0x88	; 136
    3bde:	70 e2       	ldi	r23, 0x20	; 32
    3be0:	87 e8       	ldi	r24, 0x87	; 135
    3be2:	9b e1       	ldi	r25, 0x1B	; 27
    3be4:	0e 94 f0 13 	call	0x27e0	; 0x27e0 <xTaskGenericCreate>
	xTaskCreate(testServo,"",500,NULL,1,NULL);
    3be8:	20 e0       	ldi	r18, 0x00	; 0
    3bea:	30 e0       	ldi	r19, 0x00	; 0
    3bec:	44 ef       	ldi	r20, 0xF4	; 244
    3bee:	51 e0       	ldi	r21, 0x01	; 1
    3bf0:	68 e8       	ldi	r22, 0x88	; 136
    3bf2:	70 e2       	ldi	r23, 0x20	; 32
    3bf4:	8e ec       	ldi	r24, 0xCE	; 206
    3bf6:	9b e1       	ldi	r25, 0x1B	; 27
    3bf8:	0e 94 f0 13 	call	0x27e0	; 0x27e0 <xTaskGenericCreate>
	//xTaskCreate(testQtouch,"",500,NULL,1,NULL);
	//xTaskCreate(testLight,"",500,NULL,1,NULL);
	xTaskCreate(testRead,"",500,NULL,1,NULL);
    3bfc:	20 e0       	ldi	r18, 0x00	; 0
    3bfe:	30 e0       	ldi	r19, 0x00	; 0
    3c00:	44 ef       	ldi	r20, 0xF4	; 244
    3c02:	51 e0       	ldi	r21, 0x01	; 1
    3c04:	68 e8       	ldi	r22, 0x88	; 136
    3c06:	70 e2       	ldi	r23, 0x20	; 32
    3c08:	89 e4       	ldi	r24, 0x49	; 73
    3c0a:	9d e1       	ldi	r25, 0x1D	; 29
    3c0c:	0e 94 f0 13 	call	0x27e0	; 0x27e0 <xTaskGenericCreate>
	xTaskCreate(testHeap,"",500,NULL,1,NULL);
    3c10:	20 e0       	ldi	r18, 0x00	; 0
    3c12:	30 e0       	ldi	r19, 0x00	; 0
    3c14:	44 ef       	ldi	r20, 0xF4	; 244
    3c16:	51 e0       	ldi	r21, 0x01	; 1
    3c18:	68 e8       	ldi	r22, 0x88	; 136
    3c1a:	70 e2       	ldi	r23, 0x20	; 32
    3c1c:	8d e7       	ldi	r24, 0x7D	; 125
    3c1e:	9b e1       	ldi	r25, 0x1B	; 27
    3c20:	0e 94 f0 13 	call	0x27e0	; 0x27e0 <xTaskGenericCreate>
	xTaskCreate(testUsart,"",500,NULL,1,NULL);
    3c24:	20 e0       	ldi	r18, 0x00	; 0
    3c26:	30 e0       	ldi	r19, 0x00	; 0
    3c28:	44 ef       	ldi	r20, 0xF4	; 244
    3c2a:	51 e0       	ldi	r21, 0x01	; 1
    3c2c:	68 e8       	ldi	r22, 0x88	; 136
    3c2e:	70 e2       	ldi	r23, 0x20	; 32
    3c30:	8a e2       	ldi	r24, 0x2A	; 42
    3c32:	9c e1       	ldi	r25, 0x1C	; 28
    3c34:	0e 94 f0 13 	call	0x27e0	; 0x27e0 <xTaskGenericCreate>
	xTaskCreate(testLCD,"",500,NULL,1,NULL);
    3c38:	20 e0       	ldi	r18, 0x00	; 0
    3c3a:	30 e0       	ldi	r19, 0x00	; 0
    3c3c:	44 ef       	ldi	r20, 0xF4	; 244
    3c3e:	51 e0       	ldi	r21, 0x01	; 1
    3c40:	68 e8       	ldi	r22, 0x88	; 136
    3c42:	70 e2       	ldi	r23, 0x20	; 32
    3c44:	8a ef       	ldi	r24, 0xFA	; 250
    3c46:	9a e1       	ldi	r25, 0x1A	; 26
    3c48:	0e 94 f0 13 	call	0x27e0	; 0x27e0 <xTaskGenericCreate>
	//xTaskCreate(resetAll,"",500,NULL,1,NULL); //jika dibutuhkan reset
	xTimerStart(timerPing, 0);
    3c4c:	0e 94 2a 15 	call	0x2a54	; 0x2a54 <xTaskGetTickCount>
    3c50:	00 e0       	ldi	r16, 0x00	; 0
    3c52:	10 e0       	ldi	r17, 0x00	; 0
    3c54:	20 e0       	ldi	r18, 0x00	; 0
    3c56:	30 e0       	ldi	r19, 0x00	; 0
    3c58:	ac 01       	movw	r20, r24
    3c5a:	61 e0       	ldi	r22, 0x01	; 1
    3c5c:	c4 01       	movw	r24, r8
    3c5e:	64 da       	rcall	.-2872   	; 0x3128 <xTimerGenericCommand>
	vTaskStartScheduler();
    3c60:	0e 94 f1 14 	call	0x29e2	; 0x29e2 <vTaskStartScheduler>

	// Insert application code here, after the board has been initialized.
}
    3c64:	80 e0       	ldi	r24, 0x00	; 0
    3c66:	90 e0       	ldi	r25, 0x00	; 0
    3c68:	2b 96       	adiw	r28, 0x0b	; 11
    3c6a:	cd bf       	out	0x3d, r28	; 61
    3c6c:	de bf       	out	0x3e, r29	; 62
    3c6e:	df 91       	pop	r29
    3c70:	cf 91       	pop	r28
    3c72:	1f 91       	pop	r17
    3c74:	0f 91       	pop	r16
    3c76:	ff 90       	pop	r15
    3c78:	ef 90       	pop	r14
    3c7a:	df 90       	pop	r13
    3c7c:	cf 90       	pop	r12
    3c7e:	bf 90       	pop	r11
    3c80:	af 90       	pop	r10
    3c82:	9f 90       	pop	r9
    3c84:	8f 90       	pop	r8
    3c86:	08 95       	ret

00003c88 <__udivmodsi4>:
    3c88:	a1 e2       	ldi	r26, 0x21	; 33
    3c8a:	1a 2e       	mov	r1, r26
    3c8c:	aa 1b       	sub	r26, r26
    3c8e:	bb 1b       	sub	r27, r27
    3c90:	fd 01       	movw	r30, r26
    3c92:	0d c0       	rjmp	.+26     	; 0x3cae <__udivmodsi4_ep>

00003c94 <__udivmodsi4_loop>:
    3c94:	aa 1f       	adc	r26, r26
    3c96:	bb 1f       	adc	r27, r27
    3c98:	ee 1f       	adc	r30, r30
    3c9a:	ff 1f       	adc	r31, r31
    3c9c:	a2 17       	cp	r26, r18
    3c9e:	b3 07       	cpc	r27, r19
    3ca0:	e4 07       	cpc	r30, r20
    3ca2:	f5 07       	cpc	r31, r21
    3ca4:	20 f0       	brcs	.+8      	; 0x3cae <__udivmodsi4_ep>
    3ca6:	a2 1b       	sub	r26, r18
    3ca8:	b3 0b       	sbc	r27, r19
    3caa:	e4 0b       	sbc	r30, r20
    3cac:	f5 0b       	sbc	r31, r21

00003cae <__udivmodsi4_ep>:
    3cae:	66 1f       	adc	r22, r22
    3cb0:	77 1f       	adc	r23, r23
    3cb2:	88 1f       	adc	r24, r24
    3cb4:	99 1f       	adc	r25, r25
    3cb6:	1a 94       	dec	r1
    3cb8:	69 f7       	brne	.-38     	; 0x3c94 <__udivmodsi4_loop>
    3cba:	60 95       	com	r22
    3cbc:	70 95       	com	r23
    3cbe:	80 95       	com	r24
    3cc0:	90 95       	com	r25
    3cc2:	9b 01       	movw	r18, r22
    3cc4:	ac 01       	movw	r20, r24
    3cc6:	bd 01       	movw	r22, r26
    3cc8:	cf 01       	movw	r24, r30
    3cca:	08 95       	ret

00003ccc <__tablejump2__>:
    3ccc:	ee 0f       	add	r30, r30
    3cce:	ff 1f       	adc	r31, r31
    3cd0:	88 1f       	adc	r24, r24
    3cd2:	8b bf       	out	0x3b, r24	; 59
    3cd4:	07 90       	elpm	r0, Z+
    3cd6:	f6 91       	elpm	r31, Z
    3cd8:	e0 2d       	mov	r30, r0
    3cda:	19 94       	eijmp

00003cdc <memcpy>:
    3cdc:	fb 01       	movw	r30, r22
    3cde:	dc 01       	movw	r26, r24
    3ce0:	02 c0       	rjmp	.+4      	; 0x3ce6 <memcpy+0xa>
    3ce2:	01 90       	ld	r0, Z+
    3ce4:	0d 92       	st	X+, r0
    3ce6:	41 50       	subi	r20, 0x01	; 1
    3ce8:	50 40       	sbci	r21, 0x00	; 0
    3cea:	d8 f7       	brcc	.-10     	; 0x3ce2 <memcpy+0x6>
    3cec:	08 95       	ret

00003cee <snprintf>:
    3cee:	0f 93       	push	r16
    3cf0:	1f 93       	push	r17
    3cf2:	cf 93       	push	r28
    3cf4:	df 93       	push	r29
    3cf6:	cd b7       	in	r28, 0x3d	; 61
    3cf8:	de b7       	in	r29, 0x3e	; 62
    3cfa:	2e 97       	sbiw	r28, 0x0e	; 14
    3cfc:	cd bf       	out	0x3d, r28	; 61
    3cfe:	de bf       	out	0x3e, r29	; 62
    3d00:	0e 89       	ldd	r16, Y+22	; 0x16
    3d02:	1f 89       	ldd	r17, Y+23	; 0x17
    3d04:	88 8d       	ldd	r24, Y+24	; 0x18
    3d06:	99 8d       	ldd	r25, Y+25	; 0x19
    3d08:	26 e0       	ldi	r18, 0x06	; 6
    3d0a:	2c 83       	std	Y+4, r18	; 0x04
    3d0c:	09 83       	std	Y+1, r16	; 0x01
    3d0e:	1a 83       	std	Y+2, r17	; 0x02
    3d10:	97 ff       	sbrs	r25, 7
    3d12:	02 c0       	rjmp	.+4      	; 0x3d18 <snprintf+0x2a>
    3d14:	80 e0       	ldi	r24, 0x00	; 0
    3d16:	90 e8       	ldi	r25, 0x80	; 128
    3d18:	01 97       	sbiw	r24, 0x01	; 1
    3d1a:	8d 83       	std	Y+5, r24	; 0x05
    3d1c:	9e 83       	std	Y+6, r25	; 0x06
    3d1e:	ae 01       	movw	r20, r28
    3d20:	44 5e       	subi	r20, 0xE4	; 228
    3d22:	5f 4f       	sbci	r21, 0xFF	; 255
    3d24:	6a 8d       	ldd	r22, Y+26	; 0x1a
    3d26:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3d28:	ce 01       	movw	r24, r28
    3d2a:	01 96       	adiw	r24, 0x01	; 1
    3d2c:	16 d0       	rcall	.+44     	; 0x3d5a <vfprintf>
    3d2e:	4d 81       	ldd	r20, Y+5	; 0x05
    3d30:	5e 81       	ldd	r21, Y+6	; 0x06
    3d32:	57 fd       	sbrc	r21, 7
    3d34:	0a c0       	rjmp	.+20     	; 0x3d4a <snprintf+0x5c>
    3d36:	2f 81       	ldd	r18, Y+7	; 0x07
    3d38:	38 85       	ldd	r19, Y+8	; 0x08
    3d3a:	42 17       	cp	r20, r18
    3d3c:	53 07       	cpc	r21, r19
    3d3e:	0c f4       	brge	.+2      	; 0x3d42 <snprintf+0x54>
    3d40:	9a 01       	movw	r18, r20
    3d42:	f8 01       	movw	r30, r16
    3d44:	e2 0f       	add	r30, r18
    3d46:	f3 1f       	adc	r31, r19
    3d48:	10 82       	st	Z, r1
    3d4a:	2e 96       	adiw	r28, 0x0e	; 14
    3d4c:	cd bf       	out	0x3d, r28	; 61
    3d4e:	de bf       	out	0x3e, r29	; 62
    3d50:	df 91       	pop	r29
    3d52:	cf 91       	pop	r28
    3d54:	1f 91       	pop	r17
    3d56:	0f 91       	pop	r16
    3d58:	08 95       	ret

00003d5a <vfprintf>:
    3d5a:	2f 92       	push	r2
    3d5c:	3f 92       	push	r3
    3d5e:	4f 92       	push	r4
    3d60:	5f 92       	push	r5
    3d62:	6f 92       	push	r6
    3d64:	7f 92       	push	r7
    3d66:	8f 92       	push	r8
    3d68:	9f 92       	push	r9
    3d6a:	af 92       	push	r10
    3d6c:	bf 92       	push	r11
    3d6e:	cf 92       	push	r12
    3d70:	df 92       	push	r13
    3d72:	ef 92       	push	r14
    3d74:	ff 92       	push	r15
    3d76:	0f 93       	push	r16
    3d78:	1f 93       	push	r17
    3d7a:	cf 93       	push	r28
    3d7c:	df 93       	push	r29
    3d7e:	cd b7       	in	r28, 0x3d	; 61
    3d80:	de b7       	in	r29, 0x3e	; 62
    3d82:	2c 97       	sbiw	r28, 0x0c	; 12
    3d84:	cd bf       	out	0x3d, r28	; 61
    3d86:	de bf       	out	0x3e, r29	; 62
    3d88:	7c 01       	movw	r14, r24
    3d8a:	6b 01       	movw	r12, r22
    3d8c:	8a 01       	movw	r16, r20
    3d8e:	fc 01       	movw	r30, r24
    3d90:	16 82       	std	Z+6, r1	; 0x06
    3d92:	17 82       	std	Z+7, r1	; 0x07
    3d94:	83 81       	ldd	r24, Z+3	; 0x03
    3d96:	81 ff       	sbrs	r24, 1
    3d98:	b0 c1       	rjmp	.+864    	; 0x40fa <vfprintf+0x3a0>
    3d9a:	ce 01       	movw	r24, r28
    3d9c:	01 96       	adiw	r24, 0x01	; 1
    3d9e:	4c 01       	movw	r8, r24
    3da0:	f7 01       	movw	r30, r14
    3da2:	93 81       	ldd	r25, Z+3	; 0x03
    3da4:	f6 01       	movw	r30, r12
    3da6:	93 fd       	sbrc	r25, 3
    3da8:	85 91       	lpm	r24, Z+
    3daa:	93 ff       	sbrs	r25, 3
    3dac:	81 91       	ld	r24, Z+
    3dae:	6f 01       	movw	r12, r30
    3db0:	88 23       	and	r24, r24
    3db2:	09 f4       	brne	.+2      	; 0x3db6 <vfprintf+0x5c>
    3db4:	9e c1       	rjmp	.+828    	; 0x40f2 <vfprintf+0x398>
    3db6:	85 32       	cpi	r24, 0x25	; 37
    3db8:	39 f4       	brne	.+14     	; 0x3dc8 <vfprintf+0x6e>
    3dba:	93 fd       	sbrc	r25, 3
    3dbc:	85 91       	lpm	r24, Z+
    3dbe:	93 ff       	sbrs	r25, 3
    3dc0:	81 91       	ld	r24, Z+
    3dc2:	6f 01       	movw	r12, r30
    3dc4:	85 32       	cpi	r24, 0x25	; 37
    3dc6:	21 f4       	brne	.+8      	; 0x3dd0 <vfprintf+0x76>
    3dc8:	b7 01       	movw	r22, r14
    3dca:	90 e0       	ldi	r25, 0x00	; 0
    3dcc:	c4 d1       	rcall	.+904    	; 0x4156 <fputc>
    3dce:	e8 cf       	rjmp	.-48     	; 0x3da0 <vfprintf+0x46>
    3dd0:	51 2c       	mov	r5, r1
    3dd2:	31 2c       	mov	r3, r1
    3dd4:	20 e0       	ldi	r18, 0x00	; 0
    3dd6:	20 32       	cpi	r18, 0x20	; 32
    3dd8:	a0 f4       	brcc	.+40     	; 0x3e02 <vfprintf+0xa8>
    3dda:	8b 32       	cpi	r24, 0x2B	; 43
    3ddc:	69 f0       	breq	.+26     	; 0x3df8 <vfprintf+0x9e>
    3dde:	30 f4       	brcc	.+12     	; 0x3dec <vfprintf+0x92>
    3de0:	80 32       	cpi	r24, 0x20	; 32
    3de2:	59 f0       	breq	.+22     	; 0x3dfa <vfprintf+0xa0>
    3de4:	83 32       	cpi	r24, 0x23	; 35
    3de6:	69 f4       	brne	.+26     	; 0x3e02 <vfprintf+0xa8>
    3de8:	20 61       	ori	r18, 0x10	; 16
    3dea:	2c c0       	rjmp	.+88     	; 0x3e44 <vfprintf+0xea>
    3dec:	8d 32       	cpi	r24, 0x2D	; 45
    3dee:	39 f0       	breq	.+14     	; 0x3dfe <vfprintf+0xa4>
    3df0:	80 33       	cpi	r24, 0x30	; 48
    3df2:	39 f4       	brne	.+14     	; 0x3e02 <vfprintf+0xa8>
    3df4:	21 60       	ori	r18, 0x01	; 1
    3df6:	26 c0       	rjmp	.+76     	; 0x3e44 <vfprintf+0xea>
    3df8:	22 60       	ori	r18, 0x02	; 2
    3dfa:	24 60       	ori	r18, 0x04	; 4
    3dfc:	23 c0       	rjmp	.+70     	; 0x3e44 <vfprintf+0xea>
    3dfe:	28 60       	ori	r18, 0x08	; 8
    3e00:	21 c0       	rjmp	.+66     	; 0x3e44 <vfprintf+0xea>
    3e02:	27 fd       	sbrc	r18, 7
    3e04:	27 c0       	rjmp	.+78     	; 0x3e54 <vfprintf+0xfa>
    3e06:	30 ed       	ldi	r19, 0xD0	; 208
    3e08:	38 0f       	add	r19, r24
    3e0a:	3a 30       	cpi	r19, 0x0A	; 10
    3e0c:	78 f4       	brcc	.+30     	; 0x3e2c <vfprintf+0xd2>
    3e0e:	26 ff       	sbrs	r18, 6
    3e10:	06 c0       	rjmp	.+12     	; 0x3e1e <vfprintf+0xc4>
    3e12:	fa e0       	ldi	r31, 0x0A	; 10
    3e14:	5f 9e       	mul	r5, r31
    3e16:	30 0d       	add	r19, r0
    3e18:	11 24       	eor	r1, r1
    3e1a:	53 2e       	mov	r5, r19
    3e1c:	13 c0       	rjmp	.+38     	; 0x3e44 <vfprintf+0xea>
    3e1e:	8a e0       	ldi	r24, 0x0A	; 10
    3e20:	38 9e       	mul	r3, r24
    3e22:	30 0d       	add	r19, r0
    3e24:	11 24       	eor	r1, r1
    3e26:	33 2e       	mov	r3, r19
    3e28:	20 62       	ori	r18, 0x20	; 32
    3e2a:	0c c0       	rjmp	.+24     	; 0x3e44 <vfprintf+0xea>
    3e2c:	8e 32       	cpi	r24, 0x2E	; 46
    3e2e:	21 f4       	brne	.+8      	; 0x3e38 <vfprintf+0xde>
    3e30:	26 fd       	sbrc	r18, 6
    3e32:	5f c1       	rjmp	.+702    	; 0x40f2 <vfprintf+0x398>
    3e34:	20 64       	ori	r18, 0x40	; 64
    3e36:	06 c0       	rjmp	.+12     	; 0x3e44 <vfprintf+0xea>
    3e38:	8c 36       	cpi	r24, 0x6C	; 108
    3e3a:	11 f4       	brne	.+4      	; 0x3e40 <vfprintf+0xe6>
    3e3c:	20 68       	ori	r18, 0x80	; 128
    3e3e:	02 c0       	rjmp	.+4      	; 0x3e44 <vfprintf+0xea>
    3e40:	88 36       	cpi	r24, 0x68	; 104
    3e42:	41 f4       	brne	.+16     	; 0x3e54 <vfprintf+0xfa>
    3e44:	f6 01       	movw	r30, r12
    3e46:	93 fd       	sbrc	r25, 3
    3e48:	85 91       	lpm	r24, Z+
    3e4a:	93 ff       	sbrs	r25, 3
    3e4c:	81 91       	ld	r24, Z+
    3e4e:	6f 01       	movw	r12, r30
    3e50:	81 11       	cpse	r24, r1
    3e52:	c1 cf       	rjmp	.-126    	; 0x3dd6 <vfprintf+0x7c>
    3e54:	98 2f       	mov	r25, r24
    3e56:	9f 7d       	andi	r25, 0xDF	; 223
    3e58:	95 54       	subi	r25, 0x45	; 69
    3e5a:	93 30       	cpi	r25, 0x03	; 3
    3e5c:	28 f4       	brcc	.+10     	; 0x3e68 <vfprintf+0x10e>
    3e5e:	0c 5f       	subi	r16, 0xFC	; 252
    3e60:	1f 4f       	sbci	r17, 0xFF	; 255
    3e62:	ff e3       	ldi	r31, 0x3F	; 63
    3e64:	f9 83       	std	Y+1, r31	; 0x01
    3e66:	0d c0       	rjmp	.+26     	; 0x3e82 <vfprintf+0x128>
    3e68:	83 36       	cpi	r24, 0x63	; 99
    3e6a:	31 f0       	breq	.+12     	; 0x3e78 <vfprintf+0x11e>
    3e6c:	83 37       	cpi	r24, 0x73	; 115
    3e6e:	71 f0       	breq	.+28     	; 0x3e8c <vfprintf+0x132>
    3e70:	83 35       	cpi	r24, 0x53	; 83
    3e72:	09 f0       	breq	.+2      	; 0x3e76 <vfprintf+0x11c>
    3e74:	57 c0       	rjmp	.+174    	; 0x3f24 <vfprintf+0x1ca>
    3e76:	21 c0       	rjmp	.+66     	; 0x3eba <vfprintf+0x160>
    3e78:	f8 01       	movw	r30, r16
    3e7a:	80 81       	ld	r24, Z
    3e7c:	89 83       	std	Y+1, r24	; 0x01
    3e7e:	0e 5f       	subi	r16, 0xFE	; 254
    3e80:	1f 4f       	sbci	r17, 0xFF	; 255
    3e82:	44 24       	eor	r4, r4
    3e84:	43 94       	inc	r4
    3e86:	51 2c       	mov	r5, r1
    3e88:	54 01       	movw	r10, r8
    3e8a:	14 c0       	rjmp	.+40     	; 0x3eb4 <vfprintf+0x15a>
    3e8c:	38 01       	movw	r6, r16
    3e8e:	f2 e0       	ldi	r31, 0x02	; 2
    3e90:	6f 0e       	add	r6, r31
    3e92:	71 1c       	adc	r7, r1
    3e94:	f8 01       	movw	r30, r16
    3e96:	a0 80       	ld	r10, Z
    3e98:	b1 80       	ldd	r11, Z+1	; 0x01
    3e9a:	26 ff       	sbrs	r18, 6
    3e9c:	03 c0       	rjmp	.+6      	; 0x3ea4 <vfprintf+0x14a>
    3e9e:	65 2d       	mov	r22, r5
    3ea0:	70 e0       	ldi	r23, 0x00	; 0
    3ea2:	02 c0       	rjmp	.+4      	; 0x3ea8 <vfprintf+0x14e>
    3ea4:	6f ef       	ldi	r22, 0xFF	; 255
    3ea6:	7f ef       	ldi	r23, 0xFF	; 255
    3ea8:	c5 01       	movw	r24, r10
    3eaa:	2c 87       	std	Y+12, r18	; 0x0c
    3eac:	49 d1       	rcall	.+658    	; 0x4140 <strnlen>
    3eae:	2c 01       	movw	r4, r24
    3eb0:	83 01       	movw	r16, r6
    3eb2:	2c 85       	ldd	r18, Y+12	; 0x0c
    3eb4:	2f 77       	andi	r18, 0x7F	; 127
    3eb6:	22 2e       	mov	r2, r18
    3eb8:	16 c0       	rjmp	.+44     	; 0x3ee6 <vfprintf+0x18c>
    3eba:	38 01       	movw	r6, r16
    3ebc:	f2 e0       	ldi	r31, 0x02	; 2
    3ebe:	6f 0e       	add	r6, r31
    3ec0:	71 1c       	adc	r7, r1
    3ec2:	f8 01       	movw	r30, r16
    3ec4:	a0 80       	ld	r10, Z
    3ec6:	b1 80       	ldd	r11, Z+1	; 0x01
    3ec8:	26 ff       	sbrs	r18, 6
    3eca:	03 c0       	rjmp	.+6      	; 0x3ed2 <vfprintf+0x178>
    3ecc:	65 2d       	mov	r22, r5
    3ece:	70 e0       	ldi	r23, 0x00	; 0
    3ed0:	02 c0       	rjmp	.+4      	; 0x3ed6 <vfprintf+0x17c>
    3ed2:	6f ef       	ldi	r22, 0xFF	; 255
    3ed4:	7f ef       	ldi	r23, 0xFF	; 255
    3ed6:	c5 01       	movw	r24, r10
    3ed8:	2c 87       	std	Y+12, r18	; 0x0c
    3eda:	27 d1       	rcall	.+590    	; 0x412a <strnlen_P>
    3edc:	2c 01       	movw	r4, r24
    3ede:	2c 85       	ldd	r18, Y+12	; 0x0c
    3ee0:	20 68       	ori	r18, 0x80	; 128
    3ee2:	22 2e       	mov	r2, r18
    3ee4:	83 01       	movw	r16, r6
    3ee6:	23 fc       	sbrc	r2, 3
    3ee8:	19 c0       	rjmp	.+50     	; 0x3f1c <vfprintf+0x1c2>
    3eea:	83 2d       	mov	r24, r3
    3eec:	90 e0       	ldi	r25, 0x00	; 0
    3eee:	48 16       	cp	r4, r24
    3ef0:	59 06       	cpc	r5, r25
    3ef2:	a0 f4       	brcc	.+40     	; 0x3f1c <vfprintf+0x1c2>
    3ef4:	b7 01       	movw	r22, r14
    3ef6:	80 e2       	ldi	r24, 0x20	; 32
    3ef8:	90 e0       	ldi	r25, 0x00	; 0
    3efa:	2d d1       	rcall	.+602    	; 0x4156 <fputc>
    3efc:	3a 94       	dec	r3
    3efe:	f5 cf       	rjmp	.-22     	; 0x3eea <vfprintf+0x190>
    3f00:	f5 01       	movw	r30, r10
    3f02:	27 fc       	sbrc	r2, 7
    3f04:	85 91       	lpm	r24, Z+
    3f06:	27 fe       	sbrs	r2, 7
    3f08:	81 91       	ld	r24, Z+
    3f0a:	5f 01       	movw	r10, r30
    3f0c:	b7 01       	movw	r22, r14
    3f0e:	90 e0       	ldi	r25, 0x00	; 0
    3f10:	22 d1       	rcall	.+580    	; 0x4156 <fputc>
    3f12:	31 10       	cpse	r3, r1
    3f14:	3a 94       	dec	r3
    3f16:	f1 e0       	ldi	r31, 0x01	; 1
    3f18:	4f 1a       	sub	r4, r31
    3f1a:	51 08       	sbc	r5, r1
    3f1c:	41 14       	cp	r4, r1
    3f1e:	51 04       	cpc	r5, r1
    3f20:	79 f7       	brne	.-34     	; 0x3f00 <vfprintf+0x1a6>
    3f22:	de c0       	rjmp	.+444    	; 0x40e0 <vfprintf+0x386>
    3f24:	84 36       	cpi	r24, 0x64	; 100
    3f26:	11 f0       	breq	.+4      	; 0x3f2c <vfprintf+0x1d2>
    3f28:	89 36       	cpi	r24, 0x69	; 105
    3f2a:	31 f5       	brne	.+76     	; 0x3f78 <vfprintf+0x21e>
    3f2c:	f8 01       	movw	r30, r16
    3f2e:	27 ff       	sbrs	r18, 7
    3f30:	07 c0       	rjmp	.+14     	; 0x3f40 <vfprintf+0x1e6>
    3f32:	60 81       	ld	r22, Z
    3f34:	71 81       	ldd	r23, Z+1	; 0x01
    3f36:	82 81       	ldd	r24, Z+2	; 0x02
    3f38:	93 81       	ldd	r25, Z+3	; 0x03
    3f3a:	0c 5f       	subi	r16, 0xFC	; 252
    3f3c:	1f 4f       	sbci	r17, 0xFF	; 255
    3f3e:	08 c0       	rjmp	.+16     	; 0x3f50 <vfprintf+0x1f6>
    3f40:	60 81       	ld	r22, Z
    3f42:	71 81       	ldd	r23, Z+1	; 0x01
    3f44:	07 2e       	mov	r0, r23
    3f46:	00 0c       	add	r0, r0
    3f48:	88 0b       	sbc	r24, r24
    3f4a:	99 0b       	sbc	r25, r25
    3f4c:	0e 5f       	subi	r16, 0xFE	; 254
    3f4e:	1f 4f       	sbci	r17, 0xFF	; 255
    3f50:	2f 76       	andi	r18, 0x6F	; 111
    3f52:	72 2e       	mov	r7, r18
    3f54:	97 ff       	sbrs	r25, 7
    3f56:	09 c0       	rjmp	.+18     	; 0x3f6a <vfprintf+0x210>
    3f58:	90 95       	com	r25
    3f5a:	80 95       	com	r24
    3f5c:	70 95       	com	r23
    3f5e:	61 95       	neg	r22
    3f60:	7f 4f       	sbci	r23, 0xFF	; 255
    3f62:	8f 4f       	sbci	r24, 0xFF	; 255
    3f64:	9f 4f       	sbci	r25, 0xFF	; 255
    3f66:	20 68       	ori	r18, 0x80	; 128
    3f68:	72 2e       	mov	r7, r18
    3f6a:	2a e0       	ldi	r18, 0x0A	; 10
    3f6c:	30 e0       	ldi	r19, 0x00	; 0
    3f6e:	a4 01       	movw	r20, r8
    3f70:	2a d1       	rcall	.+596    	; 0x41c6 <__ultoa_invert>
    3f72:	a8 2e       	mov	r10, r24
    3f74:	a8 18       	sub	r10, r8
    3f76:	43 c0       	rjmp	.+134    	; 0x3ffe <vfprintf+0x2a4>
    3f78:	85 37       	cpi	r24, 0x75	; 117
    3f7a:	29 f4       	brne	.+10     	; 0x3f86 <vfprintf+0x22c>
    3f7c:	2f 7e       	andi	r18, 0xEF	; 239
    3f7e:	b2 2e       	mov	r11, r18
    3f80:	2a e0       	ldi	r18, 0x0A	; 10
    3f82:	30 e0       	ldi	r19, 0x00	; 0
    3f84:	25 c0       	rjmp	.+74     	; 0x3fd0 <vfprintf+0x276>
    3f86:	f2 2f       	mov	r31, r18
    3f88:	f9 7f       	andi	r31, 0xF9	; 249
    3f8a:	bf 2e       	mov	r11, r31
    3f8c:	8f 36       	cpi	r24, 0x6F	; 111
    3f8e:	c1 f0       	breq	.+48     	; 0x3fc0 <vfprintf+0x266>
    3f90:	18 f4       	brcc	.+6      	; 0x3f98 <vfprintf+0x23e>
    3f92:	88 35       	cpi	r24, 0x58	; 88
    3f94:	79 f0       	breq	.+30     	; 0x3fb4 <vfprintf+0x25a>
    3f96:	ad c0       	rjmp	.+346    	; 0x40f2 <vfprintf+0x398>
    3f98:	80 37       	cpi	r24, 0x70	; 112
    3f9a:	19 f0       	breq	.+6      	; 0x3fa2 <vfprintf+0x248>
    3f9c:	88 37       	cpi	r24, 0x78	; 120
    3f9e:	21 f0       	breq	.+8      	; 0x3fa8 <vfprintf+0x24e>
    3fa0:	a8 c0       	rjmp	.+336    	; 0x40f2 <vfprintf+0x398>
    3fa2:	2f 2f       	mov	r18, r31
    3fa4:	20 61       	ori	r18, 0x10	; 16
    3fa6:	b2 2e       	mov	r11, r18
    3fa8:	b4 fe       	sbrs	r11, 4
    3faa:	0d c0       	rjmp	.+26     	; 0x3fc6 <vfprintf+0x26c>
    3fac:	8b 2d       	mov	r24, r11
    3fae:	84 60       	ori	r24, 0x04	; 4
    3fb0:	b8 2e       	mov	r11, r24
    3fb2:	09 c0       	rjmp	.+18     	; 0x3fc6 <vfprintf+0x26c>
    3fb4:	24 ff       	sbrs	r18, 4
    3fb6:	0a c0       	rjmp	.+20     	; 0x3fcc <vfprintf+0x272>
    3fb8:	9f 2f       	mov	r25, r31
    3fba:	96 60       	ori	r25, 0x06	; 6
    3fbc:	b9 2e       	mov	r11, r25
    3fbe:	06 c0       	rjmp	.+12     	; 0x3fcc <vfprintf+0x272>
    3fc0:	28 e0       	ldi	r18, 0x08	; 8
    3fc2:	30 e0       	ldi	r19, 0x00	; 0
    3fc4:	05 c0       	rjmp	.+10     	; 0x3fd0 <vfprintf+0x276>
    3fc6:	20 e1       	ldi	r18, 0x10	; 16
    3fc8:	30 e0       	ldi	r19, 0x00	; 0
    3fca:	02 c0       	rjmp	.+4      	; 0x3fd0 <vfprintf+0x276>
    3fcc:	20 e1       	ldi	r18, 0x10	; 16
    3fce:	32 e0       	ldi	r19, 0x02	; 2
    3fd0:	f8 01       	movw	r30, r16
    3fd2:	b7 fe       	sbrs	r11, 7
    3fd4:	07 c0       	rjmp	.+14     	; 0x3fe4 <vfprintf+0x28a>
    3fd6:	60 81       	ld	r22, Z
    3fd8:	71 81       	ldd	r23, Z+1	; 0x01
    3fda:	82 81       	ldd	r24, Z+2	; 0x02
    3fdc:	93 81       	ldd	r25, Z+3	; 0x03
    3fde:	0c 5f       	subi	r16, 0xFC	; 252
    3fe0:	1f 4f       	sbci	r17, 0xFF	; 255
    3fe2:	06 c0       	rjmp	.+12     	; 0x3ff0 <vfprintf+0x296>
    3fe4:	60 81       	ld	r22, Z
    3fe6:	71 81       	ldd	r23, Z+1	; 0x01
    3fe8:	80 e0       	ldi	r24, 0x00	; 0
    3fea:	90 e0       	ldi	r25, 0x00	; 0
    3fec:	0e 5f       	subi	r16, 0xFE	; 254
    3fee:	1f 4f       	sbci	r17, 0xFF	; 255
    3ff0:	a4 01       	movw	r20, r8
    3ff2:	e9 d0       	rcall	.+466    	; 0x41c6 <__ultoa_invert>
    3ff4:	a8 2e       	mov	r10, r24
    3ff6:	a8 18       	sub	r10, r8
    3ff8:	fb 2d       	mov	r31, r11
    3ffa:	ff 77       	andi	r31, 0x7F	; 127
    3ffc:	7f 2e       	mov	r7, r31
    3ffe:	76 fe       	sbrs	r7, 6
    4000:	0b c0       	rjmp	.+22     	; 0x4018 <vfprintf+0x2be>
    4002:	37 2d       	mov	r19, r7
    4004:	3e 7f       	andi	r19, 0xFE	; 254
    4006:	a5 14       	cp	r10, r5
    4008:	50 f4       	brcc	.+20     	; 0x401e <vfprintf+0x2c4>
    400a:	74 fe       	sbrs	r7, 4
    400c:	0a c0       	rjmp	.+20     	; 0x4022 <vfprintf+0x2c8>
    400e:	72 fc       	sbrc	r7, 2
    4010:	08 c0       	rjmp	.+16     	; 0x4022 <vfprintf+0x2c8>
    4012:	37 2d       	mov	r19, r7
    4014:	3e 7e       	andi	r19, 0xEE	; 238
    4016:	05 c0       	rjmp	.+10     	; 0x4022 <vfprintf+0x2c8>
    4018:	ba 2c       	mov	r11, r10
    401a:	37 2d       	mov	r19, r7
    401c:	03 c0       	rjmp	.+6      	; 0x4024 <vfprintf+0x2ca>
    401e:	ba 2c       	mov	r11, r10
    4020:	01 c0       	rjmp	.+2      	; 0x4024 <vfprintf+0x2ca>
    4022:	b5 2c       	mov	r11, r5
    4024:	34 ff       	sbrs	r19, 4
    4026:	0d c0       	rjmp	.+26     	; 0x4042 <vfprintf+0x2e8>
    4028:	fe 01       	movw	r30, r28
    402a:	ea 0d       	add	r30, r10
    402c:	f1 1d       	adc	r31, r1
    402e:	80 81       	ld	r24, Z
    4030:	80 33       	cpi	r24, 0x30	; 48
    4032:	11 f4       	brne	.+4      	; 0x4038 <vfprintf+0x2de>
    4034:	39 7e       	andi	r19, 0xE9	; 233
    4036:	09 c0       	rjmp	.+18     	; 0x404a <vfprintf+0x2f0>
    4038:	32 ff       	sbrs	r19, 2
    403a:	06 c0       	rjmp	.+12     	; 0x4048 <vfprintf+0x2ee>
    403c:	b3 94       	inc	r11
    403e:	b3 94       	inc	r11
    4040:	04 c0       	rjmp	.+8      	; 0x404a <vfprintf+0x2f0>
    4042:	83 2f       	mov	r24, r19
    4044:	86 78       	andi	r24, 0x86	; 134
    4046:	09 f0       	breq	.+2      	; 0x404a <vfprintf+0x2f0>
    4048:	b3 94       	inc	r11
    404a:	33 fd       	sbrc	r19, 3
    404c:	12 c0       	rjmp	.+36     	; 0x4072 <vfprintf+0x318>
    404e:	30 ff       	sbrs	r19, 0
    4050:	06 c0       	rjmp	.+12     	; 0x405e <vfprintf+0x304>
    4052:	5a 2c       	mov	r5, r10
    4054:	b3 14       	cp	r11, r3
    4056:	18 f4       	brcc	.+6      	; 0x405e <vfprintf+0x304>
    4058:	53 0c       	add	r5, r3
    405a:	5b 18       	sub	r5, r11
    405c:	b3 2c       	mov	r11, r3
    405e:	b3 14       	cp	r11, r3
    4060:	60 f4       	brcc	.+24     	; 0x407a <vfprintf+0x320>
    4062:	b7 01       	movw	r22, r14
    4064:	80 e2       	ldi	r24, 0x20	; 32
    4066:	90 e0       	ldi	r25, 0x00	; 0
    4068:	3c 87       	std	Y+12, r19	; 0x0c
    406a:	75 d0       	rcall	.+234    	; 0x4156 <fputc>
    406c:	b3 94       	inc	r11
    406e:	3c 85       	ldd	r19, Y+12	; 0x0c
    4070:	f6 cf       	rjmp	.-20     	; 0x405e <vfprintf+0x304>
    4072:	b3 14       	cp	r11, r3
    4074:	10 f4       	brcc	.+4      	; 0x407a <vfprintf+0x320>
    4076:	3b 18       	sub	r3, r11
    4078:	01 c0       	rjmp	.+2      	; 0x407c <vfprintf+0x322>
    407a:	31 2c       	mov	r3, r1
    407c:	34 ff       	sbrs	r19, 4
    407e:	11 c0       	rjmp	.+34     	; 0x40a2 <vfprintf+0x348>
    4080:	b7 01       	movw	r22, r14
    4082:	80 e3       	ldi	r24, 0x30	; 48
    4084:	90 e0       	ldi	r25, 0x00	; 0
    4086:	3c 87       	std	Y+12, r19	; 0x0c
    4088:	66 d0       	rcall	.+204    	; 0x4156 <fputc>
    408a:	3c 85       	ldd	r19, Y+12	; 0x0c
    408c:	32 ff       	sbrs	r19, 2
    408e:	16 c0       	rjmp	.+44     	; 0x40bc <vfprintf+0x362>
    4090:	31 fd       	sbrc	r19, 1
    4092:	03 c0       	rjmp	.+6      	; 0x409a <vfprintf+0x340>
    4094:	88 e7       	ldi	r24, 0x78	; 120
    4096:	90 e0       	ldi	r25, 0x00	; 0
    4098:	02 c0       	rjmp	.+4      	; 0x409e <vfprintf+0x344>
    409a:	88 e5       	ldi	r24, 0x58	; 88
    409c:	90 e0       	ldi	r25, 0x00	; 0
    409e:	b7 01       	movw	r22, r14
    40a0:	0c c0       	rjmp	.+24     	; 0x40ba <vfprintf+0x360>
    40a2:	83 2f       	mov	r24, r19
    40a4:	86 78       	andi	r24, 0x86	; 134
    40a6:	51 f0       	breq	.+20     	; 0x40bc <vfprintf+0x362>
    40a8:	31 ff       	sbrs	r19, 1
    40aa:	02 c0       	rjmp	.+4      	; 0x40b0 <vfprintf+0x356>
    40ac:	8b e2       	ldi	r24, 0x2B	; 43
    40ae:	01 c0       	rjmp	.+2      	; 0x40b2 <vfprintf+0x358>
    40b0:	80 e2       	ldi	r24, 0x20	; 32
    40b2:	37 fd       	sbrc	r19, 7
    40b4:	8d e2       	ldi	r24, 0x2D	; 45
    40b6:	b7 01       	movw	r22, r14
    40b8:	90 e0       	ldi	r25, 0x00	; 0
    40ba:	4d d0       	rcall	.+154    	; 0x4156 <fputc>
    40bc:	a5 14       	cp	r10, r5
    40be:	30 f4       	brcc	.+12     	; 0x40cc <vfprintf+0x372>
    40c0:	b7 01       	movw	r22, r14
    40c2:	80 e3       	ldi	r24, 0x30	; 48
    40c4:	90 e0       	ldi	r25, 0x00	; 0
    40c6:	47 d0       	rcall	.+142    	; 0x4156 <fputc>
    40c8:	5a 94       	dec	r5
    40ca:	f8 cf       	rjmp	.-16     	; 0x40bc <vfprintf+0x362>
    40cc:	aa 94       	dec	r10
    40ce:	f4 01       	movw	r30, r8
    40d0:	ea 0d       	add	r30, r10
    40d2:	f1 1d       	adc	r31, r1
    40d4:	80 81       	ld	r24, Z
    40d6:	b7 01       	movw	r22, r14
    40d8:	90 e0       	ldi	r25, 0x00	; 0
    40da:	3d d0       	rcall	.+122    	; 0x4156 <fputc>
    40dc:	a1 10       	cpse	r10, r1
    40de:	f6 cf       	rjmp	.-20     	; 0x40cc <vfprintf+0x372>
    40e0:	33 20       	and	r3, r3
    40e2:	09 f4       	brne	.+2      	; 0x40e6 <vfprintf+0x38c>
    40e4:	5d ce       	rjmp	.-838    	; 0x3da0 <vfprintf+0x46>
    40e6:	b7 01       	movw	r22, r14
    40e8:	80 e2       	ldi	r24, 0x20	; 32
    40ea:	90 e0       	ldi	r25, 0x00	; 0
    40ec:	34 d0       	rcall	.+104    	; 0x4156 <fputc>
    40ee:	3a 94       	dec	r3
    40f0:	f7 cf       	rjmp	.-18     	; 0x40e0 <vfprintf+0x386>
    40f2:	f7 01       	movw	r30, r14
    40f4:	86 81       	ldd	r24, Z+6	; 0x06
    40f6:	97 81       	ldd	r25, Z+7	; 0x07
    40f8:	02 c0       	rjmp	.+4      	; 0x40fe <vfprintf+0x3a4>
    40fa:	8f ef       	ldi	r24, 0xFF	; 255
    40fc:	9f ef       	ldi	r25, 0xFF	; 255
    40fe:	2c 96       	adiw	r28, 0x0c	; 12
    4100:	cd bf       	out	0x3d, r28	; 61
    4102:	de bf       	out	0x3e, r29	; 62
    4104:	df 91       	pop	r29
    4106:	cf 91       	pop	r28
    4108:	1f 91       	pop	r17
    410a:	0f 91       	pop	r16
    410c:	ff 90       	pop	r15
    410e:	ef 90       	pop	r14
    4110:	df 90       	pop	r13
    4112:	cf 90       	pop	r12
    4114:	bf 90       	pop	r11
    4116:	af 90       	pop	r10
    4118:	9f 90       	pop	r9
    411a:	8f 90       	pop	r8
    411c:	7f 90       	pop	r7
    411e:	6f 90       	pop	r6
    4120:	5f 90       	pop	r5
    4122:	4f 90       	pop	r4
    4124:	3f 90       	pop	r3
    4126:	2f 90       	pop	r2
    4128:	08 95       	ret

0000412a <strnlen_P>:
    412a:	fc 01       	movw	r30, r24
    412c:	05 90       	lpm	r0, Z+
    412e:	61 50       	subi	r22, 0x01	; 1
    4130:	70 40       	sbci	r23, 0x00	; 0
    4132:	01 10       	cpse	r0, r1
    4134:	d8 f7       	brcc	.-10     	; 0x412c <strnlen_P+0x2>
    4136:	80 95       	com	r24
    4138:	90 95       	com	r25
    413a:	8e 0f       	add	r24, r30
    413c:	9f 1f       	adc	r25, r31
    413e:	08 95       	ret

00004140 <strnlen>:
    4140:	fc 01       	movw	r30, r24
    4142:	61 50       	subi	r22, 0x01	; 1
    4144:	70 40       	sbci	r23, 0x00	; 0
    4146:	01 90       	ld	r0, Z+
    4148:	01 10       	cpse	r0, r1
    414a:	d8 f7       	brcc	.-10     	; 0x4142 <strnlen+0x2>
    414c:	80 95       	com	r24
    414e:	90 95       	com	r25
    4150:	8e 0f       	add	r24, r30
    4152:	9f 1f       	adc	r25, r31
    4154:	08 95       	ret

00004156 <fputc>:
    4156:	0f 93       	push	r16
    4158:	1f 93       	push	r17
    415a:	cf 93       	push	r28
    415c:	df 93       	push	r29
    415e:	fb 01       	movw	r30, r22
    4160:	23 81       	ldd	r18, Z+3	; 0x03
    4162:	21 fd       	sbrc	r18, 1
    4164:	03 c0       	rjmp	.+6      	; 0x416c <fputc+0x16>
    4166:	8f ef       	ldi	r24, 0xFF	; 255
    4168:	9f ef       	ldi	r25, 0xFF	; 255
    416a:	28 c0       	rjmp	.+80     	; 0x41bc <fputc+0x66>
    416c:	22 ff       	sbrs	r18, 2
    416e:	16 c0       	rjmp	.+44     	; 0x419c <fputc+0x46>
    4170:	46 81       	ldd	r20, Z+6	; 0x06
    4172:	57 81       	ldd	r21, Z+7	; 0x07
    4174:	24 81       	ldd	r18, Z+4	; 0x04
    4176:	35 81       	ldd	r19, Z+5	; 0x05
    4178:	42 17       	cp	r20, r18
    417a:	53 07       	cpc	r21, r19
    417c:	44 f4       	brge	.+16     	; 0x418e <fputc+0x38>
    417e:	a0 81       	ld	r26, Z
    4180:	b1 81       	ldd	r27, Z+1	; 0x01
    4182:	9d 01       	movw	r18, r26
    4184:	2f 5f       	subi	r18, 0xFF	; 255
    4186:	3f 4f       	sbci	r19, 0xFF	; 255
    4188:	20 83       	st	Z, r18
    418a:	31 83       	std	Z+1, r19	; 0x01
    418c:	8c 93       	st	X, r24
    418e:	26 81       	ldd	r18, Z+6	; 0x06
    4190:	37 81       	ldd	r19, Z+7	; 0x07
    4192:	2f 5f       	subi	r18, 0xFF	; 255
    4194:	3f 4f       	sbci	r19, 0xFF	; 255
    4196:	26 83       	std	Z+6, r18	; 0x06
    4198:	37 83       	std	Z+7, r19	; 0x07
    419a:	10 c0       	rjmp	.+32     	; 0x41bc <fputc+0x66>
    419c:	eb 01       	movw	r28, r22
    419e:	09 2f       	mov	r16, r25
    41a0:	18 2f       	mov	r17, r24
    41a2:	00 84       	ldd	r0, Z+8	; 0x08
    41a4:	f1 85       	ldd	r31, Z+9	; 0x09
    41a6:	e0 2d       	mov	r30, r0
    41a8:	19 95       	eicall
    41aa:	89 2b       	or	r24, r25
    41ac:	e1 f6       	brne	.-72     	; 0x4166 <fputc+0x10>
    41ae:	8e 81       	ldd	r24, Y+6	; 0x06
    41b0:	9f 81       	ldd	r25, Y+7	; 0x07
    41b2:	01 96       	adiw	r24, 0x01	; 1
    41b4:	8e 83       	std	Y+6, r24	; 0x06
    41b6:	9f 83       	std	Y+7, r25	; 0x07
    41b8:	81 2f       	mov	r24, r17
    41ba:	90 2f       	mov	r25, r16
    41bc:	df 91       	pop	r29
    41be:	cf 91       	pop	r28
    41c0:	1f 91       	pop	r17
    41c2:	0f 91       	pop	r16
    41c4:	08 95       	ret

000041c6 <__ultoa_invert>:
    41c6:	fa 01       	movw	r30, r20
    41c8:	aa 27       	eor	r26, r26
    41ca:	28 30       	cpi	r18, 0x08	; 8
    41cc:	51 f1       	breq	.+84     	; 0x4222 <__ultoa_invert+0x5c>
    41ce:	20 31       	cpi	r18, 0x10	; 16
    41d0:	81 f1       	breq	.+96     	; 0x4232 <__ultoa_invert+0x6c>
    41d2:	e8 94       	clt
    41d4:	6f 93       	push	r22
    41d6:	6e 7f       	andi	r22, 0xFE	; 254
    41d8:	6e 5f       	subi	r22, 0xFE	; 254
    41da:	7f 4f       	sbci	r23, 0xFF	; 255
    41dc:	8f 4f       	sbci	r24, 0xFF	; 255
    41de:	9f 4f       	sbci	r25, 0xFF	; 255
    41e0:	af 4f       	sbci	r26, 0xFF	; 255
    41e2:	b1 e0       	ldi	r27, 0x01	; 1
    41e4:	3e d0       	rcall	.+124    	; 0x4262 <__ultoa_invert+0x9c>
    41e6:	b4 e0       	ldi	r27, 0x04	; 4
    41e8:	3c d0       	rcall	.+120    	; 0x4262 <__ultoa_invert+0x9c>
    41ea:	67 0f       	add	r22, r23
    41ec:	78 1f       	adc	r23, r24
    41ee:	89 1f       	adc	r24, r25
    41f0:	9a 1f       	adc	r25, r26
    41f2:	a1 1d       	adc	r26, r1
    41f4:	68 0f       	add	r22, r24
    41f6:	79 1f       	adc	r23, r25
    41f8:	8a 1f       	adc	r24, r26
    41fa:	91 1d       	adc	r25, r1
    41fc:	a1 1d       	adc	r26, r1
    41fe:	6a 0f       	add	r22, r26
    4200:	71 1d       	adc	r23, r1
    4202:	81 1d       	adc	r24, r1
    4204:	91 1d       	adc	r25, r1
    4206:	a1 1d       	adc	r26, r1
    4208:	20 d0       	rcall	.+64     	; 0x424a <__ultoa_invert+0x84>
    420a:	09 f4       	brne	.+2      	; 0x420e <__ultoa_invert+0x48>
    420c:	68 94       	set
    420e:	3f 91       	pop	r19
    4210:	2a e0       	ldi	r18, 0x0A	; 10
    4212:	26 9f       	mul	r18, r22
    4214:	11 24       	eor	r1, r1
    4216:	30 19       	sub	r19, r0
    4218:	30 5d       	subi	r19, 0xD0	; 208
    421a:	31 93       	st	Z+, r19
    421c:	de f6       	brtc	.-74     	; 0x41d4 <__ultoa_invert+0xe>
    421e:	cf 01       	movw	r24, r30
    4220:	08 95       	ret
    4222:	46 2f       	mov	r20, r22
    4224:	47 70       	andi	r20, 0x07	; 7
    4226:	40 5d       	subi	r20, 0xD0	; 208
    4228:	41 93       	st	Z+, r20
    422a:	b3 e0       	ldi	r27, 0x03	; 3
    422c:	0f d0       	rcall	.+30     	; 0x424c <__ultoa_invert+0x86>
    422e:	c9 f7       	brne	.-14     	; 0x4222 <__ultoa_invert+0x5c>
    4230:	f6 cf       	rjmp	.-20     	; 0x421e <__ultoa_invert+0x58>
    4232:	46 2f       	mov	r20, r22
    4234:	4f 70       	andi	r20, 0x0F	; 15
    4236:	40 5d       	subi	r20, 0xD0	; 208
    4238:	4a 33       	cpi	r20, 0x3A	; 58
    423a:	18 f0       	brcs	.+6      	; 0x4242 <__ultoa_invert+0x7c>
    423c:	49 5d       	subi	r20, 0xD9	; 217
    423e:	31 fd       	sbrc	r19, 1
    4240:	40 52       	subi	r20, 0x20	; 32
    4242:	41 93       	st	Z+, r20
    4244:	02 d0       	rcall	.+4      	; 0x424a <__ultoa_invert+0x84>
    4246:	a9 f7       	brne	.-22     	; 0x4232 <__ultoa_invert+0x6c>
    4248:	ea cf       	rjmp	.-44     	; 0x421e <__ultoa_invert+0x58>
    424a:	b4 e0       	ldi	r27, 0x04	; 4
    424c:	a6 95       	lsr	r26
    424e:	97 95       	ror	r25
    4250:	87 95       	ror	r24
    4252:	77 95       	ror	r23
    4254:	67 95       	ror	r22
    4256:	ba 95       	dec	r27
    4258:	c9 f7       	brne	.-14     	; 0x424c <__ultoa_invert+0x86>
    425a:	00 97       	sbiw	r24, 0x00	; 0
    425c:	61 05       	cpc	r22, r1
    425e:	71 05       	cpc	r23, r1
    4260:	08 95       	ret
    4262:	9b 01       	movw	r18, r22
    4264:	ac 01       	movw	r20, r24
    4266:	0a 2e       	mov	r0, r26
    4268:	06 94       	lsr	r0
    426a:	57 95       	ror	r21
    426c:	47 95       	ror	r20
    426e:	37 95       	ror	r19
    4270:	27 95       	ror	r18
    4272:	ba 95       	dec	r27
    4274:	c9 f7       	brne	.-14     	; 0x4268 <__ultoa_invert+0xa2>
    4276:	62 0f       	add	r22, r18
    4278:	73 1f       	adc	r23, r19
    427a:	84 1f       	adc	r24, r20
    427c:	95 1f       	adc	r25, r21
    427e:	a0 1d       	adc	r26, r0
    4280:	08 95       	ret

00004282 <_exit>:
    4282:	f8 94       	cli

00004284 <__stop_program>:
    4284:	ff cf       	rjmp	.-2      	; 0x4284 <__stop_program>
